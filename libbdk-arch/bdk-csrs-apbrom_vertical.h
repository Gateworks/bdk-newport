#ifndef __BDK_CSRS_APBROM_VERTICAL_H__
#define __BDK_CSRS_APBROM_VERTICAL_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX APBROM_VERTICAL.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Register (RSL32b) apbrom_vertical#_authstatus
 *
 * APBROM Vertical Authstatus Register
 * Reports the current status of the authentication control signals.
 */
union bdk_apbrom_verticalx_authstatus
{
    uint32_t u;
    struct bdk_apbrom_verticalx_authstatus_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
#else /* Word 0 - Little Endian */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_authstatus_s cn; */
};
typedef union bdk_apbrom_verticalx_authstatus bdk_apbrom_verticalx_authstatus_t;

static inline uint64_t BDK_APBROM_VERTICALX_AUTHSTATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_AUTHSTATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fb8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_AUTHSTATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_AUTHSTATUS(a) bdk_apbrom_verticalx_authstatus_t
#define bustype_BDK_APBROM_VERTICALX_AUTHSTATUS(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_AUTHSTATUS(a) "APBROM_VERTICALX_AUTHSTATUS"
#define busnum_BDK_APBROM_VERTICALX_AUTHSTATUS(a) (a)
#define arguments_BDK_APBROM_VERTICALX_AUTHSTATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_cidr0
 *
 * APBROM Vertical Cidr0 Register
 * The CIDR0 register is part of the set of component identification registers.
 */
union bdk_apbrom_verticalx_cidr0
{
    uint32_t u;
    struct bdk_apbrom_verticalx_cidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_cidr0_s cn; */
};
typedef union bdk_apbrom_verticalx_cidr0 bdk_apbrom_verticalx_cidr0_t;

static inline uint64_t BDK_APBROM_VERTICALX_CIDR0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_CIDR0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100ff0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_CIDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_CIDR0(a) bdk_apbrom_verticalx_cidr0_t
#define bustype_BDK_APBROM_VERTICALX_CIDR0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_CIDR0(a) "APBROM_VERTICALX_CIDR0"
#define busnum_BDK_APBROM_VERTICALX_CIDR0(a) (a)
#define arguments_BDK_APBROM_VERTICALX_CIDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_cidr1
 *
 * APBROM Vertical Cidr1 Register
 * The CIDR1 register is part of the set of component identification registers.
 */
union bdk_apbrom_verticalx_cidr1
{
    uint32_t u;
    struct bdk_apbrom_verticalx_cidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_cidr1_s cn; */
};
typedef union bdk_apbrom_verticalx_cidr1 bdk_apbrom_verticalx_cidr1_t;

static inline uint64_t BDK_APBROM_VERTICALX_CIDR1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_CIDR1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100ff4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_CIDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_CIDR1(a) bdk_apbrom_verticalx_cidr1_t
#define bustype_BDK_APBROM_VERTICALX_CIDR1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_CIDR1(a) "APBROM_VERTICALX_CIDR1"
#define busnum_BDK_APBROM_VERTICALX_CIDR1(a) (a)
#define arguments_BDK_APBROM_VERTICALX_CIDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_cidr2
 *
 * APBROM Vertical Cidr2 Register
 * The CIDR2 register is part of the set of component identification registers.
 */
union bdk_apbrom_verticalx_cidr2
{
    uint32_t u;
    struct bdk_apbrom_verticalx_cidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_cidr2_s cn; */
};
typedef union bdk_apbrom_verticalx_cidr2 bdk_apbrom_verticalx_cidr2_t;

static inline uint64_t BDK_APBROM_VERTICALX_CIDR2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_CIDR2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100ff8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_CIDR2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_CIDR2(a) bdk_apbrom_verticalx_cidr2_t
#define bustype_BDK_APBROM_VERTICALX_CIDR2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_CIDR2(a) "APBROM_VERTICALX_CIDR2"
#define busnum_BDK_APBROM_VERTICALX_CIDR2(a) (a)
#define arguments_BDK_APBROM_VERTICALX_CIDR2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_cidr3
 *
 * APBROM Vertical Cidr3 Register
 * The CIDR3 register is part of the set of component identification registers.
 */
union bdk_apbrom_verticalx_cidr3
{
    uint32_t u;
    struct bdk_apbrom_verticalx_cidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_cidr3_s cn; */
};
typedef union bdk_apbrom_verticalx_cidr3 bdk_apbrom_verticalx_cidr3_t;

static inline uint64_t BDK_APBROM_VERTICALX_CIDR3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_CIDR3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100ffcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_CIDR3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_CIDR3(a) bdk_apbrom_verticalx_cidr3_t
#define bustype_BDK_APBROM_VERTICALX_CIDR3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_CIDR3(a) "APBROM_VERTICALX_CIDR3"
#define busnum_BDK_APBROM_VERTICALX_CIDR3(a) (a)
#define arguments_BDK_APBROM_VERTICALX_CIDR3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_devarch
 *
 * APBROM Vertical Devarch Register
 * Identifies the architect and architecture of a CoreSight component. The architect
 * might differ from the designer of a component, for example Arm defines the
 * architecture but another company designs and implements the component.
 */
union bdk_apbrom_verticalx_devarch
{
    uint32_t u;
    struct bdk_apbrom_verticalx_devarch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
#else /* Word 0 - Little Endian */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_devarch_s cn; */
};
typedef union bdk_apbrom_verticalx_devarch bdk_apbrom_verticalx_devarch_t;

static inline uint64_t BDK_APBROM_VERTICALX_DEVARCH(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_DEVARCH(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fbcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_DEVARCH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_DEVARCH(a) bdk_apbrom_verticalx_devarch_t
#define bustype_BDK_APBROM_VERTICALX_DEVARCH(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_DEVARCH(a) "APBROM_VERTICALX_DEVARCH"
#define busnum_BDK_APBROM_VERTICALX_DEVARCH(a) (a)
#define arguments_BDK_APBROM_VERTICALX_DEVARCH(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_devid
 *
 * APBROM Vertical Devid Register
 * This register is IMPLEMENTATION DEFINED for each Part Number and Designer. The
 * register indicates the capabilities of the component.
 */
union bdk_apbrom_verticalx_devid
{
    uint32_t u;
    struct bdk_apbrom_verticalx_devid_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
#else /* Word 0 - Little Endian */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_devid_s cn; */
};
typedef union bdk_apbrom_verticalx_devid bdk_apbrom_verticalx_devid_t;

static inline uint64_t BDK_APBROM_VERTICALX_DEVID(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_DEVID(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fc8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_DEVID", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_DEVID(a) bdk_apbrom_verticalx_devid_t
#define bustype_BDK_APBROM_VERTICALX_DEVID(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_DEVID(a) "APBROM_VERTICALX_DEVID"
#define busnum_BDK_APBROM_VERTICALX_DEVID(a) (a)
#define arguments_BDK_APBROM_VERTICALX_DEVID(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr0
 *
 * APBROM Vertical Pidr0 Register
 * The PIDR0 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr0
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
#else /* Word 0 - Little Endian */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr0_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr0 bdk_apbrom_verticalx_pidr0_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fe0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR0(a) bdk_apbrom_verticalx_pidr0_t
#define bustype_BDK_APBROM_VERTICALX_PIDR0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR0(a) "APBROM_VERTICALX_PIDR0"
#define busnum_BDK_APBROM_VERTICALX_PIDR0(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr1
 *
 * APBROM Vertical Pidr1 Register
 * The PIDR1 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr1
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
#else /* Word 0 - Little Endian */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr1_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr1 bdk_apbrom_verticalx_pidr1_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fe4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR1(a) bdk_apbrom_verticalx_pidr1_t
#define bustype_BDK_APBROM_VERTICALX_PIDR1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR1(a) "APBROM_VERTICALX_PIDR1"
#define busnum_BDK_APBROM_VERTICALX_PIDR1(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr2
 *
 * APBROM Vertical Pidr2 Register
 * The PIDR2 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr2
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
#else /* Word 0 - Little Endian */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr2_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr2 bdk_apbrom_verticalx_pidr2_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fe8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR2(a) bdk_apbrom_verticalx_pidr2_t
#define bustype_BDK_APBROM_VERTICALX_PIDR2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR2(a) "APBROM_VERTICALX_PIDR2"
#define busnum_BDK_APBROM_VERTICALX_PIDR2(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr3
 *
 * APBROM Vertical Pidr3 Register
 * The PIDR3 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr3
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr3_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr3 bdk_apbrom_verticalx_pidr3_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR3(a) bdk_apbrom_verticalx_pidr3_t
#define bustype_BDK_APBROM_VERTICALX_PIDR3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR3(a) "APBROM_VERTICALX_PIDR3"
#define busnum_BDK_APBROM_VERTICALX_PIDR3(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr4
 *
 * APBROM Vertical Pidr4 Register
 * The PIDR4 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr4
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
#else /* Word 0 - Little Endian */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr4_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr4 bdk_apbrom_verticalx_pidr4_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fd0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR4(a) bdk_apbrom_verticalx_pidr4_t
#define bustype_BDK_APBROM_VERTICALX_PIDR4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR4(a) "APBROM_VERTICALX_PIDR4"
#define busnum_BDK_APBROM_VERTICALX_PIDR4(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr5
 *
 * APBROM Vertical Pidr5 Register
 * The PIDR5 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr5
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr5_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr5 bdk_apbrom_verticalx_pidr5_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fd4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR5(a) bdk_apbrom_verticalx_pidr5_t
#define bustype_BDK_APBROM_VERTICALX_PIDR5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR5(a) "APBROM_VERTICALX_PIDR5"
#define busnum_BDK_APBROM_VERTICALX_PIDR5(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr6
 *
 * APBROM Vertical Pidr6 Register
 * The PIDR6 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr6
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr6_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr6 bdk_apbrom_verticalx_pidr6_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fd8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR6(a) bdk_apbrom_verticalx_pidr6_t
#define bustype_BDK_APBROM_VERTICALX_PIDR6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR6(a) "APBROM_VERTICALX_PIDR6"
#define busnum_BDK_APBROM_VERTICALX_PIDR6(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_pidr7
 *
 * APBROM Vertical Pidr7 Register
 * The PIDR7 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_verticalx_pidr7
{
    uint32_t u;
    struct bdk_apbrom_verticalx_pidr7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_pidr7_s cn; */
};
typedef union bdk_apbrom_verticalx_pidr7 bdk_apbrom_verticalx_pidr7_t;

static inline uint64_t BDK_APBROM_VERTICALX_PIDR7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_PIDR7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100fdcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_PIDR7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_PIDR7(a) bdk_apbrom_verticalx_pidr7_t
#define bustype_BDK_APBROM_VERTICALX_PIDR7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_PIDR7(a) "APBROM_VERTICALX_PIDR7"
#define busnum_BDK_APBROM_VERTICALX_PIDR7(a) (a)
#define arguments_BDK_APBROM_VERTICALX_PIDR7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry0
 *
 * APBROM Vertical Romentry0 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry0
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry0_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry0 bdk_apbrom_verticalx_romentry0_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100000ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY0(a) bdk_apbrom_verticalx_romentry0_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY0(a) "APBROM_VERTICALX_ROMENTRY0"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY0(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry1
 *
 * APBROM Vertical Romentry1 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry1
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry1_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry1 bdk_apbrom_verticalx_romentry1_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100004ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY1(a) bdk_apbrom_verticalx_romentry1_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY1(a) "APBROM_VERTICALX_ROMENTRY1"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY1(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry10
 *
 * APBROM Vertical Romentry10 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry10
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry10_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry10 bdk_apbrom_verticalx_romentry10_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY10(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY10(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100028ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY10(a) bdk_apbrom_verticalx_romentry10_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY10(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY10(a) "APBROM_VERTICALX_ROMENTRY10"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY10(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry100
 *
 * APBROM Vertical Romentry100 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry100
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry100_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry100_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry100 bdk_apbrom_verticalx_romentry100_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY100(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY100(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100190ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY100", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY100(a) bdk_apbrom_verticalx_romentry100_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY100(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY100(a) "APBROM_VERTICALX_ROMENTRY100"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY100(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY100(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry101
 *
 * APBROM Vertical Romentry101 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry101
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry101_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry101_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry101 bdk_apbrom_verticalx_romentry101_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY101(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY101(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100194ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY101", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY101(a) bdk_apbrom_verticalx_romentry101_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY101(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY101(a) "APBROM_VERTICALX_ROMENTRY101"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY101(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY101(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry102
 *
 * APBROM Vertical Romentry102 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry102
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry102_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry102_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry102 bdk_apbrom_verticalx_romentry102_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY102(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY102(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100198ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY102", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY102(a) bdk_apbrom_verticalx_romentry102_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY102(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY102(a) "APBROM_VERTICALX_ROMENTRY102"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY102(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY102(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry103
 *
 * APBROM Vertical Romentry103 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry103
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry103_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry103_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry103 bdk_apbrom_verticalx_romentry103_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY103(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY103(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610019cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY103", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY103(a) bdk_apbrom_verticalx_romentry103_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY103(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY103(a) "APBROM_VERTICALX_ROMENTRY103"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY103(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY103(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry104
 *
 * APBROM Vertical Romentry104 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry104
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry104_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry104 bdk_apbrom_verticalx_romentry104_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY104(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY104(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY104", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY104(a) bdk_apbrom_verticalx_romentry104_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY104(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY104(a) "APBROM_VERTICALX_ROMENTRY104"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY104(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY104(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry105
 *
 * APBROM Vertical Romentry105 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry105
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry105_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry105_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry105 bdk_apbrom_verticalx_romentry105_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY105(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY105(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY105", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY105(a) bdk_apbrom_verticalx_romentry105_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY105(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY105(a) "APBROM_VERTICALX_ROMENTRY105"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY105(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY105(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry106
 *
 * APBROM Vertical Romentry106 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry106
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry106_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry106_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry106 bdk_apbrom_verticalx_romentry106_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY106(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY106(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY106", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY106(a) bdk_apbrom_verticalx_romentry106_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY106(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY106(a) "APBROM_VERTICALX_ROMENTRY106"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY106(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY106(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry107
 *
 * APBROM Vertical Romentry107 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry107
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry107_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry107_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry107 bdk_apbrom_verticalx_romentry107_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY107(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY107(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY107", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY107(a) bdk_apbrom_verticalx_romentry107_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY107(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY107(a) "APBROM_VERTICALX_ROMENTRY107"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY107(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY107(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry108
 *
 * APBROM Vertical Romentry108 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry108
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry108_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry108_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry108 bdk_apbrom_verticalx_romentry108_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY108(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY108(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY108", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY108(a) bdk_apbrom_verticalx_romentry108_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY108(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY108(a) "APBROM_VERTICALX_ROMENTRY108"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY108(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY108(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry109
 *
 * APBROM Vertical Romentry109 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry109
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry109_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry109_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry109 bdk_apbrom_verticalx_romentry109_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY109(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY109(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY109", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY109(a) bdk_apbrom_verticalx_romentry109_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY109(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY109(a) "APBROM_VERTICALX_ROMENTRY109"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY109(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY109(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry11
 *
 * APBROM Vertical Romentry11 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry11
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry11_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry11 bdk_apbrom_verticalx_romentry11_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY11(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY11(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610002cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY11(a) bdk_apbrom_verticalx_romentry11_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY11(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY11(a) "APBROM_VERTICALX_ROMENTRY11"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY11(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry110
 *
 * APBROM Vertical Romentry110 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry110
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry110_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry110_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry110 bdk_apbrom_verticalx_romentry110_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY110(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY110(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY110", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY110(a) bdk_apbrom_verticalx_romentry110_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY110(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY110(a) "APBROM_VERTICALX_ROMENTRY110"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY110(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY110(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry111
 *
 * APBROM Vertical Romentry111 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry111
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry111_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry111_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry111 bdk_apbrom_verticalx_romentry111_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY111(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY111(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY111", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY111(a) bdk_apbrom_verticalx_romentry111_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY111(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY111(a) "APBROM_VERTICALX_ROMENTRY111"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY111(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY111(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry112
 *
 * APBROM Vertical Romentry112 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry112
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry112_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry112 bdk_apbrom_verticalx_romentry112_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY112(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY112(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY112", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY112(a) bdk_apbrom_verticalx_romentry112_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY112(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY112(a) "APBROM_VERTICALX_ROMENTRY112"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY112(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY112(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry113
 *
 * APBROM Vertical Romentry113 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry113
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry113_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry113_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry113 bdk_apbrom_verticalx_romentry113_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY113(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY113(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY113", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY113(a) bdk_apbrom_verticalx_romentry113_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY113(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY113(a) "APBROM_VERTICALX_ROMENTRY113"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY113(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY113(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry114
 *
 * APBROM Vertical Romentry114 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry114
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry114_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry114_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry114 bdk_apbrom_verticalx_romentry114_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY114(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY114(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY114", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY114(a) bdk_apbrom_verticalx_romentry114_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY114(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY114(a) "APBROM_VERTICALX_ROMENTRY114"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY114(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY114(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry115
 *
 * APBROM Vertical Romentry115 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry115
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry115_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry115_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry115 bdk_apbrom_verticalx_romentry115_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY115(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY115(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY115", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY115(a) bdk_apbrom_verticalx_romentry115_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY115(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY115(a) "APBROM_VERTICALX_ROMENTRY115"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY115(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY115(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry116
 *
 * APBROM Vertical Romentry116 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry116
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry116_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry116_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry116 bdk_apbrom_verticalx_romentry116_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY116(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY116(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY116", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY116(a) bdk_apbrom_verticalx_romentry116_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY116(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY116(a) "APBROM_VERTICALX_ROMENTRY116"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY116(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY116(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry117
 *
 * APBROM Vertical Romentry117 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry117
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry117_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry117_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry117 bdk_apbrom_verticalx_romentry117_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY117(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY117(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY117", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY117(a) bdk_apbrom_verticalx_romentry117_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY117(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY117(a) "APBROM_VERTICALX_ROMENTRY117"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY117(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY117(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry118
 *
 * APBROM Vertical Romentry118 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry118
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry118_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry118_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry118 bdk_apbrom_verticalx_romentry118_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY118(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY118(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY118", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY118(a) bdk_apbrom_verticalx_romentry118_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY118(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY118(a) "APBROM_VERTICALX_ROMENTRY118"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY118(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY118(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry119
 *
 * APBROM Vertical Romentry119 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry119
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry119_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry119_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry119 bdk_apbrom_verticalx_romentry119_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY119(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY119(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY119", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY119(a) bdk_apbrom_verticalx_romentry119_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY119(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY119(a) "APBROM_VERTICALX_ROMENTRY119"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY119(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY119(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry12
 *
 * APBROM Vertical Romentry12 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry12
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry12_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry12 bdk_apbrom_verticalx_romentry12_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY12(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY12(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100030ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY12(a) bdk_apbrom_verticalx_romentry12_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY12(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY12(a) "APBROM_VERTICALX_ROMENTRY12"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY12(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry120
 *
 * APBROM Vertical Romentry120 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry120
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry120_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry120 bdk_apbrom_verticalx_romentry120_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY120(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY120(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY120", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY120(a) bdk_apbrom_verticalx_romentry120_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY120(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY120(a) "APBROM_VERTICALX_ROMENTRY120"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY120(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY120(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry121
 *
 * APBROM Vertical Romentry121 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry121
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry121_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry121_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry121 bdk_apbrom_verticalx_romentry121_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY121(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY121(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY121", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY121(a) bdk_apbrom_verticalx_romentry121_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY121(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY121(a) "APBROM_VERTICALX_ROMENTRY121"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY121(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY121(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry122
 *
 * APBROM Vertical Romentry122 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry122
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry122_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry122_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry122 bdk_apbrom_verticalx_romentry122_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY122(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY122(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY122", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY122(a) bdk_apbrom_verticalx_romentry122_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY122(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY122(a) "APBROM_VERTICALX_ROMENTRY122"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY122(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY122(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry123
 *
 * APBROM Vertical Romentry123 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry123
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry123_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry123_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry123 bdk_apbrom_verticalx_romentry123_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY123(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY123(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY123", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY123(a) bdk_apbrom_verticalx_romentry123_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY123(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY123(a) "APBROM_VERTICALX_ROMENTRY123"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY123(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY123(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry124
 *
 * APBROM Vertical Romentry124 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry124
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry124_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry124_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry124 bdk_apbrom_verticalx_romentry124_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY124(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY124(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY124", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY124(a) bdk_apbrom_verticalx_romentry124_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY124(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY124(a) "APBROM_VERTICALX_ROMENTRY124"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY124(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY124(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry125
 *
 * APBROM Vertical Romentry125 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry125
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry125_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry125_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry125 bdk_apbrom_verticalx_romentry125_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY125(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY125(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY125", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY125(a) bdk_apbrom_verticalx_romentry125_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY125(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY125(a) "APBROM_VERTICALX_ROMENTRY125"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY125(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY125(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry126
 *
 * APBROM Vertical Romentry126 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry126
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry126_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry126_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry126 bdk_apbrom_verticalx_romentry126_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY126(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY126(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY126", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY126(a) bdk_apbrom_verticalx_romentry126_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY126(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY126(a) "APBROM_VERTICALX_ROMENTRY126"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY126(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY126(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry127
 *
 * APBROM Vertical Romentry127 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry127
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry127_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry127_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry127 bdk_apbrom_verticalx_romentry127_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY127(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY127(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461001fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY127", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY127(a) bdk_apbrom_verticalx_romentry127_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY127(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY127(a) "APBROM_VERTICALX_ROMENTRY127"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY127(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY127(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry128
 *
 * APBROM Vertical Romentry128 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry128
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry128_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry128 bdk_apbrom_verticalx_romentry128_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY128(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY128(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100200ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY128(a) bdk_apbrom_verticalx_romentry128_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY128(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY128(a) "APBROM_VERTICALX_ROMENTRY128"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY128(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY128(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry129
 *
 * APBROM Vertical Romentry129 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry129
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry129_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry129_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry129 bdk_apbrom_verticalx_romentry129_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY129(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY129(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100204ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY129", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY129(a) bdk_apbrom_verticalx_romentry129_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY129(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY129(a) "APBROM_VERTICALX_ROMENTRY129"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY129(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY129(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry13
 *
 * APBROM Vertical Romentry13 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry13
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry13_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry13 bdk_apbrom_verticalx_romentry13_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY13(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY13(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100034ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY13(a) bdk_apbrom_verticalx_romentry13_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY13(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY13(a) "APBROM_VERTICALX_ROMENTRY13"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY13(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY13(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry130
 *
 * APBROM Vertical Romentry130 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry130
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry130_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry130_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry130 bdk_apbrom_verticalx_romentry130_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY130(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY130(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100208ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY130", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY130(a) bdk_apbrom_verticalx_romentry130_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY130(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY130(a) "APBROM_VERTICALX_ROMENTRY130"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY130(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY130(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry131
 *
 * APBROM Vertical Romentry131 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry131
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry131_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry131_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry131 bdk_apbrom_verticalx_romentry131_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY131(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY131(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610020cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY131", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY131(a) bdk_apbrom_verticalx_romentry131_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY131(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY131(a) "APBROM_VERTICALX_ROMENTRY131"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY131(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY131(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry132
 *
 * APBROM Vertical Romentry132 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry132
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry132_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry132_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry132 bdk_apbrom_verticalx_romentry132_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY132(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY132(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100210ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY132", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY132(a) bdk_apbrom_verticalx_romentry132_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY132(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY132(a) "APBROM_VERTICALX_ROMENTRY132"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY132(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY132(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry133
 *
 * APBROM Vertical Romentry133 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry133
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry133_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry133_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry133 bdk_apbrom_verticalx_romentry133_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY133(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY133(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100214ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY133", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY133(a) bdk_apbrom_verticalx_romentry133_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY133(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY133(a) "APBROM_VERTICALX_ROMENTRY133"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY133(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY133(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry134
 *
 * APBROM Vertical Romentry134 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry134
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry134_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry134_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry134 bdk_apbrom_verticalx_romentry134_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY134(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY134(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100218ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY134", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY134(a) bdk_apbrom_verticalx_romentry134_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY134(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY134(a) "APBROM_VERTICALX_ROMENTRY134"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY134(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY134(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry135
 *
 * APBROM Vertical Romentry135 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry135
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry135_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry135_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry135 bdk_apbrom_verticalx_romentry135_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY135(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY135(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610021cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY135", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY135(a) bdk_apbrom_verticalx_romentry135_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY135(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY135(a) "APBROM_VERTICALX_ROMENTRY135"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY135(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY135(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry136
 *
 * APBROM Vertical Romentry136 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry136
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry136_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry136 bdk_apbrom_verticalx_romentry136_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY136(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY136(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100220ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY136", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY136(a) bdk_apbrom_verticalx_romentry136_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY136(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY136(a) "APBROM_VERTICALX_ROMENTRY136"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY136(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY136(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry137
 *
 * APBROM Vertical Romentry137 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry137
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry137_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry137_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry137 bdk_apbrom_verticalx_romentry137_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY137(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY137(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100224ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY137", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY137(a) bdk_apbrom_verticalx_romentry137_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY137(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY137(a) "APBROM_VERTICALX_ROMENTRY137"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY137(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY137(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry138
 *
 * APBROM Vertical Romentry138 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry138
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry138_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry138_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry138 bdk_apbrom_verticalx_romentry138_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY138(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY138(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100228ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY138", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY138(a) bdk_apbrom_verticalx_romentry138_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY138(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY138(a) "APBROM_VERTICALX_ROMENTRY138"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY138(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY138(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry139
 *
 * APBROM Vertical Romentry139 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry139
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry139_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry139_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry139 bdk_apbrom_verticalx_romentry139_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY139(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY139(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610022cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY139", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY139(a) bdk_apbrom_verticalx_romentry139_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY139(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY139(a) "APBROM_VERTICALX_ROMENTRY139"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY139(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY139(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry14
 *
 * APBROM Vertical Romentry14 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry14
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry14_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry14 bdk_apbrom_verticalx_romentry14_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY14(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY14(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100038ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY14", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY14(a) bdk_apbrom_verticalx_romentry14_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY14(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY14(a) "APBROM_VERTICALX_ROMENTRY14"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY14(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY14(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry140
 *
 * APBROM Vertical Romentry140 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry140
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry140_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry140_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry140 bdk_apbrom_verticalx_romentry140_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY140(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY140(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100230ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY140", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY140(a) bdk_apbrom_verticalx_romentry140_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY140(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY140(a) "APBROM_VERTICALX_ROMENTRY140"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY140(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY140(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry141
 *
 * APBROM Vertical Romentry141 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry141
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry141_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry141_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry141 bdk_apbrom_verticalx_romentry141_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY141(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY141(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100234ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY141", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY141(a) bdk_apbrom_verticalx_romentry141_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY141(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY141(a) "APBROM_VERTICALX_ROMENTRY141"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY141(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY141(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry142
 *
 * APBROM Vertical Romentry142 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry142
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry142_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry142_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry142 bdk_apbrom_verticalx_romentry142_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY142(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY142(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100238ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY142", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY142(a) bdk_apbrom_verticalx_romentry142_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY142(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY142(a) "APBROM_VERTICALX_ROMENTRY142"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY142(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY142(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry143
 *
 * APBROM Vertical Romentry143 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry143
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry143_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry143_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry143 bdk_apbrom_verticalx_romentry143_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY143(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY143(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610023cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY143", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY143(a) bdk_apbrom_verticalx_romentry143_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY143(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY143(a) "APBROM_VERTICALX_ROMENTRY143"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY143(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY143(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry144
 *
 * APBROM Vertical Romentry144 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry144
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry144_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry144 bdk_apbrom_verticalx_romentry144_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY144(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY144(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100240ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY144", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY144(a) bdk_apbrom_verticalx_romentry144_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY144(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY144(a) "APBROM_VERTICALX_ROMENTRY144"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY144(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY144(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry145
 *
 * APBROM Vertical Romentry145 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry145
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry145_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry145_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry145 bdk_apbrom_verticalx_romentry145_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY145(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY145(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100244ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY145", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY145(a) bdk_apbrom_verticalx_romentry145_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY145(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY145(a) "APBROM_VERTICALX_ROMENTRY145"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY145(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY145(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry146
 *
 * APBROM Vertical Romentry146 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry146
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry146_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry146_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry146 bdk_apbrom_verticalx_romentry146_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY146(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY146(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100248ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY146", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY146(a) bdk_apbrom_verticalx_romentry146_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY146(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY146(a) "APBROM_VERTICALX_ROMENTRY146"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY146(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY146(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry147
 *
 * APBROM Vertical Romentry147 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry147
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry147_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry147_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry147 bdk_apbrom_verticalx_romentry147_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY147(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY147(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610024cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY147", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY147(a) bdk_apbrom_verticalx_romentry147_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY147(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY147(a) "APBROM_VERTICALX_ROMENTRY147"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY147(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY147(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry148
 *
 * APBROM Vertical Romentry148 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry148
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry148_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry148_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry148 bdk_apbrom_verticalx_romentry148_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY148(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY148(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100250ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY148", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY148(a) bdk_apbrom_verticalx_romentry148_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY148(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY148(a) "APBROM_VERTICALX_ROMENTRY148"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY148(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY148(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry149
 *
 * APBROM Vertical Romentry149 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry149
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry149_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry149_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry149 bdk_apbrom_verticalx_romentry149_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY149(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY149(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100254ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY149", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY149(a) bdk_apbrom_verticalx_romentry149_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY149(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY149(a) "APBROM_VERTICALX_ROMENTRY149"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY149(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY149(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry15
 *
 * APBROM Vertical Romentry15 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry15
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry15_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry15 bdk_apbrom_verticalx_romentry15_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY15(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY15(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610003cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY15", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY15(a) bdk_apbrom_verticalx_romentry15_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY15(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY15(a) "APBROM_VERTICALX_ROMENTRY15"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY15(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY15(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry150
 *
 * APBROM Vertical Romentry150 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry150
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry150_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry150_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry150 bdk_apbrom_verticalx_romentry150_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY150(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY150(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100258ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY150", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY150(a) bdk_apbrom_verticalx_romentry150_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY150(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY150(a) "APBROM_VERTICALX_ROMENTRY150"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY150(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY150(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry151
 *
 * APBROM Vertical Romentry151 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry151
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry151_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry151_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry151 bdk_apbrom_verticalx_romentry151_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY151(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY151(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610025cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY151", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY151(a) bdk_apbrom_verticalx_romentry151_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY151(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY151(a) "APBROM_VERTICALX_ROMENTRY151"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY151(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY151(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry152
 *
 * APBROM Vertical Romentry152 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry152
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry152_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry152 bdk_apbrom_verticalx_romentry152_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY152(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY152(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100260ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY152", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY152(a) bdk_apbrom_verticalx_romentry152_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY152(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY152(a) "APBROM_VERTICALX_ROMENTRY152"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY152(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY152(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry153
 *
 * APBROM Vertical Romentry153 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry153
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry153_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry153_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry153 bdk_apbrom_verticalx_romentry153_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY153(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY153(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100264ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY153", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY153(a) bdk_apbrom_verticalx_romentry153_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY153(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY153(a) "APBROM_VERTICALX_ROMENTRY153"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY153(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY153(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry154
 *
 * APBROM Vertical Romentry154 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry154
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry154_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry154_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry154 bdk_apbrom_verticalx_romentry154_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY154(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY154(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100268ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY154", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY154(a) bdk_apbrom_verticalx_romentry154_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY154(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY154(a) "APBROM_VERTICALX_ROMENTRY154"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY154(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY154(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry155
 *
 * APBROM Vertical Romentry155 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry155
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry155_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry155_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry155 bdk_apbrom_verticalx_romentry155_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY155(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY155(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610026cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY155", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY155(a) bdk_apbrom_verticalx_romentry155_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY155(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY155(a) "APBROM_VERTICALX_ROMENTRY155"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY155(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY155(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry156
 *
 * APBROM Vertical Romentry156 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry156
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry156_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry156_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry156 bdk_apbrom_verticalx_romentry156_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY156(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY156(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100270ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY156", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY156(a) bdk_apbrom_verticalx_romentry156_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY156(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY156(a) "APBROM_VERTICALX_ROMENTRY156"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY156(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY156(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry157
 *
 * APBROM Vertical Romentry157 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry157
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry157_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry157_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry157 bdk_apbrom_verticalx_romentry157_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY157(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY157(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100274ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY157", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY157(a) bdk_apbrom_verticalx_romentry157_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY157(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY157(a) "APBROM_VERTICALX_ROMENTRY157"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY157(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY157(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry158
 *
 * APBROM Vertical Romentry158 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry158
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry158_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry158_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry158 bdk_apbrom_verticalx_romentry158_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY158(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY158(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100278ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY158", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY158(a) bdk_apbrom_verticalx_romentry158_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY158(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY158(a) "APBROM_VERTICALX_ROMENTRY158"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY158(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY158(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry159
 *
 * APBROM Vertical Romentry159 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry159
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry159_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry159_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry159 bdk_apbrom_verticalx_romentry159_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY159(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY159(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610027cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY159", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY159(a) bdk_apbrom_verticalx_romentry159_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY159(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY159(a) "APBROM_VERTICALX_ROMENTRY159"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY159(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY159(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry16
 *
 * APBROM Vertical Romentry16 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry16
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry16_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry16 bdk_apbrom_verticalx_romentry16_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY16(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY16(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100040ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY16", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY16(a) bdk_apbrom_verticalx_romentry16_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY16(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY16(a) "APBROM_VERTICALX_ROMENTRY16"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY16(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY16(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry160
 *
 * APBROM Vertical Romentry160 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry160
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry160_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry160 bdk_apbrom_verticalx_romentry160_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY160(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY160(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100280ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY160", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY160(a) bdk_apbrom_verticalx_romentry160_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY160(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY160(a) "APBROM_VERTICALX_ROMENTRY160"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY160(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY160(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry161
 *
 * APBROM Vertical Romentry161 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry161
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry161_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry161_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry161 bdk_apbrom_verticalx_romentry161_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY161(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY161(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100284ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY161", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY161(a) bdk_apbrom_verticalx_romentry161_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY161(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY161(a) "APBROM_VERTICALX_ROMENTRY161"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY161(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY161(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry162
 *
 * APBROM Vertical Romentry162 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry162
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry162_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry162_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry162 bdk_apbrom_verticalx_romentry162_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY162(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY162(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100288ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY162", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY162(a) bdk_apbrom_verticalx_romentry162_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY162(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY162(a) "APBROM_VERTICALX_ROMENTRY162"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY162(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY162(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry163
 *
 * APBROM Vertical Romentry163 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry163
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry163_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry163_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry163 bdk_apbrom_verticalx_romentry163_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY163(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY163(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610028cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY163", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY163(a) bdk_apbrom_verticalx_romentry163_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY163(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY163(a) "APBROM_VERTICALX_ROMENTRY163"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY163(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY163(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry164
 *
 * APBROM Vertical Romentry164 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry164
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry164_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry164_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry164 bdk_apbrom_verticalx_romentry164_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY164(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY164(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100290ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY164", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY164(a) bdk_apbrom_verticalx_romentry164_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY164(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY164(a) "APBROM_VERTICALX_ROMENTRY164"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY164(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY164(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry165
 *
 * APBROM Vertical Romentry165 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry165
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry165_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry165_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry165 bdk_apbrom_verticalx_romentry165_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY165(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY165(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100294ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY165", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY165(a) bdk_apbrom_verticalx_romentry165_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY165(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY165(a) "APBROM_VERTICALX_ROMENTRY165"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY165(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY165(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry166
 *
 * APBROM Vertical Romentry166 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry166
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry166_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry166_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry166 bdk_apbrom_verticalx_romentry166_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY166(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY166(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100298ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY166", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY166(a) bdk_apbrom_verticalx_romentry166_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY166(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY166(a) "APBROM_VERTICALX_ROMENTRY166"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY166(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY166(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry167
 *
 * APBROM Vertical Romentry167 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry167
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry167_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry167_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry167 bdk_apbrom_verticalx_romentry167_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY167(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY167(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610029cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY167", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY167(a) bdk_apbrom_verticalx_romentry167_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY167(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY167(a) "APBROM_VERTICALX_ROMENTRY167"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY167(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY167(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry168
 *
 * APBROM Vertical Romentry168 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry168
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry168_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry168 bdk_apbrom_verticalx_romentry168_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY168(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY168(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY168", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY168(a) bdk_apbrom_verticalx_romentry168_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY168(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY168(a) "APBROM_VERTICALX_ROMENTRY168"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY168(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY168(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry169
 *
 * APBROM Vertical Romentry169 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry169
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry169_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry169_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry169 bdk_apbrom_verticalx_romentry169_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY169(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY169(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY169", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY169(a) bdk_apbrom_verticalx_romentry169_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY169(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY169(a) "APBROM_VERTICALX_ROMENTRY169"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY169(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY169(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry17
 *
 * APBROM Vertical Romentry17 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry17
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry17_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry17 bdk_apbrom_verticalx_romentry17_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY17(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY17(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100044ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY17", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY17(a) bdk_apbrom_verticalx_romentry17_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY17(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY17(a) "APBROM_VERTICALX_ROMENTRY17"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY17(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY17(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry170
 *
 * APBROM Vertical Romentry170 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry170
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry170_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry170_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry170 bdk_apbrom_verticalx_romentry170_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY170(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY170(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY170", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY170(a) bdk_apbrom_verticalx_romentry170_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY170(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY170(a) "APBROM_VERTICALX_ROMENTRY170"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY170(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY170(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry171
 *
 * APBROM Vertical Romentry171 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry171
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry171_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry171_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry171 bdk_apbrom_verticalx_romentry171_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY171(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY171(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY171", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY171(a) bdk_apbrom_verticalx_romentry171_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY171(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY171(a) "APBROM_VERTICALX_ROMENTRY171"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY171(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY171(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry172
 *
 * APBROM Vertical Romentry172 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry172
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry172_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry172_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry172 bdk_apbrom_verticalx_romentry172_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY172(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY172(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY172", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY172(a) bdk_apbrom_verticalx_romentry172_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY172(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY172(a) "APBROM_VERTICALX_ROMENTRY172"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY172(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY172(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry173
 *
 * APBROM Vertical Romentry173 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry173
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry173_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry173_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry173 bdk_apbrom_verticalx_romentry173_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY173(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY173(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY173", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY173(a) bdk_apbrom_verticalx_romentry173_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY173(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY173(a) "APBROM_VERTICALX_ROMENTRY173"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY173(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY173(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry174
 *
 * APBROM Vertical Romentry174 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry174
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry174_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry174_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry174 bdk_apbrom_verticalx_romentry174_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY174(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY174(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY174", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY174(a) bdk_apbrom_verticalx_romentry174_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY174(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY174(a) "APBROM_VERTICALX_ROMENTRY174"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY174(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY174(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry175
 *
 * APBROM Vertical Romentry175 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry175
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry175_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry175_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry175 bdk_apbrom_verticalx_romentry175_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY175(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY175(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY175", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY175(a) bdk_apbrom_verticalx_romentry175_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY175(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY175(a) "APBROM_VERTICALX_ROMENTRY175"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY175(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY175(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry176
 *
 * APBROM Vertical Romentry176 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry176
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry176_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry176 bdk_apbrom_verticalx_romentry176_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY176(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY176(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY176", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY176(a) bdk_apbrom_verticalx_romentry176_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY176(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY176(a) "APBROM_VERTICALX_ROMENTRY176"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY176(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY176(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry177
 *
 * APBROM Vertical Romentry177 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry177
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry177_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry177_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry177 bdk_apbrom_verticalx_romentry177_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY177(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY177(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY177", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY177(a) bdk_apbrom_verticalx_romentry177_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY177(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY177(a) "APBROM_VERTICALX_ROMENTRY177"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY177(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY177(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry178
 *
 * APBROM Vertical Romentry178 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry178
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry178_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry178_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry178 bdk_apbrom_verticalx_romentry178_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY178(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY178(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY178", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY178(a) bdk_apbrom_verticalx_romentry178_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY178(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY178(a) "APBROM_VERTICALX_ROMENTRY178"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY178(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY178(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry179
 *
 * APBROM Vertical Romentry179 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry179
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry179_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry179_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry179 bdk_apbrom_verticalx_romentry179_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY179(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY179(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY179", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY179(a) bdk_apbrom_verticalx_romentry179_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY179(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY179(a) "APBROM_VERTICALX_ROMENTRY179"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY179(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY179(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry18
 *
 * APBROM Vertical Romentry18 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry18
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry18_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry18 bdk_apbrom_verticalx_romentry18_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY18(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY18(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100048ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY18", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY18(a) bdk_apbrom_verticalx_romentry18_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY18(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY18(a) "APBROM_VERTICALX_ROMENTRY18"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY18(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY18(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry180
 *
 * APBROM Vertical Romentry180 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry180
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry180_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry180_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry180 bdk_apbrom_verticalx_romentry180_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY180(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY180(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY180", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY180(a) bdk_apbrom_verticalx_romentry180_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY180(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY180(a) "APBROM_VERTICALX_ROMENTRY180"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY180(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY180(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry181
 *
 * APBROM Vertical Romentry181 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry181
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry181_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry181_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry181 bdk_apbrom_verticalx_romentry181_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY181(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY181(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY181", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY181(a) bdk_apbrom_verticalx_romentry181_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY181(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY181(a) "APBROM_VERTICALX_ROMENTRY181"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY181(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY181(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry182
 *
 * APBROM Vertical Romentry182 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry182
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry182_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry182_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry182 bdk_apbrom_verticalx_romentry182_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY182(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY182(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY182", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY182(a) bdk_apbrom_verticalx_romentry182_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY182(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY182(a) "APBROM_VERTICALX_ROMENTRY182"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY182(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY182(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry183
 *
 * APBROM Vertical Romentry183 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry183
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry183_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry183_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry183 bdk_apbrom_verticalx_romentry183_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY183(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY183(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY183", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY183(a) bdk_apbrom_verticalx_romentry183_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY183(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY183(a) "APBROM_VERTICALX_ROMENTRY183"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY183(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY183(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry184
 *
 * APBROM Vertical Romentry184 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry184
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry184_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry184 bdk_apbrom_verticalx_romentry184_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY184(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY184(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY184", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY184(a) bdk_apbrom_verticalx_romentry184_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY184(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY184(a) "APBROM_VERTICALX_ROMENTRY184"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY184(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY184(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry185
 *
 * APBROM Vertical Romentry185 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry185
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry185_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry185_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry185 bdk_apbrom_verticalx_romentry185_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY185(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY185(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY185", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY185(a) bdk_apbrom_verticalx_romentry185_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY185(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY185(a) "APBROM_VERTICALX_ROMENTRY185"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY185(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY185(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry186
 *
 * APBROM Vertical Romentry186 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry186
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry186_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry186_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry186 bdk_apbrom_verticalx_romentry186_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY186(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY186(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY186", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY186(a) bdk_apbrom_verticalx_romentry186_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY186(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY186(a) "APBROM_VERTICALX_ROMENTRY186"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY186(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY186(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry187
 *
 * APBROM Vertical Romentry187 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry187
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry187_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry187_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry187 bdk_apbrom_verticalx_romentry187_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY187(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY187(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY187", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY187(a) bdk_apbrom_verticalx_romentry187_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY187(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY187(a) "APBROM_VERTICALX_ROMENTRY187"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY187(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY187(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry188
 *
 * APBROM Vertical Romentry188 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry188
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry188_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry188_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry188 bdk_apbrom_verticalx_romentry188_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY188(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY188(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY188", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY188(a) bdk_apbrom_verticalx_romentry188_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY188(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY188(a) "APBROM_VERTICALX_ROMENTRY188"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY188(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY188(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry189
 *
 * APBROM Vertical Romentry189 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry189
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry189_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry189_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry189 bdk_apbrom_verticalx_romentry189_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY189(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY189(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY189", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY189(a) bdk_apbrom_verticalx_romentry189_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY189(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY189(a) "APBROM_VERTICALX_ROMENTRY189"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY189(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY189(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry19
 *
 * APBROM Vertical Romentry19 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry19
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry19_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry19 bdk_apbrom_verticalx_romentry19_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY19(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY19(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610004cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY19", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY19(a) bdk_apbrom_verticalx_romentry19_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY19(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY19(a) "APBROM_VERTICALX_ROMENTRY19"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY19(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY19(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry190
 *
 * APBROM Vertical Romentry190 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry190
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry190_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry190_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry190 bdk_apbrom_verticalx_romentry190_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY190(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY190(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY190", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY190(a) bdk_apbrom_verticalx_romentry190_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY190(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY190(a) "APBROM_VERTICALX_ROMENTRY190"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY190(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY190(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry191
 *
 * APBROM Vertical Romentry191 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry191
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry191_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry191_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry191 bdk_apbrom_verticalx_romentry191_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY191(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY191(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461002fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY191", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY191(a) bdk_apbrom_verticalx_romentry191_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY191(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY191(a) "APBROM_VERTICALX_ROMENTRY191"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY191(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY191(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry192
 *
 * APBROM Vertical Romentry192 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry192
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry192_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry192 bdk_apbrom_verticalx_romentry192_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY192(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY192(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100300ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY192(a) bdk_apbrom_verticalx_romentry192_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY192(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY192(a) "APBROM_VERTICALX_ROMENTRY192"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY192(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY192(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry193
 *
 * APBROM Vertical Romentry193 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry193
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry193_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry193_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry193 bdk_apbrom_verticalx_romentry193_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY193(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY193(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100304ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY193", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY193(a) bdk_apbrom_verticalx_romentry193_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY193(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY193(a) "APBROM_VERTICALX_ROMENTRY193"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY193(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY193(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry194
 *
 * APBROM Vertical Romentry194 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry194
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry194_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry194_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry194 bdk_apbrom_verticalx_romentry194_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY194(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY194(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100308ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY194", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY194(a) bdk_apbrom_verticalx_romentry194_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY194(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY194(a) "APBROM_VERTICALX_ROMENTRY194"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY194(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY194(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry195
 *
 * APBROM Vertical Romentry195 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry195
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry195_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry195_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry195 bdk_apbrom_verticalx_romentry195_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY195(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY195(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610030cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY195", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY195(a) bdk_apbrom_verticalx_romentry195_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY195(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY195(a) "APBROM_VERTICALX_ROMENTRY195"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY195(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY195(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry196
 *
 * APBROM Vertical Romentry196 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry196
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry196_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry196_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry196 bdk_apbrom_verticalx_romentry196_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY196(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY196(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100310ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY196", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY196(a) bdk_apbrom_verticalx_romentry196_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY196(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY196(a) "APBROM_VERTICALX_ROMENTRY196"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY196(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY196(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry197
 *
 * APBROM Vertical Romentry197 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry197
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry197_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry197_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry197 bdk_apbrom_verticalx_romentry197_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY197(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY197(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100314ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY197", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY197(a) bdk_apbrom_verticalx_romentry197_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY197(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY197(a) "APBROM_VERTICALX_ROMENTRY197"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY197(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY197(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry198
 *
 * APBROM Vertical Romentry198 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry198
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry198_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry198_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry198 bdk_apbrom_verticalx_romentry198_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY198(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY198(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100318ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY198", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY198(a) bdk_apbrom_verticalx_romentry198_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY198(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY198(a) "APBROM_VERTICALX_ROMENTRY198"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY198(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY198(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry199
 *
 * APBROM Vertical Romentry199 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry199
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry199_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry199_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry199 bdk_apbrom_verticalx_romentry199_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY199(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY199(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610031cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY199", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY199(a) bdk_apbrom_verticalx_romentry199_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY199(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY199(a) "APBROM_VERTICALX_ROMENTRY199"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY199(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY199(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry2
 *
 * APBROM Vertical Romentry2 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry2
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry2_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry2 bdk_apbrom_verticalx_romentry2_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100008ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY2(a) bdk_apbrom_verticalx_romentry2_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY2(a) "APBROM_VERTICALX_ROMENTRY2"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY2(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry20
 *
 * APBROM Vertical Romentry20 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry20
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry20_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry20 bdk_apbrom_verticalx_romentry20_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY20(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY20(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100050ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY20", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY20(a) bdk_apbrom_verticalx_romentry20_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY20(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY20(a) "APBROM_VERTICALX_ROMENTRY20"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY20(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY20(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry200
 *
 * APBROM Vertical Romentry200 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry200
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry200_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry200_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry200 bdk_apbrom_verticalx_romentry200_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY200(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY200(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100320ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY200", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY200(a) bdk_apbrom_verticalx_romentry200_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY200(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY200(a) "APBROM_VERTICALX_ROMENTRY200"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY200(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY200(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry201
 *
 * APBROM Vertical Romentry201 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry201
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry201_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry201_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry201 bdk_apbrom_verticalx_romentry201_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY201(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY201(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100324ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY201", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY201(a) bdk_apbrom_verticalx_romentry201_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY201(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY201(a) "APBROM_VERTICALX_ROMENTRY201"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY201(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY201(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry202
 *
 * APBROM Vertical Romentry202 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry202
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry202_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry202_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry202 bdk_apbrom_verticalx_romentry202_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY202(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY202(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100328ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY202", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY202(a) bdk_apbrom_verticalx_romentry202_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY202(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY202(a) "APBROM_VERTICALX_ROMENTRY202"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY202(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY202(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry203
 *
 * APBROM Vertical Romentry203 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry203
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry203_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry203_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry203 bdk_apbrom_verticalx_romentry203_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY203(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY203(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610032cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY203", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY203(a) bdk_apbrom_verticalx_romentry203_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY203(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY203(a) "APBROM_VERTICALX_ROMENTRY203"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY203(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY203(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry204
 *
 * APBROM Vertical Romentry204 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry204
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry204_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry204_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry204 bdk_apbrom_verticalx_romentry204_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY204(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY204(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100330ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY204", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY204(a) bdk_apbrom_verticalx_romentry204_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY204(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY204(a) "APBROM_VERTICALX_ROMENTRY204"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY204(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY204(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry205
 *
 * APBROM Vertical Romentry205 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry205
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry205_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry205_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry205 bdk_apbrom_verticalx_romentry205_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY205(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY205(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100334ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY205", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY205(a) bdk_apbrom_verticalx_romentry205_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY205(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY205(a) "APBROM_VERTICALX_ROMENTRY205"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY205(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY205(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry206
 *
 * APBROM Vertical Romentry206 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry206
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry206_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry206_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry206 bdk_apbrom_verticalx_romentry206_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY206(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY206(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100338ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY206", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY206(a) bdk_apbrom_verticalx_romentry206_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY206(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY206(a) "APBROM_VERTICALX_ROMENTRY206"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY206(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY206(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry207
 *
 * APBROM Vertical Romentry207 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry207
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry207_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry207_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry207 bdk_apbrom_verticalx_romentry207_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY207(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY207(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610033cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY207", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY207(a) bdk_apbrom_verticalx_romentry207_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY207(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY207(a) "APBROM_VERTICALX_ROMENTRY207"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY207(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY207(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry208
 *
 * APBROM Vertical Romentry208 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry208
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry208_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry208_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry208 bdk_apbrom_verticalx_romentry208_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY208(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY208(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100340ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY208", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY208(a) bdk_apbrom_verticalx_romentry208_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY208(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY208(a) "APBROM_VERTICALX_ROMENTRY208"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY208(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY208(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry209
 *
 * APBROM Vertical Romentry209 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry209
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry209_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry209_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry209 bdk_apbrom_verticalx_romentry209_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY209(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY209(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100344ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY209", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY209(a) bdk_apbrom_verticalx_romentry209_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY209(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY209(a) "APBROM_VERTICALX_ROMENTRY209"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY209(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY209(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry21
 *
 * APBROM Vertical Romentry21 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry21
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry21_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry21 bdk_apbrom_verticalx_romentry21_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY21(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY21(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100054ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY21", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY21(a) bdk_apbrom_verticalx_romentry21_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY21(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY21(a) "APBROM_VERTICALX_ROMENTRY21"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY21(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY21(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry210
 *
 * APBROM Vertical Romentry210 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry210
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry210_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry210_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry210 bdk_apbrom_verticalx_romentry210_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY210(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY210(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100348ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY210", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY210(a) bdk_apbrom_verticalx_romentry210_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY210(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY210(a) "APBROM_VERTICALX_ROMENTRY210"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY210(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY210(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry211
 *
 * APBROM Vertical Romentry211 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry211
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry211_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry211_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry211 bdk_apbrom_verticalx_romentry211_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY211(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY211(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610034cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY211", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY211(a) bdk_apbrom_verticalx_romentry211_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY211(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY211(a) "APBROM_VERTICALX_ROMENTRY211"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY211(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY211(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry212
 *
 * APBROM Vertical Romentry212 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry212
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry212_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry212_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry212 bdk_apbrom_verticalx_romentry212_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY212(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY212(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100350ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY212", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY212(a) bdk_apbrom_verticalx_romentry212_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY212(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY212(a) "APBROM_VERTICALX_ROMENTRY212"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY212(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY212(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry213
 *
 * APBROM Vertical Romentry213 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry213
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry213_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry213_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry213 bdk_apbrom_verticalx_romentry213_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY213(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY213(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100354ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY213", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY213(a) bdk_apbrom_verticalx_romentry213_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY213(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY213(a) "APBROM_VERTICALX_ROMENTRY213"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY213(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY213(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry214
 *
 * APBROM Vertical Romentry214 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry214
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry214_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry214_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry214 bdk_apbrom_verticalx_romentry214_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY214(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY214(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100358ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY214", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY214(a) bdk_apbrom_verticalx_romentry214_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY214(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY214(a) "APBROM_VERTICALX_ROMENTRY214"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY214(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY214(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry215
 *
 * APBROM Vertical Romentry215 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry215
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry215_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry215_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry215 bdk_apbrom_verticalx_romentry215_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY215(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY215(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610035cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY215", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY215(a) bdk_apbrom_verticalx_romentry215_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY215(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY215(a) "APBROM_VERTICALX_ROMENTRY215"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY215(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY215(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry216
 *
 * APBROM Vertical Romentry216 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry216
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry216_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry216_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry216 bdk_apbrom_verticalx_romentry216_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY216(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY216(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100360ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY216", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY216(a) bdk_apbrom_verticalx_romentry216_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY216(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY216(a) "APBROM_VERTICALX_ROMENTRY216"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY216(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY216(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry217
 *
 * APBROM Vertical Romentry217 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry217
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry217_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry217_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry217 bdk_apbrom_verticalx_romentry217_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY217(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY217(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100364ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY217", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY217(a) bdk_apbrom_verticalx_romentry217_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY217(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY217(a) "APBROM_VERTICALX_ROMENTRY217"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY217(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY217(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry218
 *
 * APBROM Vertical Romentry218 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry218
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry218_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry218_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry218 bdk_apbrom_verticalx_romentry218_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY218(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY218(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100368ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY218", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY218(a) bdk_apbrom_verticalx_romentry218_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY218(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY218(a) "APBROM_VERTICALX_ROMENTRY218"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY218(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY218(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry219
 *
 * APBROM Vertical Romentry219 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry219
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry219_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry219_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry219 bdk_apbrom_verticalx_romentry219_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY219(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY219(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610036cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY219", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY219(a) bdk_apbrom_verticalx_romentry219_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY219(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY219(a) "APBROM_VERTICALX_ROMENTRY219"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY219(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY219(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry22
 *
 * APBROM Vertical Romentry22 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry22
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry22_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry22 bdk_apbrom_verticalx_romentry22_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY22(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY22(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100058ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY22", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY22(a) bdk_apbrom_verticalx_romentry22_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY22(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY22(a) "APBROM_VERTICALX_ROMENTRY22"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY22(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY22(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry220
 *
 * APBROM Vertical Romentry220 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry220
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry220_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry220_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry220 bdk_apbrom_verticalx_romentry220_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY220(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY220(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100370ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY220", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY220(a) bdk_apbrom_verticalx_romentry220_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY220(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY220(a) "APBROM_VERTICALX_ROMENTRY220"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY220(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY220(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry221
 *
 * APBROM Vertical Romentry221 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry221
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry221_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry221_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry221 bdk_apbrom_verticalx_romentry221_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY221(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY221(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100374ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY221", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY221(a) bdk_apbrom_verticalx_romentry221_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY221(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY221(a) "APBROM_VERTICALX_ROMENTRY221"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY221(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY221(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry222
 *
 * APBROM Vertical Romentry222 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry222
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry222_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry222_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry222 bdk_apbrom_verticalx_romentry222_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY222(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY222(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100378ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY222", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY222(a) bdk_apbrom_verticalx_romentry222_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY222(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY222(a) "APBROM_VERTICALX_ROMENTRY222"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY222(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY222(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry223
 *
 * APBROM Vertical Romentry223 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry223
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry223_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry223_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry223 bdk_apbrom_verticalx_romentry223_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY223(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY223(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610037cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY223", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY223(a) bdk_apbrom_verticalx_romentry223_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY223(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY223(a) "APBROM_VERTICALX_ROMENTRY223"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY223(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY223(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry224
 *
 * APBROM Vertical Romentry224 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry224
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry224_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry224_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry224 bdk_apbrom_verticalx_romentry224_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY224(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY224(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100380ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY224", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY224(a) bdk_apbrom_verticalx_romentry224_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY224(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY224(a) "APBROM_VERTICALX_ROMENTRY224"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY224(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY224(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry225
 *
 * APBROM Vertical Romentry225 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry225
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry225_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry225_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry225 bdk_apbrom_verticalx_romentry225_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY225(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY225(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100384ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY225", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY225(a) bdk_apbrom_verticalx_romentry225_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY225(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY225(a) "APBROM_VERTICALX_ROMENTRY225"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY225(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY225(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry226
 *
 * APBROM Vertical Romentry226 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry226
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry226_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry226_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry226 bdk_apbrom_verticalx_romentry226_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY226(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY226(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100388ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY226", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY226(a) bdk_apbrom_verticalx_romentry226_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY226(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY226(a) "APBROM_VERTICALX_ROMENTRY226"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY226(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY226(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry227
 *
 * APBROM Vertical Romentry227 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry227
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry227_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry227_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry227 bdk_apbrom_verticalx_romentry227_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY227(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY227(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610038cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY227", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY227(a) bdk_apbrom_verticalx_romentry227_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY227(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY227(a) "APBROM_VERTICALX_ROMENTRY227"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY227(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY227(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry228
 *
 * APBROM Vertical Romentry228 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry228
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry228_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry228_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry228 bdk_apbrom_verticalx_romentry228_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY228(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY228(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100390ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY228", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY228(a) bdk_apbrom_verticalx_romentry228_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY228(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY228(a) "APBROM_VERTICALX_ROMENTRY228"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY228(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY228(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry229
 *
 * APBROM Vertical Romentry229 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry229
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry229_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry229_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry229 bdk_apbrom_verticalx_romentry229_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY229(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY229(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100394ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY229", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY229(a) bdk_apbrom_verticalx_romentry229_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY229(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY229(a) "APBROM_VERTICALX_ROMENTRY229"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY229(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY229(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry23
 *
 * APBROM Vertical Romentry23 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry23
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry23_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry23_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry23 bdk_apbrom_verticalx_romentry23_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY23(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY23(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610005cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY23", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY23(a) bdk_apbrom_verticalx_romentry23_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY23(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY23(a) "APBROM_VERTICALX_ROMENTRY23"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY23(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY23(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry230
 *
 * APBROM Vertical Romentry230 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry230
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry230_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry230_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry230 bdk_apbrom_verticalx_romentry230_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY230(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY230(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100398ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY230", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY230(a) bdk_apbrom_verticalx_romentry230_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY230(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY230(a) "APBROM_VERTICALX_ROMENTRY230"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY230(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY230(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry231
 *
 * APBROM Vertical Romentry231 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry231
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry231_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry231_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry231 bdk_apbrom_verticalx_romentry231_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY231(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY231(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610039cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY231", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY231(a) bdk_apbrom_verticalx_romentry231_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY231(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY231(a) "APBROM_VERTICALX_ROMENTRY231"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY231(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY231(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry232
 *
 * APBROM Vertical Romentry232 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry232
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry232_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry232_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry232 bdk_apbrom_verticalx_romentry232_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY232(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY232(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY232", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY232(a) bdk_apbrom_verticalx_romentry232_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY232(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY232(a) "APBROM_VERTICALX_ROMENTRY232"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY232(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY232(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry233
 *
 * APBROM Vertical Romentry233 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry233
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry233_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry233_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry233 bdk_apbrom_verticalx_romentry233_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY233(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY233(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY233", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY233(a) bdk_apbrom_verticalx_romentry233_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY233(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY233(a) "APBROM_VERTICALX_ROMENTRY233"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY233(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY233(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry234
 *
 * APBROM Vertical Romentry234 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry234
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry234_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry234_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry234 bdk_apbrom_verticalx_romentry234_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY234(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY234(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY234", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY234(a) bdk_apbrom_verticalx_romentry234_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY234(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY234(a) "APBROM_VERTICALX_ROMENTRY234"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY234(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY234(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry235
 *
 * APBROM Vertical Romentry235 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry235
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry235_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry235_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry235 bdk_apbrom_verticalx_romentry235_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY235(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY235(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY235", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY235(a) bdk_apbrom_verticalx_romentry235_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY235(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY235(a) "APBROM_VERTICALX_ROMENTRY235"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY235(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY235(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry236
 *
 * APBROM Vertical Romentry236 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry236
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry236_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry236_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry236 bdk_apbrom_verticalx_romentry236_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY236(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY236(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY236", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY236(a) bdk_apbrom_verticalx_romentry236_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY236(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY236(a) "APBROM_VERTICALX_ROMENTRY236"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY236(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY236(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry237
 *
 * APBROM Vertical Romentry237 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry237
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry237_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry237_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry237 bdk_apbrom_verticalx_romentry237_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY237(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY237(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY237", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY237(a) bdk_apbrom_verticalx_romentry237_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY237(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY237(a) "APBROM_VERTICALX_ROMENTRY237"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY237(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY237(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry238
 *
 * APBROM Vertical Romentry238 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry238
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry238_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry238_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry238 bdk_apbrom_verticalx_romentry238_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY238(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY238(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY238", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY238(a) bdk_apbrom_verticalx_romentry238_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY238(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY238(a) "APBROM_VERTICALX_ROMENTRY238"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY238(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY238(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry239
 *
 * APBROM Vertical Romentry239 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry239
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry239_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry239_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry239 bdk_apbrom_verticalx_romentry239_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY239(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY239(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY239", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY239(a) bdk_apbrom_verticalx_romentry239_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY239(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY239(a) "APBROM_VERTICALX_ROMENTRY239"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY239(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY239(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry24
 *
 * APBROM Vertical Romentry24 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry24
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry24_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry24 bdk_apbrom_verticalx_romentry24_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY24(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY24(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100060ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY24", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY24(a) bdk_apbrom_verticalx_romentry24_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY24(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY24(a) "APBROM_VERTICALX_ROMENTRY24"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY24(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY24(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry240
 *
 * APBROM Vertical Romentry240 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry240
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry240_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry240_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry240 bdk_apbrom_verticalx_romentry240_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY240(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY240(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY240", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY240(a) bdk_apbrom_verticalx_romentry240_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY240(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY240(a) "APBROM_VERTICALX_ROMENTRY240"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY240(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY240(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry241
 *
 * APBROM Vertical Romentry241 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry241
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry241_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry241_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry241 bdk_apbrom_verticalx_romentry241_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY241(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY241(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY241", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY241(a) bdk_apbrom_verticalx_romentry241_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY241(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY241(a) "APBROM_VERTICALX_ROMENTRY241"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY241(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY241(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry242
 *
 * APBROM Vertical Romentry242 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry242
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry242_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry242_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry242 bdk_apbrom_verticalx_romentry242_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY242(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY242(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY242", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY242(a) bdk_apbrom_verticalx_romentry242_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY242(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY242(a) "APBROM_VERTICALX_ROMENTRY242"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY242(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY242(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry243
 *
 * APBROM Vertical Romentry243 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry243
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry243_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry243_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry243 bdk_apbrom_verticalx_romentry243_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY243(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY243(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY243", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY243(a) bdk_apbrom_verticalx_romentry243_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY243(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY243(a) "APBROM_VERTICALX_ROMENTRY243"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY243(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY243(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry244
 *
 * APBROM Vertical Romentry244 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry244
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry244_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry244_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry244 bdk_apbrom_verticalx_romentry244_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY244(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY244(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY244", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY244(a) bdk_apbrom_verticalx_romentry244_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY244(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY244(a) "APBROM_VERTICALX_ROMENTRY244"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY244(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY244(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry245
 *
 * APBROM Vertical Romentry245 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry245
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry245_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry245_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry245 bdk_apbrom_verticalx_romentry245_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY245(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY245(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY245", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY245(a) bdk_apbrom_verticalx_romentry245_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY245(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY245(a) "APBROM_VERTICALX_ROMENTRY245"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY245(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY245(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry246
 *
 * APBROM Vertical Romentry246 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry246
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry246_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry246_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry246 bdk_apbrom_verticalx_romentry246_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY246(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY246(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY246", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY246(a) bdk_apbrom_verticalx_romentry246_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY246(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY246(a) "APBROM_VERTICALX_ROMENTRY246"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY246(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY246(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry247
 *
 * APBROM Vertical Romentry247 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry247
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry247_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry247_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry247 bdk_apbrom_verticalx_romentry247_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY247(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY247(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY247", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY247(a) bdk_apbrom_verticalx_romentry247_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY247(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY247(a) "APBROM_VERTICALX_ROMENTRY247"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY247(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY247(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry248
 *
 * APBROM Vertical Romentry248 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry248
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry248_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry248_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry248 bdk_apbrom_verticalx_romentry248_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY248(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY248(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY248", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY248(a) bdk_apbrom_verticalx_romentry248_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY248(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY248(a) "APBROM_VERTICALX_ROMENTRY248"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY248(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY248(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry249
 *
 * APBROM Vertical Romentry249 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry249
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry249_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry249_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry249 bdk_apbrom_verticalx_romentry249_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY249(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY249(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY249", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY249(a) bdk_apbrom_verticalx_romentry249_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY249(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY249(a) "APBROM_VERTICALX_ROMENTRY249"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY249(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY249(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry25
 *
 * APBROM Vertical Romentry25 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry25
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry25_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry25 bdk_apbrom_verticalx_romentry25_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY25(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY25(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100064ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY25", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY25(a) bdk_apbrom_verticalx_romentry25_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY25(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY25(a) "APBROM_VERTICALX_ROMENTRY25"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY25(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY25(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry250
 *
 * APBROM Vertical Romentry250 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry250
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry250_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry250_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry250 bdk_apbrom_verticalx_romentry250_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY250(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY250(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY250", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY250(a) bdk_apbrom_verticalx_romentry250_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY250(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY250(a) "APBROM_VERTICALX_ROMENTRY250"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY250(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY250(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry251
 *
 * APBROM Vertical Romentry251 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry251
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry251_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry251_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry251 bdk_apbrom_verticalx_romentry251_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY251(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY251(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY251", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY251(a) bdk_apbrom_verticalx_romentry251_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY251(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY251(a) "APBROM_VERTICALX_ROMENTRY251"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY251(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY251(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry252
 *
 * APBROM Vertical Romentry252 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry252
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry252_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry252_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry252 bdk_apbrom_verticalx_romentry252_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY252(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY252(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY252", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY252(a) bdk_apbrom_verticalx_romentry252_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY252(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY252(a) "APBROM_VERTICALX_ROMENTRY252"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY252(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY252(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry253
 *
 * APBROM Vertical Romentry253 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry253
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry253_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry253_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry253 bdk_apbrom_verticalx_romentry253_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY253(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY253(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY253", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY253(a) bdk_apbrom_verticalx_romentry253_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY253(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY253(a) "APBROM_VERTICALX_ROMENTRY253"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY253(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY253(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry254
 *
 * APBROM Vertical Romentry254 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry254
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry254_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry254_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry254 bdk_apbrom_verticalx_romentry254_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY254(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY254(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY254", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY254(a) bdk_apbrom_verticalx_romentry254_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY254(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY254(a) "APBROM_VERTICALX_ROMENTRY254"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY254(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY254(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry255
 *
 * APBROM Vertical Romentry255 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry255
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry255_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry255_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry255 bdk_apbrom_verticalx_romentry255_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY255(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY255(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461003fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY255", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY255(a) bdk_apbrom_verticalx_romentry255_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY255(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY255(a) "APBROM_VERTICALX_ROMENTRY255"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY255(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY255(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry256
 *
 * APBROM Vertical Romentry256 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry256
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry256_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry256_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry256 bdk_apbrom_verticalx_romentry256_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY256(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY256(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100400ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY256", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY256(a) bdk_apbrom_verticalx_romentry256_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY256(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY256(a) "APBROM_VERTICALX_ROMENTRY256"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY256(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY256(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry257
 *
 * APBROM Vertical Romentry257 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry257
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry257_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry257_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry257 bdk_apbrom_verticalx_romentry257_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY257(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY257(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100404ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY257", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY257(a) bdk_apbrom_verticalx_romentry257_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY257(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY257(a) "APBROM_VERTICALX_ROMENTRY257"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY257(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY257(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry258
 *
 * APBROM Vertical Romentry258 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry258
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry258_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry258_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry258 bdk_apbrom_verticalx_romentry258_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY258(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY258(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100408ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY258", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY258(a) bdk_apbrom_verticalx_romentry258_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY258(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY258(a) "APBROM_VERTICALX_ROMENTRY258"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY258(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY258(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry259
 *
 * APBROM Vertical Romentry259 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry259
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry259_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry259_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry259 bdk_apbrom_verticalx_romentry259_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY259(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY259(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610040cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY259", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY259(a) bdk_apbrom_verticalx_romentry259_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY259(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY259(a) "APBROM_VERTICALX_ROMENTRY259"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY259(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY259(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry26
 *
 * APBROM Vertical Romentry26 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry26
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry26_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry26_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry26 bdk_apbrom_verticalx_romentry26_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY26(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY26(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100068ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY26", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY26(a) bdk_apbrom_verticalx_romentry26_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY26(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY26(a) "APBROM_VERTICALX_ROMENTRY26"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY26(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY26(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry260
 *
 * APBROM Vertical Romentry260 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry260
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry260_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry260_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry260 bdk_apbrom_verticalx_romentry260_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY260(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY260(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100410ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY260", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY260(a) bdk_apbrom_verticalx_romentry260_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY260(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY260(a) "APBROM_VERTICALX_ROMENTRY260"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY260(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY260(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry261
 *
 * APBROM Vertical Romentry261 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry261
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry261_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry261_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry261 bdk_apbrom_verticalx_romentry261_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY261(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY261(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100414ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY261", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY261(a) bdk_apbrom_verticalx_romentry261_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY261(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY261(a) "APBROM_VERTICALX_ROMENTRY261"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY261(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY261(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry262
 *
 * APBROM Vertical Romentry262 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry262
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry262_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry262_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry262 bdk_apbrom_verticalx_romentry262_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY262(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY262(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100418ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY262", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY262(a) bdk_apbrom_verticalx_romentry262_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY262(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY262(a) "APBROM_VERTICALX_ROMENTRY262"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY262(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY262(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry263
 *
 * APBROM Vertical Romentry263 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry263
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry263_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry263_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry263 bdk_apbrom_verticalx_romentry263_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY263(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY263(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610041cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY263", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY263(a) bdk_apbrom_verticalx_romentry263_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY263(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY263(a) "APBROM_VERTICALX_ROMENTRY263"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY263(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY263(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry264
 *
 * APBROM Vertical Romentry264 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry264
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry264_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry264_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry264 bdk_apbrom_verticalx_romentry264_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY264(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY264(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100420ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY264", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY264(a) bdk_apbrom_verticalx_romentry264_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY264(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY264(a) "APBROM_VERTICALX_ROMENTRY264"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY264(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY264(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry265
 *
 * APBROM Vertical Romentry265 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry265
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry265_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry265_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry265 bdk_apbrom_verticalx_romentry265_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY265(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY265(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100424ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY265", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY265(a) bdk_apbrom_verticalx_romentry265_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY265(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY265(a) "APBROM_VERTICALX_ROMENTRY265"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY265(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY265(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry266
 *
 * APBROM Vertical Romentry266 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry266
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry266_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry266_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry266 bdk_apbrom_verticalx_romentry266_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY266(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY266(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100428ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY266", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY266(a) bdk_apbrom_verticalx_romentry266_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY266(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY266(a) "APBROM_VERTICALX_ROMENTRY266"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY266(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY266(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry267
 *
 * APBROM Vertical Romentry267 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry267
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry267_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry267_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry267 bdk_apbrom_verticalx_romentry267_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY267(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY267(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610042cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY267", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY267(a) bdk_apbrom_verticalx_romentry267_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY267(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY267(a) "APBROM_VERTICALX_ROMENTRY267"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY267(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY267(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry268
 *
 * APBROM Vertical Romentry268 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry268
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry268_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry268_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry268 bdk_apbrom_verticalx_romentry268_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY268(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY268(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100430ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY268", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY268(a) bdk_apbrom_verticalx_romentry268_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY268(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY268(a) "APBROM_VERTICALX_ROMENTRY268"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY268(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY268(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry269
 *
 * APBROM Vertical Romentry269 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry269
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry269_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry269_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry269 bdk_apbrom_verticalx_romentry269_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY269(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY269(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100434ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY269", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY269(a) bdk_apbrom_verticalx_romentry269_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY269(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY269(a) "APBROM_VERTICALX_ROMENTRY269"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY269(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY269(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry27
 *
 * APBROM Vertical Romentry27 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry27
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry27_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry27_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry27 bdk_apbrom_verticalx_romentry27_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY27(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY27(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610006cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY27", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY27(a) bdk_apbrom_verticalx_romentry27_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY27(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY27(a) "APBROM_VERTICALX_ROMENTRY27"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY27(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY27(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry270
 *
 * APBROM Vertical Romentry270 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry270
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry270_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry270_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry270 bdk_apbrom_verticalx_romentry270_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY270(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY270(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100438ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY270", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY270(a) bdk_apbrom_verticalx_romentry270_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY270(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY270(a) "APBROM_VERTICALX_ROMENTRY270"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY270(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY270(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry271
 *
 * APBROM Vertical Romentry271 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry271
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry271_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry271_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry271 bdk_apbrom_verticalx_romentry271_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY271(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY271(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610043cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY271", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY271(a) bdk_apbrom_verticalx_romentry271_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY271(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY271(a) "APBROM_VERTICALX_ROMENTRY271"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY271(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY271(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry272
 *
 * APBROM Vertical Romentry272 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry272
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry272_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry272_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry272 bdk_apbrom_verticalx_romentry272_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY272(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY272(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100440ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY272", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY272(a) bdk_apbrom_verticalx_romentry272_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY272(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY272(a) "APBROM_VERTICALX_ROMENTRY272"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY272(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY272(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry273
 *
 * APBROM Vertical Romentry273 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry273
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry273_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry273_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry273 bdk_apbrom_verticalx_romentry273_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY273(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY273(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100444ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY273", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY273(a) bdk_apbrom_verticalx_romentry273_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY273(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY273(a) "APBROM_VERTICALX_ROMENTRY273"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY273(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY273(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry274
 *
 * APBROM Vertical Romentry274 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry274
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry274_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry274_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry274 bdk_apbrom_verticalx_romentry274_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY274(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY274(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100448ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY274", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY274(a) bdk_apbrom_verticalx_romentry274_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY274(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY274(a) "APBROM_VERTICALX_ROMENTRY274"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY274(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY274(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry275
 *
 * APBROM Vertical Romentry275 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry275
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry275_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry275_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry275 bdk_apbrom_verticalx_romentry275_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY275(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY275(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610044cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY275", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY275(a) bdk_apbrom_verticalx_romentry275_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY275(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY275(a) "APBROM_VERTICALX_ROMENTRY275"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY275(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY275(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry276
 *
 * APBROM Vertical Romentry276 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry276
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry276_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry276_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry276 bdk_apbrom_verticalx_romentry276_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY276(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY276(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100450ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY276", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY276(a) bdk_apbrom_verticalx_romentry276_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY276(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY276(a) "APBROM_VERTICALX_ROMENTRY276"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY276(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY276(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry277
 *
 * APBROM Vertical Romentry277 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry277
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry277_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry277_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry277 bdk_apbrom_verticalx_romentry277_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY277(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY277(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100454ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY277", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY277(a) bdk_apbrom_verticalx_romentry277_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY277(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY277(a) "APBROM_VERTICALX_ROMENTRY277"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY277(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY277(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry278
 *
 * APBROM Vertical Romentry278 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry278
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry278_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry278_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry278 bdk_apbrom_verticalx_romentry278_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY278(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY278(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100458ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY278", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY278(a) bdk_apbrom_verticalx_romentry278_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY278(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY278(a) "APBROM_VERTICALX_ROMENTRY278"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY278(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY278(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry279
 *
 * APBROM Vertical Romentry279 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry279
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry279_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry279_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry279 bdk_apbrom_verticalx_romentry279_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY279(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY279(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610045cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY279", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY279(a) bdk_apbrom_verticalx_romentry279_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY279(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY279(a) "APBROM_VERTICALX_ROMENTRY279"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY279(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY279(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry28
 *
 * APBROM Vertical Romentry28 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry28
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry28_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry28_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry28 bdk_apbrom_verticalx_romentry28_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY28(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY28(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100070ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY28", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY28(a) bdk_apbrom_verticalx_romentry28_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY28(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY28(a) "APBROM_VERTICALX_ROMENTRY28"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY28(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY28(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry280
 *
 * APBROM Vertical Romentry280 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry280
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry280_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry280_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry280 bdk_apbrom_verticalx_romentry280_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY280(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY280(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100460ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY280", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY280(a) bdk_apbrom_verticalx_romentry280_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY280(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY280(a) "APBROM_VERTICALX_ROMENTRY280"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY280(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY280(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry281
 *
 * APBROM Vertical Romentry281 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry281
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry281_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry281_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry281 bdk_apbrom_verticalx_romentry281_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY281(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY281(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100464ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY281", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY281(a) bdk_apbrom_verticalx_romentry281_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY281(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY281(a) "APBROM_VERTICALX_ROMENTRY281"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY281(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY281(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry282
 *
 * APBROM Vertical Romentry282 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry282
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry282_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry282_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry282 bdk_apbrom_verticalx_romentry282_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY282(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY282(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100468ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY282", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY282(a) bdk_apbrom_verticalx_romentry282_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY282(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY282(a) "APBROM_VERTICALX_ROMENTRY282"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY282(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY282(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry283
 *
 * APBROM Vertical Romentry283 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry283
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry283_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry283_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry283 bdk_apbrom_verticalx_romentry283_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY283(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY283(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610046cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY283", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY283(a) bdk_apbrom_verticalx_romentry283_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY283(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY283(a) "APBROM_VERTICALX_ROMENTRY283"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY283(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY283(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry284
 *
 * APBROM Vertical Romentry284 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry284
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry284_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry284_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry284 bdk_apbrom_verticalx_romentry284_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY284(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY284(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100470ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY284", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY284(a) bdk_apbrom_verticalx_romentry284_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY284(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY284(a) "APBROM_VERTICALX_ROMENTRY284"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY284(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY284(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry285
 *
 * APBROM Vertical Romentry285 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry285
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry285_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry285_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry285 bdk_apbrom_verticalx_romentry285_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY285(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY285(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100474ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY285", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY285(a) bdk_apbrom_verticalx_romentry285_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY285(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY285(a) "APBROM_VERTICALX_ROMENTRY285"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY285(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY285(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry286
 *
 * APBROM Vertical Romentry286 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry286
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry286_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry286_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry286 bdk_apbrom_verticalx_romentry286_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY286(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY286(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100478ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY286", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY286(a) bdk_apbrom_verticalx_romentry286_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY286(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY286(a) "APBROM_VERTICALX_ROMENTRY286"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY286(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY286(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry287
 *
 * APBROM Vertical Romentry287 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry287
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry287_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry287_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry287 bdk_apbrom_verticalx_romentry287_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY287(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY287(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610047cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY287", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY287(a) bdk_apbrom_verticalx_romentry287_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY287(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY287(a) "APBROM_VERTICALX_ROMENTRY287"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY287(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY287(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry288
 *
 * APBROM Vertical Romentry288 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry288
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry288_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry288_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry288 bdk_apbrom_verticalx_romentry288_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY288(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY288(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100480ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY288", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY288(a) bdk_apbrom_verticalx_romentry288_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY288(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY288(a) "APBROM_VERTICALX_ROMENTRY288"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY288(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY288(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry289
 *
 * APBROM Vertical Romentry289 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry289
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry289_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry289_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry289 bdk_apbrom_verticalx_romentry289_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY289(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY289(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100484ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY289", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY289(a) bdk_apbrom_verticalx_romentry289_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY289(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY289(a) "APBROM_VERTICALX_ROMENTRY289"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY289(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY289(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry29
 *
 * APBROM Vertical Romentry29 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry29
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry29_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry29_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry29 bdk_apbrom_verticalx_romentry29_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY29(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY29(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100074ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY29", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY29(a) bdk_apbrom_verticalx_romentry29_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY29(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY29(a) "APBROM_VERTICALX_ROMENTRY29"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY29(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY29(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry290
 *
 * APBROM Vertical Romentry290 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry290
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry290_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry290_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry290 bdk_apbrom_verticalx_romentry290_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY290(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY290(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100488ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY290", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY290(a) bdk_apbrom_verticalx_romentry290_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY290(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY290(a) "APBROM_VERTICALX_ROMENTRY290"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY290(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY290(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry291
 *
 * APBROM Vertical Romentry291 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry291
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry291_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry291_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry291 bdk_apbrom_verticalx_romentry291_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY291(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY291(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610048cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY291", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY291(a) bdk_apbrom_verticalx_romentry291_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY291(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY291(a) "APBROM_VERTICALX_ROMENTRY291"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY291(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY291(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry292
 *
 * APBROM Vertical Romentry292 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry292
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry292_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry292_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry292 bdk_apbrom_verticalx_romentry292_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY292(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY292(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100490ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY292", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY292(a) bdk_apbrom_verticalx_romentry292_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY292(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY292(a) "APBROM_VERTICALX_ROMENTRY292"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY292(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY292(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry293
 *
 * APBROM Vertical Romentry293 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry293
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry293_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry293_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry293 bdk_apbrom_verticalx_romentry293_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY293(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY293(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100494ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY293", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY293(a) bdk_apbrom_verticalx_romentry293_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY293(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY293(a) "APBROM_VERTICALX_ROMENTRY293"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY293(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY293(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry294
 *
 * APBROM Vertical Romentry294 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry294
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry294_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry294_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry294 bdk_apbrom_verticalx_romentry294_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY294(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY294(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100498ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY294", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY294(a) bdk_apbrom_verticalx_romentry294_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY294(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY294(a) "APBROM_VERTICALX_ROMENTRY294"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY294(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY294(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry295
 *
 * APBROM Vertical Romentry295 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry295
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry295_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry295_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry295 bdk_apbrom_verticalx_romentry295_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY295(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY295(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610049cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY295", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY295(a) bdk_apbrom_verticalx_romentry295_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY295(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY295(a) "APBROM_VERTICALX_ROMENTRY295"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY295(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY295(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry296
 *
 * APBROM Vertical Romentry296 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry296
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry296_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry296_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry296 bdk_apbrom_verticalx_romentry296_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY296(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY296(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY296", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY296(a) bdk_apbrom_verticalx_romentry296_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY296(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY296(a) "APBROM_VERTICALX_ROMENTRY296"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY296(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY296(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry297
 *
 * APBROM Vertical Romentry297 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry297
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry297_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry297_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry297 bdk_apbrom_verticalx_romentry297_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY297(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY297(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY297", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY297(a) bdk_apbrom_verticalx_romentry297_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY297(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY297(a) "APBROM_VERTICALX_ROMENTRY297"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY297(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY297(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry298
 *
 * APBROM Vertical Romentry298 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry298
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry298_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry298_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry298 bdk_apbrom_verticalx_romentry298_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY298(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY298(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY298", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY298(a) bdk_apbrom_verticalx_romentry298_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY298(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY298(a) "APBROM_VERTICALX_ROMENTRY298"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY298(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY298(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry299
 *
 * APBROM Vertical Romentry299 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry299
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry299_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry299_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry299 bdk_apbrom_verticalx_romentry299_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY299(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY299(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY299", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY299(a) bdk_apbrom_verticalx_romentry299_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY299(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY299(a) "APBROM_VERTICALX_ROMENTRY299"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY299(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY299(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry3
 *
 * APBROM Vertical Romentry3 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry3
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry3_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry3 bdk_apbrom_verticalx_romentry3_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610000cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY3(a) bdk_apbrom_verticalx_romentry3_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY3(a) "APBROM_VERTICALX_ROMENTRY3"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY3(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry30
 *
 * APBROM Vertical Romentry30 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry30
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry30_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry30_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry30 bdk_apbrom_verticalx_romentry30_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY30(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY30(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100078ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY30", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY30(a) bdk_apbrom_verticalx_romentry30_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY30(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY30(a) "APBROM_VERTICALX_ROMENTRY30"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY30(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY30(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry300
 *
 * APBROM Vertical Romentry300 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry300
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry300_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry300_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry300 bdk_apbrom_verticalx_romentry300_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY300(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY300(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY300", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY300(a) bdk_apbrom_verticalx_romentry300_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY300(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY300(a) "APBROM_VERTICALX_ROMENTRY300"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY300(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY300(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry301
 *
 * APBROM Vertical Romentry301 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry301
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry301_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry301_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry301 bdk_apbrom_verticalx_romentry301_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY301(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY301(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY301", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY301(a) bdk_apbrom_verticalx_romentry301_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY301(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY301(a) "APBROM_VERTICALX_ROMENTRY301"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY301(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY301(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry302
 *
 * APBROM Vertical Romentry302 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry302
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry302_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry302_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry302 bdk_apbrom_verticalx_romentry302_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY302(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY302(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY302", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY302(a) bdk_apbrom_verticalx_romentry302_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY302(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY302(a) "APBROM_VERTICALX_ROMENTRY302"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY302(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY302(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry303
 *
 * APBROM Vertical Romentry303 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry303
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry303_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry303_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry303 bdk_apbrom_verticalx_romentry303_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY303(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY303(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY303", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY303(a) bdk_apbrom_verticalx_romentry303_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY303(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY303(a) "APBROM_VERTICALX_ROMENTRY303"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY303(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY303(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry304
 *
 * APBROM Vertical Romentry304 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry304
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry304_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry304_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry304 bdk_apbrom_verticalx_romentry304_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY304(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY304(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY304", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY304(a) bdk_apbrom_verticalx_romentry304_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY304(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY304(a) "APBROM_VERTICALX_ROMENTRY304"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY304(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY304(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry305
 *
 * APBROM Vertical Romentry305 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry305
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry305_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry305_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry305 bdk_apbrom_verticalx_romentry305_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY305(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY305(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY305", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY305(a) bdk_apbrom_verticalx_romentry305_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY305(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY305(a) "APBROM_VERTICALX_ROMENTRY305"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY305(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY305(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry306
 *
 * APBROM Vertical Romentry306 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry306
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry306_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry306_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry306 bdk_apbrom_verticalx_romentry306_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY306(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY306(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY306", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY306(a) bdk_apbrom_verticalx_romentry306_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY306(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY306(a) "APBROM_VERTICALX_ROMENTRY306"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY306(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY306(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry307
 *
 * APBROM Vertical Romentry307 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry307
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry307_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry307_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry307 bdk_apbrom_verticalx_romentry307_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY307(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY307(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY307", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY307(a) bdk_apbrom_verticalx_romentry307_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY307(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY307(a) "APBROM_VERTICALX_ROMENTRY307"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY307(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY307(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry308
 *
 * APBROM Vertical Romentry308 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry308
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry308_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry308_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry308 bdk_apbrom_verticalx_romentry308_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY308(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY308(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY308", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY308(a) bdk_apbrom_verticalx_romentry308_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY308(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY308(a) "APBROM_VERTICALX_ROMENTRY308"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY308(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY308(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry309
 *
 * APBROM Vertical Romentry309 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry309
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry309_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry309_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry309 bdk_apbrom_verticalx_romentry309_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY309(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY309(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY309", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY309(a) bdk_apbrom_verticalx_romentry309_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY309(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY309(a) "APBROM_VERTICALX_ROMENTRY309"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY309(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY309(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry31
 *
 * APBROM Vertical Romentry31 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry31
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry31_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry31 bdk_apbrom_verticalx_romentry31_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY31(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY31(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610007cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY31", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY31(a) bdk_apbrom_verticalx_romentry31_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY31(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY31(a) "APBROM_VERTICALX_ROMENTRY31"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY31(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY31(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry310
 *
 * APBROM Vertical Romentry310 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry310
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry310_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry310_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry310 bdk_apbrom_verticalx_romentry310_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY310(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY310(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY310", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY310(a) bdk_apbrom_verticalx_romentry310_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY310(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY310(a) "APBROM_VERTICALX_ROMENTRY310"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY310(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY310(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry311
 *
 * APBROM Vertical Romentry311 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry311
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry311_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry311_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry311 bdk_apbrom_verticalx_romentry311_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY311(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY311(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY311", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY311(a) bdk_apbrom_verticalx_romentry311_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY311(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY311(a) "APBROM_VERTICALX_ROMENTRY311"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY311(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY311(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry312
 *
 * APBROM Vertical Romentry312 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry312
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry312_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry312_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry312 bdk_apbrom_verticalx_romentry312_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY312(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY312(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY312", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY312(a) bdk_apbrom_verticalx_romentry312_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY312(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY312(a) "APBROM_VERTICALX_ROMENTRY312"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY312(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY312(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry313
 *
 * APBROM Vertical Romentry313 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry313
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry313_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry313_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry313 bdk_apbrom_verticalx_romentry313_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY313(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY313(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY313", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY313(a) bdk_apbrom_verticalx_romentry313_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY313(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY313(a) "APBROM_VERTICALX_ROMENTRY313"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY313(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY313(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry314
 *
 * APBROM Vertical Romentry314 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry314
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry314_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry314_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry314 bdk_apbrom_verticalx_romentry314_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY314(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY314(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY314", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY314(a) bdk_apbrom_verticalx_romentry314_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY314(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY314(a) "APBROM_VERTICALX_ROMENTRY314"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY314(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY314(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry315
 *
 * APBROM Vertical Romentry315 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry315
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry315_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry315_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry315 bdk_apbrom_verticalx_romentry315_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY315(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY315(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY315", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY315(a) bdk_apbrom_verticalx_romentry315_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY315(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY315(a) "APBROM_VERTICALX_ROMENTRY315"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY315(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY315(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry316
 *
 * APBROM Vertical Romentry316 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry316
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry316_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry316_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry316 bdk_apbrom_verticalx_romentry316_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY316(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY316(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY316", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY316(a) bdk_apbrom_verticalx_romentry316_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY316(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY316(a) "APBROM_VERTICALX_ROMENTRY316"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY316(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY316(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry317
 *
 * APBROM Vertical Romentry317 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry317
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry317_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry317_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry317 bdk_apbrom_verticalx_romentry317_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY317(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY317(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY317", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY317(a) bdk_apbrom_verticalx_romentry317_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY317(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY317(a) "APBROM_VERTICALX_ROMENTRY317"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY317(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY317(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry318
 *
 * APBROM Vertical Romentry318 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry318
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry318_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry318_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry318 bdk_apbrom_verticalx_romentry318_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY318(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY318(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY318", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY318(a) bdk_apbrom_verticalx_romentry318_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY318(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY318(a) "APBROM_VERTICALX_ROMENTRY318"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY318(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY318(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry319
 *
 * APBROM Vertical Romentry319 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry319
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry319_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry319_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry319 bdk_apbrom_verticalx_romentry319_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY319(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY319(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461004fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY319", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY319(a) bdk_apbrom_verticalx_romentry319_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY319(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY319(a) "APBROM_VERTICALX_ROMENTRY319"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY319(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY319(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry32
 *
 * APBROM Vertical Romentry32 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry32
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry32_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry32 bdk_apbrom_verticalx_romentry32_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY32(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY32(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100080ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY32", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY32(a) bdk_apbrom_verticalx_romentry32_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY32(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY32(a) "APBROM_VERTICALX_ROMENTRY32"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY32(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY32(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry320
 *
 * APBROM Vertical Romentry320 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry320
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry320_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry320_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry320 bdk_apbrom_verticalx_romentry320_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY320(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY320(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100500ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY320", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY320(a) bdk_apbrom_verticalx_romentry320_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY320(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY320(a) "APBROM_VERTICALX_ROMENTRY320"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY320(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY320(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry321
 *
 * APBROM Vertical Romentry321 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry321
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry321_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry321_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry321 bdk_apbrom_verticalx_romentry321_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY321(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY321(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100504ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY321", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY321(a) bdk_apbrom_verticalx_romentry321_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY321(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY321(a) "APBROM_VERTICALX_ROMENTRY321"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY321(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY321(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry322
 *
 * APBROM Vertical Romentry322 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry322
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry322_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry322_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry322 bdk_apbrom_verticalx_romentry322_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY322(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY322(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100508ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY322", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY322(a) bdk_apbrom_verticalx_romentry322_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY322(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY322(a) "APBROM_VERTICALX_ROMENTRY322"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY322(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY322(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry323
 *
 * APBROM Vertical Romentry323 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry323
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry323_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry323_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry323 bdk_apbrom_verticalx_romentry323_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY323(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY323(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610050cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY323", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY323(a) bdk_apbrom_verticalx_romentry323_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY323(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY323(a) "APBROM_VERTICALX_ROMENTRY323"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY323(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY323(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry324
 *
 * APBROM Vertical Romentry324 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry324
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry324_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry324_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry324 bdk_apbrom_verticalx_romentry324_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY324(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY324(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100510ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY324", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY324(a) bdk_apbrom_verticalx_romentry324_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY324(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY324(a) "APBROM_VERTICALX_ROMENTRY324"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY324(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY324(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry325
 *
 * APBROM Vertical Romentry325 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry325
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry325_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry325_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry325 bdk_apbrom_verticalx_romentry325_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY325(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY325(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100514ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY325", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY325(a) bdk_apbrom_verticalx_romentry325_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY325(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY325(a) "APBROM_VERTICALX_ROMENTRY325"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY325(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY325(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry326
 *
 * APBROM Vertical Romentry326 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry326
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry326_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry326_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry326 bdk_apbrom_verticalx_romentry326_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY326(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY326(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100518ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY326", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY326(a) bdk_apbrom_verticalx_romentry326_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY326(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY326(a) "APBROM_VERTICALX_ROMENTRY326"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY326(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY326(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry327
 *
 * APBROM Vertical Romentry327 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry327
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry327_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry327_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry327 bdk_apbrom_verticalx_romentry327_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY327(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY327(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610051cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY327", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY327(a) bdk_apbrom_verticalx_romentry327_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY327(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY327(a) "APBROM_VERTICALX_ROMENTRY327"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY327(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY327(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry328
 *
 * APBROM Vertical Romentry328 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry328
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry328_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry328_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry328 bdk_apbrom_verticalx_romentry328_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY328(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY328(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100520ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY328", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY328(a) bdk_apbrom_verticalx_romentry328_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY328(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY328(a) "APBROM_VERTICALX_ROMENTRY328"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY328(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY328(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry329
 *
 * APBROM Vertical Romentry329 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry329
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry329_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry329_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry329 bdk_apbrom_verticalx_romentry329_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY329(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY329(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100524ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY329", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY329(a) bdk_apbrom_verticalx_romentry329_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY329(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY329(a) "APBROM_VERTICALX_ROMENTRY329"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY329(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY329(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry33
 *
 * APBROM Vertical Romentry33 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry33
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry33_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry33_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry33 bdk_apbrom_verticalx_romentry33_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY33(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY33(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100084ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY33", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY33(a) bdk_apbrom_verticalx_romentry33_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY33(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY33(a) "APBROM_VERTICALX_ROMENTRY33"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY33(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY33(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry330
 *
 * APBROM Vertical Romentry330 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry330
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry330_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry330_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry330 bdk_apbrom_verticalx_romentry330_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY330(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY330(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100528ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY330", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY330(a) bdk_apbrom_verticalx_romentry330_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY330(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY330(a) "APBROM_VERTICALX_ROMENTRY330"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY330(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY330(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry331
 *
 * APBROM Vertical Romentry331 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry331
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry331_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry331_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry331 bdk_apbrom_verticalx_romentry331_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY331(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY331(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610052cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY331", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY331(a) bdk_apbrom_verticalx_romentry331_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY331(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY331(a) "APBROM_VERTICALX_ROMENTRY331"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY331(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY331(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry332
 *
 * APBROM Vertical Romentry332 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry332
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry332_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry332_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry332 bdk_apbrom_verticalx_romentry332_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY332(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY332(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100530ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY332", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY332(a) bdk_apbrom_verticalx_romentry332_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY332(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY332(a) "APBROM_VERTICALX_ROMENTRY332"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY332(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY332(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry333
 *
 * APBROM Vertical Romentry333 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry333
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry333_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry333_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry333 bdk_apbrom_verticalx_romentry333_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY333(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY333(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100534ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY333", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY333(a) bdk_apbrom_verticalx_romentry333_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY333(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY333(a) "APBROM_VERTICALX_ROMENTRY333"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY333(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY333(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry334
 *
 * APBROM Vertical Romentry334 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry334
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry334_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry334_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry334 bdk_apbrom_verticalx_romentry334_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY334(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY334(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100538ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY334", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY334(a) bdk_apbrom_verticalx_romentry334_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY334(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY334(a) "APBROM_VERTICALX_ROMENTRY334"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY334(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY334(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry335
 *
 * APBROM Vertical Romentry335 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry335
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry335_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry335_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry335 bdk_apbrom_verticalx_romentry335_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY335(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY335(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610053cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY335", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY335(a) bdk_apbrom_verticalx_romentry335_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY335(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY335(a) "APBROM_VERTICALX_ROMENTRY335"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY335(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY335(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry336
 *
 * APBROM Vertical Romentry336 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry336
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry336_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry336_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry336 bdk_apbrom_verticalx_romentry336_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY336(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY336(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100540ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY336", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY336(a) bdk_apbrom_verticalx_romentry336_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY336(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY336(a) "APBROM_VERTICALX_ROMENTRY336"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY336(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY336(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry337
 *
 * APBROM Vertical Romentry337 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry337
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry337_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry337_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry337 bdk_apbrom_verticalx_romentry337_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY337(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY337(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100544ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY337", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY337(a) bdk_apbrom_verticalx_romentry337_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY337(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY337(a) "APBROM_VERTICALX_ROMENTRY337"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY337(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY337(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry338
 *
 * APBROM Vertical Romentry338 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry338
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry338_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry338_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry338 bdk_apbrom_verticalx_romentry338_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY338(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY338(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100548ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY338", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY338(a) bdk_apbrom_verticalx_romentry338_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY338(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY338(a) "APBROM_VERTICALX_ROMENTRY338"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY338(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY338(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry339
 *
 * APBROM Vertical Romentry339 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry339
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry339_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry339_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry339 bdk_apbrom_verticalx_romentry339_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY339(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY339(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610054cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY339", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY339(a) bdk_apbrom_verticalx_romentry339_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY339(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY339(a) "APBROM_VERTICALX_ROMENTRY339"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY339(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY339(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry34
 *
 * APBROM Vertical Romentry34 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry34
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry34_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry34_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry34 bdk_apbrom_verticalx_romentry34_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY34(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY34(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100088ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY34", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY34(a) bdk_apbrom_verticalx_romentry34_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY34(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY34(a) "APBROM_VERTICALX_ROMENTRY34"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY34(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY34(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry340
 *
 * APBROM Vertical Romentry340 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry340
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry340_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry340_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry340 bdk_apbrom_verticalx_romentry340_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY340(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY340(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100550ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY340", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY340(a) bdk_apbrom_verticalx_romentry340_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY340(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY340(a) "APBROM_VERTICALX_ROMENTRY340"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY340(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY340(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry341
 *
 * APBROM Vertical Romentry341 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry341
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry341_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry341_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry341 bdk_apbrom_verticalx_romentry341_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY341(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY341(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100554ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY341", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY341(a) bdk_apbrom_verticalx_romentry341_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY341(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY341(a) "APBROM_VERTICALX_ROMENTRY341"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY341(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY341(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry342
 *
 * APBROM Vertical Romentry342 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry342
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry342_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry342_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry342 bdk_apbrom_verticalx_romentry342_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY342(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY342(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100558ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY342", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY342(a) bdk_apbrom_verticalx_romentry342_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY342(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY342(a) "APBROM_VERTICALX_ROMENTRY342"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY342(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY342(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry343
 *
 * APBROM Vertical Romentry343 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry343
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry343_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry343_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry343 bdk_apbrom_verticalx_romentry343_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY343(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY343(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610055cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY343", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY343(a) bdk_apbrom_verticalx_romentry343_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY343(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY343(a) "APBROM_VERTICALX_ROMENTRY343"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY343(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY343(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry344
 *
 * APBROM Vertical Romentry344 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry344
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry344_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry344_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry344 bdk_apbrom_verticalx_romentry344_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY344(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY344(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100560ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY344", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY344(a) bdk_apbrom_verticalx_romentry344_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY344(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY344(a) "APBROM_VERTICALX_ROMENTRY344"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY344(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY344(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry345
 *
 * APBROM Vertical Romentry345 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry345
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry345_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry345_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry345 bdk_apbrom_verticalx_romentry345_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY345(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY345(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100564ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY345", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY345(a) bdk_apbrom_verticalx_romentry345_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY345(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY345(a) "APBROM_VERTICALX_ROMENTRY345"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY345(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY345(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry346
 *
 * APBROM Vertical Romentry346 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry346
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry346_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry346_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry346 bdk_apbrom_verticalx_romentry346_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY346(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY346(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100568ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY346", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY346(a) bdk_apbrom_verticalx_romentry346_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY346(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY346(a) "APBROM_VERTICALX_ROMENTRY346"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY346(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY346(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry347
 *
 * APBROM Vertical Romentry347 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry347
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry347_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry347_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry347 bdk_apbrom_verticalx_romentry347_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY347(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY347(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610056cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY347", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY347(a) bdk_apbrom_verticalx_romentry347_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY347(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY347(a) "APBROM_VERTICALX_ROMENTRY347"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY347(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY347(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry348
 *
 * APBROM Vertical Romentry348 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry348
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry348_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry348_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry348 bdk_apbrom_verticalx_romentry348_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY348(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY348(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100570ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY348", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY348(a) bdk_apbrom_verticalx_romentry348_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY348(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY348(a) "APBROM_VERTICALX_ROMENTRY348"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY348(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY348(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry349
 *
 * APBROM Vertical Romentry349 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry349
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry349_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry349_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry349 bdk_apbrom_verticalx_romentry349_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY349(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY349(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100574ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY349", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY349(a) bdk_apbrom_verticalx_romentry349_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY349(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY349(a) "APBROM_VERTICALX_ROMENTRY349"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY349(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY349(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry35
 *
 * APBROM Vertical Romentry35 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry35
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry35_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry35_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry35 bdk_apbrom_verticalx_romentry35_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY35(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY35(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610008cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY35", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY35(a) bdk_apbrom_verticalx_romentry35_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY35(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY35(a) "APBROM_VERTICALX_ROMENTRY35"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY35(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY35(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry350
 *
 * APBROM Vertical Romentry350 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry350
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry350_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry350_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry350 bdk_apbrom_verticalx_romentry350_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY350(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY350(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100578ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY350", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY350(a) bdk_apbrom_verticalx_romentry350_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY350(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY350(a) "APBROM_VERTICALX_ROMENTRY350"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY350(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY350(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry351
 *
 * APBROM Vertical Romentry351 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry351
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry351_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry351_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry351 bdk_apbrom_verticalx_romentry351_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY351(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY351(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610057cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY351", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY351(a) bdk_apbrom_verticalx_romentry351_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY351(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY351(a) "APBROM_VERTICALX_ROMENTRY351"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY351(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY351(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry352
 *
 * APBROM Vertical Romentry352 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry352
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry352_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry352_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry352 bdk_apbrom_verticalx_romentry352_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY352(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY352(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100580ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY352", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY352(a) bdk_apbrom_verticalx_romentry352_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY352(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY352(a) "APBROM_VERTICALX_ROMENTRY352"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY352(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY352(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry353
 *
 * APBROM Vertical Romentry353 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry353
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry353_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry353_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry353 bdk_apbrom_verticalx_romentry353_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY353(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY353(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100584ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY353", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY353(a) bdk_apbrom_verticalx_romentry353_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY353(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY353(a) "APBROM_VERTICALX_ROMENTRY353"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY353(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY353(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry354
 *
 * APBROM Vertical Romentry354 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry354
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry354_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry354_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry354 bdk_apbrom_verticalx_romentry354_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY354(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY354(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100588ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY354", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY354(a) bdk_apbrom_verticalx_romentry354_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY354(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY354(a) "APBROM_VERTICALX_ROMENTRY354"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY354(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY354(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry355
 *
 * APBROM Vertical Romentry355 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry355
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry355_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry355_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry355 bdk_apbrom_verticalx_romentry355_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY355(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY355(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610058cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY355", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY355(a) bdk_apbrom_verticalx_romentry355_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY355(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY355(a) "APBROM_VERTICALX_ROMENTRY355"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY355(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY355(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry356
 *
 * APBROM Vertical Romentry356 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry356
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry356_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry356_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry356 bdk_apbrom_verticalx_romentry356_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY356(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY356(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100590ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY356", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY356(a) bdk_apbrom_verticalx_romentry356_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY356(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY356(a) "APBROM_VERTICALX_ROMENTRY356"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY356(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY356(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry357
 *
 * APBROM Vertical Romentry357 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry357
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry357_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry357_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry357 bdk_apbrom_verticalx_romentry357_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY357(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY357(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100594ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY357", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY357(a) bdk_apbrom_verticalx_romentry357_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY357(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY357(a) "APBROM_VERTICALX_ROMENTRY357"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY357(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY357(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry358
 *
 * APBROM Vertical Romentry358 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry358
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry358_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry358_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry358 bdk_apbrom_verticalx_romentry358_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY358(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY358(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100598ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY358", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY358(a) bdk_apbrom_verticalx_romentry358_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY358(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY358(a) "APBROM_VERTICALX_ROMENTRY358"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY358(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY358(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry359
 *
 * APBROM Vertical Romentry359 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry359
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry359_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry359_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry359 bdk_apbrom_verticalx_romentry359_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY359(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY359(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610059cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY359", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY359(a) bdk_apbrom_verticalx_romentry359_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY359(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY359(a) "APBROM_VERTICALX_ROMENTRY359"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY359(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY359(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry36
 *
 * APBROM Vertical Romentry36 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry36
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry36_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry36_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry36 bdk_apbrom_verticalx_romentry36_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY36(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY36(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100090ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY36", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY36(a) bdk_apbrom_verticalx_romentry36_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY36(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY36(a) "APBROM_VERTICALX_ROMENTRY36"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY36(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY36(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry360
 *
 * APBROM Vertical Romentry360 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry360
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry360_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry360_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry360 bdk_apbrom_verticalx_romentry360_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY360(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY360(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY360", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY360(a) bdk_apbrom_verticalx_romentry360_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY360(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY360(a) "APBROM_VERTICALX_ROMENTRY360"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY360(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY360(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry361
 *
 * APBROM Vertical Romentry361 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry361
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry361_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry361_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry361 bdk_apbrom_verticalx_romentry361_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY361(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY361(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY361", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY361(a) bdk_apbrom_verticalx_romentry361_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY361(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY361(a) "APBROM_VERTICALX_ROMENTRY361"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY361(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY361(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry362
 *
 * APBROM Vertical Romentry362 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry362
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry362_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry362_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry362 bdk_apbrom_verticalx_romentry362_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY362(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY362(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY362", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY362(a) bdk_apbrom_verticalx_romentry362_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY362(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY362(a) "APBROM_VERTICALX_ROMENTRY362"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY362(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY362(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry363
 *
 * APBROM Vertical Romentry363 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry363
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry363_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry363_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry363 bdk_apbrom_verticalx_romentry363_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY363(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY363(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY363", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY363(a) bdk_apbrom_verticalx_romentry363_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY363(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY363(a) "APBROM_VERTICALX_ROMENTRY363"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY363(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY363(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry364
 *
 * APBROM Vertical Romentry364 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry364
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry364_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry364_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry364 bdk_apbrom_verticalx_romentry364_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY364(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY364(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY364", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY364(a) bdk_apbrom_verticalx_romentry364_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY364(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY364(a) "APBROM_VERTICALX_ROMENTRY364"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY364(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY364(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry365
 *
 * APBROM Vertical Romentry365 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry365
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry365_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry365_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry365 bdk_apbrom_verticalx_romentry365_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY365(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY365(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY365", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY365(a) bdk_apbrom_verticalx_romentry365_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY365(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY365(a) "APBROM_VERTICALX_ROMENTRY365"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY365(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY365(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry366
 *
 * APBROM Vertical Romentry366 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry366
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry366_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry366_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry366 bdk_apbrom_verticalx_romentry366_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY366(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY366(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY366", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY366(a) bdk_apbrom_verticalx_romentry366_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY366(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY366(a) "APBROM_VERTICALX_ROMENTRY366"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY366(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY366(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry367
 *
 * APBROM Vertical Romentry367 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry367
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry367_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry367_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry367 bdk_apbrom_verticalx_romentry367_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY367(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY367(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY367", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY367(a) bdk_apbrom_verticalx_romentry367_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY367(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY367(a) "APBROM_VERTICALX_ROMENTRY367"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY367(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY367(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry368
 *
 * APBROM Vertical Romentry368 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry368
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry368_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry368_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry368 bdk_apbrom_verticalx_romentry368_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY368(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY368(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY368", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY368(a) bdk_apbrom_verticalx_romentry368_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY368(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY368(a) "APBROM_VERTICALX_ROMENTRY368"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY368(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY368(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry369
 *
 * APBROM Vertical Romentry369 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry369
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry369_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry369_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry369 bdk_apbrom_verticalx_romentry369_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY369(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY369(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY369", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY369(a) bdk_apbrom_verticalx_romentry369_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY369(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY369(a) "APBROM_VERTICALX_ROMENTRY369"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY369(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY369(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry37
 *
 * APBROM Vertical Romentry37 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry37
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry37_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry37_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry37 bdk_apbrom_verticalx_romentry37_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY37(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY37(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100094ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY37", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY37(a) bdk_apbrom_verticalx_romentry37_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY37(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY37(a) "APBROM_VERTICALX_ROMENTRY37"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY37(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY37(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry370
 *
 * APBROM Vertical Romentry370 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry370
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry370_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry370_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry370 bdk_apbrom_verticalx_romentry370_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY370(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY370(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY370", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY370(a) bdk_apbrom_verticalx_romentry370_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY370(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY370(a) "APBROM_VERTICALX_ROMENTRY370"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY370(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY370(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry371
 *
 * APBROM Vertical Romentry371 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry371
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry371_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry371_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry371 bdk_apbrom_verticalx_romentry371_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY371(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY371(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY371", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY371(a) bdk_apbrom_verticalx_romentry371_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY371(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY371(a) "APBROM_VERTICALX_ROMENTRY371"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY371(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY371(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry372
 *
 * APBROM Vertical Romentry372 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry372
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry372_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry372_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry372 bdk_apbrom_verticalx_romentry372_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY372(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY372(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY372", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY372(a) bdk_apbrom_verticalx_romentry372_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY372(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY372(a) "APBROM_VERTICALX_ROMENTRY372"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY372(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY372(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry373
 *
 * APBROM Vertical Romentry373 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry373
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry373_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry373_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry373 bdk_apbrom_verticalx_romentry373_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY373(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY373(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY373", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY373(a) bdk_apbrom_verticalx_romentry373_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY373(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY373(a) "APBROM_VERTICALX_ROMENTRY373"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY373(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY373(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry374
 *
 * APBROM Vertical Romentry374 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry374
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry374_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry374_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry374 bdk_apbrom_verticalx_romentry374_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY374(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY374(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY374", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY374(a) bdk_apbrom_verticalx_romentry374_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY374(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY374(a) "APBROM_VERTICALX_ROMENTRY374"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY374(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY374(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry375
 *
 * APBROM Vertical Romentry375 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry375
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry375_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry375_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry375 bdk_apbrom_verticalx_romentry375_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY375(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY375(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY375", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY375(a) bdk_apbrom_verticalx_romentry375_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY375(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY375(a) "APBROM_VERTICALX_ROMENTRY375"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY375(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY375(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry376
 *
 * APBROM Vertical Romentry376 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry376
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry376_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry376_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry376 bdk_apbrom_verticalx_romentry376_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY376(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY376(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY376", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY376(a) bdk_apbrom_verticalx_romentry376_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY376(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY376(a) "APBROM_VERTICALX_ROMENTRY376"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY376(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY376(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry377
 *
 * APBROM Vertical Romentry377 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry377
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry377_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry377_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry377 bdk_apbrom_verticalx_romentry377_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY377(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY377(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY377", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY377(a) bdk_apbrom_verticalx_romentry377_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY377(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY377(a) "APBROM_VERTICALX_ROMENTRY377"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY377(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY377(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry378
 *
 * APBROM Vertical Romentry378 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry378
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry378_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry378_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry378 bdk_apbrom_verticalx_romentry378_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY378(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY378(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY378", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY378(a) bdk_apbrom_verticalx_romentry378_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY378(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY378(a) "APBROM_VERTICALX_ROMENTRY378"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY378(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY378(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry379
 *
 * APBROM Vertical Romentry379 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry379
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry379_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry379_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry379 bdk_apbrom_verticalx_romentry379_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY379(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY379(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY379", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY379(a) bdk_apbrom_verticalx_romentry379_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY379(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY379(a) "APBROM_VERTICALX_ROMENTRY379"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY379(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY379(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry38
 *
 * APBROM Vertical Romentry38 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry38
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry38_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry38_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry38 bdk_apbrom_verticalx_romentry38_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY38(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY38(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100098ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY38", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY38(a) bdk_apbrom_verticalx_romentry38_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY38(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY38(a) "APBROM_VERTICALX_ROMENTRY38"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY38(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY38(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry380
 *
 * APBROM Vertical Romentry380 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry380
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry380_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry380_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry380 bdk_apbrom_verticalx_romentry380_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY380(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY380(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY380", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY380(a) bdk_apbrom_verticalx_romentry380_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY380(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY380(a) "APBROM_VERTICALX_ROMENTRY380"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY380(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY380(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry381
 *
 * APBROM Vertical Romentry381 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry381
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry381_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry381_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry381 bdk_apbrom_verticalx_romentry381_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY381(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY381(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY381", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY381(a) bdk_apbrom_verticalx_romentry381_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY381(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY381(a) "APBROM_VERTICALX_ROMENTRY381"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY381(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY381(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry382
 *
 * APBROM Vertical Romentry382 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry382
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry382_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry382_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry382 bdk_apbrom_verticalx_romentry382_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY382(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY382(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY382", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY382(a) bdk_apbrom_verticalx_romentry382_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY382(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY382(a) "APBROM_VERTICALX_ROMENTRY382"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY382(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY382(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry383
 *
 * APBROM Vertical Romentry383 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry383
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry383_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry383_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry383 bdk_apbrom_verticalx_romentry383_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY383(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY383(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461005fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY383", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY383(a) bdk_apbrom_verticalx_romentry383_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY383(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY383(a) "APBROM_VERTICALX_ROMENTRY383"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY383(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY383(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry384
 *
 * APBROM Vertical Romentry384 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry384
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry384_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry384_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry384 bdk_apbrom_verticalx_romentry384_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY384(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY384(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100600ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY384", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY384(a) bdk_apbrom_verticalx_romentry384_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY384(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY384(a) "APBROM_VERTICALX_ROMENTRY384"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY384(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY384(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry385
 *
 * APBROM Vertical Romentry385 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry385
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry385_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry385_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry385 bdk_apbrom_verticalx_romentry385_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY385(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY385(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100604ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY385", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY385(a) bdk_apbrom_verticalx_romentry385_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY385(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY385(a) "APBROM_VERTICALX_ROMENTRY385"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY385(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY385(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry386
 *
 * APBROM Vertical Romentry386 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry386
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry386_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry386_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry386 bdk_apbrom_verticalx_romentry386_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY386(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY386(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100608ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY386", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY386(a) bdk_apbrom_verticalx_romentry386_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY386(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY386(a) "APBROM_VERTICALX_ROMENTRY386"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY386(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY386(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry387
 *
 * APBROM Vertical Romentry387 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry387
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry387_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry387_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry387 bdk_apbrom_verticalx_romentry387_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY387(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY387(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610060cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY387", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY387(a) bdk_apbrom_verticalx_romentry387_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY387(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY387(a) "APBROM_VERTICALX_ROMENTRY387"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY387(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY387(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry388
 *
 * APBROM Vertical Romentry388 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry388
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry388_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry388_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry388 bdk_apbrom_verticalx_romentry388_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY388(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY388(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100610ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY388", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY388(a) bdk_apbrom_verticalx_romentry388_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY388(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY388(a) "APBROM_VERTICALX_ROMENTRY388"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY388(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY388(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry389
 *
 * APBROM Vertical Romentry389 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry389
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry389_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry389_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry389 bdk_apbrom_verticalx_romentry389_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY389(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY389(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100614ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY389", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY389(a) bdk_apbrom_verticalx_romentry389_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY389(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY389(a) "APBROM_VERTICALX_ROMENTRY389"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY389(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY389(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry39
 *
 * APBROM Vertical Romentry39 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry39
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry39_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry39_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry39 bdk_apbrom_verticalx_romentry39_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY39(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY39(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610009cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY39", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY39(a) bdk_apbrom_verticalx_romentry39_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY39(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY39(a) "APBROM_VERTICALX_ROMENTRY39"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY39(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY39(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry390
 *
 * APBROM Vertical Romentry390 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry390
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry390_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry390_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry390 bdk_apbrom_verticalx_romentry390_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY390(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY390(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100618ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY390", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY390(a) bdk_apbrom_verticalx_romentry390_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY390(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY390(a) "APBROM_VERTICALX_ROMENTRY390"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY390(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY390(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry391
 *
 * APBROM Vertical Romentry391 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry391
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry391_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry391_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry391 bdk_apbrom_verticalx_romentry391_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY391(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY391(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610061cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY391", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY391(a) bdk_apbrom_verticalx_romentry391_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY391(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY391(a) "APBROM_VERTICALX_ROMENTRY391"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY391(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY391(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry392
 *
 * APBROM Vertical Romentry392 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry392
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry392_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry392_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry392 bdk_apbrom_verticalx_romentry392_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY392(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY392(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100620ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY392", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY392(a) bdk_apbrom_verticalx_romentry392_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY392(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY392(a) "APBROM_VERTICALX_ROMENTRY392"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY392(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY392(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry393
 *
 * APBROM Vertical Romentry393 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry393
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry393_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry393_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry393 bdk_apbrom_verticalx_romentry393_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY393(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY393(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100624ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY393", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY393(a) bdk_apbrom_verticalx_romentry393_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY393(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY393(a) "APBROM_VERTICALX_ROMENTRY393"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY393(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY393(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry394
 *
 * APBROM Vertical Romentry394 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry394
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry394_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry394_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry394 bdk_apbrom_verticalx_romentry394_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY394(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY394(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100628ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY394", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY394(a) bdk_apbrom_verticalx_romentry394_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY394(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY394(a) "APBROM_VERTICALX_ROMENTRY394"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY394(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY394(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry395
 *
 * APBROM Vertical Romentry395 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry395
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry395_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry395_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry395 bdk_apbrom_verticalx_romentry395_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY395(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY395(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610062cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY395", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY395(a) bdk_apbrom_verticalx_romentry395_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY395(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY395(a) "APBROM_VERTICALX_ROMENTRY395"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY395(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY395(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry396
 *
 * APBROM Vertical Romentry396 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry396
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry396_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry396_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry396 bdk_apbrom_verticalx_romentry396_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY396(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY396(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100630ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY396", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY396(a) bdk_apbrom_verticalx_romentry396_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY396(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY396(a) "APBROM_VERTICALX_ROMENTRY396"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY396(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY396(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry397
 *
 * APBROM Vertical Romentry397 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry397
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry397_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry397_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry397 bdk_apbrom_verticalx_romentry397_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY397(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY397(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100634ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY397", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY397(a) bdk_apbrom_verticalx_romentry397_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY397(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY397(a) "APBROM_VERTICALX_ROMENTRY397"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY397(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY397(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry398
 *
 * APBROM Vertical Romentry398 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry398
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry398_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry398_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry398 bdk_apbrom_verticalx_romentry398_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY398(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY398(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100638ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY398", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY398(a) bdk_apbrom_verticalx_romentry398_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY398(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY398(a) "APBROM_VERTICALX_ROMENTRY398"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY398(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY398(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry399
 *
 * APBROM Vertical Romentry399 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry399
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry399_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry399_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry399 bdk_apbrom_verticalx_romentry399_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY399(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY399(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610063cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY399", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY399(a) bdk_apbrom_verticalx_romentry399_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY399(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY399(a) "APBROM_VERTICALX_ROMENTRY399"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY399(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY399(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry4
 *
 * APBROM Vertical Romentry4 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry4
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry4_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry4 bdk_apbrom_verticalx_romentry4_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100010ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY4(a) bdk_apbrom_verticalx_romentry4_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY4(a) "APBROM_VERTICALX_ROMENTRY4"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY4(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry40
 *
 * APBROM Vertical Romentry40 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry40
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry40_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry40 bdk_apbrom_verticalx_romentry40_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY40(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY40(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY40", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY40(a) bdk_apbrom_verticalx_romentry40_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY40(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY40(a) "APBROM_VERTICALX_ROMENTRY40"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY40(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY40(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry400
 *
 * APBROM Vertical Romentry400 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry400
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry400_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry400_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry400 bdk_apbrom_verticalx_romentry400_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY400(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY400(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100640ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY400", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY400(a) bdk_apbrom_verticalx_romentry400_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY400(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY400(a) "APBROM_VERTICALX_ROMENTRY400"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY400(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY400(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry401
 *
 * APBROM Vertical Romentry401 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry401
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry401_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry401_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry401 bdk_apbrom_verticalx_romentry401_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY401(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY401(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100644ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY401", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY401(a) bdk_apbrom_verticalx_romentry401_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY401(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY401(a) "APBROM_VERTICALX_ROMENTRY401"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY401(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY401(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry402
 *
 * APBROM Vertical Romentry402 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry402
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry402_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry402_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry402 bdk_apbrom_verticalx_romentry402_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY402(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY402(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100648ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY402", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY402(a) bdk_apbrom_verticalx_romentry402_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY402(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY402(a) "APBROM_VERTICALX_ROMENTRY402"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY402(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY402(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry403
 *
 * APBROM Vertical Romentry403 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry403
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry403_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry403_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry403 bdk_apbrom_verticalx_romentry403_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY403(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY403(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610064cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY403", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY403(a) bdk_apbrom_verticalx_romentry403_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY403(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY403(a) "APBROM_VERTICALX_ROMENTRY403"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY403(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY403(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry404
 *
 * APBROM Vertical Romentry404 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry404
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry404_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry404_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry404 bdk_apbrom_verticalx_romentry404_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY404(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY404(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100650ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY404", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY404(a) bdk_apbrom_verticalx_romentry404_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY404(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY404(a) "APBROM_VERTICALX_ROMENTRY404"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY404(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY404(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry405
 *
 * APBROM Vertical Romentry405 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry405
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry405_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry405_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry405 bdk_apbrom_verticalx_romentry405_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY405(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY405(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100654ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY405", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY405(a) bdk_apbrom_verticalx_romentry405_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY405(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY405(a) "APBROM_VERTICALX_ROMENTRY405"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY405(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY405(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry406
 *
 * APBROM Vertical Romentry406 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry406
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry406_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry406_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry406 bdk_apbrom_verticalx_romentry406_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY406(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY406(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100658ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY406", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY406(a) bdk_apbrom_verticalx_romentry406_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY406(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY406(a) "APBROM_VERTICALX_ROMENTRY406"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY406(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY406(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry407
 *
 * APBROM Vertical Romentry407 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry407
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry407_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry407_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry407 bdk_apbrom_verticalx_romentry407_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY407(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY407(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610065cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY407", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY407(a) bdk_apbrom_verticalx_romentry407_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY407(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY407(a) "APBROM_VERTICALX_ROMENTRY407"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY407(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY407(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry408
 *
 * APBROM Vertical Romentry408 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry408
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry408_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry408_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry408 bdk_apbrom_verticalx_romentry408_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY408(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY408(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100660ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY408", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY408(a) bdk_apbrom_verticalx_romentry408_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY408(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY408(a) "APBROM_VERTICALX_ROMENTRY408"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY408(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY408(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry409
 *
 * APBROM Vertical Romentry409 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry409
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry409_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry409_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry409 bdk_apbrom_verticalx_romentry409_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY409(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY409(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100664ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY409", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY409(a) bdk_apbrom_verticalx_romentry409_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY409(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY409(a) "APBROM_VERTICALX_ROMENTRY409"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY409(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY409(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry41
 *
 * APBROM Vertical Romentry41 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry41
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry41_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry41_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry41 bdk_apbrom_verticalx_romentry41_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY41(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY41(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY41", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY41(a) bdk_apbrom_verticalx_romentry41_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY41(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY41(a) "APBROM_VERTICALX_ROMENTRY41"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY41(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY41(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry410
 *
 * APBROM Vertical Romentry410 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry410
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry410_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry410_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry410 bdk_apbrom_verticalx_romentry410_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY410(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY410(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100668ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY410", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY410(a) bdk_apbrom_verticalx_romentry410_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY410(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY410(a) "APBROM_VERTICALX_ROMENTRY410"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY410(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY410(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry411
 *
 * APBROM Vertical Romentry411 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry411
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry411_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry411_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry411 bdk_apbrom_verticalx_romentry411_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY411(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY411(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610066cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY411", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY411(a) bdk_apbrom_verticalx_romentry411_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY411(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY411(a) "APBROM_VERTICALX_ROMENTRY411"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY411(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY411(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry412
 *
 * APBROM Vertical Romentry412 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry412
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry412_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry412_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry412 bdk_apbrom_verticalx_romentry412_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY412(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY412(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100670ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY412", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY412(a) bdk_apbrom_verticalx_romentry412_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY412(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY412(a) "APBROM_VERTICALX_ROMENTRY412"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY412(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY412(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry413
 *
 * APBROM Vertical Romentry413 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry413
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry413_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry413_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry413 bdk_apbrom_verticalx_romentry413_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY413(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY413(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100674ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY413", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY413(a) bdk_apbrom_verticalx_romentry413_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY413(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY413(a) "APBROM_VERTICALX_ROMENTRY413"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY413(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY413(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry414
 *
 * APBROM Vertical Romentry414 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry414
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry414_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry414_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry414 bdk_apbrom_verticalx_romentry414_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY414(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY414(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100678ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY414", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY414(a) bdk_apbrom_verticalx_romentry414_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY414(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY414(a) "APBROM_VERTICALX_ROMENTRY414"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY414(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY414(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry415
 *
 * APBROM Vertical Romentry415 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry415
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry415_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry415_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry415 bdk_apbrom_verticalx_romentry415_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY415(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY415(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610067cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY415", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY415(a) bdk_apbrom_verticalx_romentry415_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY415(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY415(a) "APBROM_VERTICALX_ROMENTRY415"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY415(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY415(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry416
 *
 * APBROM Vertical Romentry416 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry416
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry416_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry416_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry416 bdk_apbrom_verticalx_romentry416_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY416(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY416(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100680ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY416", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY416(a) bdk_apbrom_verticalx_romentry416_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY416(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY416(a) "APBROM_VERTICALX_ROMENTRY416"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY416(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY416(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry417
 *
 * APBROM Vertical Romentry417 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry417
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry417_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry417_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry417 bdk_apbrom_verticalx_romentry417_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY417(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY417(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100684ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY417", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY417(a) bdk_apbrom_verticalx_romentry417_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY417(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY417(a) "APBROM_VERTICALX_ROMENTRY417"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY417(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY417(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry418
 *
 * APBROM Vertical Romentry418 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry418
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry418_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry418_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry418 bdk_apbrom_verticalx_romentry418_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY418(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY418(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100688ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY418", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY418(a) bdk_apbrom_verticalx_romentry418_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY418(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY418(a) "APBROM_VERTICALX_ROMENTRY418"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY418(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY418(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry419
 *
 * APBROM Vertical Romentry419 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry419
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry419_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry419_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry419 bdk_apbrom_verticalx_romentry419_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY419(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY419(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610068cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY419", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY419(a) bdk_apbrom_verticalx_romentry419_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY419(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY419(a) "APBROM_VERTICALX_ROMENTRY419"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY419(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY419(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry42
 *
 * APBROM Vertical Romentry42 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry42
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry42_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry42_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry42 bdk_apbrom_verticalx_romentry42_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY42(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY42(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY42", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY42(a) bdk_apbrom_verticalx_romentry42_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY42(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY42(a) "APBROM_VERTICALX_ROMENTRY42"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY42(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY42(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry420
 *
 * APBROM Vertical Romentry420 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry420
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry420_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry420_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry420 bdk_apbrom_verticalx_romentry420_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY420(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY420(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100690ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY420", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY420(a) bdk_apbrom_verticalx_romentry420_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY420(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY420(a) "APBROM_VERTICALX_ROMENTRY420"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY420(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY420(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry421
 *
 * APBROM Vertical Romentry421 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry421
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry421_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry421_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry421 bdk_apbrom_verticalx_romentry421_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY421(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY421(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100694ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY421", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY421(a) bdk_apbrom_verticalx_romentry421_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY421(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY421(a) "APBROM_VERTICALX_ROMENTRY421"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY421(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY421(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry422
 *
 * APBROM Vertical Romentry422 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry422
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry422_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry422_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry422 bdk_apbrom_verticalx_romentry422_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY422(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY422(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100698ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY422", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY422(a) bdk_apbrom_verticalx_romentry422_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY422(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY422(a) "APBROM_VERTICALX_ROMENTRY422"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY422(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY422(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry423
 *
 * APBROM Vertical Romentry423 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry423
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry423_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry423_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry423 bdk_apbrom_verticalx_romentry423_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY423(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY423(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610069cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY423", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY423(a) bdk_apbrom_verticalx_romentry423_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY423(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY423(a) "APBROM_VERTICALX_ROMENTRY423"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY423(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY423(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry424
 *
 * APBROM Vertical Romentry424 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry424
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry424_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry424_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry424 bdk_apbrom_verticalx_romentry424_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY424(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY424(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY424", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY424(a) bdk_apbrom_verticalx_romentry424_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY424(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY424(a) "APBROM_VERTICALX_ROMENTRY424"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY424(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY424(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry425
 *
 * APBROM Vertical Romentry425 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry425
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry425_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry425_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry425 bdk_apbrom_verticalx_romentry425_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY425(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY425(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY425", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY425(a) bdk_apbrom_verticalx_romentry425_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY425(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY425(a) "APBROM_VERTICALX_ROMENTRY425"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY425(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY425(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry426
 *
 * APBROM Vertical Romentry426 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry426
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry426_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry426_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry426 bdk_apbrom_verticalx_romentry426_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY426(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY426(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY426", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY426(a) bdk_apbrom_verticalx_romentry426_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY426(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY426(a) "APBROM_VERTICALX_ROMENTRY426"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY426(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY426(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry427
 *
 * APBROM Vertical Romentry427 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry427
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry427_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry427_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry427 bdk_apbrom_verticalx_romentry427_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY427(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY427(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY427", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY427(a) bdk_apbrom_verticalx_romentry427_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY427(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY427(a) "APBROM_VERTICALX_ROMENTRY427"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY427(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY427(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry428
 *
 * APBROM Vertical Romentry428 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry428
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry428_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry428_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry428 bdk_apbrom_verticalx_romentry428_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY428(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY428(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY428", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY428(a) bdk_apbrom_verticalx_romentry428_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY428(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY428(a) "APBROM_VERTICALX_ROMENTRY428"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY428(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY428(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry429
 *
 * APBROM Vertical Romentry429 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry429
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry429_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry429_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry429 bdk_apbrom_verticalx_romentry429_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY429(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY429(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY429", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY429(a) bdk_apbrom_verticalx_romentry429_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY429(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY429(a) "APBROM_VERTICALX_ROMENTRY429"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY429(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY429(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry43
 *
 * APBROM Vertical Romentry43 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry43
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry43_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry43_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry43 bdk_apbrom_verticalx_romentry43_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY43(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY43(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY43", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY43(a) bdk_apbrom_verticalx_romentry43_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY43(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY43(a) "APBROM_VERTICALX_ROMENTRY43"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY43(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY43(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry430
 *
 * APBROM Vertical Romentry430 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry430
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry430_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry430_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry430 bdk_apbrom_verticalx_romentry430_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY430(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY430(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY430", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY430(a) bdk_apbrom_verticalx_romentry430_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY430(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY430(a) "APBROM_VERTICALX_ROMENTRY430"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY430(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY430(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry431
 *
 * APBROM Vertical Romentry431 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry431
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry431_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry431_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry431 bdk_apbrom_verticalx_romentry431_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY431(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY431(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY431", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY431(a) bdk_apbrom_verticalx_romentry431_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY431(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY431(a) "APBROM_VERTICALX_ROMENTRY431"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY431(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY431(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry432
 *
 * APBROM Vertical Romentry432 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry432
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry432_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry432_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry432 bdk_apbrom_verticalx_romentry432_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY432(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY432(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY432", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY432(a) bdk_apbrom_verticalx_romentry432_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY432(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY432(a) "APBROM_VERTICALX_ROMENTRY432"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY432(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY432(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry433
 *
 * APBROM Vertical Romentry433 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry433
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry433_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry433_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry433 bdk_apbrom_verticalx_romentry433_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY433(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY433(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY433", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY433(a) bdk_apbrom_verticalx_romentry433_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY433(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY433(a) "APBROM_VERTICALX_ROMENTRY433"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY433(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY433(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry434
 *
 * APBROM Vertical Romentry434 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry434
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry434_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry434_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry434 bdk_apbrom_verticalx_romentry434_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY434(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY434(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY434", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY434(a) bdk_apbrom_verticalx_romentry434_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY434(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY434(a) "APBROM_VERTICALX_ROMENTRY434"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY434(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY434(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry435
 *
 * APBROM Vertical Romentry435 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry435
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry435_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry435_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry435 bdk_apbrom_verticalx_romentry435_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY435(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY435(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY435", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY435(a) bdk_apbrom_verticalx_romentry435_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY435(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY435(a) "APBROM_VERTICALX_ROMENTRY435"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY435(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY435(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry436
 *
 * APBROM Vertical Romentry436 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry436
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry436_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry436_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry436 bdk_apbrom_verticalx_romentry436_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY436(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY436(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY436", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY436(a) bdk_apbrom_verticalx_romentry436_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY436(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY436(a) "APBROM_VERTICALX_ROMENTRY436"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY436(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY436(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry437
 *
 * APBROM Vertical Romentry437 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry437
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry437_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry437_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry437 bdk_apbrom_verticalx_romentry437_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY437(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY437(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY437", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY437(a) bdk_apbrom_verticalx_romentry437_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY437(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY437(a) "APBROM_VERTICALX_ROMENTRY437"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY437(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY437(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry438
 *
 * APBROM Vertical Romentry438 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry438
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry438_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry438_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry438 bdk_apbrom_verticalx_romentry438_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY438(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY438(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY438", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY438(a) bdk_apbrom_verticalx_romentry438_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY438(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY438(a) "APBROM_VERTICALX_ROMENTRY438"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY438(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY438(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry439
 *
 * APBROM Vertical Romentry439 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry439
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry439_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry439_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry439 bdk_apbrom_verticalx_romentry439_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY439(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY439(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY439", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY439(a) bdk_apbrom_verticalx_romentry439_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY439(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY439(a) "APBROM_VERTICALX_ROMENTRY439"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY439(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY439(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry44
 *
 * APBROM Vertical Romentry44 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry44
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry44_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry44_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry44 bdk_apbrom_verticalx_romentry44_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY44(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY44(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY44", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY44(a) bdk_apbrom_verticalx_romentry44_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY44(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY44(a) "APBROM_VERTICALX_ROMENTRY44"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY44(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY44(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry440
 *
 * APBROM Vertical Romentry440 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry440
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry440_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry440_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry440 bdk_apbrom_verticalx_romentry440_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY440(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY440(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY440", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY440(a) bdk_apbrom_verticalx_romentry440_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY440(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY440(a) "APBROM_VERTICALX_ROMENTRY440"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY440(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY440(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry441
 *
 * APBROM Vertical Romentry441 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry441
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry441_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry441_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry441 bdk_apbrom_verticalx_romentry441_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY441(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY441(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY441", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY441(a) bdk_apbrom_verticalx_romentry441_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY441(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY441(a) "APBROM_VERTICALX_ROMENTRY441"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY441(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY441(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry442
 *
 * APBROM Vertical Romentry442 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry442
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry442_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry442_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry442 bdk_apbrom_verticalx_romentry442_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY442(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY442(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY442", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY442(a) bdk_apbrom_verticalx_romentry442_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY442(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY442(a) "APBROM_VERTICALX_ROMENTRY442"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY442(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY442(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry443
 *
 * APBROM Vertical Romentry443 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry443
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry443_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry443_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry443 bdk_apbrom_verticalx_romentry443_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY443(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY443(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY443", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY443(a) bdk_apbrom_verticalx_romentry443_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY443(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY443(a) "APBROM_VERTICALX_ROMENTRY443"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY443(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY443(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry444
 *
 * APBROM Vertical Romentry444 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry444
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry444_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry444_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry444 bdk_apbrom_verticalx_romentry444_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY444(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY444(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY444", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY444(a) bdk_apbrom_verticalx_romentry444_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY444(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY444(a) "APBROM_VERTICALX_ROMENTRY444"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY444(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY444(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry445
 *
 * APBROM Vertical Romentry445 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry445
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry445_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry445_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry445 bdk_apbrom_verticalx_romentry445_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY445(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY445(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY445", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY445(a) bdk_apbrom_verticalx_romentry445_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY445(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY445(a) "APBROM_VERTICALX_ROMENTRY445"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY445(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY445(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry446
 *
 * APBROM Vertical Romentry446 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry446
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry446_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry446_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry446 bdk_apbrom_verticalx_romentry446_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY446(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY446(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY446", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY446(a) bdk_apbrom_verticalx_romentry446_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY446(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY446(a) "APBROM_VERTICALX_ROMENTRY446"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY446(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY446(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry447
 *
 * APBROM Vertical Romentry447 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry447
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry447_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry447_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry447 bdk_apbrom_verticalx_romentry447_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY447(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY447(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461006fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY447", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY447(a) bdk_apbrom_verticalx_romentry447_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY447(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY447(a) "APBROM_VERTICALX_ROMENTRY447"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY447(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY447(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry448
 *
 * APBROM Vertical Romentry448 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry448
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry448_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry448_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry448 bdk_apbrom_verticalx_romentry448_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY448(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY448(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100700ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY448", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY448(a) bdk_apbrom_verticalx_romentry448_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY448(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY448(a) "APBROM_VERTICALX_ROMENTRY448"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY448(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY448(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry449
 *
 * APBROM Vertical Romentry449 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry449
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry449_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry449_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry449 bdk_apbrom_verticalx_romentry449_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY449(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY449(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100704ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY449", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY449(a) bdk_apbrom_verticalx_romentry449_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY449(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY449(a) "APBROM_VERTICALX_ROMENTRY449"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY449(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY449(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry45
 *
 * APBROM Vertical Romentry45 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry45
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry45_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry45_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry45 bdk_apbrom_verticalx_romentry45_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY45(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY45(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY45", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY45(a) bdk_apbrom_verticalx_romentry45_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY45(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY45(a) "APBROM_VERTICALX_ROMENTRY45"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY45(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY45(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry450
 *
 * APBROM Vertical Romentry450 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry450
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry450_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry450_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry450 bdk_apbrom_verticalx_romentry450_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY450(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY450(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100708ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY450", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY450(a) bdk_apbrom_verticalx_romentry450_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY450(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY450(a) "APBROM_VERTICALX_ROMENTRY450"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY450(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY450(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry451
 *
 * APBROM Vertical Romentry451 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry451
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry451_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry451_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry451 bdk_apbrom_verticalx_romentry451_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY451(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY451(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610070cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY451", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY451(a) bdk_apbrom_verticalx_romentry451_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY451(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY451(a) "APBROM_VERTICALX_ROMENTRY451"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY451(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY451(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry452
 *
 * APBROM Vertical Romentry452 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry452
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry452_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry452_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry452 bdk_apbrom_verticalx_romentry452_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY452(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY452(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100710ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY452", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY452(a) bdk_apbrom_verticalx_romentry452_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY452(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY452(a) "APBROM_VERTICALX_ROMENTRY452"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY452(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY452(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry453
 *
 * APBROM Vertical Romentry453 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry453
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry453_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry453_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry453 bdk_apbrom_verticalx_romentry453_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY453(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY453(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100714ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY453", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY453(a) bdk_apbrom_verticalx_romentry453_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY453(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY453(a) "APBROM_VERTICALX_ROMENTRY453"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY453(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY453(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry454
 *
 * APBROM Vertical Romentry454 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry454
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry454_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry454_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry454 bdk_apbrom_verticalx_romentry454_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY454(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY454(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100718ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY454", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY454(a) bdk_apbrom_verticalx_romentry454_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY454(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY454(a) "APBROM_VERTICALX_ROMENTRY454"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY454(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY454(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry455
 *
 * APBROM Vertical Romentry455 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry455
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry455_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry455_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry455 bdk_apbrom_verticalx_romentry455_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY455(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY455(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610071cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY455", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY455(a) bdk_apbrom_verticalx_romentry455_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY455(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY455(a) "APBROM_VERTICALX_ROMENTRY455"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY455(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY455(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry456
 *
 * APBROM Vertical Romentry456 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry456
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry456_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry456_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry456 bdk_apbrom_verticalx_romentry456_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY456(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY456(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100720ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY456", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY456(a) bdk_apbrom_verticalx_romentry456_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY456(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY456(a) "APBROM_VERTICALX_ROMENTRY456"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY456(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY456(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry457
 *
 * APBROM Vertical Romentry457 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry457
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry457_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry457_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry457 bdk_apbrom_verticalx_romentry457_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY457(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY457(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100724ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY457", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY457(a) bdk_apbrom_verticalx_romentry457_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY457(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY457(a) "APBROM_VERTICALX_ROMENTRY457"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY457(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY457(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry458
 *
 * APBROM Vertical Romentry458 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry458
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry458_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry458_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry458 bdk_apbrom_verticalx_romentry458_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY458(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY458(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100728ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY458", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY458(a) bdk_apbrom_verticalx_romentry458_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY458(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY458(a) "APBROM_VERTICALX_ROMENTRY458"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY458(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY458(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry459
 *
 * APBROM Vertical Romentry459 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry459
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry459_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry459_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry459 bdk_apbrom_verticalx_romentry459_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY459(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY459(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610072cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY459", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY459(a) bdk_apbrom_verticalx_romentry459_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY459(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY459(a) "APBROM_VERTICALX_ROMENTRY459"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY459(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY459(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry46
 *
 * APBROM Vertical Romentry46 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry46
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry46_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry46_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry46 bdk_apbrom_verticalx_romentry46_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY46(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY46(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY46", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY46(a) bdk_apbrom_verticalx_romentry46_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY46(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY46(a) "APBROM_VERTICALX_ROMENTRY46"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY46(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY46(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry460
 *
 * APBROM Vertical Romentry460 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry460
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry460_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry460_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry460 bdk_apbrom_verticalx_romentry460_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY460(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY460(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100730ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY460", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY460(a) bdk_apbrom_verticalx_romentry460_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY460(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY460(a) "APBROM_VERTICALX_ROMENTRY460"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY460(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY460(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry461
 *
 * APBROM Vertical Romentry461 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry461
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry461_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry461_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry461 bdk_apbrom_verticalx_romentry461_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY461(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY461(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100734ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY461", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY461(a) bdk_apbrom_verticalx_romentry461_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY461(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY461(a) "APBROM_VERTICALX_ROMENTRY461"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY461(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY461(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry462
 *
 * APBROM Vertical Romentry462 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry462
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry462_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry462_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry462 bdk_apbrom_verticalx_romentry462_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY462(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY462(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100738ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY462", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY462(a) bdk_apbrom_verticalx_romentry462_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY462(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY462(a) "APBROM_VERTICALX_ROMENTRY462"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY462(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY462(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry463
 *
 * APBROM Vertical Romentry463 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry463
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry463_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry463_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry463 bdk_apbrom_verticalx_romentry463_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY463(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY463(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610073cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY463", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY463(a) bdk_apbrom_verticalx_romentry463_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY463(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY463(a) "APBROM_VERTICALX_ROMENTRY463"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY463(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY463(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry464
 *
 * APBROM Vertical Romentry464 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry464
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry464_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry464_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry464 bdk_apbrom_verticalx_romentry464_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY464(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY464(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100740ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY464", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY464(a) bdk_apbrom_verticalx_romentry464_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY464(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY464(a) "APBROM_VERTICALX_ROMENTRY464"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY464(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY464(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry465
 *
 * APBROM Vertical Romentry465 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry465
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry465_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry465_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry465 bdk_apbrom_verticalx_romentry465_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY465(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY465(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100744ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY465", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY465(a) bdk_apbrom_verticalx_romentry465_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY465(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY465(a) "APBROM_VERTICALX_ROMENTRY465"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY465(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY465(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry466
 *
 * APBROM Vertical Romentry466 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry466
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry466_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry466_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry466 bdk_apbrom_verticalx_romentry466_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY466(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY466(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100748ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY466", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY466(a) bdk_apbrom_verticalx_romentry466_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY466(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY466(a) "APBROM_VERTICALX_ROMENTRY466"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY466(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY466(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry467
 *
 * APBROM Vertical Romentry467 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry467
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry467_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry467_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry467 bdk_apbrom_verticalx_romentry467_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY467(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY467(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610074cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY467", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY467(a) bdk_apbrom_verticalx_romentry467_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY467(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY467(a) "APBROM_VERTICALX_ROMENTRY467"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY467(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY467(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry468
 *
 * APBROM Vertical Romentry468 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry468
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry468_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry468_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry468 bdk_apbrom_verticalx_romentry468_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY468(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY468(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100750ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY468", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY468(a) bdk_apbrom_verticalx_romentry468_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY468(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY468(a) "APBROM_VERTICALX_ROMENTRY468"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY468(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY468(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry469
 *
 * APBROM Vertical Romentry469 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry469
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry469_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry469_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry469 bdk_apbrom_verticalx_romentry469_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY469(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY469(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100754ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY469", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY469(a) bdk_apbrom_verticalx_romentry469_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY469(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY469(a) "APBROM_VERTICALX_ROMENTRY469"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY469(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY469(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry47
 *
 * APBROM Vertical Romentry47 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry47
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry47_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry47_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry47 bdk_apbrom_verticalx_romentry47_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY47(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY47(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY47", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY47(a) bdk_apbrom_verticalx_romentry47_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY47(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY47(a) "APBROM_VERTICALX_ROMENTRY47"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY47(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY47(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry470
 *
 * APBROM Vertical Romentry470 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry470
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry470_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry470_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry470 bdk_apbrom_verticalx_romentry470_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY470(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY470(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100758ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY470", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY470(a) bdk_apbrom_verticalx_romentry470_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY470(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY470(a) "APBROM_VERTICALX_ROMENTRY470"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY470(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY470(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry471
 *
 * APBROM Vertical Romentry471 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry471
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry471_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry471_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry471 bdk_apbrom_verticalx_romentry471_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY471(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY471(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610075cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY471", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY471(a) bdk_apbrom_verticalx_romentry471_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY471(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY471(a) "APBROM_VERTICALX_ROMENTRY471"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY471(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY471(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry472
 *
 * APBROM Vertical Romentry472 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry472
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry472_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry472_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry472 bdk_apbrom_verticalx_romentry472_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY472(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY472(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100760ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY472", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY472(a) bdk_apbrom_verticalx_romentry472_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY472(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY472(a) "APBROM_VERTICALX_ROMENTRY472"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY472(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY472(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry473
 *
 * APBROM Vertical Romentry473 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry473
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry473_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry473_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry473 bdk_apbrom_verticalx_romentry473_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY473(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY473(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100764ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY473", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY473(a) bdk_apbrom_verticalx_romentry473_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY473(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY473(a) "APBROM_VERTICALX_ROMENTRY473"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY473(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY473(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry474
 *
 * APBROM Vertical Romentry474 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry474
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry474_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry474_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry474 bdk_apbrom_verticalx_romentry474_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY474(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY474(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100768ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY474", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY474(a) bdk_apbrom_verticalx_romentry474_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY474(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY474(a) "APBROM_VERTICALX_ROMENTRY474"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY474(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY474(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry475
 *
 * APBROM Vertical Romentry475 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry475
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry475_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry475_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry475 bdk_apbrom_verticalx_romentry475_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY475(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY475(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610076cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY475", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY475(a) bdk_apbrom_verticalx_romentry475_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY475(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY475(a) "APBROM_VERTICALX_ROMENTRY475"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY475(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY475(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry476
 *
 * APBROM Vertical Romentry476 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry476
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry476_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry476_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry476 bdk_apbrom_verticalx_romentry476_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY476(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY476(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100770ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY476", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY476(a) bdk_apbrom_verticalx_romentry476_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY476(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY476(a) "APBROM_VERTICALX_ROMENTRY476"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY476(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY476(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry477
 *
 * APBROM Vertical Romentry477 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry477
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry477_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry477_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry477 bdk_apbrom_verticalx_romentry477_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY477(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY477(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100774ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY477", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY477(a) bdk_apbrom_verticalx_romentry477_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY477(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY477(a) "APBROM_VERTICALX_ROMENTRY477"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY477(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY477(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry478
 *
 * APBROM Vertical Romentry478 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry478
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry478_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry478_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry478 bdk_apbrom_verticalx_romentry478_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY478(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY478(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100778ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY478", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY478(a) bdk_apbrom_verticalx_romentry478_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY478(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY478(a) "APBROM_VERTICALX_ROMENTRY478"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY478(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY478(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry479
 *
 * APBROM Vertical Romentry479 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry479
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry479_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry479_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry479 bdk_apbrom_verticalx_romentry479_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY479(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY479(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610077cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY479", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY479(a) bdk_apbrom_verticalx_romentry479_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY479(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY479(a) "APBROM_VERTICALX_ROMENTRY479"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY479(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY479(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry48
 *
 * APBROM Vertical Romentry48 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry48
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry48_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry48 bdk_apbrom_verticalx_romentry48_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY48(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY48(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY48", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY48(a) bdk_apbrom_verticalx_romentry48_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY48(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY48(a) "APBROM_VERTICALX_ROMENTRY48"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY48(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY48(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry480
 *
 * APBROM Vertical Romentry480 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry480
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry480_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry480_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry480 bdk_apbrom_verticalx_romentry480_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY480(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY480(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100780ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY480", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY480(a) bdk_apbrom_verticalx_romentry480_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY480(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY480(a) "APBROM_VERTICALX_ROMENTRY480"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY480(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY480(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry481
 *
 * APBROM Vertical Romentry481 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry481
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry481_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry481_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry481 bdk_apbrom_verticalx_romentry481_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY481(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY481(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100784ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY481", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY481(a) bdk_apbrom_verticalx_romentry481_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY481(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY481(a) "APBROM_VERTICALX_ROMENTRY481"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY481(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY481(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry482
 *
 * APBROM Vertical Romentry482 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry482
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry482_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry482_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry482 bdk_apbrom_verticalx_romentry482_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY482(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY482(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100788ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY482", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY482(a) bdk_apbrom_verticalx_romentry482_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY482(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY482(a) "APBROM_VERTICALX_ROMENTRY482"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY482(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY482(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry483
 *
 * APBROM Vertical Romentry483 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry483
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry483_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry483_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry483 bdk_apbrom_verticalx_romentry483_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY483(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY483(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610078cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY483", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY483(a) bdk_apbrom_verticalx_romentry483_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY483(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY483(a) "APBROM_VERTICALX_ROMENTRY483"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY483(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY483(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry484
 *
 * APBROM Vertical Romentry484 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry484
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry484_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry484_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry484 bdk_apbrom_verticalx_romentry484_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY484(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY484(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100790ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY484", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY484(a) bdk_apbrom_verticalx_romentry484_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY484(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY484(a) "APBROM_VERTICALX_ROMENTRY484"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY484(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY484(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry485
 *
 * APBROM Vertical Romentry485 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry485
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry485_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry485_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry485 bdk_apbrom_verticalx_romentry485_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY485(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY485(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100794ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY485", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY485(a) bdk_apbrom_verticalx_romentry485_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY485(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY485(a) "APBROM_VERTICALX_ROMENTRY485"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY485(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY485(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry486
 *
 * APBROM Vertical Romentry486 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry486
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry486_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry486_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry486 bdk_apbrom_verticalx_romentry486_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY486(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY486(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100798ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY486", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY486(a) bdk_apbrom_verticalx_romentry486_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY486(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY486(a) "APBROM_VERTICALX_ROMENTRY486"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY486(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY486(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry487
 *
 * APBROM Vertical Romentry487 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry487
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry487_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry487_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry487 bdk_apbrom_verticalx_romentry487_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY487(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY487(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610079cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY487", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY487(a) bdk_apbrom_verticalx_romentry487_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY487(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY487(a) "APBROM_VERTICALX_ROMENTRY487"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY487(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY487(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry488
 *
 * APBROM Vertical Romentry488 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry488
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry488_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry488_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry488 bdk_apbrom_verticalx_romentry488_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY488(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY488(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007a0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY488", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY488(a) bdk_apbrom_verticalx_romentry488_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY488(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY488(a) "APBROM_VERTICALX_ROMENTRY488"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY488(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY488(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry489
 *
 * APBROM Vertical Romentry489 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry489
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry489_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry489_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry489 bdk_apbrom_verticalx_romentry489_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY489(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY489(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007a4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY489", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY489(a) bdk_apbrom_verticalx_romentry489_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY489(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY489(a) "APBROM_VERTICALX_ROMENTRY489"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY489(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY489(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry49
 *
 * APBROM Vertical Romentry49 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry49
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry49_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry49_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry49 bdk_apbrom_verticalx_romentry49_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY49(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY49(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY49", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY49(a) bdk_apbrom_verticalx_romentry49_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY49(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY49(a) "APBROM_VERTICALX_ROMENTRY49"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY49(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY49(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry490
 *
 * APBROM Vertical Romentry490 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry490
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry490_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry490_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry490 bdk_apbrom_verticalx_romentry490_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY490(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY490(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007a8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY490", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY490(a) bdk_apbrom_verticalx_romentry490_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY490(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY490(a) "APBROM_VERTICALX_ROMENTRY490"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY490(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY490(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry491
 *
 * APBROM Vertical Romentry491 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry491
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry491_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry491_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry491 bdk_apbrom_verticalx_romentry491_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY491(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY491(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007acll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY491", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY491(a) bdk_apbrom_verticalx_romentry491_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY491(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY491(a) "APBROM_VERTICALX_ROMENTRY491"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY491(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY491(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry492
 *
 * APBROM Vertical Romentry492 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry492
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry492_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry492_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry492 bdk_apbrom_verticalx_romentry492_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY492(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY492(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007b0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY492", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY492(a) bdk_apbrom_verticalx_romentry492_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY492(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY492(a) "APBROM_VERTICALX_ROMENTRY492"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY492(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY492(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry493
 *
 * APBROM Vertical Romentry493 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry493
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry493_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry493_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry493 bdk_apbrom_verticalx_romentry493_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY493(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY493(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007b4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY493", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY493(a) bdk_apbrom_verticalx_romentry493_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY493(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY493(a) "APBROM_VERTICALX_ROMENTRY493"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY493(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY493(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry494
 *
 * APBROM Vertical Romentry494 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry494
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry494_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry494_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry494 bdk_apbrom_verticalx_romentry494_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY494(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY494(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007b8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY494", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY494(a) bdk_apbrom_verticalx_romentry494_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY494(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY494(a) "APBROM_VERTICALX_ROMENTRY494"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY494(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY494(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry495
 *
 * APBROM Vertical Romentry495 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry495
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry495_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry495_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry495 bdk_apbrom_verticalx_romentry495_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY495(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY495(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007bcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY495", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY495(a) bdk_apbrom_verticalx_romentry495_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY495(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY495(a) "APBROM_VERTICALX_ROMENTRY495"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY495(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY495(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry496
 *
 * APBROM Vertical Romentry496 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry496
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry496_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry496_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry496 bdk_apbrom_verticalx_romentry496_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY496(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY496(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007c0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY496", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY496(a) bdk_apbrom_verticalx_romentry496_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY496(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY496(a) "APBROM_VERTICALX_ROMENTRY496"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY496(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY496(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry497
 *
 * APBROM Vertical Romentry497 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry497
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry497_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry497_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry497 bdk_apbrom_verticalx_romentry497_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY497(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY497(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007c4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY497", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY497(a) bdk_apbrom_verticalx_romentry497_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY497(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY497(a) "APBROM_VERTICALX_ROMENTRY497"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY497(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY497(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry498
 *
 * APBROM Vertical Romentry498 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry498
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry498_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry498_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry498 bdk_apbrom_verticalx_romentry498_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY498(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY498(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY498", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY498(a) bdk_apbrom_verticalx_romentry498_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY498(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY498(a) "APBROM_VERTICALX_ROMENTRY498"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY498(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY498(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry499
 *
 * APBROM Vertical Romentry499 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry499
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry499_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry499_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry499 bdk_apbrom_verticalx_romentry499_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY499(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY499(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY499", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY499(a) bdk_apbrom_verticalx_romentry499_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY499(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY499(a) "APBROM_VERTICALX_ROMENTRY499"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY499(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY499(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry5
 *
 * APBROM Vertical Romentry5 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry5
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry5_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry5 bdk_apbrom_verticalx_romentry5_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100014ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY5(a) bdk_apbrom_verticalx_romentry5_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY5(a) "APBROM_VERTICALX_ROMENTRY5"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY5(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry50
 *
 * APBROM Vertical Romentry50 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry50
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry50_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry50_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry50 bdk_apbrom_verticalx_romentry50_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY50(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY50(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000c8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY50", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY50(a) bdk_apbrom_verticalx_romentry50_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY50(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY50(a) "APBROM_VERTICALX_ROMENTRY50"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY50(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY50(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry500
 *
 * APBROM Vertical Romentry500 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry500
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry500_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry500_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry500 bdk_apbrom_verticalx_romentry500_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY500(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY500(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY500", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY500(a) bdk_apbrom_verticalx_romentry500_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY500(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY500(a) "APBROM_VERTICALX_ROMENTRY500"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY500(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY500(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry501
 *
 * APBROM Vertical Romentry501 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry501
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry501_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry501_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry501 bdk_apbrom_verticalx_romentry501_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY501(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY501(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY501", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY501(a) bdk_apbrom_verticalx_romentry501_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY501(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY501(a) "APBROM_VERTICALX_ROMENTRY501"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY501(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY501(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry502
 *
 * APBROM Vertical Romentry502 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry502
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry502_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry502_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry502 bdk_apbrom_verticalx_romentry502_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY502(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY502(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY502", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY502(a) bdk_apbrom_verticalx_romentry502_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY502(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY502(a) "APBROM_VERTICALX_ROMENTRY502"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY502(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY502(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry503
 *
 * APBROM Vertical Romentry503 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry503
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry503_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry503_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry503 bdk_apbrom_verticalx_romentry503_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY503(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY503(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY503", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY503(a) bdk_apbrom_verticalx_romentry503_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY503(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY503(a) "APBROM_VERTICALX_ROMENTRY503"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY503(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY503(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry504
 *
 * APBROM Vertical Romentry504 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry504
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry504_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry504_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry504 bdk_apbrom_verticalx_romentry504_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY504(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY504(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY504", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY504(a) bdk_apbrom_verticalx_romentry504_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY504(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY504(a) "APBROM_VERTICALX_ROMENTRY504"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY504(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY504(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry505
 *
 * APBROM Vertical Romentry505 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry505
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry505_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry505_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry505 bdk_apbrom_verticalx_romentry505_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY505(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY505(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY505", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY505(a) bdk_apbrom_verticalx_romentry505_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY505(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY505(a) "APBROM_VERTICALX_ROMENTRY505"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY505(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY505(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry506
 *
 * APBROM Vertical Romentry506 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry506
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry506_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry506_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry506 bdk_apbrom_verticalx_romentry506_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY506(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY506(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY506", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY506(a) bdk_apbrom_verticalx_romentry506_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY506(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY506(a) "APBROM_VERTICALX_ROMENTRY506"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY506(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY506(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry507
 *
 * APBROM Vertical Romentry507 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry507
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry507_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry507_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry507 bdk_apbrom_verticalx_romentry507_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY507(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY507(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY507", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY507(a) bdk_apbrom_verticalx_romentry507_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY507(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY507(a) "APBROM_VERTICALX_ROMENTRY507"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY507(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY507(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry508
 *
 * APBROM Vertical Romentry508 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry508
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry508_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry508_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry508 bdk_apbrom_verticalx_romentry508_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY508(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY508(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY508", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY508(a) bdk_apbrom_verticalx_romentry508_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY508(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY508(a) "APBROM_VERTICALX_ROMENTRY508"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY508(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY508(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry509
 *
 * APBROM Vertical Romentry509 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry509
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry509_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry509_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry509 bdk_apbrom_verticalx_romentry509_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY509(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY509(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY509", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY509(a) bdk_apbrom_verticalx_romentry509_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY509(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY509(a) "APBROM_VERTICALX_ROMENTRY509"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY509(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY509(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry51
 *
 * APBROM Vertical Romentry51 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry51
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry51_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry51_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry51 bdk_apbrom_verticalx_romentry51_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY51(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY51(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000ccll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY51", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY51(a) bdk_apbrom_verticalx_romentry51_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY51(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY51(a) "APBROM_VERTICALX_ROMENTRY51"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY51(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY51(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry510
 *
 * APBROM Vertical Romentry510 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry510
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry510_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry510_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry510 bdk_apbrom_verticalx_romentry510_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY510(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY510(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY510", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY510(a) bdk_apbrom_verticalx_romentry510_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY510(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY510(a) "APBROM_VERTICALX_ROMENTRY510"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY510(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY510(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry511
 *
 * APBROM Vertical Romentry511 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry511
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry511_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry511_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry511 bdk_apbrom_verticalx_romentry511_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY511(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY511(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461007fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY511", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY511(a) bdk_apbrom_verticalx_romentry511_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY511(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY511(a) "APBROM_VERTICALX_ROMENTRY511"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY511(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY511(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry52
 *
 * APBROM Vertical Romentry52 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry52
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry52_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry52_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry52 bdk_apbrom_verticalx_romentry52_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY52(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY52(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000d0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY52", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY52(a) bdk_apbrom_verticalx_romentry52_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY52(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY52(a) "APBROM_VERTICALX_ROMENTRY52"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY52(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY52(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry53
 *
 * APBROM Vertical Romentry53 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry53
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry53_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry53_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry53 bdk_apbrom_verticalx_romentry53_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY53(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY53(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000d4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY53", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY53(a) bdk_apbrom_verticalx_romentry53_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY53(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY53(a) "APBROM_VERTICALX_ROMENTRY53"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY53(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY53(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry54
 *
 * APBROM Vertical Romentry54 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry54
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry54_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry54_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry54 bdk_apbrom_verticalx_romentry54_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY54(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY54(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000d8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY54", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY54(a) bdk_apbrom_verticalx_romentry54_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY54(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY54(a) "APBROM_VERTICALX_ROMENTRY54"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY54(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY54(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry55
 *
 * APBROM Vertical Romentry55 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry55
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry55_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry55_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry55 bdk_apbrom_verticalx_romentry55_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY55(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY55(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000dcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY55", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY55(a) bdk_apbrom_verticalx_romentry55_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY55(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY55(a) "APBROM_VERTICALX_ROMENTRY55"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY55(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY55(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry56
 *
 * APBROM Vertical Romentry56 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry56
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry56_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry56 bdk_apbrom_verticalx_romentry56_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY56(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY56(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000e0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY56", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY56(a) bdk_apbrom_verticalx_romentry56_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY56(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY56(a) "APBROM_VERTICALX_ROMENTRY56"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY56(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY56(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry57
 *
 * APBROM Vertical Romentry57 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry57
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry57_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry57_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry57 bdk_apbrom_verticalx_romentry57_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY57(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY57(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000e4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY57", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY57(a) bdk_apbrom_verticalx_romentry57_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY57(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY57(a) "APBROM_VERTICALX_ROMENTRY57"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY57(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY57(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry58
 *
 * APBROM Vertical Romentry58 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry58
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry58_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry58_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry58 bdk_apbrom_verticalx_romentry58_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY58(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY58(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000e8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY58", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY58(a) bdk_apbrom_verticalx_romentry58_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY58(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY58(a) "APBROM_VERTICALX_ROMENTRY58"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY58(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY58(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry59
 *
 * APBROM Vertical Romentry59 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry59
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry59_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry59_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry59 bdk_apbrom_verticalx_romentry59_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY59(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY59(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000ecll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY59", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY59(a) bdk_apbrom_verticalx_romentry59_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY59(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY59(a) "APBROM_VERTICALX_ROMENTRY59"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY59(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY59(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry6
 *
 * APBROM Vertical Romentry6 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry6
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry6_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry6 bdk_apbrom_verticalx_romentry6_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100018ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY6(a) bdk_apbrom_verticalx_romentry6_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY6(a) "APBROM_VERTICALX_ROMENTRY6"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY6(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry60
 *
 * APBROM Vertical Romentry60 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry60
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry60_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry60_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry60 bdk_apbrom_verticalx_romentry60_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY60(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY60(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000f0ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY60", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY60(a) bdk_apbrom_verticalx_romentry60_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY60(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY60(a) "APBROM_VERTICALX_ROMENTRY60"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY60(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY60(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry61
 *
 * APBROM Vertical Romentry61 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry61
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry61_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry61_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry61 bdk_apbrom_verticalx_romentry61_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY61(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY61(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000f4ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY61", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY61(a) bdk_apbrom_verticalx_romentry61_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY61(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY61(a) "APBROM_VERTICALX_ROMENTRY61"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY61(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY61(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry62
 *
 * APBROM Vertical Romentry62 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry62
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry62_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry62_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry62 bdk_apbrom_verticalx_romentry62_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY62(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY62(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000f8ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY62", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY62(a) bdk_apbrom_verticalx_romentry62_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY62(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY62(a) "APBROM_VERTICALX_ROMENTRY62"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY62(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY62(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry63
 *
 * APBROM Vertical Romentry63 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry63
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry63_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry63_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry63 bdk_apbrom_verticalx_romentry63_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY63(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY63(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e0461000fcll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY63", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY63(a) bdk_apbrom_verticalx_romentry63_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY63(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY63(a) "APBROM_VERTICALX_ROMENTRY63"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY63(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY63(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry64
 *
 * APBROM Vertical Romentry64 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry64
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry64_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry64 bdk_apbrom_verticalx_romentry64_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY64(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY64(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100100ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY64(a) bdk_apbrom_verticalx_romentry64_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY64(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY64(a) "APBROM_VERTICALX_ROMENTRY64"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY64(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY64(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry65
 *
 * APBROM Vertical Romentry65 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry65
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry65_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry65_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry65 bdk_apbrom_verticalx_romentry65_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY65(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY65(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100104ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY65", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY65(a) bdk_apbrom_verticalx_romentry65_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY65(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY65(a) "APBROM_VERTICALX_ROMENTRY65"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY65(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY65(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry66
 *
 * APBROM Vertical Romentry66 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry66
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry66_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry66_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry66 bdk_apbrom_verticalx_romentry66_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY66(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY66(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100108ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY66", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY66(a) bdk_apbrom_verticalx_romentry66_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY66(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY66(a) "APBROM_VERTICALX_ROMENTRY66"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY66(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY66(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry67
 *
 * APBROM Vertical Romentry67 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry67
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry67_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry67_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry67 bdk_apbrom_verticalx_romentry67_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY67(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY67(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610010cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY67", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY67(a) bdk_apbrom_verticalx_romentry67_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY67(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY67(a) "APBROM_VERTICALX_ROMENTRY67"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY67(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY67(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry68
 *
 * APBROM Vertical Romentry68 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry68
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry68_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry68_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry68 bdk_apbrom_verticalx_romentry68_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY68(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY68(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100110ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY68", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY68(a) bdk_apbrom_verticalx_romentry68_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY68(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY68(a) "APBROM_VERTICALX_ROMENTRY68"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY68(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY68(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry69
 *
 * APBROM Vertical Romentry69 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry69
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry69_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry69_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry69 bdk_apbrom_verticalx_romentry69_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY69(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY69(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100114ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY69", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY69(a) bdk_apbrom_verticalx_romentry69_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY69(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY69(a) "APBROM_VERTICALX_ROMENTRY69"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY69(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY69(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry7
 *
 * APBROM Vertical Romentry7 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry7
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry7_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry7 bdk_apbrom_verticalx_romentry7_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610001cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY7(a) bdk_apbrom_verticalx_romentry7_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY7(a) "APBROM_VERTICALX_ROMENTRY7"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY7(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry70
 *
 * APBROM Vertical Romentry70 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry70
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry70_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry70_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry70 bdk_apbrom_verticalx_romentry70_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY70(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY70(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100118ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY70", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY70(a) bdk_apbrom_verticalx_romentry70_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY70(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY70(a) "APBROM_VERTICALX_ROMENTRY70"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY70(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY70(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry71
 *
 * APBROM Vertical Romentry71 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry71
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry71_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry71_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry71 bdk_apbrom_verticalx_romentry71_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY71(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY71(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610011cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY71", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY71(a) bdk_apbrom_verticalx_romentry71_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY71(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY71(a) "APBROM_VERTICALX_ROMENTRY71"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY71(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY71(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry72
 *
 * APBROM Vertical Romentry72 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry72
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry72_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry72 bdk_apbrom_verticalx_romentry72_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY72(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY72(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100120ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY72", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY72(a) bdk_apbrom_verticalx_romentry72_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY72(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY72(a) "APBROM_VERTICALX_ROMENTRY72"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY72(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY72(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry73
 *
 * APBROM Vertical Romentry73 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry73
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry73_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry73_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry73 bdk_apbrom_verticalx_romentry73_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY73(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY73(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100124ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY73", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY73(a) bdk_apbrom_verticalx_romentry73_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY73(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY73(a) "APBROM_VERTICALX_ROMENTRY73"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY73(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY73(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry74
 *
 * APBROM Vertical Romentry74 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry74
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry74_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry74_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry74 bdk_apbrom_verticalx_romentry74_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY74(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY74(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100128ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY74", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY74(a) bdk_apbrom_verticalx_romentry74_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY74(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY74(a) "APBROM_VERTICALX_ROMENTRY74"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY74(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY74(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry75
 *
 * APBROM Vertical Romentry75 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry75
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry75_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry75_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry75 bdk_apbrom_verticalx_romentry75_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY75(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY75(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610012cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY75", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY75(a) bdk_apbrom_verticalx_romentry75_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY75(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY75(a) "APBROM_VERTICALX_ROMENTRY75"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY75(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY75(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry76
 *
 * APBROM Vertical Romentry76 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry76
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry76_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry76_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry76 bdk_apbrom_verticalx_romentry76_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY76(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY76(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100130ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY76", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY76(a) bdk_apbrom_verticalx_romentry76_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY76(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY76(a) "APBROM_VERTICALX_ROMENTRY76"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY76(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY76(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry77
 *
 * APBROM Vertical Romentry77 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry77
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry77_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry77_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry77 bdk_apbrom_verticalx_romentry77_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY77(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY77(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100134ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY77", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY77(a) bdk_apbrom_verticalx_romentry77_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY77(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY77(a) "APBROM_VERTICALX_ROMENTRY77"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY77(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY77(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry78
 *
 * APBROM Vertical Romentry78 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry78
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry78_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry78_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry78 bdk_apbrom_verticalx_romentry78_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY78(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY78(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100138ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY78", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY78(a) bdk_apbrom_verticalx_romentry78_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY78(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY78(a) "APBROM_VERTICALX_ROMENTRY78"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY78(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY78(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry79
 *
 * APBROM Vertical Romentry79 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry79
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry79_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry79_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry79 bdk_apbrom_verticalx_romentry79_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY79(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY79(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610013cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY79", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY79(a) bdk_apbrom_verticalx_romentry79_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY79(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY79(a) "APBROM_VERTICALX_ROMENTRY79"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY79(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY79(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry8
 *
 * APBROM Vertical Romentry8 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry8
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry8_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry8 bdk_apbrom_verticalx_romentry8_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY8(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100020ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY8(a) bdk_apbrom_verticalx_romentry8_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY8(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY8(a) "APBROM_VERTICALX_ROMENTRY8"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY8(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry80
 *
 * APBROM Vertical Romentry80 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry80
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry80_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry80 bdk_apbrom_verticalx_romentry80_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY80(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY80(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100140ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY80", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY80(a) bdk_apbrom_verticalx_romentry80_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY80(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY80(a) "APBROM_VERTICALX_ROMENTRY80"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY80(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY80(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry81
 *
 * APBROM Vertical Romentry81 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry81
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry81_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry81_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry81 bdk_apbrom_verticalx_romentry81_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY81(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY81(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100144ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY81", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY81(a) bdk_apbrom_verticalx_romentry81_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY81(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY81(a) "APBROM_VERTICALX_ROMENTRY81"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY81(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY81(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry82
 *
 * APBROM Vertical Romentry82 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry82
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry82_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry82_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry82 bdk_apbrom_verticalx_romentry82_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY82(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY82(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100148ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY82", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY82(a) bdk_apbrom_verticalx_romentry82_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY82(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY82(a) "APBROM_VERTICALX_ROMENTRY82"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY82(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY82(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry83
 *
 * APBROM Vertical Romentry83 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry83
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry83_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry83_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry83 bdk_apbrom_verticalx_romentry83_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY83(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY83(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610014cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY83", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY83(a) bdk_apbrom_verticalx_romentry83_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY83(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY83(a) "APBROM_VERTICALX_ROMENTRY83"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY83(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY83(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry84
 *
 * APBROM Vertical Romentry84 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry84
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry84_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry84_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry84 bdk_apbrom_verticalx_romentry84_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY84(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY84(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100150ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY84", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY84(a) bdk_apbrom_verticalx_romentry84_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY84(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY84(a) "APBROM_VERTICALX_ROMENTRY84"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY84(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY84(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry85
 *
 * APBROM Vertical Romentry85 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry85
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry85_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry85_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry85 bdk_apbrom_verticalx_romentry85_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY85(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY85(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100154ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY85", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY85(a) bdk_apbrom_verticalx_romentry85_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY85(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY85(a) "APBROM_VERTICALX_ROMENTRY85"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY85(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY85(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry86
 *
 * APBROM Vertical Romentry86 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry86
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry86_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry86_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry86 bdk_apbrom_verticalx_romentry86_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY86(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY86(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100158ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY86", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY86(a) bdk_apbrom_verticalx_romentry86_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY86(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY86(a) "APBROM_VERTICALX_ROMENTRY86"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY86(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY86(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry87
 *
 * APBROM Vertical Romentry87 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry87
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry87_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry87_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry87 bdk_apbrom_verticalx_romentry87_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY87(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY87(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610015cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY87", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY87(a) bdk_apbrom_verticalx_romentry87_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY87(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY87(a) "APBROM_VERTICALX_ROMENTRY87"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY87(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY87(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry88
 *
 * APBROM Vertical Romentry88 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry88
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry88_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry88 bdk_apbrom_verticalx_romentry88_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY88(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY88(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100160ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY88", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY88(a) bdk_apbrom_verticalx_romentry88_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY88(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY88(a) "APBROM_VERTICALX_ROMENTRY88"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY88(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY88(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry89
 *
 * APBROM Vertical Romentry89 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry89
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry89_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry89_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry89 bdk_apbrom_verticalx_romentry89_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY89(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY89(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100164ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY89", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY89(a) bdk_apbrom_verticalx_romentry89_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY89(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY89(a) "APBROM_VERTICALX_ROMENTRY89"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY89(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY89(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry9
 *
 * APBROM Vertical Romentry9 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry9
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry9_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry9 bdk_apbrom_verticalx_romentry9_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY9(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY9(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100024ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY9(a) bdk_apbrom_verticalx_romentry9_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY9(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY9(a) "APBROM_VERTICALX_ROMENTRY9"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY9(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry90
 *
 * APBROM Vertical Romentry90 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry90
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry90_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry90_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry90 bdk_apbrom_verticalx_romentry90_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY90(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY90(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100168ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY90", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY90(a) bdk_apbrom_verticalx_romentry90_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY90(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY90(a) "APBROM_VERTICALX_ROMENTRY90"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY90(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY90(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry91
 *
 * APBROM Vertical Romentry91 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry91
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry91_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry91_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry91 bdk_apbrom_verticalx_romentry91_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY91(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY91(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610016cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY91", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY91(a) bdk_apbrom_verticalx_romentry91_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY91(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY91(a) "APBROM_VERTICALX_ROMENTRY91"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY91(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY91(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry92
 *
 * APBROM Vertical Romentry92 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry92
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry92_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry92_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry92 bdk_apbrom_verticalx_romentry92_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY92(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY92(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100170ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY92", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY92(a) bdk_apbrom_verticalx_romentry92_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY92(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY92(a) "APBROM_VERTICALX_ROMENTRY92"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY92(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY92(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry93
 *
 * APBROM Vertical Romentry93 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry93
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry93_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry93_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry93 bdk_apbrom_verticalx_romentry93_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY93(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY93(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100174ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY93", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY93(a) bdk_apbrom_verticalx_romentry93_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY93(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY93(a) "APBROM_VERTICALX_ROMENTRY93"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY93(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY93(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry94
 *
 * APBROM Vertical Romentry94 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry94
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry94_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry94_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry94 bdk_apbrom_verticalx_romentry94_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY94(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY94(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100178ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY94", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY94(a) bdk_apbrom_verticalx_romentry94_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY94(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY94(a) "APBROM_VERTICALX_ROMENTRY94"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY94(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY94(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry95
 *
 * APBROM Vertical Romentry95 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry95
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry95_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry95_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry95 bdk_apbrom_verticalx_romentry95_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY95(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY95(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610017cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY95", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY95(a) bdk_apbrom_verticalx_romentry95_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY95(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY95(a) "APBROM_VERTICALX_ROMENTRY95"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY95(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY95(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry96
 *
 * APBROM Vertical Romentry96 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry96
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry96_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry96 bdk_apbrom_verticalx_romentry96_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY96(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY96(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100180ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY96", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY96(a) bdk_apbrom_verticalx_romentry96_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY96(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY96(a) "APBROM_VERTICALX_ROMENTRY96"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY96(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY96(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry97
 *
 * APBROM Vertical Romentry97 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry97
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry97_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry97_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry97 bdk_apbrom_verticalx_romentry97_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY97(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY97(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100184ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY97", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY97(a) bdk_apbrom_verticalx_romentry97_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY97(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY97(a) "APBROM_VERTICALX_ROMENTRY97"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY97(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY97(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry98
 *
 * APBROM Vertical Romentry98 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry98
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry98_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry98_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry98 bdk_apbrom_verticalx_romentry98_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY98(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY98(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e046100188ll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY98", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY98(a) bdk_apbrom_verticalx_romentry98_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY98(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY98(a) "APBROM_VERTICALX_ROMENTRY98"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY98(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY98(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_vertical#_romentry99
 *
 * APBROM Vertical Romentry99 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_verticalx_romentry99
{
    uint32_t u;
    struct bdk_apbrom_verticalx_romentry99_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_verticalx_romentry99_s cn; */
};
typedef union bdk_apbrom_verticalx_romentry99 bdk_apbrom_verticalx_romentry99_t;

static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY99(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_VERTICALX_ROMENTRY99(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=3))
        return 0x87e04610018cll + 0x100000ll * ((a) & 0x3);
    __bdk_csr_fatal("APBROM_VERTICALX_ROMENTRY99", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_VERTICALX_ROMENTRY99(a) bdk_apbrom_verticalx_romentry99_t
#define bustype_BDK_APBROM_VERTICALX_ROMENTRY99(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_VERTICALX_ROMENTRY99(a) "APBROM_VERTICALX_ROMENTRY99"
#define busnum_BDK_APBROM_VERTICALX_ROMENTRY99(a) (a)
#define arguments_BDK_APBROM_VERTICALX_ROMENTRY99(a) (a),-1,-1,-1

#endif /* __BDK_CSRS_APBROM_VERTICAL_H__ */
