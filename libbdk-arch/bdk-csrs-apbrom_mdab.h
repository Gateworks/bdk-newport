#ifndef __BDK_CSRS_APBROM_MDAB_H__
#define __BDK_CSRS_APBROM_MDAB_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX APBROM_MDAB.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Register (RSL32b) apbrom_mdab#_authstatus
 *
 * APBROM Mdab Authstatus Register
 * Reports the current status of the authentication control signals.
 */
union bdk_apbrom_mdabx_authstatus
{
    uint32_t u;
    struct bdk_apbrom_mdabx_authstatus_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
#else /* Word 0 - Little Endian */
        uint32_t nsid                  : 2;  /**< [  1:  0](RO) Non-secure invasive debug. */
        uint32_t nsnid                 : 2;  /**< [  3:  2](RO) Non-secure non-invasive debug. */
        uint32_t sid                   : 2;  /**< [  5:  4](RO) Secure invasive debug. */
        uint32_t snid                  : 2;  /**< [  7:  6](RO) Secure non-invasive debug. */
        uint32_t hid                   : 2;  /**< [  9:  8](RO) Hypervisor invasive debug. */
        uint32_t hnid                  : 2;  /**< [ 11: 10](RO) Hypervisor non-invasive debug. */
        uint32_t res0_0                : 20; /**< [ 31: 12](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_authstatus_s cn; */
};
typedef union bdk_apbrom_mdabx_authstatus bdk_apbrom_mdabx_authstatus_t;

static inline uint64_t BDK_APBROM_MDABX_AUTHSTATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_AUTHSTATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fb8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_AUTHSTATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_AUTHSTATUS(a) bdk_apbrom_mdabx_authstatus_t
#define bustype_BDK_APBROM_MDABX_AUTHSTATUS(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_AUTHSTATUS(a) "APBROM_MDABX_AUTHSTATUS"
#define busnum_BDK_APBROM_MDABX_AUTHSTATUS(a) (a)
#define arguments_BDK_APBROM_MDABX_AUTHSTATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_cidr0
 *
 * APBROM Mdab Cidr0 Register
 * The CIDR0 register is part of the set of component identification registers.
 */
union bdk_apbrom_mdabx_cidr0
{
    uint32_t u;
    struct bdk_apbrom_mdabx_cidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_0               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x0D. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_cidr0_s cn; */
};
typedef union bdk_apbrom_mdabx_cidr0 bdk_apbrom_mdabx_cidr0_t;

static inline uint64_t BDK_APBROM_MDABX_CIDR0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_CIDR0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110ff0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_CIDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_CIDR0(a) bdk_apbrom_mdabx_cidr0_t
#define bustype_BDK_APBROM_MDABX_CIDR0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_CIDR0(a) "APBROM_MDABX_CIDR0"
#define busnum_BDK_APBROM_MDABX_CIDR0(a) (a)
#define arguments_BDK_APBROM_MDABX_CIDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_cidr1
 *
 * APBROM Mdab Cidr1 Register
 * The CIDR1 register is part of the set of component identification registers.
 */
union bdk_apbrom_mdabx_cidr1
{
    uint32_t u;
    struct bdk_apbrom_mdabx_cidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_1               : 4;  /**< [  3:  0](RO) Preamble. Returns 0x0. */
        uint32_t class_f               : 4;  /**< [  7:  4](RO) Component class. Returns 0x9, indicating this is a CoreSight component. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_cidr1_s cn; */
};
typedef union bdk_apbrom_mdabx_cidr1 bdk_apbrom_mdabx_cidr1_t;

static inline uint64_t BDK_APBROM_MDABX_CIDR1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_CIDR1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110ff4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_CIDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_CIDR1(a) bdk_apbrom_mdabx_cidr1_t
#define bustype_BDK_APBROM_MDABX_CIDR1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_CIDR1(a) "APBROM_MDABX_CIDR1"
#define busnum_BDK_APBROM_MDABX_CIDR1(a) (a)
#define arguments_BDK_APBROM_MDABX_CIDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_cidr2
 *
 * APBROM Mdab Cidr2 Register
 * The CIDR2 register is part of the set of component identification registers.
 */
union bdk_apbrom_mdabx_cidr2
{
    uint32_t u;
    struct bdk_apbrom_mdabx_cidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_2               : 8;  /**< [  7:  0](RO) Preamble. Returns 0x05. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_cidr2_s cn; */
};
typedef union bdk_apbrom_mdabx_cidr2 bdk_apbrom_mdabx_cidr2_t;

static inline uint64_t BDK_APBROM_MDABX_CIDR2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_CIDR2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110ff8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_CIDR2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_CIDR2(a) bdk_apbrom_mdabx_cidr2_t
#define bustype_BDK_APBROM_MDABX_CIDR2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_CIDR2(a) "APBROM_MDABX_CIDR2"
#define busnum_BDK_APBROM_MDABX_CIDR2(a) (a)
#define arguments_BDK_APBROM_MDABX_CIDR2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_cidr3
 *
 * APBROM Mdab Cidr3 Register
 * The CIDR3 register is part of the set of component identification registers.
 */
union bdk_apbrom_mdabx_cidr3
{
    uint32_t u;
    struct bdk_apbrom_mdabx_cidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
#else /* Word 0 - Little Endian */
        uint32_t prmbl_3               : 8;  /**< [  7:  0](RO) Preamble. Returns 0xB1. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_cidr3_s cn; */
};
typedef union bdk_apbrom_mdabx_cidr3 bdk_apbrom_mdabx_cidr3_t;

static inline uint64_t BDK_APBROM_MDABX_CIDR3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_CIDR3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110ffc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_CIDR3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_CIDR3(a) bdk_apbrom_mdabx_cidr3_t
#define bustype_BDK_APBROM_MDABX_CIDR3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_CIDR3(a) "APBROM_MDABX_CIDR3"
#define busnum_BDK_APBROM_MDABX_CIDR3(a) (a)
#define arguments_BDK_APBROM_MDABX_CIDR3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_devarch
 *
 * APBROM Mdab Devarch Register
 * Identifies the architect and architecture of a CoreSight component. The architect
 * might differ from the designer of a component, for example Arm defines the
 * architecture but another company designs and implements the component.
 */
union bdk_apbrom_mdabx_devarch
{
    uint32_t u;
    struct bdk_apbrom_mdabx_devarch_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
#else /* Word 0 - Little Endian */
        uint32_t archid                : 16; /**< [ 15:  0](RO) Architecture ID. Returns 0x0af7, identifying ROM Table Architecture v0. */
        uint32_t revision              : 4;  /**< [ 19: 16](RO) Architecture revision. Returns the revision of the architecture that the ARCHID field specifies. */
        uint32_t present               : 1;  /**< [ 20: 20](RO) Returns 1, indicating that the DEVARCH register is present. */
        uint32_t architect             : 11; /**< [ 31: 21](RO) Returns 0x23b, denoting Arm as architect of the component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_devarch_s cn; */
};
typedef union bdk_apbrom_mdabx_devarch bdk_apbrom_mdabx_devarch_t;

static inline uint64_t BDK_APBROM_MDABX_DEVARCH(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_DEVARCH(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fbc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_DEVARCH", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_DEVARCH(a) bdk_apbrom_mdabx_devarch_t
#define bustype_BDK_APBROM_MDABX_DEVARCH(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_DEVARCH(a) "APBROM_MDABX_DEVARCH"
#define busnum_BDK_APBROM_MDABX_DEVARCH(a) (a)
#define arguments_BDK_APBROM_MDABX_DEVARCH(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_devid
 *
 * APBROM Mdab Devid Register
 * This register is IMPLEMENTATION DEFINED for each Part Number and Designer. The
 * register indicates the capabilities of the component.
 */
union bdk_apbrom_mdabx_devid
{
    uint32_t u;
    struct bdk_apbrom_mdabx_devid_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
#else /* Word 0 - Little Endian */
        uint32_t format                : 3;  /**< [  2:  0](RO) Indicates that this is a 32-bit ROM table. */
        uint32_t res0_0                : 1;  /**< [  3:  3](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t sysmem                : 1;  /**< [  4:  4](RO) Indicates whether system memory is present on the bus. Set by the SYSMEM parameter. */
        uint32_t prr                   : 1;  /**< [  5:  5](RO) Indicates that power request functionality is included. Set by the GPR_PRESENT parameter. */
        uint32_t res0_1                : 26; /**< [ 31:  6](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_devid_s cn; */
};
typedef union bdk_apbrom_mdabx_devid bdk_apbrom_mdabx_devid_t;

static inline uint64_t BDK_APBROM_MDABX_DEVID(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_DEVID(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fc8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_DEVID", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_DEVID(a) bdk_apbrom_mdabx_devid_t
#define bustype_BDK_APBROM_MDABX_DEVID(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_DEVID(a) "APBROM_MDABX_DEVID"
#define busnum_BDK_APBROM_MDABX_DEVID(a) (a)
#define arguments_BDK_APBROM_MDABX_DEVID(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr0
 *
 * APBROM Mdab Pidr0 Register
 * The PIDR0 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr0
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
#else /* Word 0 - Little Endian */
        uint32_t part_0                : 8;  /**< [  7:  0](RO) Part number, bits[7:0]. Set by the configuration inputs part_number[7:0] */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr0_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr0 bdk_apbrom_mdabx_pidr0_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fe0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR0(a) bdk_apbrom_mdabx_pidr0_t
#define bustype_BDK_APBROM_MDABX_PIDR0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR0(a) "APBROM_MDABX_PIDR0"
#define busnum_BDK_APBROM_MDABX_PIDR0(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr1
 *
 * APBROM Mdab Pidr1 Register
 * The PIDR1 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr1
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
#else /* Word 0 - Little Endian */
        uint32_t part_1                : 4;  /**< [  3:  0](RO) Part number, bits[11:8]. Set by the configuration inputs part_number[11:8]. */
        uint32_t des_0                 : 4;  /**< [  7:  4](RO) JEP106 identification code, bits[3:0]. Set by the configuration inputs
                                                                 jep106_id[3:0]. Together, with PIDR4.DES_2 and PIDR2.DES_1, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr1_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr1 bdk_apbrom_mdabx_pidr1_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fe4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR1(a) bdk_apbrom_mdabx_pidr1_t
#define bustype_BDK_APBROM_MDABX_PIDR1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR1(a) "APBROM_MDABX_PIDR1"
#define busnum_BDK_APBROM_MDABX_PIDR1(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr2
 *
 * APBROM Mdab Pidr2 Register
 * The PIDR2 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr2
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
#else /* Word 0 - Little Endian */
        uint32_t des_1                 : 3;  /**< [  2:  0](RO) JEP106 identification code, bits[6:4]. Set by the configuration inputs
                                                                 jep106_id[6:4]. Together, with PIDR4.DES_2 and PIDR1.DES_0, they indicate the
                                                                 designer of the component and not the implementer, except where the two are the
                                                                 same. */
        uint32_t jedec                 : 1;  /**< [  3:  3](RO) 1 - Always set. Indicates that a JEDEC assigned value is used. */
        uint32_t revision              : 4;  /**< [  7:  4](RO) Revision. Set by the configuration inputs revision[3:0]. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr2_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr2 bdk_apbrom_mdabx_pidr2_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fe8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR2(a) bdk_apbrom_mdabx_pidr2_t
#define bustype_BDK_APBROM_MDABX_PIDR2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR2(a) "APBROM_MDABX_PIDR2"
#define busnum_BDK_APBROM_MDABX_PIDR2(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr3
 *
 * APBROM Mdab Pidr3 Register
 * The PIDR3 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr3
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
#else /* Word 0 - Little Endian */
        uint32_t cmod                  : 4;  /**< [  3:  0](RO) Customer Modified. Where the component is reusable IP, this value indicates if
                                                                 the customer has modified the behavior of the component. In most cases this
                                                                 field is 0x0. */
        uint32_t revand                : 4;  /**< [  7:  4](RO) This field indicates minor errata fixes specific to this design, for example
                                                                 metal fixes after implementation. In most cases this field is 0x0. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr3_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr3 bdk_apbrom_mdabx_pidr3_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR3(a) bdk_apbrom_mdabx_pidr3_t
#define bustype_BDK_APBROM_MDABX_PIDR3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR3(a) "APBROM_MDABX_PIDR3"
#define busnum_BDK_APBROM_MDABX_PIDR3(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr4
 *
 * APBROM Mdab Pidr4 Register
 * The PIDR4 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr4
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
#else /* Word 0 - Little Endian */
        uint32_t des_2                 : 4;  /**< [  3:  0](RO) JEP106 continuation code. Together, with PIDR2.DES_1 and PIDR1.DES_0, they
                                                                 indicate the designer of the component and not the implementer, except where the
                                                                 two are the same. */
        uint32_t size                  : 4;  /**< [  7:  4](RO) Indicates the memory size that is used by this component. Returns 0 indicating
                                                                 that the component uses an UNKNOWN number of 4KB blocks. Using the SIZE field to
                                                                 indicate the size of the component is deprecated. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr4_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr4 bdk_apbrom_mdabx_pidr4_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fd0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR4(a) bdk_apbrom_mdabx_pidr4_t
#define bustype_BDK_APBROM_MDABX_PIDR4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR4(a) "APBROM_MDABX_PIDR4"
#define busnum_BDK_APBROM_MDABX_PIDR4(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr5
 *
 * APBROM Mdab Pidr5 Register
 * The PIDR5 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr5
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr5                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr5_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr5 bdk_apbrom_mdabx_pidr5_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fd4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR5(a) bdk_apbrom_mdabx_pidr5_t
#define bustype_BDK_APBROM_MDABX_PIDR5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR5(a) "APBROM_MDABX_PIDR5"
#define busnum_BDK_APBROM_MDABX_PIDR5(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr6
 *
 * APBROM Mdab Pidr6 Register
 * The PIDR6 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr6
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr6                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr6_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr6 bdk_apbrom_mdabx_pidr6_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fd8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR6(a) bdk_apbrom_mdabx_pidr6_t
#define bustype_BDK_APBROM_MDABX_PIDR6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR6(a) "APBROM_MDABX_PIDR6"
#define busnum_BDK_APBROM_MDABX_PIDR6(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_pidr7
 *
 * APBROM Mdab Pidr7 Register
 * The PIDR7 register is part of the set of peripheral identification registers.
 */
union bdk_apbrom_mdabx_pidr7
{
    uint32_t u;
    struct bdk_apbrom_mdabx_pidr7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pidr7                 : 8;  /**< [  7:  0](RO) Reserved. */
        uint32_t res0_0                : 24; /**< [ 31:  8](RO) Reserved bit or field with Should-Be-Zero-or-Preserved (SBZP) behavior. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_pidr7_s cn; */
};
typedef union bdk_apbrom_mdabx_pidr7 bdk_apbrom_mdabx_pidr7_t;

static inline uint64_t BDK_APBROM_MDABX_PIDR7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_PIDR7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110fdc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_PIDR7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_PIDR7(a) bdk_apbrom_mdabx_pidr7_t
#define bustype_BDK_APBROM_MDABX_PIDR7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_PIDR7(a) "APBROM_MDABX_PIDR7"
#define busnum_BDK_APBROM_MDABX_PIDR7(a) (a)
#define arguments_BDK_APBROM_MDABX_PIDR7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry0
 *
 * APBROM Mdab Romentry0 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry0
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry0_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry0 bdk_apbrom_mdabx_romentry0_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110000 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY0(a) bdk_apbrom_mdabx_romentry0_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY0(a) "APBROM_MDABX_ROMENTRY0"
#define busnum_BDK_APBROM_MDABX_ROMENTRY0(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry1
 *
 * APBROM Mdab Romentry1 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry1
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry1_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry1 bdk_apbrom_mdabx_romentry1_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110004 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY1(a) bdk_apbrom_mdabx_romentry1_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY1(a) "APBROM_MDABX_ROMENTRY1"
#define busnum_BDK_APBROM_MDABX_ROMENTRY1(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry10
 *
 * APBROM Mdab Romentry10 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry10
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry10_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry10 bdk_apbrom_mdabx_romentry10_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY10(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY10(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110028 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY10(a) bdk_apbrom_mdabx_romentry10_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY10(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY10(a) "APBROM_MDABX_ROMENTRY10"
#define busnum_BDK_APBROM_MDABX_ROMENTRY10(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry100
 *
 * APBROM Mdab Romentry100 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry100
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry100_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry100_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry100 bdk_apbrom_mdabx_romentry100_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY100(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY100(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110190 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY100", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY100(a) bdk_apbrom_mdabx_romentry100_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY100(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY100(a) "APBROM_MDABX_ROMENTRY100"
#define busnum_BDK_APBROM_MDABX_ROMENTRY100(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY100(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry101
 *
 * APBROM Mdab Romentry101 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry101
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry101_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry101_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry101 bdk_apbrom_mdabx_romentry101_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY101(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY101(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110194 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY101", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY101(a) bdk_apbrom_mdabx_romentry101_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY101(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY101(a) "APBROM_MDABX_ROMENTRY101"
#define busnum_BDK_APBROM_MDABX_ROMENTRY101(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY101(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry102
 *
 * APBROM Mdab Romentry102 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry102
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry102_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry102_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry102 bdk_apbrom_mdabx_romentry102_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY102(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY102(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110198 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY102", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY102(a) bdk_apbrom_mdabx_romentry102_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY102(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY102(a) "APBROM_MDABX_ROMENTRY102"
#define busnum_BDK_APBROM_MDABX_ROMENTRY102(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY102(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry103
 *
 * APBROM Mdab Romentry103 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry103
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry103_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry103_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry103 bdk_apbrom_mdabx_romentry103_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY103(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY103(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611019c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY103", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY103(a) bdk_apbrom_mdabx_romentry103_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY103(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY103(a) "APBROM_MDABX_ROMENTRY103"
#define busnum_BDK_APBROM_MDABX_ROMENTRY103(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY103(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry104
 *
 * APBROM Mdab Romentry104 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry104
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry104_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry104 bdk_apbrom_mdabx_romentry104_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY104(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY104(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY104", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY104(a) bdk_apbrom_mdabx_romentry104_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY104(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY104(a) "APBROM_MDABX_ROMENTRY104"
#define busnum_BDK_APBROM_MDABX_ROMENTRY104(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY104(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry105
 *
 * APBROM Mdab Romentry105 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry105
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry105_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry105_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry105 bdk_apbrom_mdabx_romentry105_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY105(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY105(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY105", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY105(a) bdk_apbrom_mdabx_romentry105_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY105(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY105(a) "APBROM_MDABX_ROMENTRY105"
#define busnum_BDK_APBROM_MDABX_ROMENTRY105(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY105(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry106
 *
 * APBROM Mdab Romentry106 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry106
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry106_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry106_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry106 bdk_apbrom_mdabx_romentry106_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY106(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY106(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY106", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY106(a) bdk_apbrom_mdabx_romentry106_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY106(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY106(a) "APBROM_MDABX_ROMENTRY106"
#define busnum_BDK_APBROM_MDABX_ROMENTRY106(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY106(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry107
 *
 * APBROM Mdab Romentry107 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry107
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry107_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry107_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry107 bdk_apbrom_mdabx_romentry107_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY107(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY107(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY107", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY107(a) bdk_apbrom_mdabx_romentry107_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY107(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY107(a) "APBROM_MDABX_ROMENTRY107"
#define busnum_BDK_APBROM_MDABX_ROMENTRY107(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY107(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry108
 *
 * APBROM Mdab Romentry108 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry108
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry108_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry108_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry108 bdk_apbrom_mdabx_romentry108_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY108(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY108(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY108", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY108(a) bdk_apbrom_mdabx_romentry108_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY108(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY108(a) "APBROM_MDABX_ROMENTRY108"
#define busnum_BDK_APBROM_MDABX_ROMENTRY108(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY108(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry109
 *
 * APBROM Mdab Romentry109 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry109
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry109_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry109_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry109 bdk_apbrom_mdabx_romentry109_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY109(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY109(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY109", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY109(a) bdk_apbrom_mdabx_romentry109_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY109(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY109(a) "APBROM_MDABX_ROMENTRY109"
#define busnum_BDK_APBROM_MDABX_ROMENTRY109(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY109(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry11
 *
 * APBROM Mdab Romentry11 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry11
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry11_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry11 bdk_apbrom_mdabx_romentry11_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY11(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY11(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611002c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY11(a) bdk_apbrom_mdabx_romentry11_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY11(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY11(a) "APBROM_MDABX_ROMENTRY11"
#define busnum_BDK_APBROM_MDABX_ROMENTRY11(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry110
 *
 * APBROM Mdab Romentry110 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry110
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry110_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry110_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry110 bdk_apbrom_mdabx_romentry110_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY110(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY110(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY110", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY110(a) bdk_apbrom_mdabx_romentry110_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY110(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY110(a) "APBROM_MDABX_ROMENTRY110"
#define busnum_BDK_APBROM_MDABX_ROMENTRY110(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY110(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry111
 *
 * APBROM Mdab Romentry111 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry111
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry111_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry111_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry111 bdk_apbrom_mdabx_romentry111_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY111(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY111(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY111", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY111(a) bdk_apbrom_mdabx_romentry111_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY111(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY111(a) "APBROM_MDABX_ROMENTRY111"
#define busnum_BDK_APBROM_MDABX_ROMENTRY111(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY111(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry112
 *
 * APBROM Mdab Romentry112 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry112
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry112_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry112 bdk_apbrom_mdabx_romentry112_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY112(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY112(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY112", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY112(a) bdk_apbrom_mdabx_romentry112_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY112(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY112(a) "APBROM_MDABX_ROMENTRY112"
#define busnum_BDK_APBROM_MDABX_ROMENTRY112(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY112(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry113
 *
 * APBROM Mdab Romentry113 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry113
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry113_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry113_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry113 bdk_apbrom_mdabx_romentry113_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY113(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY113(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY113", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY113(a) bdk_apbrom_mdabx_romentry113_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY113(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY113(a) "APBROM_MDABX_ROMENTRY113"
#define busnum_BDK_APBROM_MDABX_ROMENTRY113(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY113(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry114
 *
 * APBROM Mdab Romentry114 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry114
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry114_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry114_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry114 bdk_apbrom_mdabx_romentry114_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY114(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY114(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY114", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY114(a) bdk_apbrom_mdabx_romentry114_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY114(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY114(a) "APBROM_MDABX_ROMENTRY114"
#define busnum_BDK_APBROM_MDABX_ROMENTRY114(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY114(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry115
 *
 * APBROM Mdab Romentry115 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry115
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry115_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry115_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry115 bdk_apbrom_mdabx_romentry115_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY115(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY115(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY115", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY115(a) bdk_apbrom_mdabx_romentry115_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY115(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY115(a) "APBROM_MDABX_ROMENTRY115"
#define busnum_BDK_APBROM_MDABX_ROMENTRY115(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY115(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry116
 *
 * APBROM Mdab Romentry116 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry116
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry116_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry116_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry116 bdk_apbrom_mdabx_romentry116_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY116(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY116(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY116", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY116(a) bdk_apbrom_mdabx_romentry116_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY116(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY116(a) "APBROM_MDABX_ROMENTRY116"
#define busnum_BDK_APBROM_MDABX_ROMENTRY116(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY116(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry117
 *
 * APBROM Mdab Romentry117 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry117
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry117_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry117_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry117 bdk_apbrom_mdabx_romentry117_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY117(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY117(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY117", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY117(a) bdk_apbrom_mdabx_romentry117_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY117(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY117(a) "APBROM_MDABX_ROMENTRY117"
#define busnum_BDK_APBROM_MDABX_ROMENTRY117(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY117(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry118
 *
 * APBROM Mdab Romentry118 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry118
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry118_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry118_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry118 bdk_apbrom_mdabx_romentry118_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY118(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY118(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY118", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY118(a) bdk_apbrom_mdabx_romentry118_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY118(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY118(a) "APBROM_MDABX_ROMENTRY118"
#define busnum_BDK_APBROM_MDABX_ROMENTRY118(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY118(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry119
 *
 * APBROM Mdab Romentry119 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry119
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry119_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry119_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry119 bdk_apbrom_mdabx_romentry119_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY119(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY119(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY119", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY119(a) bdk_apbrom_mdabx_romentry119_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY119(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY119(a) "APBROM_MDABX_ROMENTRY119"
#define busnum_BDK_APBROM_MDABX_ROMENTRY119(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY119(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry12
 *
 * APBROM Mdab Romentry12 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry12
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry12_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry12 bdk_apbrom_mdabx_romentry12_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY12(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY12(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110030 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY12(a) bdk_apbrom_mdabx_romentry12_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY12(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY12(a) "APBROM_MDABX_ROMENTRY12"
#define busnum_BDK_APBROM_MDABX_ROMENTRY12(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry120
 *
 * APBROM Mdab Romentry120 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry120
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry120_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry120 bdk_apbrom_mdabx_romentry120_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY120(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY120(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY120", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY120(a) bdk_apbrom_mdabx_romentry120_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY120(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY120(a) "APBROM_MDABX_ROMENTRY120"
#define busnum_BDK_APBROM_MDABX_ROMENTRY120(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY120(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry121
 *
 * APBROM Mdab Romentry121 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry121
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry121_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry121_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry121 bdk_apbrom_mdabx_romentry121_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY121(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY121(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY121", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY121(a) bdk_apbrom_mdabx_romentry121_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY121(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY121(a) "APBROM_MDABX_ROMENTRY121"
#define busnum_BDK_APBROM_MDABX_ROMENTRY121(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY121(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry122
 *
 * APBROM Mdab Romentry122 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry122
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry122_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry122_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry122 bdk_apbrom_mdabx_romentry122_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY122(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY122(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY122", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY122(a) bdk_apbrom_mdabx_romentry122_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY122(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY122(a) "APBROM_MDABX_ROMENTRY122"
#define busnum_BDK_APBROM_MDABX_ROMENTRY122(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY122(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry123
 *
 * APBROM Mdab Romentry123 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry123
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry123_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry123_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry123 bdk_apbrom_mdabx_romentry123_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY123(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY123(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY123", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY123(a) bdk_apbrom_mdabx_romentry123_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY123(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY123(a) "APBROM_MDABX_ROMENTRY123"
#define busnum_BDK_APBROM_MDABX_ROMENTRY123(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY123(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry124
 *
 * APBROM Mdab Romentry124 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry124
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry124_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry124_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry124 bdk_apbrom_mdabx_romentry124_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY124(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY124(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY124", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY124(a) bdk_apbrom_mdabx_romentry124_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY124(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY124(a) "APBROM_MDABX_ROMENTRY124"
#define busnum_BDK_APBROM_MDABX_ROMENTRY124(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY124(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry125
 *
 * APBROM Mdab Romentry125 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry125
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry125_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry125_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry125 bdk_apbrom_mdabx_romentry125_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY125(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY125(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY125", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY125(a) bdk_apbrom_mdabx_romentry125_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY125(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY125(a) "APBROM_MDABX_ROMENTRY125"
#define busnum_BDK_APBROM_MDABX_ROMENTRY125(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY125(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry126
 *
 * APBROM Mdab Romentry126 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry126
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry126_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry126_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry126 bdk_apbrom_mdabx_romentry126_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY126(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY126(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY126", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY126(a) bdk_apbrom_mdabx_romentry126_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY126(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY126(a) "APBROM_MDABX_ROMENTRY126"
#define busnum_BDK_APBROM_MDABX_ROMENTRY126(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY126(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry127
 *
 * APBROM Mdab Romentry127 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry127
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry127_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry127_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry127 bdk_apbrom_mdabx_romentry127_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY127(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY127(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461101fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY127", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY127(a) bdk_apbrom_mdabx_romentry127_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY127(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY127(a) "APBROM_MDABX_ROMENTRY127"
#define busnum_BDK_APBROM_MDABX_ROMENTRY127(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY127(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry128
 *
 * APBROM Mdab Romentry128 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry128
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry128_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry128 bdk_apbrom_mdabx_romentry128_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY128(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY128(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110200 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY128", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY128(a) bdk_apbrom_mdabx_romentry128_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY128(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY128(a) "APBROM_MDABX_ROMENTRY128"
#define busnum_BDK_APBROM_MDABX_ROMENTRY128(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY128(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry129
 *
 * APBROM Mdab Romentry129 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry129
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry129_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry129_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry129 bdk_apbrom_mdabx_romentry129_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY129(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY129(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110204 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY129", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY129(a) bdk_apbrom_mdabx_romentry129_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY129(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY129(a) "APBROM_MDABX_ROMENTRY129"
#define busnum_BDK_APBROM_MDABX_ROMENTRY129(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY129(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry13
 *
 * APBROM Mdab Romentry13 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry13
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry13_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry13 bdk_apbrom_mdabx_romentry13_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY13(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY13(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110034 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY13(a) bdk_apbrom_mdabx_romentry13_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY13(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY13(a) "APBROM_MDABX_ROMENTRY13"
#define busnum_BDK_APBROM_MDABX_ROMENTRY13(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY13(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry130
 *
 * APBROM Mdab Romentry130 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry130
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry130_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry130_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry130 bdk_apbrom_mdabx_romentry130_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY130(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY130(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110208 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY130", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY130(a) bdk_apbrom_mdabx_romentry130_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY130(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY130(a) "APBROM_MDABX_ROMENTRY130"
#define busnum_BDK_APBROM_MDABX_ROMENTRY130(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY130(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry131
 *
 * APBROM Mdab Romentry131 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry131
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry131_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry131_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry131 bdk_apbrom_mdabx_romentry131_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY131(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY131(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611020c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY131", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY131(a) bdk_apbrom_mdabx_romentry131_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY131(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY131(a) "APBROM_MDABX_ROMENTRY131"
#define busnum_BDK_APBROM_MDABX_ROMENTRY131(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY131(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry132
 *
 * APBROM Mdab Romentry132 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry132
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry132_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry132_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry132 bdk_apbrom_mdabx_romentry132_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY132(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY132(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110210 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY132", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY132(a) bdk_apbrom_mdabx_romentry132_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY132(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY132(a) "APBROM_MDABX_ROMENTRY132"
#define busnum_BDK_APBROM_MDABX_ROMENTRY132(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY132(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry133
 *
 * APBROM Mdab Romentry133 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry133
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry133_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry133_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry133 bdk_apbrom_mdabx_romentry133_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY133(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY133(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110214 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY133", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY133(a) bdk_apbrom_mdabx_romentry133_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY133(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY133(a) "APBROM_MDABX_ROMENTRY133"
#define busnum_BDK_APBROM_MDABX_ROMENTRY133(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY133(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry134
 *
 * APBROM Mdab Romentry134 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry134
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry134_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry134_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry134 bdk_apbrom_mdabx_romentry134_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY134(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY134(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110218 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY134", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY134(a) bdk_apbrom_mdabx_romentry134_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY134(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY134(a) "APBROM_MDABX_ROMENTRY134"
#define busnum_BDK_APBROM_MDABX_ROMENTRY134(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY134(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry135
 *
 * APBROM Mdab Romentry135 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry135
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry135_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry135_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry135 bdk_apbrom_mdabx_romentry135_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY135(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY135(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611021c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY135", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY135(a) bdk_apbrom_mdabx_romentry135_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY135(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY135(a) "APBROM_MDABX_ROMENTRY135"
#define busnum_BDK_APBROM_MDABX_ROMENTRY135(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY135(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry136
 *
 * APBROM Mdab Romentry136 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry136
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry136_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry136 bdk_apbrom_mdabx_romentry136_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY136(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY136(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110220 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY136", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY136(a) bdk_apbrom_mdabx_romentry136_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY136(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY136(a) "APBROM_MDABX_ROMENTRY136"
#define busnum_BDK_APBROM_MDABX_ROMENTRY136(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY136(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry137
 *
 * APBROM Mdab Romentry137 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry137
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry137_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry137_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry137 bdk_apbrom_mdabx_romentry137_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY137(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY137(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110224 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY137", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY137(a) bdk_apbrom_mdabx_romentry137_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY137(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY137(a) "APBROM_MDABX_ROMENTRY137"
#define busnum_BDK_APBROM_MDABX_ROMENTRY137(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY137(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry138
 *
 * APBROM Mdab Romentry138 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry138
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry138_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry138_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry138 bdk_apbrom_mdabx_romentry138_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY138(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY138(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110228 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY138", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY138(a) bdk_apbrom_mdabx_romentry138_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY138(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY138(a) "APBROM_MDABX_ROMENTRY138"
#define busnum_BDK_APBROM_MDABX_ROMENTRY138(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY138(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry139
 *
 * APBROM Mdab Romentry139 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry139
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry139_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry139_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry139 bdk_apbrom_mdabx_romentry139_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY139(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY139(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611022c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY139", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY139(a) bdk_apbrom_mdabx_romentry139_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY139(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY139(a) "APBROM_MDABX_ROMENTRY139"
#define busnum_BDK_APBROM_MDABX_ROMENTRY139(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY139(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry14
 *
 * APBROM Mdab Romentry14 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry14
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry14_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry14 bdk_apbrom_mdabx_romentry14_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY14(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY14(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110038 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY14", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY14(a) bdk_apbrom_mdabx_romentry14_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY14(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY14(a) "APBROM_MDABX_ROMENTRY14"
#define busnum_BDK_APBROM_MDABX_ROMENTRY14(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY14(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry140
 *
 * APBROM Mdab Romentry140 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry140
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry140_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry140_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry140 bdk_apbrom_mdabx_romentry140_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY140(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY140(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110230 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY140", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY140(a) bdk_apbrom_mdabx_romentry140_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY140(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY140(a) "APBROM_MDABX_ROMENTRY140"
#define busnum_BDK_APBROM_MDABX_ROMENTRY140(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY140(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry141
 *
 * APBROM Mdab Romentry141 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry141
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry141_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry141_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry141 bdk_apbrom_mdabx_romentry141_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY141(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY141(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110234 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY141", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY141(a) bdk_apbrom_mdabx_romentry141_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY141(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY141(a) "APBROM_MDABX_ROMENTRY141"
#define busnum_BDK_APBROM_MDABX_ROMENTRY141(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY141(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry142
 *
 * APBROM Mdab Romentry142 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry142
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry142_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry142_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry142 bdk_apbrom_mdabx_romentry142_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY142(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY142(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110238 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY142", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY142(a) bdk_apbrom_mdabx_romentry142_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY142(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY142(a) "APBROM_MDABX_ROMENTRY142"
#define busnum_BDK_APBROM_MDABX_ROMENTRY142(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY142(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry143
 *
 * APBROM Mdab Romentry143 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry143
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry143_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry143_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry143 bdk_apbrom_mdabx_romentry143_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY143(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY143(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611023c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY143", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY143(a) bdk_apbrom_mdabx_romentry143_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY143(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY143(a) "APBROM_MDABX_ROMENTRY143"
#define busnum_BDK_APBROM_MDABX_ROMENTRY143(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY143(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry144
 *
 * APBROM Mdab Romentry144 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry144
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry144_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry144 bdk_apbrom_mdabx_romentry144_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY144(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY144(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110240 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY144", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY144(a) bdk_apbrom_mdabx_romentry144_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY144(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY144(a) "APBROM_MDABX_ROMENTRY144"
#define busnum_BDK_APBROM_MDABX_ROMENTRY144(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY144(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry145
 *
 * APBROM Mdab Romentry145 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry145
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry145_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry145_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry145 bdk_apbrom_mdabx_romentry145_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY145(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY145(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110244 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY145", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY145(a) bdk_apbrom_mdabx_romentry145_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY145(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY145(a) "APBROM_MDABX_ROMENTRY145"
#define busnum_BDK_APBROM_MDABX_ROMENTRY145(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY145(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry146
 *
 * APBROM Mdab Romentry146 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry146
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry146_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry146_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry146 bdk_apbrom_mdabx_romentry146_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY146(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY146(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110248 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY146", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY146(a) bdk_apbrom_mdabx_romentry146_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY146(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY146(a) "APBROM_MDABX_ROMENTRY146"
#define busnum_BDK_APBROM_MDABX_ROMENTRY146(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY146(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry147
 *
 * APBROM Mdab Romentry147 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry147
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry147_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry147_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry147 bdk_apbrom_mdabx_romentry147_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY147(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY147(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611024c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY147", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY147(a) bdk_apbrom_mdabx_romentry147_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY147(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY147(a) "APBROM_MDABX_ROMENTRY147"
#define busnum_BDK_APBROM_MDABX_ROMENTRY147(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY147(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry148
 *
 * APBROM Mdab Romentry148 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry148
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry148_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry148_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry148 bdk_apbrom_mdabx_romentry148_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY148(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY148(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110250 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY148", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY148(a) bdk_apbrom_mdabx_romentry148_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY148(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY148(a) "APBROM_MDABX_ROMENTRY148"
#define busnum_BDK_APBROM_MDABX_ROMENTRY148(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY148(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry149
 *
 * APBROM Mdab Romentry149 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry149
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry149_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry149_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry149 bdk_apbrom_mdabx_romentry149_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY149(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY149(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110254 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY149", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY149(a) bdk_apbrom_mdabx_romentry149_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY149(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY149(a) "APBROM_MDABX_ROMENTRY149"
#define busnum_BDK_APBROM_MDABX_ROMENTRY149(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY149(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry15
 *
 * APBROM Mdab Romentry15 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry15
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry15_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry15 bdk_apbrom_mdabx_romentry15_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY15(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY15(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611003c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY15", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY15(a) bdk_apbrom_mdabx_romentry15_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY15(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY15(a) "APBROM_MDABX_ROMENTRY15"
#define busnum_BDK_APBROM_MDABX_ROMENTRY15(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY15(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry150
 *
 * APBROM Mdab Romentry150 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry150
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry150_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry150_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry150 bdk_apbrom_mdabx_romentry150_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY150(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY150(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110258 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY150", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY150(a) bdk_apbrom_mdabx_romentry150_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY150(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY150(a) "APBROM_MDABX_ROMENTRY150"
#define busnum_BDK_APBROM_MDABX_ROMENTRY150(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY150(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry151
 *
 * APBROM Mdab Romentry151 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry151
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry151_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry151_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry151 bdk_apbrom_mdabx_romentry151_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY151(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY151(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611025c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY151", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY151(a) bdk_apbrom_mdabx_romentry151_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY151(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY151(a) "APBROM_MDABX_ROMENTRY151"
#define busnum_BDK_APBROM_MDABX_ROMENTRY151(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY151(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry152
 *
 * APBROM Mdab Romentry152 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry152
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry152_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry152 bdk_apbrom_mdabx_romentry152_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY152(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY152(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110260 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY152", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY152(a) bdk_apbrom_mdabx_romentry152_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY152(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY152(a) "APBROM_MDABX_ROMENTRY152"
#define busnum_BDK_APBROM_MDABX_ROMENTRY152(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY152(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry153
 *
 * APBROM Mdab Romentry153 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry153
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry153_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry153_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry153 bdk_apbrom_mdabx_romentry153_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY153(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY153(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110264 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY153", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY153(a) bdk_apbrom_mdabx_romentry153_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY153(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY153(a) "APBROM_MDABX_ROMENTRY153"
#define busnum_BDK_APBROM_MDABX_ROMENTRY153(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY153(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry154
 *
 * APBROM Mdab Romentry154 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry154
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry154_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry154_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry154 bdk_apbrom_mdabx_romentry154_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY154(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY154(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110268 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY154", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY154(a) bdk_apbrom_mdabx_romentry154_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY154(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY154(a) "APBROM_MDABX_ROMENTRY154"
#define busnum_BDK_APBROM_MDABX_ROMENTRY154(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY154(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry155
 *
 * APBROM Mdab Romentry155 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry155
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry155_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry155_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry155 bdk_apbrom_mdabx_romentry155_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY155(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY155(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611026c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY155", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY155(a) bdk_apbrom_mdabx_romentry155_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY155(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY155(a) "APBROM_MDABX_ROMENTRY155"
#define busnum_BDK_APBROM_MDABX_ROMENTRY155(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY155(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry156
 *
 * APBROM Mdab Romentry156 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry156
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry156_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry156_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry156 bdk_apbrom_mdabx_romentry156_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY156(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY156(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110270 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY156", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY156(a) bdk_apbrom_mdabx_romentry156_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY156(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY156(a) "APBROM_MDABX_ROMENTRY156"
#define busnum_BDK_APBROM_MDABX_ROMENTRY156(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY156(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry157
 *
 * APBROM Mdab Romentry157 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry157
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry157_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry157_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry157 bdk_apbrom_mdabx_romentry157_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY157(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY157(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110274 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY157", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY157(a) bdk_apbrom_mdabx_romentry157_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY157(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY157(a) "APBROM_MDABX_ROMENTRY157"
#define busnum_BDK_APBROM_MDABX_ROMENTRY157(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY157(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry158
 *
 * APBROM Mdab Romentry158 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry158
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry158_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry158_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry158 bdk_apbrom_mdabx_romentry158_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY158(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY158(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110278 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY158", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY158(a) bdk_apbrom_mdabx_romentry158_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY158(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY158(a) "APBROM_MDABX_ROMENTRY158"
#define busnum_BDK_APBROM_MDABX_ROMENTRY158(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY158(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry159
 *
 * APBROM Mdab Romentry159 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry159
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry159_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry159_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry159 bdk_apbrom_mdabx_romentry159_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY159(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY159(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611027c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY159", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY159(a) bdk_apbrom_mdabx_romentry159_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY159(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY159(a) "APBROM_MDABX_ROMENTRY159"
#define busnum_BDK_APBROM_MDABX_ROMENTRY159(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY159(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry16
 *
 * APBROM Mdab Romentry16 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry16
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry16_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry16 bdk_apbrom_mdabx_romentry16_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY16(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY16(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110040 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY16", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY16(a) bdk_apbrom_mdabx_romentry16_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY16(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY16(a) "APBROM_MDABX_ROMENTRY16"
#define busnum_BDK_APBROM_MDABX_ROMENTRY16(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY16(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry160
 *
 * APBROM Mdab Romentry160 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry160
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry160_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry160 bdk_apbrom_mdabx_romentry160_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY160(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY160(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110280 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY160", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY160(a) bdk_apbrom_mdabx_romentry160_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY160(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY160(a) "APBROM_MDABX_ROMENTRY160"
#define busnum_BDK_APBROM_MDABX_ROMENTRY160(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY160(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry161
 *
 * APBROM Mdab Romentry161 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry161
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry161_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry161_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry161 bdk_apbrom_mdabx_romentry161_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY161(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY161(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110284 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY161", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY161(a) bdk_apbrom_mdabx_romentry161_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY161(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY161(a) "APBROM_MDABX_ROMENTRY161"
#define busnum_BDK_APBROM_MDABX_ROMENTRY161(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY161(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry162
 *
 * APBROM Mdab Romentry162 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry162
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry162_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry162_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry162 bdk_apbrom_mdabx_romentry162_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY162(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY162(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110288 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY162", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY162(a) bdk_apbrom_mdabx_romentry162_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY162(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY162(a) "APBROM_MDABX_ROMENTRY162"
#define busnum_BDK_APBROM_MDABX_ROMENTRY162(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY162(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry163
 *
 * APBROM Mdab Romentry163 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry163
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry163_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry163_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry163 bdk_apbrom_mdabx_romentry163_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY163(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY163(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611028c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY163", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY163(a) bdk_apbrom_mdabx_romentry163_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY163(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY163(a) "APBROM_MDABX_ROMENTRY163"
#define busnum_BDK_APBROM_MDABX_ROMENTRY163(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY163(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry164
 *
 * APBROM Mdab Romentry164 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry164
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry164_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry164_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry164 bdk_apbrom_mdabx_romentry164_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY164(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY164(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110290 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY164", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY164(a) bdk_apbrom_mdabx_romentry164_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY164(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY164(a) "APBROM_MDABX_ROMENTRY164"
#define busnum_BDK_APBROM_MDABX_ROMENTRY164(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY164(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry165
 *
 * APBROM Mdab Romentry165 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry165
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry165_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry165_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry165 bdk_apbrom_mdabx_romentry165_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY165(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY165(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110294 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY165", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY165(a) bdk_apbrom_mdabx_romentry165_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY165(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY165(a) "APBROM_MDABX_ROMENTRY165"
#define busnum_BDK_APBROM_MDABX_ROMENTRY165(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY165(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry166
 *
 * APBROM Mdab Romentry166 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry166
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry166_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry166_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry166 bdk_apbrom_mdabx_romentry166_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY166(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY166(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110298 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY166", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY166(a) bdk_apbrom_mdabx_romentry166_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY166(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY166(a) "APBROM_MDABX_ROMENTRY166"
#define busnum_BDK_APBROM_MDABX_ROMENTRY166(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY166(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry167
 *
 * APBROM Mdab Romentry167 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry167
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry167_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry167_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry167 bdk_apbrom_mdabx_romentry167_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY167(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY167(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611029c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY167", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY167(a) bdk_apbrom_mdabx_romentry167_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY167(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY167(a) "APBROM_MDABX_ROMENTRY167"
#define busnum_BDK_APBROM_MDABX_ROMENTRY167(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY167(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry168
 *
 * APBROM Mdab Romentry168 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry168
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry168_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry168 bdk_apbrom_mdabx_romentry168_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY168(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY168(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY168", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY168(a) bdk_apbrom_mdabx_romentry168_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY168(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY168(a) "APBROM_MDABX_ROMENTRY168"
#define busnum_BDK_APBROM_MDABX_ROMENTRY168(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY168(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry169
 *
 * APBROM Mdab Romentry169 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry169
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry169_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry169_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry169 bdk_apbrom_mdabx_romentry169_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY169(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY169(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY169", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY169(a) bdk_apbrom_mdabx_romentry169_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY169(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY169(a) "APBROM_MDABX_ROMENTRY169"
#define busnum_BDK_APBROM_MDABX_ROMENTRY169(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY169(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry17
 *
 * APBROM Mdab Romentry17 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry17
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry17_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry17 bdk_apbrom_mdabx_romentry17_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY17(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY17(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110044 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY17", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY17(a) bdk_apbrom_mdabx_romentry17_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY17(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY17(a) "APBROM_MDABX_ROMENTRY17"
#define busnum_BDK_APBROM_MDABX_ROMENTRY17(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY17(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry170
 *
 * APBROM Mdab Romentry170 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry170
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry170_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry170_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry170 bdk_apbrom_mdabx_romentry170_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY170(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY170(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY170", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY170(a) bdk_apbrom_mdabx_romentry170_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY170(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY170(a) "APBROM_MDABX_ROMENTRY170"
#define busnum_BDK_APBROM_MDABX_ROMENTRY170(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY170(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry171
 *
 * APBROM Mdab Romentry171 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry171
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry171_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry171_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry171 bdk_apbrom_mdabx_romentry171_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY171(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY171(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY171", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY171(a) bdk_apbrom_mdabx_romentry171_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY171(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY171(a) "APBROM_MDABX_ROMENTRY171"
#define busnum_BDK_APBROM_MDABX_ROMENTRY171(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY171(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry172
 *
 * APBROM Mdab Romentry172 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry172
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry172_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry172_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry172 bdk_apbrom_mdabx_romentry172_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY172(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY172(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY172", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY172(a) bdk_apbrom_mdabx_romentry172_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY172(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY172(a) "APBROM_MDABX_ROMENTRY172"
#define busnum_BDK_APBROM_MDABX_ROMENTRY172(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY172(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry173
 *
 * APBROM Mdab Romentry173 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry173
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry173_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry173_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry173 bdk_apbrom_mdabx_romentry173_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY173(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY173(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY173", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY173(a) bdk_apbrom_mdabx_romentry173_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY173(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY173(a) "APBROM_MDABX_ROMENTRY173"
#define busnum_BDK_APBROM_MDABX_ROMENTRY173(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY173(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry174
 *
 * APBROM Mdab Romentry174 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry174
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry174_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry174_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry174 bdk_apbrom_mdabx_romentry174_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY174(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY174(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY174", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY174(a) bdk_apbrom_mdabx_romentry174_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY174(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY174(a) "APBROM_MDABX_ROMENTRY174"
#define busnum_BDK_APBROM_MDABX_ROMENTRY174(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY174(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry175
 *
 * APBROM Mdab Romentry175 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry175
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry175_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry175_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry175 bdk_apbrom_mdabx_romentry175_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY175(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY175(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY175", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY175(a) bdk_apbrom_mdabx_romentry175_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY175(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY175(a) "APBROM_MDABX_ROMENTRY175"
#define busnum_BDK_APBROM_MDABX_ROMENTRY175(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY175(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry176
 *
 * APBROM Mdab Romentry176 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry176
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry176_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry176 bdk_apbrom_mdabx_romentry176_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY176(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY176(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY176", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY176(a) bdk_apbrom_mdabx_romentry176_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY176(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY176(a) "APBROM_MDABX_ROMENTRY176"
#define busnum_BDK_APBROM_MDABX_ROMENTRY176(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY176(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry177
 *
 * APBROM Mdab Romentry177 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry177
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry177_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry177_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry177 bdk_apbrom_mdabx_romentry177_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY177(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY177(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY177", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY177(a) bdk_apbrom_mdabx_romentry177_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY177(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY177(a) "APBROM_MDABX_ROMENTRY177"
#define busnum_BDK_APBROM_MDABX_ROMENTRY177(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY177(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry178
 *
 * APBROM Mdab Romentry178 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry178
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry178_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry178_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry178 bdk_apbrom_mdabx_romentry178_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY178(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY178(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY178", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY178(a) bdk_apbrom_mdabx_romentry178_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY178(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY178(a) "APBROM_MDABX_ROMENTRY178"
#define busnum_BDK_APBROM_MDABX_ROMENTRY178(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY178(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry179
 *
 * APBROM Mdab Romentry179 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry179
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry179_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry179_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry179 bdk_apbrom_mdabx_romentry179_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY179(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY179(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY179", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY179(a) bdk_apbrom_mdabx_romentry179_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY179(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY179(a) "APBROM_MDABX_ROMENTRY179"
#define busnum_BDK_APBROM_MDABX_ROMENTRY179(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY179(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry18
 *
 * APBROM Mdab Romentry18 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry18
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry18_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry18 bdk_apbrom_mdabx_romentry18_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY18(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY18(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110048 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY18", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY18(a) bdk_apbrom_mdabx_romentry18_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY18(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY18(a) "APBROM_MDABX_ROMENTRY18"
#define busnum_BDK_APBROM_MDABX_ROMENTRY18(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY18(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry180
 *
 * APBROM Mdab Romentry180 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry180
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry180_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry180_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry180 bdk_apbrom_mdabx_romentry180_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY180(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY180(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY180", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY180(a) bdk_apbrom_mdabx_romentry180_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY180(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY180(a) "APBROM_MDABX_ROMENTRY180"
#define busnum_BDK_APBROM_MDABX_ROMENTRY180(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY180(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry181
 *
 * APBROM Mdab Romentry181 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry181
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry181_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry181_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry181 bdk_apbrom_mdabx_romentry181_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY181(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY181(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY181", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY181(a) bdk_apbrom_mdabx_romentry181_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY181(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY181(a) "APBROM_MDABX_ROMENTRY181"
#define busnum_BDK_APBROM_MDABX_ROMENTRY181(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY181(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry182
 *
 * APBROM Mdab Romentry182 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry182
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry182_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry182_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry182 bdk_apbrom_mdabx_romentry182_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY182(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY182(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY182", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY182(a) bdk_apbrom_mdabx_romentry182_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY182(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY182(a) "APBROM_MDABX_ROMENTRY182"
#define busnum_BDK_APBROM_MDABX_ROMENTRY182(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY182(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry183
 *
 * APBROM Mdab Romentry183 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry183
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry183_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry183_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry183 bdk_apbrom_mdabx_romentry183_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY183(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY183(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY183", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY183(a) bdk_apbrom_mdabx_romentry183_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY183(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY183(a) "APBROM_MDABX_ROMENTRY183"
#define busnum_BDK_APBROM_MDABX_ROMENTRY183(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY183(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry184
 *
 * APBROM Mdab Romentry184 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry184
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry184_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry184 bdk_apbrom_mdabx_romentry184_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY184(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY184(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY184", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY184(a) bdk_apbrom_mdabx_romentry184_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY184(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY184(a) "APBROM_MDABX_ROMENTRY184"
#define busnum_BDK_APBROM_MDABX_ROMENTRY184(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY184(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry185
 *
 * APBROM Mdab Romentry185 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry185
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry185_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry185_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry185 bdk_apbrom_mdabx_romentry185_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY185(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY185(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY185", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY185(a) bdk_apbrom_mdabx_romentry185_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY185(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY185(a) "APBROM_MDABX_ROMENTRY185"
#define busnum_BDK_APBROM_MDABX_ROMENTRY185(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY185(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry186
 *
 * APBROM Mdab Romentry186 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry186
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry186_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry186_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry186 bdk_apbrom_mdabx_romentry186_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY186(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY186(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY186", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY186(a) bdk_apbrom_mdabx_romentry186_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY186(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY186(a) "APBROM_MDABX_ROMENTRY186"
#define busnum_BDK_APBROM_MDABX_ROMENTRY186(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY186(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry187
 *
 * APBROM Mdab Romentry187 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry187
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry187_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry187_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry187 bdk_apbrom_mdabx_romentry187_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY187(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY187(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY187", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY187(a) bdk_apbrom_mdabx_romentry187_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY187(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY187(a) "APBROM_MDABX_ROMENTRY187"
#define busnum_BDK_APBROM_MDABX_ROMENTRY187(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY187(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry188
 *
 * APBROM Mdab Romentry188 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry188
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry188_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry188_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry188 bdk_apbrom_mdabx_romentry188_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY188(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY188(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY188", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY188(a) bdk_apbrom_mdabx_romentry188_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY188(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY188(a) "APBROM_MDABX_ROMENTRY188"
#define busnum_BDK_APBROM_MDABX_ROMENTRY188(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY188(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry189
 *
 * APBROM Mdab Romentry189 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry189
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry189_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry189_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry189 bdk_apbrom_mdabx_romentry189_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY189(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY189(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY189", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY189(a) bdk_apbrom_mdabx_romentry189_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY189(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY189(a) "APBROM_MDABX_ROMENTRY189"
#define busnum_BDK_APBROM_MDABX_ROMENTRY189(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY189(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry19
 *
 * APBROM Mdab Romentry19 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry19
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry19_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry19 bdk_apbrom_mdabx_romentry19_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY19(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY19(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611004c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY19", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY19(a) bdk_apbrom_mdabx_romentry19_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY19(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY19(a) "APBROM_MDABX_ROMENTRY19"
#define busnum_BDK_APBROM_MDABX_ROMENTRY19(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY19(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry190
 *
 * APBROM Mdab Romentry190 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry190
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry190_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry190_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry190 bdk_apbrom_mdabx_romentry190_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY190(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY190(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY190", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY190(a) bdk_apbrom_mdabx_romentry190_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY190(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY190(a) "APBROM_MDABX_ROMENTRY190"
#define busnum_BDK_APBROM_MDABX_ROMENTRY190(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY190(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry191
 *
 * APBROM Mdab Romentry191 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry191
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry191_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry191_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry191 bdk_apbrom_mdabx_romentry191_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY191(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY191(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461102fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY191", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY191(a) bdk_apbrom_mdabx_romentry191_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY191(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY191(a) "APBROM_MDABX_ROMENTRY191"
#define busnum_BDK_APBROM_MDABX_ROMENTRY191(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY191(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry192
 *
 * APBROM Mdab Romentry192 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry192
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry192_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry192 bdk_apbrom_mdabx_romentry192_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY192(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY192(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110300 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY192", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY192(a) bdk_apbrom_mdabx_romentry192_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY192(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY192(a) "APBROM_MDABX_ROMENTRY192"
#define busnum_BDK_APBROM_MDABX_ROMENTRY192(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY192(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry193
 *
 * APBROM Mdab Romentry193 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry193
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry193_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry193_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry193 bdk_apbrom_mdabx_romentry193_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY193(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY193(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110304 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY193", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY193(a) bdk_apbrom_mdabx_romentry193_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY193(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY193(a) "APBROM_MDABX_ROMENTRY193"
#define busnum_BDK_APBROM_MDABX_ROMENTRY193(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY193(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry194
 *
 * APBROM Mdab Romentry194 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry194
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry194_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry194_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry194 bdk_apbrom_mdabx_romentry194_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY194(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY194(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110308 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY194", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY194(a) bdk_apbrom_mdabx_romentry194_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY194(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY194(a) "APBROM_MDABX_ROMENTRY194"
#define busnum_BDK_APBROM_MDABX_ROMENTRY194(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY194(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry195
 *
 * APBROM Mdab Romentry195 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry195
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry195_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry195_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry195 bdk_apbrom_mdabx_romentry195_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY195(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY195(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611030c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY195", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY195(a) bdk_apbrom_mdabx_romentry195_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY195(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY195(a) "APBROM_MDABX_ROMENTRY195"
#define busnum_BDK_APBROM_MDABX_ROMENTRY195(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY195(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry196
 *
 * APBROM Mdab Romentry196 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry196
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry196_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry196_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry196 bdk_apbrom_mdabx_romentry196_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY196(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY196(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110310 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY196", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY196(a) bdk_apbrom_mdabx_romentry196_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY196(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY196(a) "APBROM_MDABX_ROMENTRY196"
#define busnum_BDK_APBROM_MDABX_ROMENTRY196(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY196(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry197
 *
 * APBROM Mdab Romentry197 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry197
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry197_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry197_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry197 bdk_apbrom_mdabx_romentry197_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY197(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY197(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110314 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY197", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY197(a) bdk_apbrom_mdabx_romentry197_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY197(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY197(a) "APBROM_MDABX_ROMENTRY197"
#define busnum_BDK_APBROM_MDABX_ROMENTRY197(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY197(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry198
 *
 * APBROM Mdab Romentry198 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry198
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry198_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry198_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry198 bdk_apbrom_mdabx_romentry198_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY198(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY198(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110318 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY198", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY198(a) bdk_apbrom_mdabx_romentry198_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY198(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY198(a) "APBROM_MDABX_ROMENTRY198"
#define busnum_BDK_APBROM_MDABX_ROMENTRY198(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY198(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry199
 *
 * APBROM Mdab Romentry199 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry199
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry199_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry199_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry199 bdk_apbrom_mdabx_romentry199_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY199(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY199(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611031c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY199", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY199(a) bdk_apbrom_mdabx_romentry199_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY199(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY199(a) "APBROM_MDABX_ROMENTRY199"
#define busnum_BDK_APBROM_MDABX_ROMENTRY199(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY199(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry2
 *
 * APBROM Mdab Romentry2 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry2
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry2_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry2 bdk_apbrom_mdabx_romentry2_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110008 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY2(a) bdk_apbrom_mdabx_romentry2_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY2(a) "APBROM_MDABX_ROMENTRY2"
#define busnum_BDK_APBROM_MDABX_ROMENTRY2(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry20
 *
 * APBROM Mdab Romentry20 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry20
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry20_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry20 bdk_apbrom_mdabx_romentry20_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY20(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY20(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110050 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY20", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY20(a) bdk_apbrom_mdabx_romentry20_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY20(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY20(a) "APBROM_MDABX_ROMENTRY20"
#define busnum_BDK_APBROM_MDABX_ROMENTRY20(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY20(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry200
 *
 * APBROM Mdab Romentry200 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry200
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry200_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry200_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry200 bdk_apbrom_mdabx_romentry200_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY200(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY200(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110320 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY200", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY200(a) bdk_apbrom_mdabx_romentry200_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY200(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY200(a) "APBROM_MDABX_ROMENTRY200"
#define busnum_BDK_APBROM_MDABX_ROMENTRY200(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY200(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry201
 *
 * APBROM Mdab Romentry201 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry201
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry201_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry201_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry201 bdk_apbrom_mdabx_romentry201_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY201(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY201(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110324 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY201", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY201(a) bdk_apbrom_mdabx_romentry201_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY201(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY201(a) "APBROM_MDABX_ROMENTRY201"
#define busnum_BDK_APBROM_MDABX_ROMENTRY201(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY201(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry202
 *
 * APBROM Mdab Romentry202 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry202
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry202_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry202_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry202 bdk_apbrom_mdabx_romentry202_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY202(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY202(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110328 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY202", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY202(a) bdk_apbrom_mdabx_romentry202_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY202(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY202(a) "APBROM_MDABX_ROMENTRY202"
#define busnum_BDK_APBROM_MDABX_ROMENTRY202(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY202(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry203
 *
 * APBROM Mdab Romentry203 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry203
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry203_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry203_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry203 bdk_apbrom_mdabx_romentry203_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY203(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY203(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611032c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY203", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY203(a) bdk_apbrom_mdabx_romentry203_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY203(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY203(a) "APBROM_MDABX_ROMENTRY203"
#define busnum_BDK_APBROM_MDABX_ROMENTRY203(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY203(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry204
 *
 * APBROM Mdab Romentry204 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry204
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry204_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry204_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry204 bdk_apbrom_mdabx_romentry204_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY204(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY204(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110330 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY204", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY204(a) bdk_apbrom_mdabx_romentry204_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY204(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY204(a) "APBROM_MDABX_ROMENTRY204"
#define busnum_BDK_APBROM_MDABX_ROMENTRY204(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY204(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry205
 *
 * APBROM Mdab Romentry205 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry205
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry205_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry205_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry205 bdk_apbrom_mdabx_romentry205_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY205(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY205(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110334 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY205", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY205(a) bdk_apbrom_mdabx_romentry205_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY205(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY205(a) "APBROM_MDABX_ROMENTRY205"
#define busnum_BDK_APBROM_MDABX_ROMENTRY205(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY205(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry206
 *
 * APBROM Mdab Romentry206 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry206
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry206_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry206_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry206 bdk_apbrom_mdabx_romentry206_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY206(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY206(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110338 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY206", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY206(a) bdk_apbrom_mdabx_romentry206_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY206(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY206(a) "APBROM_MDABX_ROMENTRY206"
#define busnum_BDK_APBROM_MDABX_ROMENTRY206(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY206(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry207
 *
 * APBROM Mdab Romentry207 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry207
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry207_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry207_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry207 bdk_apbrom_mdabx_romentry207_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY207(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY207(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611033c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY207", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY207(a) bdk_apbrom_mdabx_romentry207_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY207(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY207(a) "APBROM_MDABX_ROMENTRY207"
#define busnum_BDK_APBROM_MDABX_ROMENTRY207(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY207(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry208
 *
 * APBROM Mdab Romentry208 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry208
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry208_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry208_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry208 bdk_apbrom_mdabx_romentry208_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY208(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY208(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110340 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY208", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY208(a) bdk_apbrom_mdabx_romentry208_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY208(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY208(a) "APBROM_MDABX_ROMENTRY208"
#define busnum_BDK_APBROM_MDABX_ROMENTRY208(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY208(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry209
 *
 * APBROM Mdab Romentry209 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry209
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry209_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry209_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry209 bdk_apbrom_mdabx_romentry209_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY209(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY209(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110344 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY209", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY209(a) bdk_apbrom_mdabx_romentry209_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY209(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY209(a) "APBROM_MDABX_ROMENTRY209"
#define busnum_BDK_APBROM_MDABX_ROMENTRY209(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY209(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry21
 *
 * APBROM Mdab Romentry21 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry21
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry21_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry21 bdk_apbrom_mdabx_romentry21_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY21(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY21(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110054 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY21", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY21(a) bdk_apbrom_mdabx_romentry21_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY21(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY21(a) "APBROM_MDABX_ROMENTRY21"
#define busnum_BDK_APBROM_MDABX_ROMENTRY21(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY21(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry210
 *
 * APBROM Mdab Romentry210 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry210
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry210_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry210_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry210 bdk_apbrom_mdabx_romentry210_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY210(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY210(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110348 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY210", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY210(a) bdk_apbrom_mdabx_romentry210_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY210(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY210(a) "APBROM_MDABX_ROMENTRY210"
#define busnum_BDK_APBROM_MDABX_ROMENTRY210(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY210(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry211
 *
 * APBROM Mdab Romentry211 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry211
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry211_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry211_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry211 bdk_apbrom_mdabx_romentry211_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY211(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY211(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611034c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY211", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY211(a) bdk_apbrom_mdabx_romentry211_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY211(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY211(a) "APBROM_MDABX_ROMENTRY211"
#define busnum_BDK_APBROM_MDABX_ROMENTRY211(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY211(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry212
 *
 * APBROM Mdab Romentry212 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry212
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry212_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry212_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry212 bdk_apbrom_mdabx_romentry212_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY212(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY212(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110350 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY212", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY212(a) bdk_apbrom_mdabx_romentry212_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY212(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY212(a) "APBROM_MDABX_ROMENTRY212"
#define busnum_BDK_APBROM_MDABX_ROMENTRY212(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY212(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry213
 *
 * APBROM Mdab Romentry213 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry213
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry213_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry213_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry213 bdk_apbrom_mdabx_romentry213_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY213(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY213(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110354 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY213", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY213(a) bdk_apbrom_mdabx_romentry213_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY213(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY213(a) "APBROM_MDABX_ROMENTRY213"
#define busnum_BDK_APBROM_MDABX_ROMENTRY213(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY213(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry214
 *
 * APBROM Mdab Romentry214 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry214
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry214_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry214_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry214 bdk_apbrom_mdabx_romentry214_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY214(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY214(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110358 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY214", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY214(a) bdk_apbrom_mdabx_romentry214_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY214(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY214(a) "APBROM_MDABX_ROMENTRY214"
#define busnum_BDK_APBROM_MDABX_ROMENTRY214(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY214(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry215
 *
 * APBROM Mdab Romentry215 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry215
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry215_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry215_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry215 bdk_apbrom_mdabx_romentry215_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY215(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY215(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611035c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY215", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY215(a) bdk_apbrom_mdabx_romentry215_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY215(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY215(a) "APBROM_MDABX_ROMENTRY215"
#define busnum_BDK_APBROM_MDABX_ROMENTRY215(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY215(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry216
 *
 * APBROM Mdab Romentry216 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry216
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry216_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry216_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry216 bdk_apbrom_mdabx_romentry216_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY216(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY216(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110360 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY216", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY216(a) bdk_apbrom_mdabx_romentry216_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY216(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY216(a) "APBROM_MDABX_ROMENTRY216"
#define busnum_BDK_APBROM_MDABX_ROMENTRY216(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY216(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry217
 *
 * APBROM Mdab Romentry217 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry217
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry217_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry217_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry217 bdk_apbrom_mdabx_romentry217_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY217(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY217(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110364 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY217", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY217(a) bdk_apbrom_mdabx_romentry217_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY217(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY217(a) "APBROM_MDABX_ROMENTRY217"
#define busnum_BDK_APBROM_MDABX_ROMENTRY217(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY217(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry218
 *
 * APBROM Mdab Romentry218 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry218
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry218_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry218_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry218 bdk_apbrom_mdabx_romentry218_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY218(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY218(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110368 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY218", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY218(a) bdk_apbrom_mdabx_romentry218_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY218(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY218(a) "APBROM_MDABX_ROMENTRY218"
#define busnum_BDK_APBROM_MDABX_ROMENTRY218(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY218(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry219
 *
 * APBROM Mdab Romentry219 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry219
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry219_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry219_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry219 bdk_apbrom_mdabx_romentry219_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY219(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY219(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611036c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY219", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY219(a) bdk_apbrom_mdabx_romentry219_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY219(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY219(a) "APBROM_MDABX_ROMENTRY219"
#define busnum_BDK_APBROM_MDABX_ROMENTRY219(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY219(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry22
 *
 * APBROM Mdab Romentry22 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry22
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry22_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry22 bdk_apbrom_mdabx_romentry22_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY22(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY22(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110058 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY22", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY22(a) bdk_apbrom_mdabx_romentry22_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY22(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY22(a) "APBROM_MDABX_ROMENTRY22"
#define busnum_BDK_APBROM_MDABX_ROMENTRY22(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY22(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry220
 *
 * APBROM Mdab Romentry220 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry220
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry220_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry220_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry220 bdk_apbrom_mdabx_romentry220_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY220(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY220(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110370 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY220", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY220(a) bdk_apbrom_mdabx_romentry220_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY220(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY220(a) "APBROM_MDABX_ROMENTRY220"
#define busnum_BDK_APBROM_MDABX_ROMENTRY220(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY220(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry221
 *
 * APBROM Mdab Romentry221 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry221
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry221_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry221_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry221 bdk_apbrom_mdabx_romentry221_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY221(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY221(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110374 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY221", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY221(a) bdk_apbrom_mdabx_romentry221_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY221(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY221(a) "APBROM_MDABX_ROMENTRY221"
#define busnum_BDK_APBROM_MDABX_ROMENTRY221(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY221(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry222
 *
 * APBROM Mdab Romentry222 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry222
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry222_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry222_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry222 bdk_apbrom_mdabx_romentry222_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY222(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY222(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110378 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY222", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY222(a) bdk_apbrom_mdabx_romentry222_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY222(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY222(a) "APBROM_MDABX_ROMENTRY222"
#define busnum_BDK_APBROM_MDABX_ROMENTRY222(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY222(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry223
 *
 * APBROM Mdab Romentry223 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry223
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry223_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry223_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry223 bdk_apbrom_mdabx_romentry223_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY223(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY223(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611037c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY223", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY223(a) bdk_apbrom_mdabx_romentry223_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY223(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY223(a) "APBROM_MDABX_ROMENTRY223"
#define busnum_BDK_APBROM_MDABX_ROMENTRY223(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY223(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry224
 *
 * APBROM Mdab Romentry224 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry224
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry224_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry224_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry224 bdk_apbrom_mdabx_romentry224_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY224(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY224(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110380 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY224", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY224(a) bdk_apbrom_mdabx_romentry224_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY224(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY224(a) "APBROM_MDABX_ROMENTRY224"
#define busnum_BDK_APBROM_MDABX_ROMENTRY224(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY224(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry225
 *
 * APBROM Mdab Romentry225 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry225
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry225_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry225_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry225 bdk_apbrom_mdabx_romentry225_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY225(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY225(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110384 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY225", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY225(a) bdk_apbrom_mdabx_romentry225_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY225(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY225(a) "APBROM_MDABX_ROMENTRY225"
#define busnum_BDK_APBROM_MDABX_ROMENTRY225(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY225(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry226
 *
 * APBROM Mdab Romentry226 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry226
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry226_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry226_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry226 bdk_apbrom_mdabx_romentry226_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY226(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY226(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110388 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY226", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY226(a) bdk_apbrom_mdabx_romentry226_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY226(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY226(a) "APBROM_MDABX_ROMENTRY226"
#define busnum_BDK_APBROM_MDABX_ROMENTRY226(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY226(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry227
 *
 * APBROM Mdab Romentry227 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry227
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry227_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry227_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry227 bdk_apbrom_mdabx_romentry227_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY227(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY227(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611038c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY227", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY227(a) bdk_apbrom_mdabx_romentry227_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY227(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY227(a) "APBROM_MDABX_ROMENTRY227"
#define busnum_BDK_APBROM_MDABX_ROMENTRY227(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY227(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry228
 *
 * APBROM Mdab Romentry228 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry228
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry228_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry228_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry228 bdk_apbrom_mdabx_romentry228_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY228(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY228(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110390 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY228", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY228(a) bdk_apbrom_mdabx_romentry228_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY228(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY228(a) "APBROM_MDABX_ROMENTRY228"
#define busnum_BDK_APBROM_MDABX_ROMENTRY228(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY228(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry229
 *
 * APBROM Mdab Romentry229 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry229
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry229_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry229_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry229 bdk_apbrom_mdabx_romentry229_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY229(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY229(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110394 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY229", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY229(a) bdk_apbrom_mdabx_romentry229_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY229(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY229(a) "APBROM_MDABX_ROMENTRY229"
#define busnum_BDK_APBROM_MDABX_ROMENTRY229(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY229(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry23
 *
 * APBROM Mdab Romentry23 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry23
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry23_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry23_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry23 bdk_apbrom_mdabx_romentry23_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY23(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY23(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611005c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY23", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY23(a) bdk_apbrom_mdabx_romentry23_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY23(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY23(a) "APBROM_MDABX_ROMENTRY23"
#define busnum_BDK_APBROM_MDABX_ROMENTRY23(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY23(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry230
 *
 * APBROM Mdab Romentry230 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry230
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry230_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry230_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry230 bdk_apbrom_mdabx_romentry230_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY230(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY230(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110398 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY230", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY230(a) bdk_apbrom_mdabx_romentry230_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY230(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY230(a) "APBROM_MDABX_ROMENTRY230"
#define busnum_BDK_APBROM_MDABX_ROMENTRY230(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY230(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry231
 *
 * APBROM Mdab Romentry231 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry231
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry231_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry231_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry231 bdk_apbrom_mdabx_romentry231_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY231(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY231(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611039c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY231", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY231(a) bdk_apbrom_mdabx_romentry231_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY231(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY231(a) "APBROM_MDABX_ROMENTRY231"
#define busnum_BDK_APBROM_MDABX_ROMENTRY231(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY231(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry232
 *
 * APBROM Mdab Romentry232 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry232
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry232_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry232_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry232 bdk_apbrom_mdabx_romentry232_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY232(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY232(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY232", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY232(a) bdk_apbrom_mdabx_romentry232_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY232(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY232(a) "APBROM_MDABX_ROMENTRY232"
#define busnum_BDK_APBROM_MDABX_ROMENTRY232(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY232(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry233
 *
 * APBROM Mdab Romentry233 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry233
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry233_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry233_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry233 bdk_apbrom_mdabx_romentry233_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY233(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY233(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY233", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY233(a) bdk_apbrom_mdabx_romentry233_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY233(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY233(a) "APBROM_MDABX_ROMENTRY233"
#define busnum_BDK_APBROM_MDABX_ROMENTRY233(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY233(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry234
 *
 * APBROM Mdab Romentry234 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry234
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry234_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry234_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry234 bdk_apbrom_mdabx_romentry234_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY234(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY234(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY234", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY234(a) bdk_apbrom_mdabx_romentry234_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY234(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY234(a) "APBROM_MDABX_ROMENTRY234"
#define busnum_BDK_APBROM_MDABX_ROMENTRY234(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY234(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry235
 *
 * APBROM Mdab Romentry235 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry235
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry235_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry235_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry235 bdk_apbrom_mdabx_romentry235_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY235(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY235(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY235", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY235(a) bdk_apbrom_mdabx_romentry235_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY235(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY235(a) "APBROM_MDABX_ROMENTRY235"
#define busnum_BDK_APBROM_MDABX_ROMENTRY235(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY235(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry236
 *
 * APBROM Mdab Romentry236 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry236
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry236_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry236_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry236 bdk_apbrom_mdabx_romentry236_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY236(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY236(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY236", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY236(a) bdk_apbrom_mdabx_romentry236_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY236(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY236(a) "APBROM_MDABX_ROMENTRY236"
#define busnum_BDK_APBROM_MDABX_ROMENTRY236(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY236(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry237
 *
 * APBROM Mdab Romentry237 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry237
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry237_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry237_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry237 bdk_apbrom_mdabx_romentry237_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY237(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY237(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY237", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY237(a) bdk_apbrom_mdabx_romentry237_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY237(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY237(a) "APBROM_MDABX_ROMENTRY237"
#define busnum_BDK_APBROM_MDABX_ROMENTRY237(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY237(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry238
 *
 * APBROM Mdab Romentry238 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry238
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry238_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry238_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry238 bdk_apbrom_mdabx_romentry238_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY238(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY238(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY238", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY238(a) bdk_apbrom_mdabx_romentry238_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY238(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY238(a) "APBROM_MDABX_ROMENTRY238"
#define busnum_BDK_APBROM_MDABX_ROMENTRY238(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY238(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry239
 *
 * APBROM Mdab Romentry239 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry239
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry239_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry239_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry239 bdk_apbrom_mdabx_romentry239_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY239(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY239(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY239", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY239(a) bdk_apbrom_mdabx_romentry239_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY239(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY239(a) "APBROM_MDABX_ROMENTRY239"
#define busnum_BDK_APBROM_MDABX_ROMENTRY239(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY239(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry24
 *
 * APBROM Mdab Romentry24 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry24
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry24_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry24 bdk_apbrom_mdabx_romentry24_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY24(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY24(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110060 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY24", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY24(a) bdk_apbrom_mdabx_romentry24_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY24(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY24(a) "APBROM_MDABX_ROMENTRY24"
#define busnum_BDK_APBROM_MDABX_ROMENTRY24(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY24(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry240
 *
 * APBROM Mdab Romentry240 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry240
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry240_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry240_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry240 bdk_apbrom_mdabx_romentry240_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY240(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY240(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY240", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY240(a) bdk_apbrom_mdabx_romentry240_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY240(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY240(a) "APBROM_MDABX_ROMENTRY240"
#define busnum_BDK_APBROM_MDABX_ROMENTRY240(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY240(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry241
 *
 * APBROM Mdab Romentry241 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry241
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry241_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry241_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry241 bdk_apbrom_mdabx_romentry241_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY241(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY241(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY241", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY241(a) bdk_apbrom_mdabx_romentry241_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY241(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY241(a) "APBROM_MDABX_ROMENTRY241"
#define busnum_BDK_APBROM_MDABX_ROMENTRY241(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY241(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry242
 *
 * APBROM Mdab Romentry242 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry242
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry242_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry242_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry242 bdk_apbrom_mdabx_romentry242_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY242(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY242(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY242", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY242(a) bdk_apbrom_mdabx_romentry242_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY242(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY242(a) "APBROM_MDABX_ROMENTRY242"
#define busnum_BDK_APBROM_MDABX_ROMENTRY242(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY242(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry243
 *
 * APBROM Mdab Romentry243 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry243
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry243_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry243_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry243 bdk_apbrom_mdabx_romentry243_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY243(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY243(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY243", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY243(a) bdk_apbrom_mdabx_romentry243_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY243(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY243(a) "APBROM_MDABX_ROMENTRY243"
#define busnum_BDK_APBROM_MDABX_ROMENTRY243(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY243(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry244
 *
 * APBROM Mdab Romentry244 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry244
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry244_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry244_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry244 bdk_apbrom_mdabx_romentry244_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY244(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY244(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY244", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY244(a) bdk_apbrom_mdabx_romentry244_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY244(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY244(a) "APBROM_MDABX_ROMENTRY244"
#define busnum_BDK_APBROM_MDABX_ROMENTRY244(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY244(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry245
 *
 * APBROM Mdab Romentry245 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry245
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry245_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry245_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry245 bdk_apbrom_mdabx_romentry245_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY245(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY245(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY245", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY245(a) bdk_apbrom_mdabx_romentry245_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY245(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY245(a) "APBROM_MDABX_ROMENTRY245"
#define busnum_BDK_APBROM_MDABX_ROMENTRY245(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY245(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry246
 *
 * APBROM Mdab Romentry246 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry246
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry246_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry246_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry246 bdk_apbrom_mdabx_romentry246_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY246(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY246(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY246", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY246(a) bdk_apbrom_mdabx_romentry246_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY246(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY246(a) "APBROM_MDABX_ROMENTRY246"
#define busnum_BDK_APBROM_MDABX_ROMENTRY246(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY246(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry247
 *
 * APBROM Mdab Romentry247 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry247
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry247_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry247_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry247 bdk_apbrom_mdabx_romentry247_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY247(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY247(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY247", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY247(a) bdk_apbrom_mdabx_romentry247_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY247(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY247(a) "APBROM_MDABX_ROMENTRY247"
#define busnum_BDK_APBROM_MDABX_ROMENTRY247(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY247(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry248
 *
 * APBROM Mdab Romentry248 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry248
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry248_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry248_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry248 bdk_apbrom_mdabx_romentry248_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY248(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY248(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY248", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY248(a) bdk_apbrom_mdabx_romentry248_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY248(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY248(a) "APBROM_MDABX_ROMENTRY248"
#define busnum_BDK_APBROM_MDABX_ROMENTRY248(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY248(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry249
 *
 * APBROM Mdab Romentry249 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry249
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry249_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry249_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry249 bdk_apbrom_mdabx_romentry249_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY249(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY249(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY249", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY249(a) bdk_apbrom_mdabx_romentry249_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY249(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY249(a) "APBROM_MDABX_ROMENTRY249"
#define busnum_BDK_APBROM_MDABX_ROMENTRY249(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY249(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry25
 *
 * APBROM Mdab Romentry25 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry25
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry25_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry25 bdk_apbrom_mdabx_romentry25_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY25(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY25(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110064 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY25", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY25(a) bdk_apbrom_mdabx_romentry25_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY25(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY25(a) "APBROM_MDABX_ROMENTRY25"
#define busnum_BDK_APBROM_MDABX_ROMENTRY25(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY25(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry250
 *
 * APBROM Mdab Romentry250 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry250
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry250_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry250_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry250 bdk_apbrom_mdabx_romentry250_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY250(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY250(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY250", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY250(a) bdk_apbrom_mdabx_romentry250_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY250(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY250(a) "APBROM_MDABX_ROMENTRY250"
#define busnum_BDK_APBROM_MDABX_ROMENTRY250(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY250(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry251
 *
 * APBROM Mdab Romentry251 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry251
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry251_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry251_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry251 bdk_apbrom_mdabx_romentry251_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY251(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY251(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY251", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY251(a) bdk_apbrom_mdabx_romentry251_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY251(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY251(a) "APBROM_MDABX_ROMENTRY251"
#define busnum_BDK_APBROM_MDABX_ROMENTRY251(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY251(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry252
 *
 * APBROM Mdab Romentry252 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry252
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry252_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry252_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry252 bdk_apbrom_mdabx_romentry252_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY252(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY252(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY252", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY252(a) bdk_apbrom_mdabx_romentry252_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY252(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY252(a) "APBROM_MDABX_ROMENTRY252"
#define busnum_BDK_APBROM_MDABX_ROMENTRY252(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY252(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry253
 *
 * APBROM Mdab Romentry253 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry253
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry253_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry253_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry253 bdk_apbrom_mdabx_romentry253_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY253(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY253(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY253", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY253(a) bdk_apbrom_mdabx_romentry253_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY253(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY253(a) "APBROM_MDABX_ROMENTRY253"
#define busnum_BDK_APBROM_MDABX_ROMENTRY253(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY253(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry254
 *
 * APBROM Mdab Romentry254 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry254
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry254_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry254_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry254 bdk_apbrom_mdabx_romentry254_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY254(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY254(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY254", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY254(a) bdk_apbrom_mdabx_romentry254_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY254(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY254(a) "APBROM_MDABX_ROMENTRY254"
#define busnum_BDK_APBROM_MDABX_ROMENTRY254(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY254(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry255
 *
 * APBROM Mdab Romentry255 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry255
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry255_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry255_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry255 bdk_apbrom_mdabx_romentry255_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY255(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY255(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461103fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY255", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY255(a) bdk_apbrom_mdabx_romentry255_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY255(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY255(a) "APBROM_MDABX_ROMENTRY255"
#define busnum_BDK_APBROM_MDABX_ROMENTRY255(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY255(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry256
 *
 * APBROM Mdab Romentry256 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry256
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry256_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry256_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry256 bdk_apbrom_mdabx_romentry256_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY256(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY256(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110400 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY256", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY256(a) bdk_apbrom_mdabx_romentry256_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY256(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY256(a) "APBROM_MDABX_ROMENTRY256"
#define busnum_BDK_APBROM_MDABX_ROMENTRY256(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY256(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry257
 *
 * APBROM Mdab Romentry257 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry257
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry257_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry257_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry257 bdk_apbrom_mdabx_romentry257_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY257(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY257(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110404 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY257", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY257(a) bdk_apbrom_mdabx_romentry257_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY257(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY257(a) "APBROM_MDABX_ROMENTRY257"
#define busnum_BDK_APBROM_MDABX_ROMENTRY257(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY257(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry258
 *
 * APBROM Mdab Romentry258 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry258
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry258_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry258_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry258 bdk_apbrom_mdabx_romentry258_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY258(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY258(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110408 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY258", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY258(a) bdk_apbrom_mdabx_romentry258_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY258(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY258(a) "APBROM_MDABX_ROMENTRY258"
#define busnum_BDK_APBROM_MDABX_ROMENTRY258(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY258(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry259
 *
 * APBROM Mdab Romentry259 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry259
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry259_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry259_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry259 bdk_apbrom_mdabx_romentry259_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY259(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY259(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611040c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY259", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY259(a) bdk_apbrom_mdabx_romentry259_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY259(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY259(a) "APBROM_MDABX_ROMENTRY259"
#define busnum_BDK_APBROM_MDABX_ROMENTRY259(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY259(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry26
 *
 * APBROM Mdab Romentry26 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry26
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry26_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry26_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry26 bdk_apbrom_mdabx_romentry26_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY26(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY26(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110068 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY26", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY26(a) bdk_apbrom_mdabx_romentry26_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY26(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY26(a) "APBROM_MDABX_ROMENTRY26"
#define busnum_BDK_APBROM_MDABX_ROMENTRY26(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY26(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry260
 *
 * APBROM Mdab Romentry260 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry260
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry260_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry260_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry260 bdk_apbrom_mdabx_romentry260_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY260(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY260(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110410 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY260", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY260(a) bdk_apbrom_mdabx_romentry260_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY260(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY260(a) "APBROM_MDABX_ROMENTRY260"
#define busnum_BDK_APBROM_MDABX_ROMENTRY260(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY260(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry261
 *
 * APBROM Mdab Romentry261 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry261
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry261_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry261_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry261 bdk_apbrom_mdabx_romentry261_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY261(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY261(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110414 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY261", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY261(a) bdk_apbrom_mdabx_romentry261_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY261(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY261(a) "APBROM_MDABX_ROMENTRY261"
#define busnum_BDK_APBROM_MDABX_ROMENTRY261(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY261(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry262
 *
 * APBROM Mdab Romentry262 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry262
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry262_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry262_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry262 bdk_apbrom_mdabx_romentry262_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY262(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY262(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110418 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY262", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY262(a) bdk_apbrom_mdabx_romentry262_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY262(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY262(a) "APBROM_MDABX_ROMENTRY262"
#define busnum_BDK_APBROM_MDABX_ROMENTRY262(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY262(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry263
 *
 * APBROM Mdab Romentry263 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry263
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry263_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry263_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry263 bdk_apbrom_mdabx_romentry263_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY263(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY263(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611041c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY263", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY263(a) bdk_apbrom_mdabx_romentry263_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY263(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY263(a) "APBROM_MDABX_ROMENTRY263"
#define busnum_BDK_APBROM_MDABX_ROMENTRY263(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY263(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry264
 *
 * APBROM Mdab Romentry264 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry264
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry264_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry264_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry264 bdk_apbrom_mdabx_romentry264_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY264(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY264(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110420 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY264", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY264(a) bdk_apbrom_mdabx_romentry264_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY264(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY264(a) "APBROM_MDABX_ROMENTRY264"
#define busnum_BDK_APBROM_MDABX_ROMENTRY264(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY264(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry265
 *
 * APBROM Mdab Romentry265 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry265
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry265_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry265_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry265 bdk_apbrom_mdabx_romentry265_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY265(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY265(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110424 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY265", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY265(a) bdk_apbrom_mdabx_romentry265_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY265(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY265(a) "APBROM_MDABX_ROMENTRY265"
#define busnum_BDK_APBROM_MDABX_ROMENTRY265(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY265(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry266
 *
 * APBROM Mdab Romentry266 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry266
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry266_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry266_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry266 bdk_apbrom_mdabx_romentry266_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY266(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY266(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110428 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY266", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY266(a) bdk_apbrom_mdabx_romentry266_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY266(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY266(a) "APBROM_MDABX_ROMENTRY266"
#define busnum_BDK_APBROM_MDABX_ROMENTRY266(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY266(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry267
 *
 * APBROM Mdab Romentry267 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry267
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry267_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry267_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry267 bdk_apbrom_mdabx_romentry267_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY267(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY267(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611042c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY267", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY267(a) bdk_apbrom_mdabx_romentry267_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY267(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY267(a) "APBROM_MDABX_ROMENTRY267"
#define busnum_BDK_APBROM_MDABX_ROMENTRY267(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY267(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry268
 *
 * APBROM Mdab Romentry268 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry268
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry268_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry268_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry268 bdk_apbrom_mdabx_romentry268_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY268(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY268(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110430 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY268", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY268(a) bdk_apbrom_mdabx_romentry268_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY268(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY268(a) "APBROM_MDABX_ROMENTRY268"
#define busnum_BDK_APBROM_MDABX_ROMENTRY268(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY268(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry269
 *
 * APBROM Mdab Romentry269 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry269
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry269_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry269_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry269 bdk_apbrom_mdabx_romentry269_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY269(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY269(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110434 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY269", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY269(a) bdk_apbrom_mdabx_romentry269_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY269(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY269(a) "APBROM_MDABX_ROMENTRY269"
#define busnum_BDK_APBROM_MDABX_ROMENTRY269(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY269(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry27
 *
 * APBROM Mdab Romentry27 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry27
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry27_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry27_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry27 bdk_apbrom_mdabx_romentry27_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY27(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY27(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611006c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY27", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY27(a) bdk_apbrom_mdabx_romentry27_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY27(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY27(a) "APBROM_MDABX_ROMENTRY27"
#define busnum_BDK_APBROM_MDABX_ROMENTRY27(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY27(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry270
 *
 * APBROM Mdab Romentry270 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry270
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry270_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry270_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry270 bdk_apbrom_mdabx_romentry270_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY270(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY270(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110438 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY270", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY270(a) bdk_apbrom_mdabx_romentry270_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY270(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY270(a) "APBROM_MDABX_ROMENTRY270"
#define busnum_BDK_APBROM_MDABX_ROMENTRY270(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY270(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry271
 *
 * APBROM Mdab Romentry271 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry271
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry271_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry271_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry271 bdk_apbrom_mdabx_romentry271_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY271(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY271(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611043c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY271", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY271(a) bdk_apbrom_mdabx_romentry271_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY271(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY271(a) "APBROM_MDABX_ROMENTRY271"
#define busnum_BDK_APBROM_MDABX_ROMENTRY271(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY271(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry272
 *
 * APBROM Mdab Romentry272 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry272
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry272_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry272_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry272 bdk_apbrom_mdabx_romentry272_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY272(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY272(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110440 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY272", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY272(a) bdk_apbrom_mdabx_romentry272_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY272(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY272(a) "APBROM_MDABX_ROMENTRY272"
#define busnum_BDK_APBROM_MDABX_ROMENTRY272(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY272(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry273
 *
 * APBROM Mdab Romentry273 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry273
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry273_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry273_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry273 bdk_apbrom_mdabx_romentry273_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY273(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY273(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110444 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY273", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY273(a) bdk_apbrom_mdabx_romentry273_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY273(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY273(a) "APBROM_MDABX_ROMENTRY273"
#define busnum_BDK_APBROM_MDABX_ROMENTRY273(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY273(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry274
 *
 * APBROM Mdab Romentry274 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry274
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry274_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry274_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry274 bdk_apbrom_mdabx_romentry274_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY274(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY274(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110448 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY274", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY274(a) bdk_apbrom_mdabx_romentry274_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY274(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY274(a) "APBROM_MDABX_ROMENTRY274"
#define busnum_BDK_APBROM_MDABX_ROMENTRY274(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY274(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry275
 *
 * APBROM Mdab Romentry275 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry275
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry275_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry275_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry275 bdk_apbrom_mdabx_romentry275_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY275(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY275(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611044c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY275", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY275(a) bdk_apbrom_mdabx_romentry275_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY275(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY275(a) "APBROM_MDABX_ROMENTRY275"
#define busnum_BDK_APBROM_MDABX_ROMENTRY275(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY275(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry276
 *
 * APBROM Mdab Romentry276 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry276
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry276_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry276_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry276 bdk_apbrom_mdabx_romentry276_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY276(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY276(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110450 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY276", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY276(a) bdk_apbrom_mdabx_romentry276_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY276(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY276(a) "APBROM_MDABX_ROMENTRY276"
#define busnum_BDK_APBROM_MDABX_ROMENTRY276(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY276(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry277
 *
 * APBROM Mdab Romentry277 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry277
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry277_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry277_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry277 bdk_apbrom_mdabx_romentry277_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY277(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY277(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110454 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY277", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY277(a) bdk_apbrom_mdabx_romentry277_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY277(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY277(a) "APBROM_MDABX_ROMENTRY277"
#define busnum_BDK_APBROM_MDABX_ROMENTRY277(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY277(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry278
 *
 * APBROM Mdab Romentry278 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry278
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry278_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry278_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry278 bdk_apbrom_mdabx_romentry278_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY278(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY278(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110458 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY278", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY278(a) bdk_apbrom_mdabx_romentry278_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY278(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY278(a) "APBROM_MDABX_ROMENTRY278"
#define busnum_BDK_APBROM_MDABX_ROMENTRY278(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY278(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry279
 *
 * APBROM Mdab Romentry279 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry279
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry279_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry279_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry279 bdk_apbrom_mdabx_romentry279_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY279(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY279(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611045c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY279", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY279(a) bdk_apbrom_mdabx_romentry279_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY279(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY279(a) "APBROM_MDABX_ROMENTRY279"
#define busnum_BDK_APBROM_MDABX_ROMENTRY279(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY279(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry28
 *
 * APBROM Mdab Romentry28 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry28
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry28_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry28_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry28 bdk_apbrom_mdabx_romentry28_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY28(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY28(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110070 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY28", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY28(a) bdk_apbrom_mdabx_romentry28_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY28(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY28(a) "APBROM_MDABX_ROMENTRY28"
#define busnum_BDK_APBROM_MDABX_ROMENTRY28(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY28(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry280
 *
 * APBROM Mdab Romentry280 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry280
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry280_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry280_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry280 bdk_apbrom_mdabx_romentry280_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY280(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY280(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110460 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY280", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY280(a) bdk_apbrom_mdabx_romentry280_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY280(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY280(a) "APBROM_MDABX_ROMENTRY280"
#define busnum_BDK_APBROM_MDABX_ROMENTRY280(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY280(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry281
 *
 * APBROM Mdab Romentry281 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry281
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry281_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry281_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry281 bdk_apbrom_mdabx_romentry281_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY281(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY281(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110464 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY281", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY281(a) bdk_apbrom_mdabx_romentry281_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY281(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY281(a) "APBROM_MDABX_ROMENTRY281"
#define busnum_BDK_APBROM_MDABX_ROMENTRY281(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY281(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry282
 *
 * APBROM Mdab Romentry282 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry282
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry282_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry282_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry282 bdk_apbrom_mdabx_romentry282_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY282(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY282(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110468 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY282", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY282(a) bdk_apbrom_mdabx_romentry282_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY282(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY282(a) "APBROM_MDABX_ROMENTRY282"
#define busnum_BDK_APBROM_MDABX_ROMENTRY282(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY282(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry283
 *
 * APBROM Mdab Romentry283 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry283
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry283_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry283_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry283 bdk_apbrom_mdabx_romentry283_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY283(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY283(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611046c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY283", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY283(a) bdk_apbrom_mdabx_romentry283_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY283(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY283(a) "APBROM_MDABX_ROMENTRY283"
#define busnum_BDK_APBROM_MDABX_ROMENTRY283(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY283(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry284
 *
 * APBROM Mdab Romentry284 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry284
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry284_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry284_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry284 bdk_apbrom_mdabx_romentry284_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY284(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY284(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110470 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY284", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY284(a) bdk_apbrom_mdabx_romentry284_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY284(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY284(a) "APBROM_MDABX_ROMENTRY284"
#define busnum_BDK_APBROM_MDABX_ROMENTRY284(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY284(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry285
 *
 * APBROM Mdab Romentry285 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry285
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry285_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry285_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry285 bdk_apbrom_mdabx_romentry285_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY285(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY285(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110474 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY285", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY285(a) bdk_apbrom_mdabx_romentry285_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY285(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY285(a) "APBROM_MDABX_ROMENTRY285"
#define busnum_BDK_APBROM_MDABX_ROMENTRY285(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY285(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry286
 *
 * APBROM Mdab Romentry286 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry286
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry286_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry286_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry286 bdk_apbrom_mdabx_romentry286_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY286(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY286(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110478 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY286", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY286(a) bdk_apbrom_mdabx_romentry286_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY286(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY286(a) "APBROM_MDABX_ROMENTRY286"
#define busnum_BDK_APBROM_MDABX_ROMENTRY286(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY286(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry287
 *
 * APBROM Mdab Romentry287 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry287
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry287_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry287_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry287 bdk_apbrom_mdabx_romentry287_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY287(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY287(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611047c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY287", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY287(a) bdk_apbrom_mdabx_romentry287_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY287(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY287(a) "APBROM_MDABX_ROMENTRY287"
#define busnum_BDK_APBROM_MDABX_ROMENTRY287(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY287(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry288
 *
 * APBROM Mdab Romentry288 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry288
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry288_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry288_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry288 bdk_apbrom_mdabx_romentry288_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY288(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY288(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110480 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY288", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY288(a) bdk_apbrom_mdabx_romentry288_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY288(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY288(a) "APBROM_MDABX_ROMENTRY288"
#define busnum_BDK_APBROM_MDABX_ROMENTRY288(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY288(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry289
 *
 * APBROM Mdab Romentry289 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry289
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry289_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry289_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry289 bdk_apbrom_mdabx_romentry289_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY289(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY289(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110484 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY289", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY289(a) bdk_apbrom_mdabx_romentry289_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY289(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY289(a) "APBROM_MDABX_ROMENTRY289"
#define busnum_BDK_APBROM_MDABX_ROMENTRY289(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY289(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry29
 *
 * APBROM Mdab Romentry29 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry29
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry29_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry29_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry29 bdk_apbrom_mdabx_romentry29_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY29(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY29(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110074 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY29", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY29(a) bdk_apbrom_mdabx_romentry29_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY29(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY29(a) "APBROM_MDABX_ROMENTRY29"
#define busnum_BDK_APBROM_MDABX_ROMENTRY29(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY29(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry290
 *
 * APBROM Mdab Romentry290 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry290
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry290_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry290_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry290 bdk_apbrom_mdabx_romentry290_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY290(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY290(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110488 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY290", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY290(a) bdk_apbrom_mdabx_romentry290_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY290(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY290(a) "APBROM_MDABX_ROMENTRY290"
#define busnum_BDK_APBROM_MDABX_ROMENTRY290(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY290(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry291
 *
 * APBROM Mdab Romentry291 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry291
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry291_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry291_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry291 bdk_apbrom_mdabx_romentry291_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY291(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY291(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611048c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY291", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY291(a) bdk_apbrom_mdabx_romentry291_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY291(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY291(a) "APBROM_MDABX_ROMENTRY291"
#define busnum_BDK_APBROM_MDABX_ROMENTRY291(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY291(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry292
 *
 * APBROM Mdab Romentry292 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry292
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry292_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry292_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry292 bdk_apbrom_mdabx_romentry292_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY292(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY292(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110490 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY292", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY292(a) bdk_apbrom_mdabx_romentry292_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY292(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY292(a) "APBROM_MDABX_ROMENTRY292"
#define busnum_BDK_APBROM_MDABX_ROMENTRY292(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY292(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry293
 *
 * APBROM Mdab Romentry293 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry293
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry293_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry293_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry293 bdk_apbrom_mdabx_romentry293_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY293(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY293(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110494 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY293", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY293(a) bdk_apbrom_mdabx_romentry293_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY293(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY293(a) "APBROM_MDABX_ROMENTRY293"
#define busnum_BDK_APBROM_MDABX_ROMENTRY293(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY293(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry294
 *
 * APBROM Mdab Romentry294 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry294
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry294_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry294_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry294 bdk_apbrom_mdabx_romentry294_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY294(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY294(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110498 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY294", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY294(a) bdk_apbrom_mdabx_romentry294_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY294(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY294(a) "APBROM_MDABX_ROMENTRY294"
#define busnum_BDK_APBROM_MDABX_ROMENTRY294(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY294(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry295
 *
 * APBROM Mdab Romentry295 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry295
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry295_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry295_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry295 bdk_apbrom_mdabx_romentry295_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY295(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY295(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611049c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY295", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY295(a) bdk_apbrom_mdabx_romentry295_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY295(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY295(a) "APBROM_MDABX_ROMENTRY295"
#define busnum_BDK_APBROM_MDABX_ROMENTRY295(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY295(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry296
 *
 * APBROM Mdab Romentry296 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry296
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry296_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry296_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry296 bdk_apbrom_mdabx_romentry296_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY296(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY296(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY296", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY296(a) bdk_apbrom_mdabx_romentry296_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY296(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY296(a) "APBROM_MDABX_ROMENTRY296"
#define busnum_BDK_APBROM_MDABX_ROMENTRY296(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY296(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry297
 *
 * APBROM Mdab Romentry297 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry297
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry297_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry297_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry297 bdk_apbrom_mdabx_romentry297_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY297(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY297(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY297", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY297(a) bdk_apbrom_mdabx_romentry297_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY297(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY297(a) "APBROM_MDABX_ROMENTRY297"
#define busnum_BDK_APBROM_MDABX_ROMENTRY297(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY297(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry298
 *
 * APBROM Mdab Romentry298 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry298
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry298_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry298_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry298 bdk_apbrom_mdabx_romentry298_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY298(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY298(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY298", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY298(a) bdk_apbrom_mdabx_romentry298_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY298(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY298(a) "APBROM_MDABX_ROMENTRY298"
#define busnum_BDK_APBROM_MDABX_ROMENTRY298(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY298(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry299
 *
 * APBROM Mdab Romentry299 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry299
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry299_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry299_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry299 bdk_apbrom_mdabx_romentry299_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY299(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY299(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY299", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY299(a) bdk_apbrom_mdabx_romentry299_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY299(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY299(a) "APBROM_MDABX_ROMENTRY299"
#define busnum_BDK_APBROM_MDABX_ROMENTRY299(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY299(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry3
 *
 * APBROM Mdab Romentry3 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry3
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry3_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry3 bdk_apbrom_mdabx_romentry3_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611000c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY3(a) bdk_apbrom_mdabx_romentry3_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY3(a) "APBROM_MDABX_ROMENTRY3"
#define busnum_BDK_APBROM_MDABX_ROMENTRY3(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry30
 *
 * APBROM Mdab Romentry30 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry30
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry30_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry30_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry30 bdk_apbrom_mdabx_romentry30_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY30(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY30(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110078 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY30", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY30(a) bdk_apbrom_mdabx_romentry30_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY30(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY30(a) "APBROM_MDABX_ROMENTRY30"
#define busnum_BDK_APBROM_MDABX_ROMENTRY30(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY30(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry300
 *
 * APBROM Mdab Romentry300 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry300
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry300_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry300_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry300 bdk_apbrom_mdabx_romentry300_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY300(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY300(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY300", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY300(a) bdk_apbrom_mdabx_romentry300_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY300(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY300(a) "APBROM_MDABX_ROMENTRY300"
#define busnum_BDK_APBROM_MDABX_ROMENTRY300(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY300(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry301
 *
 * APBROM Mdab Romentry301 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry301
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry301_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry301_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry301 bdk_apbrom_mdabx_romentry301_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY301(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY301(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY301", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY301(a) bdk_apbrom_mdabx_romentry301_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY301(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY301(a) "APBROM_MDABX_ROMENTRY301"
#define busnum_BDK_APBROM_MDABX_ROMENTRY301(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY301(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry302
 *
 * APBROM Mdab Romentry302 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry302
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry302_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry302_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry302 bdk_apbrom_mdabx_romentry302_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY302(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY302(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY302", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY302(a) bdk_apbrom_mdabx_romentry302_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY302(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY302(a) "APBROM_MDABX_ROMENTRY302"
#define busnum_BDK_APBROM_MDABX_ROMENTRY302(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY302(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry303
 *
 * APBROM Mdab Romentry303 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry303
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry303_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry303_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry303 bdk_apbrom_mdabx_romentry303_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY303(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY303(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY303", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY303(a) bdk_apbrom_mdabx_romentry303_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY303(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY303(a) "APBROM_MDABX_ROMENTRY303"
#define busnum_BDK_APBROM_MDABX_ROMENTRY303(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY303(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry304
 *
 * APBROM Mdab Romentry304 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry304
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry304_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry304_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry304 bdk_apbrom_mdabx_romentry304_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY304(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY304(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY304", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY304(a) bdk_apbrom_mdabx_romentry304_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY304(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY304(a) "APBROM_MDABX_ROMENTRY304"
#define busnum_BDK_APBROM_MDABX_ROMENTRY304(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY304(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry305
 *
 * APBROM Mdab Romentry305 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry305
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry305_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry305_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry305 bdk_apbrom_mdabx_romentry305_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY305(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY305(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY305", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY305(a) bdk_apbrom_mdabx_romentry305_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY305(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY305(a) "APBROM_MDABX_ROMENTRY305"
#define busnum_BDK_APBROM_MDABX_ROMENTRY305(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY305(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry306
 *
 * APBROM Mdab Romentry306 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry306
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry306_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry306_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry306 bdk_apbrom_mdabx_romentry306_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY306(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY306(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY306", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY306(a) bdk_apbrom_mdabx_romentry306_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY306(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY306(a) "APBROM_MDABX_ROMENTRY306"
#define busnum_BDK_APBROM_MDABX_ROMENTRY306(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY306(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry307
 *
 * APBROM Mdab Romentry307 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry307
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry307_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry307_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry307 bdk_apbrom_mdabx_romentry307_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY307(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY307(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY307", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY307(a) bdk_apbrom_mdabx_romentry307_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY307(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY307(a) "APBROM_MDABX_ROMENTRY307"
#define busnum_BDK_APBROM_MDABX_ROMENTRY307(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY307(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry308
 *
 * APBROM Mdab Romentry308 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry308
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry308_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry308_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry308 bdk_apbrom_mdabx_romentry308_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY308(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY308(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY308", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY308(a) bdk_apbrom_mdabx_romentry308_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY308(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY308(a) "APBROM_MDABX_ROMENTRY308"
#define busnum_BDK_APBROM_MDABX_ROMENTRY308(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY308(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry309
 *
 * APBROM Mdab Romentry309 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry309
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry309_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry309_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry309 bdk_apbrom_mdabx_romentry309_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY309(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY309(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY309", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY309(a) bdk_apbrom_mdabx_romentry309_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY309(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY309(a) "APBROM_MDABX_ROMENTRY309"
#define busnum_BDK_APBROM_MDABX_ROMENTRY309(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY309(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry31
 *
 * APBROM Mdab Romentry31 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry31
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry31_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry31_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry31 bdk_apbrom_mdabx_romentry31_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY31(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY31(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611007c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY31", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY31(a) bdk_apbrom_mdabx_romentry31_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY31(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY31(a) "APBROM_MDABX_ROMENTRY31"
#define busnum_BDK_APBROM_MDABX_ROMENTRY31(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY31(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry310
 *
 * APBROM Mdab Romentry310 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry310
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry310_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry310_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry310 bdk_apbrom_mdabx_romentry310_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY310(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY310(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY310", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY310(a) bdk_apbrom_mdabx_romentry310_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY310(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY310(a) "APBROM_MDABX_ROMENTRY310"
#define busnum_BDK_APBROM_MDABX_ROMENTRY310(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY310(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry311
 *
 * APBROM Mdab Romentry311 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry311
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry311_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry311_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry311 bdk_apbrom_mdabx_romentry311_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY311(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY311(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY311", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY311(a) bdk_apbrom_mdabx_romentry311_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY311(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY311(a) "APBROM_MDABX_ROMENTRY311"
#define busnum_BDK_APBROM_MDABX_ROMENTRY311(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY311(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry312
 *
 * APBROM Mdab Romentry312 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry312
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry312_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry312_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry312 bdk_apbrom_mdabx_romentry312_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY312(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY312(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY312", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY312(a) bdk_apbrom_mdabx_romentry312_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY312(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY312(a) "APBROM_MDABX_ROMENTRY312"
#define busnum_BDK_APBROM_MDABX_ROMENTRY312(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY312(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry313
 *
 * APBROM Mdab Romentry313 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry313
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry313_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry313_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry313 bdk_apbrom_mdabx_romentry313_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY313(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY313(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY313", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY313(a) bdk_apbrom_mdabx_romentry313_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY313(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY313(a) "APBROM_MDABX_ROMENTRY313"
#define busnum_BDK_APBROM_MDABX_ROMENTRY313(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY313(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry314
 *
 * APBROM Mdab Romentry314 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry314
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry314_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry314_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry314 bdk_apbrom_mdabx_romentry314_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY314(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY314(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY314", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY314(a) bdk_apbrom_mdabx_romentry314_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY314(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY314(a) "APBROM_MDABX_ROMENTRY314"
#define busnum_BDK_APBROM_MDABX_ROMENTRY314(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY314(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry315
 *
 * APBROM Mdab Romentry315 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry315
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry315_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry315_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry315 bdk_apbrom_mdabx_romentry315_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY315(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY315(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY315", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY315(a) bdk_apbrom_mdabx_romentry315_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY315(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY315(a) "APBROM_MDABX_ROMENTRY315"
#define busnum_BDK_APBROM_MDABX_ROMENTRY315(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY315(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry316
 *
 * APBROM Mdab Romentry316 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry316
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry316_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry316_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry316 bdk_apbrom_mdabx_romentry316_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY316(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY316(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY316", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY316(a) bdk_apbrom_mdabx_romentry316_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY316(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY316(a) "APBROM_MDABX_ROMENTRY316"
#define busnum_BDK_APBROM_MDABX_ROMENTRY316(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY316(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry317
 *
 * APBROM Mdab Romentry317 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry317
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry317_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry317_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry317 bdk_apbrom_mdabx_romentry317_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY317(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY317(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY317", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY317(a) bdk_apbrom_mdabx_romentry317_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY317(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY317(a) "APBROM_MDABX_ROMENTRY317"
#define busnum_BDK_APBROM_MDABX_ROMENTRY317(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY317(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry318
 *
 * APBROM Mdab Romentry318 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry318
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry318_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry318_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry318 bdk_apbrom_mdabx_romentry318_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY318(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY318(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY318", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY318(a) bdk_apbrom_mdabx_romentry318_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY318(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY318(a) "APBROM_MDABX_ROMENTRY318"
#define busnum_BDK_APBROM_MDABX_ROMENTRY318(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY318(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry319
 *
 * APBROM Mdab Romentry319 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry319
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry319_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry319_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry319 bdk_apbrom_mdabx_romentry319_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY319(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY319(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461104fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY319", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY319(a) bdk_apbrom_mdabx_romentry319_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY319(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY319(a) "APBROM_MDABX_ROMENTRY319"
#define busnum_BDK_APBROM_MDABX_ROMENTRY319(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY319(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry32
 *
 * APBROM Mdab Romentry32 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry32
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry32_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry32 bdk_apbrom_mdabx_romentry32_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY32(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY32(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110080 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY32", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY32(a) bdk_apbrom_mdabx_romentry32_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY32(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY32(a) "APBROM_MDABX_ROMENTRY32"
#define busnum_BDK_APBROM_MDABX_ROMENTRY32(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY32(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry320
 *
 * APBROM Mdab Romentry320 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry320
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry320_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry320_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry320 bdk_apbrom_mdabx_romentry320_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY320(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY320(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110500 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY320", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY320(a) bdk_apbrom_mdabx_romentry320_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY320(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY320(a) "APBROM_MDABX_ROMENTRY320"
#define busnum_BDK_APBROM_MDABX_ROMENTRY320(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY320(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry321
 *
 * APBROM Mdab Romentry321 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry321
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry321_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry321_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry321 bdk_apbrom_mdabx_romentry321_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY321(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY321(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110504 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY321", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY321(a) bdk_apbrom_mdabx_romentry321_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY321(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY321(a) "APBROM_MDABX_ROMENTRY321"
#define busnum_BDK_APBROM_MDABX_ROMENTRY321(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY321(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry322
 *
 * APBROM Mdab Romentry322 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry322
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry322_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry322_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry322 bdk_apbrom_mdabx_romentry322_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY322(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY322(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110508 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY322", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY322(a) bdk_apbrom_mdabx_romentry322_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY322(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY322(a) "APBROM_MDABX_ROMENTRY322"
#define busnum_BDK_APBROM_MDABX_ROMENTRY322(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY322(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry323
 *
 * APBROM Mdab Romentry323 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry323
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry323_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry323_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry323 bdk_apbrom_mdabx_romentry323_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY323(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY323(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611050c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY323", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY323(a) bdk_apbrom_mdabx_romentry323_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY323(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY323(a) "APBROM_MDABX_ROMENTRY323"
#define busnum_BDK_APBROM_MDABX_ROMENTRY323(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY323(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry324
 *
 * APBROM Mdab Romentry324 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry324
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry324_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry324_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry324 bdk_apbrom_mdabx_romentry324_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY324(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY324(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110510 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY324", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY324(a) bdk_apbrom_mdabx_romentry324_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY324(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY324(a) "APBROM_MDABX_ROMENTRY324"
#define busnum_BDK_APBROM_MDABX_ROMENTRY324(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY324(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry325
 *
 * APBROM Mdab Romentry325 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry325
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry325_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry325_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry325 bdk_apbrom_mdabx_romentry325_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY325(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY325(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110514 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY325", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY325(a) bdk_apbrom_mdabx_romentry325_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY325(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY325(a) "APBROM_MDABX_ROMENTRY325"
#define busnum_BDK_APBROM_MDABX_ROMENTRY325(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY325(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry326
 *
 * APBROM Mdab Romentry326 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry326
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry326_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry326_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry326 bdk_apbrom_mdabx_romentry326_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY326(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY326(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110518 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY326", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY326(a) bdk_apbrom_mdabx_romentry326_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY326(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY326(a) "APBROM_MDABX_ROMENTRY326"
#define busnum_BDK_APBROM_MDABX_ROMENTRY326(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY326(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry327
 *
 * APBROM Mdab Romentry327 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry327
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry327_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry327_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry327 bdk_apbrom_mdabx_romentry327_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY327(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY327(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611051c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY327", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY327(a) bdk_apbrom_mdabx_romentry327_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY327(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY327(a) "APBROM_MDABX_ROMENTRY327"
#define busnum_BDK_APBROM_MDABX_ROMENTRY327(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY327(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry328
 *
 * APBROM Mdab Romentry328 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry328
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry328_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry328_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry328 bdk_apbrom_mdabx_romentry328_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY328(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY328(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110520 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY328", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY328(a) bdk_apbrom_mdabx_romentry328_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY328(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY328(a) "APBROM_MDABX_ROMENTRY328"
#define busnum_BDK_APBROM_MDABX_ROMENTRY328(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY328(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry329
 *
 * APBROM Mdab Romentry329 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry329
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry329_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry329_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry329 bdk_apbrom_mdabx_romentry329_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY329(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY329(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110524 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY329", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY329(a) bdk_apbrom_mdabx_romentry329_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY329(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY329(a) "APBROM_MDABX_ROMENTRY329"
#define busnum_BDK_APBROM_MDABX_ROMENTRY329(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY329(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry33
 *
 * APBROM Mdab Romentry33 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry33
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry33_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry33_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry33 bdk_apbrom_mdabx_romentry33_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY33(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY33(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110084 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY33", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY33(a) bdk_apbrom_mdabx_romentry33_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY33(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY33(a) "APBROM_MDABX_ROMENTRY33"
#define busnum_BDK_APBROM_MDABX_ROMENTRY33(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY33(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry330
 *
 * APBROM Mdab Romentry330 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry330
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry330_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry330_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry330 bdk_apbrom_mdabx_romentry330_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY330(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY330(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110528 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY330", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY330(a) bdk_apbrom_mdabx_romentry330_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY330(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY330(a) "APBROM_MDABX_ROMENTRY330"
#define busnum_BDK_APBROM_MDABX_ROMENTRY330(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY330(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry331
 *
 * APBROM Mdab Romentry331 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry331
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry331_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry331_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry331 bdk_apbrom_mdabx_romentry331_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY331(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY331(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611052c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY331", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY331(a) bdk_apbrom_mdabx_romentry331_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY331(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY331(a) "APBROM_MDABX_ROMENTRY331"
#define busnum_BDK_APBROM_MDABX_ROMENTRY331(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY331(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry332
 *
 * APBROM Mdab Romentry332 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry332
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry332_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry332_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry332 bdk_apbrom_mdabx_romentry332_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY332(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY332(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110530 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY332", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY332(a) bdk_apbrom_mdabx_romentry332_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY332(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY332(a) "APBROM_MDABX_ROMENTRY332"
#define busnum_BDK_APBROM_MDABX_ROMENTRY332(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY332(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry333
 *
 * APBROM Mdab Romentry333 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry333
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry333_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry333_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry333 bdk_apbrom_mdabx_romentry333_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY333(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY333(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110534 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY333", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY333(a) bdk_apbrom_mdabx_romentry333_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY333(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY333(a) "APBROM_MDABX_ROMENTRY333"
#define busnum_BDK_APBROM_MDABX_ROMENTRY333(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY333(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry334
 *
 * APBROM Mdab Romentry334 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry334
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry334_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry334_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry334 bdk_apbrom_mdabx_romentry334_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY334(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY334(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110538 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY334", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY334(a) bdk_apbrom_mdabx_romentry334_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY334(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY334(a) "APBROM_MDABX_ROMENTRY334"
#define busnum_BDK_APBROM_MDABX_ROMENTRY334(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY334(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry335
 *
 * APBROM Mdab Romentry335 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry335
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry335_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry335_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry335 bdk_apbrom_mdabx_romentry335_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY335(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY335(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611053c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY335", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY335(a) bdk_apbrom_mdabx_romentry335_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY335(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY335(a) "APBROM_MDABX_ROMENTRY335"
#define busnum_BDK_APBROM_MDABX_ROMENTRY335(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY335(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry336
 *
 * APBROM Mdab Romentry336 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry336
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry336_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry336_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry336 bdk_apbrom_mdabx_romentry336_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY336(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY336(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110540 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY336", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY336(a) bdk_apbrom_mdabx_romentry336_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY336(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY336(a) "APBROM_MDABX_ROMENTRY336"
#define busnum_BDK_APBROM_MDABX_ROMENTRY336(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY336(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry337
 *
 * APBROM Mdab Romentry337 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry337
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry337_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry337_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry337 bdk_apbrom_mdabx_romentry337_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY337(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY337(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110544 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY337", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY337(a) bdk_apbrom_mdabx_romentry337_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY337(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY337(a) "APBROM_MDABX_ROMENTRY337"
#define busnum_BDK_APBROM_MDABX_ROMENTRY337(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY337(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry338
 *
 * APBROM Mdab Romentry338 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry338
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry338_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry338_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry338 bdk_apbrom_mdabx_romentry338_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY338(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY338(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110548 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY338", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY338(a) bdk_apbrom_mdabx_romentry338_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY338(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY338(a) "APBROM_MDABX_ROMENTRY338"
#define busnum_BDK_APBROM_MDABX_ROMENTRY338(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY338(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry339
 *
 * APBROM Mdab Romentry339 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry339
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry339_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry339_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry339 bdk_apbrom_mdabx_romentry339_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY339(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY339(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611054c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY339", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY339(a) bdk_apbrom_mdabx_romentry339_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY339(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY339(a) "APBROM_MDABX_ROMENTRY339"
#define busnum_BDK_APBROM_MDABX_ROMENTRY339(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY339(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry34
 *
 * APBROM Mdab Romentry34 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry34
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry34_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry34_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry34 bdk_apbrom_mdabx_romentry34_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY34(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY34(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110088 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY34", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY34(a) bdk_apbrom_mdabx_romentry34_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY34(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY34(a) "APBROM_MDABX_ROMENTRY34"
#define busnum_BDK_APBROM_MDABX_ROMENTRY34(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY34(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry340
 *
 * APBROM Mdab Romentry340 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry340
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry340_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry340_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry340 bdk_apbrom_mdabx_romentry340_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY340(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY340(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110550 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY340", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY340(a) bdk_apbrom_mdabx_romentry340_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY340(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY340(a) "APBROM_MDABX_ROMENTRY340"
#define busnum_BDK_APBROM_MDABX_ROMENTRY340(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY340(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry341
 *
 * APBROM Mdab Romentry341 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry341
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry341_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry341_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry341 bdk_apbrom_mdabx_romentry341_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY341(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY341(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110554 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY341", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY341(a) bdk_apbrom_mdabx_romentry341_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY341(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY341(a) "APBROM_MDABX_ROMENTRY341"
#define busnum_BDK_APBROM_MDABX_ROMENTRY341(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY341(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry342
 *
 * APBROM Mdab Romentry342 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry342
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry342_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry342_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry342 bdk_apbrom_mdabx_romentry342_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY342(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY342(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110558 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY342", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY342(a) bdk_apbrom_mdabx_romentry342_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY342(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY342(a) "APBROM_MDABX_ROMENTRY342"
#define busnum_BDK_APBROM_MDABX_ROMENTRY342(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY342(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry343
 *
 * APBROM Mdab Romentry343 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry343
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry343_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry343_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry343 bdk_apbrom_mdabx_romentry343_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY343(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY343(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611055c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY343", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY343(a) bdk_apbrom_mdabx_romentry343_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY343(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY343(a) "APBROM_MDABX_ROMENTRY343"
#define busnum_BDK_APBROM_MDABX_ROMENTRY343(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY343(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry344
 *
 * APBROM Mdab Romentry344 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry344
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry344_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry344_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry344 bdk_apbrom_mdabx_romentry344_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY344(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY344(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110560 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY344", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY344(a) bdk_apbrom_mdabx_romentry344_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY344(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY344(a) "APBROM_MDABX_ROMENTRY344"
#define busnum_BDK_APBROM_MDABX_ROMENTRY344(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY344(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry345
 *
 * APBROM Mdab Romentry345 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry345
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry345_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry345_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry345 bdk_apbrom_mdabx_romentry345_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY345(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY345(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110564 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY345", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY345(a) bdk_apbrom_mdabx_romentry345_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY345(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY345(a) "APBROM_MDABX_ROMENTRY345"
#define busnum_BDK_APBROM_MDABX_ROMENTRY345(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY345(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry346
 *
 * APBROM Mdab Romentry346 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry346
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry346_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry346_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry346 bdk_apbrom_mdabx_romentry346_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY346(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY346(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110568 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY346", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY346(a) bdk_apbrom_mdabx_romentry346_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY346(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY346(a) "APBROM_MDABX_ROMENTRY346"
#define busnum_BDK_APBROM_MDABX_ROMENTRY346(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY346(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry347
 *
 * APBROM Mdab Romentry347 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry347
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry347_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry347_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry347 bdk_apbrom_mdabx_romentry347_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY347(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY347(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611056c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY347", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY347(a) bdk_apbrom_mdabx_romentry347_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY347(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY347(a) "APBROM_MDABX_ROMENTRY347"
#define busnum_BDK_APBROM_MDABX_ROMENTRY347(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY347(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry348
 *
 * APBROM Mdab Romentry348 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry348
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry348_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry348_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry348 bdk_apbrom_mdabx_romentry348_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY348(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY348(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110570 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY348", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY348(a) bdk_apbrom_mdabx_romentry348_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY348(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY348(a) "APBROM_MDABX_ROMENTRY348"
#define busnum_BDK_APBROM_MDABX_ROMENTRY348(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY348(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry349
 *
 * APBROM Mdab Romentry349 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry349
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry349_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry349_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry349 bdk_apbrom_mdabx_romentry349_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY349(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY349(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110574 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY349", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY349(a) bdk_apbrom_mdabx_romentry349_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY349(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY349(a) "APBROM_MDABX_ROMENTRY349"
#define busnum_BDK_APBROM_MDABX_ROMENTRY349(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY349(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry35
 *
 * APBROM Mdab Romentry35 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry35
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry35_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry35_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry35 bdk_apbrom_mdabx_romentry35_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY35(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY35(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611008c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY35", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY35(a) bdk_apbrom_mdabx_romentry35_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY35(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY35(a) "APBROM_MDABX_ROMENTRY35"
#define busnum_BDK_APBROM_MDABX_ROMENTRY35(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY35(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry350
 *
 * APBROM Mdab Romentry350 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry350
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry350_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry350_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry350 bdk_apbrom_mdabx_romentry350_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY350(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY350(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110578 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY350", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY350(a) bdk_apbrom_mdabx_romentry350_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY350(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY350(a) "APBROM_MDABX_ROMENTRY350"
#define busnum_BDK_APBROM_MDABX_ROMENTRY350(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY350(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry351
 *
 * APBROM Mdab Romentry351 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry351
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry351_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry351_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry351 bdk_apbrom_mdabx_romentry351_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY351(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY351(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611057c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY351", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY351(a) bdk_apbrom_mdabx_romentry351_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY351(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY351(a) "APBROM_MDABX_ROMENTRY351"
#define busnum_BDK_APBROM_MDABX_ROMENTRY351(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY351(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry352
 *
 * APBROM Mdab Romentry352 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry352
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry352_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry352_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry352 bdk_apbrom_mdabx_romentry352_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY352(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY352(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110580 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY352", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY352(a) bdk_apbrom_mdabx_romentry352_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY352(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY352(a) "APBROM_MDABX_ROMENTRY352"
#define busnum_BDK_APBROM_MDABX_ROMENTRY352(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY352(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry353
 *
 * APBROM Mdab Romentry353 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry353
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry353_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry353_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry353 bdk_apbrom_mdabx_romentry353_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY353(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY353(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110584 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY353", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY353(a) bdk_apbrom_mdabx_romentry353_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY353(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY353(a) "APBROM_MDABX_ROMENTRY353"
#define busnum_BDK_APBROM_MDABX_ROMENTRY353(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY353(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry354
 *
 * APBROM Mdab Romentry354 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry354
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry354_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry354_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry354 bdk_apbrom_mdabx_romentry354_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY354(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY354(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110588 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY354", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY354(a) bdk_apbrom_mdabx_romentry354_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY354(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY354(a) "APBROM_MDABX_ROMENTRY354"
#define busnum_BDK_APBROM_MDABX_ROMENTRY354(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY354(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry355
 *
 * APBROM Mdab Romentry355 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry355
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry355_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry355_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry355 bdk_apbrom_mdabx_romentry355_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY355(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY355(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611058c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY355", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY355(a) bdk_apbrom_mdabx_romentry355_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY355(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY355(a) "APBROM_MDABX_ROMENTRY355"
#define busnum_BDK_APBROM_MDABX_ROMENTRY355(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY355(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry356
 *
 * APBROM Mdab Romentry356 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry356
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry356_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry356_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry356 bdk_apbrom_mdabx_romentry356_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY356(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY356(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110590 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY356", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY356(a) bdk_apbrom_mdabx_romentry356_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY356(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY356(a) "APBROM_MDABX_ROMENTRY356"
#define busnum_BDK_APBROM_MDABX_ROMENTRY356(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY356(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry357
 *
 * APBROM Mdab Romentry357 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry357
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry357_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry357_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry357 bdk_apbrom_mdabx_romentry357_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY357(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY357(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110594 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY357", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY357(a) bdk_apbrom_mdabx_romentry357_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY357(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY357(a) "APBROM_MDABX_ROMENTRY357"
#define busnum_BDK_APBROM_MDABX_ROMENTRY357(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY357(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry358
 *
 * APBROM Mdab Romentry358 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry358
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry358_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry358_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry358 bdk_apbrom_mdabx_romentry358_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY358(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY358(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110598 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY358", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY358(a) bdk_apbrom_mdabx_romentry358_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY358(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY358(a) "APBROM_MDABX_ROMENTRY358"
#define busnum_BDK_APBROM_MDABX_ROMENTRY358(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY358(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry359
 *
 * APBROM Mdab Romentry359 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry359
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry359_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry359_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry359 bdk_apbrom_mdabx_romentry359_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY359(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY359(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611059c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY359", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY359(a) bdk_apbrom_mdabx_romentry359_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY359(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY359(a) "APBROM_MDABX_ROMENTRY359"
#define busnum_BDK_APBROM_MDABX_ROMENTRY359(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY359(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry36
 *
 * APBROM Mdab Romentry36 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry36
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry36_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry36_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry36 bdk_apbrom_mdabx_romentry36_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY36(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY36(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110090 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY36", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY36(a) bdk_apbrom_mdabx_romentry36_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY36(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY36(a) "APBROM_MDABX_ROMENTRY36"
#define busnum_BDK_APBROM_MDABX_ROMENTRY36(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY36(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry360
 *
 * APBROM Mdab Romentry360 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry360
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry360_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry360_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry360 bdk_apbrom_mdabx_romentry360_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY360(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY360(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY360", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY360(a) bdk_apbrom_mdabx_romentry360_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY360(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY360(a) "APBROM_MDABX_ROMENTRY360"
#define busnum_BDK_APBROM_MDABX_ROMENTRY360(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY360(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry361
 *
 * APBROM Mdab Romentry361 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry361
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry361_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry361_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry361 bdk_apbrom_mdabx_romentry361_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY361(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY361(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY361", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY361(a) bdk_apbrom_mdabx_romentry361_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY361(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY361(a) "APBROM_MDABX_ROMENTRY361"
#define busnum_BDK_APBROM_MDABX_ROMENTRY361(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY361(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry362
 *
 * APBROM Mdab Romentry362 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry362
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry362_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry362_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry362 bdk_apbrom_mdabx_romentry362_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY362(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY362(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY362", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY362(a) bdk_apbrom_mdabx_romentry362_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY362(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY362(a) "APBROM_MDABX_ROMENTRY362"
#define busnum_BDK_APBROM_MDABX_ROMENTRY362(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY362(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry363
 *
 * APBROM Mdab Romentry363 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry363
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry363_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry363_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry363 bdk_apbrom_mdabx_romentry363_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY363(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY363(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY363", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY363(a) bdk_apbrom_mdabx_romentry363_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY363(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY363(a) "APBROM_MDABX_ROMENTRY363"
#define busnum_BDK_APBROM_MDABX_ROMENTRY363(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY363(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry364
 *
 * APBROM Mdab Romentry364 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry364
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry364_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry364_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry364 bdk_apbrom_mdabx_romentry364_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY364(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY364(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY364", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY364(a) bdk_apbrom_mdabx_romentry364_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY364(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY364(a) "APBROM_MDABX_ROMENTRY364"
#define busnum_BDK_APBROM_MDABX_ROMENTRY364(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY364(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry365
 *
 * APBROM Mdab Romentry365 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry365
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry365_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry365_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry365 bdk_apbrom_mdabx_romentry365_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY365(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY365(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY365", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY365(a) bdk_apbrom_mdabx_romentry365_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY365(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY365(a) "APBROM_MDABX_ROMENTRY365"
#define busnum_BDK_APBROM_MDABX_ROMENTRY365(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY365(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry366
 *
 * APBROM Mdab Romentry366 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry366
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry366_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry366_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry366 bdk_apbrom_mdabx_romentry366_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY366(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY366(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY366", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY366(a) bdk_apbrom_mdabx_romentry366_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY366(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY366(a) "APBROM_MDABX_ROMENTRY366"
#define busnum_BDK_APBROM_MDABX_ROMENTRY366(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY366(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry367
 *
 * APBROM Mdab Romentry367 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry367
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry367_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry367_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry367 bdk_apbrom_mdabx_romentry367_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY367(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY367(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY367", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY367(a) bdk_apbrom_mdabx_romentry367_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY367(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY367(a) "APBROM_MDABX_ROMENTRY367"
#define busnum_BDK_APBROM_MDABX_ROMENTRY367(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY367(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry368
 *
 * APBROM Mdab Romentry368 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry368
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry368_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry368_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry368 bdk_apbrom_mdabx_romentry368_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY368(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY368(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY368", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY368(a) bdk_apbrom_mdabx_romentry368_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY368(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY368(a) "APBROM_MDABX_ROMENTRY368"
#define busnum_BDK_APBROM_MDABX_ROMENTRY368(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY368(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry369
 *
 * APBROM Mdab Romentry369 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry369
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry369_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry369_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry369 bdk_apbrom_mdabx_romentry369_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY369(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY369(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY369", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY369(a) bdk_apbrom_mdabx_romentry369_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY369(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY369(a) "APBROM_MDABX_ROMENTRY369"
#define busnum_BDK_APBROM_MDABX_ROMENTRY369(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY369(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry37
 *
 * APBROM Mdab Romentry37 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry37
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry37_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry37_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry37 bdk_apbrom_mdabx_romentry37_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY37(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY37(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110094 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY37", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY37(a) bdk_apbrom_mdabx_romentry37_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY37(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY37(a) "APBROM_MDABX_ROMENTRY37"
#define busnum_BDK_APBROM_MDABX_ROMENTRY37(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY37(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry370
 *
 * APBROM Mdab Romentry370 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry370
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry370_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry370_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry370 bdk_apbrom_mdabx_romentry370_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY370(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY370(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY370", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY370(a) bdk_apbrom_mdabx_romentry370_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY370(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY370(a) "APBROM_MDABX_ROMENTRY370"
#define busnum_BDK_APBROM_MDABX_ROMENTRY370(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY370(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry371
 *
 * APBROM Mdab Romentry371 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry371
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry371_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry371_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry371 bdk_apbrom_mdabx_romentry371_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY371(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY371(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY371", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY371(a) bdk_apbrom_mdabx_romentry371_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY371(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY371(a) "APBROM_MDABX_ROMENTRY371"
#define busnum_BDK_APBROM_MDABX_ROMENTRY371(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY371(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry372
 *
 * APBROM Mdab Romentry372 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry372
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry372_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry372_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry372 bdk_apbrom_mdabx_romentry372_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY372(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY372(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY372", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY372(a) bdk_apbrom_mdabx_romentry372_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY372(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY372(a) "APBROM_MDABX_ROMENTRY372"
#define busnum_BDK_APBROM_MDABX_ROMENTRY372(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY372(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry373
 *
 * APBROM Mdab Romentry373 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry373
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry373_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry373_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry373 bdk_apbrom_mdabx_romentry373_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY373(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY373(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY373", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY373(a) bdk_apbrom_mdabx_romentry373_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY373(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY373(a) "APBROM_MDABX_ROMENTRY373"
#define busnum_BDK_APBROM_MDABX_ROMENTRY373(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY373(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry374
 *
 * APBROM Mdab Romentry374 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry374
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry374_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry374_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry374 bdk_apbrom_mdabx_romentry374_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY374(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY374(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY374", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY374(a) bdk_apbrom_mdabx_romentry374_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY374(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY374(a) "APBROM_MDABX_ROMENTRY374"
#define busnum_BDK_APBROM_MDABX_ROMENTRY374(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY374(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry375
 *
 * APBROM Mdab Romentry375 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry375
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry375_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry375_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry375 bdk_apbrom_mdabx_romentry375_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY375(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY375(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY375", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY375(a) bdk_apbrom_mdabx_romentry375_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY375(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY375(a) "APBROM_MDABX_ROMENTRY375"
#define busnum_BDK_APBROM_MDABX_ROMENTRY375(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY375(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry376
 *
 * APBROM Mdab Romentry376 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry376
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry376_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry376_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry376 bdk_apbrom_mdabx_romentry376_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY376(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY376(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY376", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY376(a) bdk_apbrom_mdabx_romentry376_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY376(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY376(a) "APBROM_MDABX_ROMENTRY376"
#define busnum_BDK_APBROM_MDABX_ROMENTRY376(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY376(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry377
 *
 * APBROM Mdab Romentry377 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry377
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry377_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry377_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry377 bdk_apbrom_mdabx_romentry377_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY377(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY377(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY377", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY377(a) bdk_apbrom_mdabx_romentry377_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY377(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY377(a) "APBROM_MDABX_ROMENTRY377"
#define busnum_BDK_APBROM_MDABX_ROMENTRY377(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY377(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry378
 *
 * APBROM Mdab Romentry378 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry378
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry378_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry378_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry378 bdk_apbrom_mdabx_romentry378_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY378(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY378(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY378", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY378(a) bdk_apbrom_mdabx_romentry378_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY378(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY378(a) "APBROM_MDABX_ROMENTRY378"
#define busnum_BDK_APBROM_MDABX_ROMENTRY378(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY378(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry379
 *
 * APBROM Mdab Romentry379 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry379
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry379_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry379_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry379 bdk_apbrom_mdabx_romentry379_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY379(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY379(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY379", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY379(a) bdk_apbrom_mdabx_romentry379_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY379(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY379(a) "APBROM_MDABX_ROMENTRY379"
#define busnum_BDK_APBROM_MDABX_ROMENTRY379(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY379(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry38
 *
 * APBROM Mdab Romentry38 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry38
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry38_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry38_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry38 bdk_apbrom_mdabx_romentry38_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY38(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY38(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110098 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY38", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY38(a) bdk_apbrom_mdabx_romentry38_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY38(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY38(a) "APBROM_MDABX_ROMENTRY38"
#define busnum_BDK_APBROM_MDABX_ROMENTRY38(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY38(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry380
 *
 * APBROM Mdab Romentry380 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry380
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry380_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry380_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry380 bdk_apbrom_mdabx_romentry380_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY380(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY380(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY380", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY380(a) bdk_apbrom_mdabx_romentry380_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY380(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY380(a) "APBROM_MDABX_ROMENTRY380"
#define busnum_BDK_APBROM_MDABX_ROMENTRY380(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY380(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry381
 *
 * APBROM Mdab Romentry381 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry381
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry381_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry381_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry381 bdk_apbrom_mdabx_romentry381_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY381(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY381(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY381", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY381(a) bdk_apbrom_mdabx_romentry381_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY381(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY381(a) "APBROM_MDABX_ROMENTRY381"
#define busnum_BDK_APBROM_MDABX_ROMENTRY381(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY381(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry382
 *
 * APBROM Mdab Romentry382 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry382
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry382_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry382_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry382 bdk_apbrom_mdabx_romentry382_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY382(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY382(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY382", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY382(a) bdk_apbrom_mdabx_romentry382_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY382(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY382(a) "APBROM_MDABX_ROMENTRY382"
#define busnum_BDK_APBROM_MDABX_ROMENTRY382(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY382(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry383
 *
 * APBROM Mdab Romentry383 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry383
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry383_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry383_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry383 bdk_apbrom_mdabx_romentry383_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY383(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY383(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461105fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY383", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY383(a) bdk_apbrom_mdabx_romentry383_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY383(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY383(a) "APBROM_MDABX_ROMENTRY383"
#define busnum_BDK_APBROM_MDABX_ROMENTRY383(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY383(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry384
 *
 * APBROM Mdab Romentry384 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry384
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry384_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry384_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry384 bdk_apbrom_mdabx_romentry384_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY384(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY384(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110600 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY384", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY384(a) bdk_apbrom_mdabx_romentry384_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY384(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY384(a) "APBROM_MDABX_ROMENTRY384"
#define busnum_BDK_APBROM_MDABX_ROMENTRY384(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY384(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry385
 *
 * APBROM Mdab Romentry385 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry385
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry385_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry385_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry385 bdk_apbrom_mdabx_romentry385_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY385(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY385(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110604 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY385", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY385(a) bdk_apbrom_mdabx_romentry385_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY385(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY385(a) "APBROM_MDABX_ROMENTRY385"
#define busnum_BDK_APBROM_MDABX_ROMENTRY385(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY385(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry386
 *
 * APBROM Mdab Romentry386 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry386
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry386_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry386_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry386 bdk_apbrom_mdabx_romentry386_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY386(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY386(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110608 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY386", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY386(a) bdk_apbrom_mdabx_romentry386_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY386(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY386(a) "APBROM_MDABX_ROMENTRY386"
#define busnum_BDK_APBROM_MDABX_ROMENTRY386(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY386(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry387
 *
 * APBROM Mdab Romentry387 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry387
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry387_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry387_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry387 bdk_apbrom_mdabx_romentry387_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY387(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY387(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611060c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY387", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY387(a) bdk_apbrom_mdabx_romentry387_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY387(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY387(a) "APBROM_MDABX_ROMENTRY387"
#define busnum_BDK_APBROM_MDABX_ROMENTRY387(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY387(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry388
 *
 * APBROM Mdab Romentry388 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry388
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry388_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry388_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry388 bdk_apbrom_mdabx_romentry388_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY388(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY388(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110610 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY388", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY388(a) bdk_apbrom_mdabx_romentry388_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY388(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY388(a) "APBROM_MDABX_ROMENTRY388"
#define busnum_BDK_APBROM_MDABX_ROMENTRY388(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY388(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry389
 *
 * APBROM Mdab Romentry389 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry389
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry389_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry389_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry389 bdk_apbrom_mdabx_romentry389_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY389(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY389(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110614 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY389", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY389(a) bdk_apbrom_mdabx_romentry389_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY389(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY389(a) "APBROM_MDABX_ROMENTRY389"
#define busnum_BDK_APBROM_MDABX_ROMENTRY389(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY389(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry39
 *
 * APBROM Mdab Romentry39 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry39
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry39_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry39_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry39 bdk_apbrom_mdabx_romentry39_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY39(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY39(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611009c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY39", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY39(a) bdk_apbrom_mdabx_romentry39_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY39(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY39(a) "APBROM_MDABX_ROMENTRY39"
#define busnum_BDK_APBROM_MDABX_ROMENTRY39(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY39(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry390
 *
 * APBROM Mdab Romentry390 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry390
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry390_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry390_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry390 bdk_apbrom_mdabx_romentry390_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY390(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY390(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110618 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY390", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY390(a) bdk_apbrom_mdabx_romentry390_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY390(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY390(a) "APBROM_MDABX_ROMENTRY390"
#define busnum_BDK_APBROM_MDABX_ROMENTRY390(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY390(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry391
 *
 * APBROM Mdab Romentry391 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry391
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry391_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry391_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry391 bdk_apbrom_mdabx_romentry391_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY391(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY391(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611061c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY391", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY391(a) bdk_apbrom_mdabx_romentry391_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY391(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY391(a) "APBROM_MDABX_ROMENTRY391"
#define busnum_BDK_APBROM_MDABX_ROMENTRY391(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY391(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry392
 *
 * APBROM Mdab Romentry392 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry392
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry392_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry392_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry392 bdk_apbrom_mdabx_romentry392_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY392(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY392(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110620 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY392", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY392(a) bdk_apbrom_mdabx_romentry392_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY392(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY392(a) "APBROM_MDABX_ROMENTRY392"
#define busnum_BDK_APBROM_MDABX_ROMENTRY392(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY392(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry393
 *
 * APBROM Mdab Romentry393 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry393
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry393_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry393_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry393 bdk_apbrom_mdabx_romentry393_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY393(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY393(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110624 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY393", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY393(a) bdk_apbrom_mdabx_romentry393_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY393(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY393(a) "APBROM_MDABX_ROMENTRY393"
#define busnum_BDK_APBROM_MDABX_ROMENTRY393(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY393(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry394
 *
 * APBROM Mdab Romentry394 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry394
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry394_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry394_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry394 bdk_apbrom_mdabx_romentry394_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY394(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY394(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110628 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY394", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY394(a) bdk_apbrom_mdabx_romentry394_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY394(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY394(a) "APBROM_MDABX_ROMENTRY394"
#define busnum_BDK_APBROM_MDABX_ROMENTRY394(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY394(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry395
 *
 * APBROM Mdab Romentry395 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry395
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry395_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry395_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry395 bdk_apbrom_mdabx_romentry395_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY395(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY395(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611062c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY395", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY395(a) bdk_apbrom_mdabx_romentry395_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY395(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY395(a) "APBROM_MDABX_ROMENTRY395"
#define busnum_BDK_APBROM_MDABX_ROMENTRY395(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY395(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry396
 *
 * APBROM Mdab Romentry396 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry396
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry396_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry396_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry396 bdk_apbrom_mdabx_romentry396_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY396(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY396(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110630 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY396", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY396(a) bdk_apbrom_mdabx_romentry396_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY396(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY396(a) "APBROM_MDABX_ROMENTRY396"
#define busnum_BDK_APBROM_MDABX_ROMENTRY396(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY396(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry397
 *
 * APBROM Mdab Romentry397 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry397
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry397_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry397_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry397 bdk_apbrom_mdabx_romentry397_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY397(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY397(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110634 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY397", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY397(a) bdk_apbrom_mdabx_romentry397_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY397(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY397(a) "APBROM_MDABX_ROMENTRY397"
#define busnum_BDK_APBROM_MDABX_ROMENTRY397(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY397(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry398
 *
 * APBROM Mdab Romentry398 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry398
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry398_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry398_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry398 bdk_apbrom_mdabx_romentry398_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY398(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY398(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110638 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY398", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY398(a) bdk_apbrom_mdabx_romentry398_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY398(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY398(a) "APBROM_MDABX_ROMENTRY398"
#define busnum_BDK_APBROM_MDABX_ROMENTRY398(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY398(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry399
 *
 * APBROM Mdab Romentry399 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry399
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry399_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry399_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry399 bdk_apbrom_mdabx_romentry399_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY399(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY399(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611063c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY399", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY399(a) bdk_apbrom_mdabx_romentry399_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY399(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY399(a) "APBROM_MDABX_ROMENTRY399"
#define busnum_BDK_APBROM_MDABX_ROMENTRY399(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY399(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry4
 *
 * APBROM Mdab Romentry4 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry4
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry4_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry4 bdk_apbrom_mdabx_romentry4_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110010 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY4(a) bdk_apbrom_mdabx_romentry4_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY4(a) "APBROM_MDABX_ROMENTRY4"
#define busnum_BDK_APBROM_MDABX_ROMENTRY4(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry40
 *
 * APBROM Mdab Romentry40 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry40
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry40_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry40 bdk_apbrom_mdabx_romentry40_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY40(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY40(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY40", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY40(a) bdk_apbrom_mdabx_romentry40_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY40(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY40(a) "APBROM_MDABX_ROMENTRY40"
#define busnum_BDK_APBROM_MDABX_ROMENTRY40(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY40(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry400
 *
 * APBROM Mdab Romentry400 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry400
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry400_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry400_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry400 bdk_apbrom_mdabx_romentry400_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY400(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY400(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110640 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY400", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY400(a) bdk_apbrom_mdabx_romentry400_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY400(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY400(a) "APBROM_MDABX_ROMENTRY400"
#define busnum_BDK_APBROM_MDABX_ROMENTRY400(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY400(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry401
 *
 * APBROM Mdab Romentry401 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry401
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry401_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry401_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry401 bdk_apbrom_mdabx_romentry401_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY401(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY401(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110644 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY401", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY401(a) bdk_apbrom_mdabx_romentry401_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY401(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY401(a) "APBROM_MDABX_ROMENTRY401"
#define busnum_BDK_APBROM_MDABX_ROMENTRY401(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY401(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry402
 *
 * APBROM Mdab Romentry402 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry402
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry402_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry402_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry402 bdk_apbrom_mdabx_romentry402_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY402(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY402(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110648 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY402", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY402(a) bdk_apbrom_mdabx_romentry402_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY402(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY402(a) "APBROM_MDABX_ROMENTRY402"
#define busnum_BDK_APBROM_MDABX_ROMENTRY402(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY402(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry403
 *
 * APBROM Mdab Romentry403 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry403
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry403_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry403_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry403 bdk_apbrom_mdabx_romentry403_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY403(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY403(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611064c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY403", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY403(a) bdk_apbrom_mdabx_romentry403_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY403(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY403(a) "APBROM_MDABX_ROMENTRY403"
#define busnum_BDK_APBROM_MDABX_ROMENTRY403(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY403(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry404
 *
 * APBROM Mdab Romentry404 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry404
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry404_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry404_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry404 bdk_apbrom_mdabx_romentry404_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY404(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY404(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110650 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY404", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY404(a) bdk_apbrom_mdabx_romentry404_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY404(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY404(a) "APBROM_MDABX_ROMENTRY404"
#define busnum_BDK_APBROM_MDABX_ROMENTRY404(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY404(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry405
 *
 * APBROM Mdab Romentry405 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry405
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry405_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry405_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry405 bdk_apbrom_mdabx_romentry405_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY405(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY405(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110654 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY405", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY405(a) bdk_apbrom_mdabx_romentry405_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY405(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY405(a) "APBROM_MDABX_ROMENTRY405"
#define busnum_BDK_APBROM_MDABX_ROMENTRY405(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY405(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry406
 *
 * APBROM Mdab Romentry406 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry406
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry406_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry406_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry406 bdk_apbrom_mdabx_romentry406_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY406(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY406(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110658 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY406", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY406(a) bdk_apbrom_mdabx_romentry406_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY406(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY406(a) "APBROM_MDABX_ROMENTRY406"
#define busnum_BDK_APBROM_MDABX_ROMENTRY406(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY406(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry407
 *
 * APBROM Mdab Romentry407 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry407
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry407_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry407_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry407 bdk_apbrom_mdabx_romentry407_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY407(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY407(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611065c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY407", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY407(a) bdk_apbrom_mdabx_romentry407_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY407(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY407(a) "APBROM_MDABX_ROMENTRY407"
#define busnum_BDK_APBROM_MDABX_ROMENTRY407(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY407(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry408
 *
 * APBROM Mdab Romentry408 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry408
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry408_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry408_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry408 bdk_apbrom_mdabx_romentry408_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY408(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY408(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110660 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY408", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY408(a) bdk_apbrom_mdabx_romentry408_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY408(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY408(a) "APBROM_MDABX_ROMENTRY408"
#define busnum_BDK_APBROM_MDABX_ROMENTRY408(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY408(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry409
 *
 * APBROM Mdab Romentry409 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry409
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry409_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry409_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry409 bdk_apbrom_mdabx_romentry409_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY409(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY409(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110664 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY409", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY409(a) bdk_apbrom_mdabx_romentry409_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY409(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY409(a) "APBROM_MDABX_ROMENTRY409"
#define busnum_BDK_APBROM_MDABX_ROMENTRY409(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY409(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry41
 *
 * APBROM Mdab Romentry41 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry41
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry41_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry41_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry41 bdk_apbrom_mdabx_romentry41_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY41(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY41(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY41", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY41(a) bdk_apbrom_mdabx_romentry41_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY41(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY41(a) "APBROM_MDABX_ROMENTRY41"
#define busnum_BDK_APBROM_MDABX_ROMENTRY41(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY41(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry410
 *
 * APBROM Mdab Romentry410 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry410
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry410_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry410_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry410 bdk_apbrom_mdabx_romentry410_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY410(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY410(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110668 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY410", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY410(a) bdk_apbrom_mdabx_romentry410_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY410(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY410(a) "APBROM_MDABX_ROMENTRY410"
#define busnum_BDK_APBROM_MDABX_ROMENTRY410(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY410(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry411
 *
 * APBROM Mdab Romentry411 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry411
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry411_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry411_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry411 bdk_apbrom_mdabx_romentry411_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY411(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY411(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611066c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY411", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY411(a) bdk_apbrom_mdabx_romentry411_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY411(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY411(a) "APBROM_MDABX_ROMENTRY411"
#define busnum_BDK_APBROM_MDABX_ROMENTRY411(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY411(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry412
 *
 * APBROM Mdab Romentry412 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry412
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry412_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry412_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry412 bdk_apbrom_mdabx_romentry412_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY412(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY412(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110670 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY412", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY412(a) bdk_apbrom_mdabx_romentry412_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY412(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY412(a) "APBROM_MDABX_ROMENTRY412"
#define busnum_BDK_APBROM_MDABX_ROMENTRY412(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY412(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry413
 *
 * APBROM Mdab Romentry413 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry413
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry413_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry413_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry413 bdk_apbrom_mdabx_romentry413_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY413(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY413(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110674 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY413", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY413(a) bdk_apbrom_mdabx_romentry413_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY413(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY413(a) "APBROM_MDABX_ROMENTRY413"
#define busnum_BDK_APBROM_MDABX_ROMENTRY413(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY413(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry414
 *
 * APBROM Mdab Romentry414 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry414
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry414_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry414_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry414 bdk_apbrom_mdabx_romentry414_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY414(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY414(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110678 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY414", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY414(a) bdk_apbrom_mdabx_romentry414_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY414(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY414(a) "APBROM_MDABX_ROMENTRY414"
#define busnum_BDK_APBROM_MDABX_ROMENTRY414(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY414(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry415
 *
 * APBROM Mdab Romentry415 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry415
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry415_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry415_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry415 bdk_apbrom_mdabx_romentry415_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY415(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY415(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611067c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY415", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY415(a) bdk_apbrom_mdabx_romentry415_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY415(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY415(a) "APBROM_MDABX_ROMENTRY415"
#define busnum_BDK_APBROM_MDABX_ROMENTRY415(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY415(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry416
 *
 * APBROM Mdab Romentry416 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry416
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry416_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry416_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry416 bdk_apbrom_mdabx_romentry416_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY416(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY416(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110680 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY416", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY416(a) bdk_apbrom_mdabx_romentry416_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY416(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY416(a) "APBROM_MDABX_ROMENTRY416"
#define busnum_BDK_APBROM_MDABX_ROMENTRY416(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY416(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry417
 *
 * APBROM Mdab Romentry417 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry417
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry417_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry417_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry417 bdk_apbrom_mdabx_romentry417_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY417(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY417(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110684 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY417", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY417(a) bdk_apbrom_mdabx_romentry417_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY417(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY417(a) "APBROM_MDABX_ROMENTRY417"
#define busnum_BDK_APBROM_MDABX_ROMENTRY417(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY417(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry418
 *
 * APBROM Mdab Romentry418 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry418
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry418_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry418_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry418 bdk_apbrom_mdabx_romentry418_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY418(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY418(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110688 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY418", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY418(a) bdk_apbrom_mdabx_romentry418_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY418(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY418(a) "APBROM_MDABX_ROMENTRY418"
#define busnum_BDK_APBROM_MDABX_ROMENTRY418(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY418(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry419
 *
 * APBROM Mdab Romentry419 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry419
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry419_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry419_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry419 bdk_apbrom_mdabx_romentry419_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY419(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY419(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611068c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY419", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY419(a) bdk_apbrom_mdabx_romentry419_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY419(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY419(a) "APBROM_MDABX_ROMENTRY419"
#define busnum_BDK_APBROM_MDABX_ROMENTRY419(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY419(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry42
 *
 * APBROM Mdab Romentry42 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry42
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry42_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry42_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry42 bdk_apbrom_mdabx_romentry42_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY42(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY42(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY42", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY42(a) bdk_apbrom_mdabx_romentry42_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY42(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY42(a) "APBROM_MDABX_ROMENTRY42"
#define busnum_BDK_APBROM_MDABX_ROMENTRY42(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY42(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry420
 *
 * APBROM Mdab Romentry420 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry420
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry420_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry420_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry420 bdk_apbrom_mdabx_romentry420_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY420(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY420(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110690 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY420", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY420(a) bdk_apbrom_mdabx_romentry420_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY420(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY420(a) "APBROM_MDABX_ROMENTRY420"
#define busnum_BDK_APBROM_MDABX_ROMENTRY420(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY420(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry421
 *
 * APBROM Mdab Romentry421 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry421
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry421_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry421_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry421 bdk_apbrom_mdabx_romentry421_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY421(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY421(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110694 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY421", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY421(a) bdk_apbrom_mdabx_romentry421_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY421(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY421(a) "APBROM_MDABX_ROMENTRY421"
#define busnum_BDK_APBROM_MDABX_ROMENTRY421(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY421(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry422
 *
 * APBROM Mdab Romentry422 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry422
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry422_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry422_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry422 bdk_apbrom_mdabx_romentry422_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY422(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY422(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110698 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY422", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY422(a) bdk_apbrom_mdabx_romentry422_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY422(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY422(a) "APBROM_MDABX_ROMENTRY422"
#define busnum_BDK_APBROM_MDABX_ROMENTRY422(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY422(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry423
 *
 * APBROM Mdab Romentry423 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry423
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry423_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry423_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry423 bdk_apbrom_mdabx_romentry423_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY423(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY423(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611069c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY423", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY423(a) bdk_apbrom_mdabx_romentry423_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY423(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY423(a) "APBROM_MDABX_ROMENTRY423"
#define busnum_BDK_APBROM_MDABX_ROMENTRY423(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY423(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry424
 *
 * APBROM Mdab Romentry424 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry424
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry424_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry424_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry424 bdk_apbrom_mdabx_romentry424_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY424(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY424(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY424", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY424(a) bdk_apbrom_mdabx_romentry424_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY424(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY424(a) "APBROM_MDABX_ROMENTRY424"
#define busnum_BDK_APBROM_MDABX_ROMENTRY424(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY424(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry425
 *
 * APBROM Mdab Romentry425 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry425
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry425_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry425_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry425 bdk_apbrom_mdabx_romentry425_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY425(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY425(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY425", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY425(a) bdk_apbrom_mdabx_romentry425_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY425(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY425(a) "APBROM_MDABX_ROMENTRY425"
#define busnum_BDK_APBROM_MDABX_ROMENTRY425(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY425(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry426
 *
 * APBROM Mdab Romentry426 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry426
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry426_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry426_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry426 bdk_apbrom_mdabx_romentry426_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY426(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY426(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY426", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY426(a) bdk_apbrom_mdabx_romentry426_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY426(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY426(a) "APBROM_MDABX_ROMENTRY426"
#define busnum_BDK_APBROM_MDABX_ROMENTRY426(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY426(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry427
 *
 * APBROM Mdab Romentry427 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry427
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry427_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry427_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry427 bdk_apbrom_mdabx_romentry427_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY427(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY427(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY427", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY427(a) bdk_apbrom_mdabx_romentry427_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY427(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY427(a) "APBROM_MDABX_ROMENTRY427"
#define busnum_BDK_APBROM_MDABX_ROMENTRY427(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY427(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry428
 *
 * APBROM Mdab Romentry428 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry428
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry428_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry428_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry428 bdk_apbrom_mdabx_romentry428_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY428(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY428(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY428", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY428(a) bdk_apbrom_mdabx_romentry428_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY428(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY428(a) "APBROM_MDABX_ROMENTRY428"
#define busnum_BDK_APBROM_MDABX_ROMENTRY428(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY428(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry429
 *
 * APBROM Mdab Romentry429 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry429
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry429_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry429_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry429 bdk_apbrom_mdabx_romentry429_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY429(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY429(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY429", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY429(a) bdk_apbrom_mdabx_romentry429_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY429(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY429(a) "APBROM_MDABX_ROMENTRY429"
#define busnum_BDK_APBROM_MDABX_ROMENTRY429(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY429(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry43
 *
 * APBROM Mdab Romentry43 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry43
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry43_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry43_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry43 bdk_apbrom_mdabx_romentry43_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY43(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY43(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY43", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY43(a) bdk_apbrom_mdabx_romentry43_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY43(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY43(a) "APBROM_MDABX_ROMENTRY43"
#define busnum_BDK_APBROM_MDABX_ROMENTRY43(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY43(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry430
 *
 * APBROM Mdab Romentry430 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry430
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry430_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry430_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry430 bdk_apbrom_mdabx_romentry430_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY430(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY430(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY430", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY430(a) bdk_apbrom_mdabx_romentry430_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY430(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY430(a) "APBROM_MDABX_ROMENTRY430"
#define busnum_BDK_APBROM_MDABX_ROMENTRY430(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY430(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry431
 *
 * APBROM Mdab Romentry431 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry431
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry431_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry431_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry431 bdk_apbrom_mdabx_romentry431_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY431(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY431(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY431", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY431(a) bdk_apbrom_mdabx_romentry431_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY431(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY431(a) "APBROM_MDABX_ROMENTRY431"
#define busnum_BDK_APBROM_MDABX_ROMENTRY431(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY431(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry432
 *
 * APBROM Mdab Romentry432 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry432
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry432_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry432_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry432 bdk_apbrom_mdabx_romentry432_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY432(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY432(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY432", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY432(a) bdk_apbrom_mdabx_romentry432_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY432(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY432(a) "APBROM_MDABX_ROMENTRY432"
#define busnum_BDK_APBROM_MDABX_ROMENTRY432(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY432(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry433
 *
 * APBROM Mdab Romentry433 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry433
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry433_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry433_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry433 bdk_apbrom_mdabx_romentry433_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY433(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY433(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY433", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY433(a) bdk_apbrom_mdabx_romentry433_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY433(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY433(a) "APBROM_MDABX_ROMENTRY433"
#define busnum_BDK_APBROM_MDABX_ROMENTRY433(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY433(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry434
 *
 * APBROM Mdab Romentry434 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry434
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry434_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry434_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry434 bdk_apbrom_mdabx_romentry434_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY434(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY434(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY434", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY434(a) bdk_apbrom_mdabx_romentry434_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY434(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY434(a) "APBROM_MDABX_ROMENTRY434"
#define busnum_BDK_APBROM_MDABX_ROMENTRY434(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY434(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry435
 *
 * APBROM Mdab Romentry435 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry435
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry435_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry435_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry435 bdk_apbrom_mdabx_romentry435_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY435(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY435(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY435", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY435(a) bdk_apbrom_mdabx_romentry435_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY435(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY435(a) "APBROM_MDABX_ROMENTRY435"
#define busnum_BDK_APBROM_MDABX_ROMENTRY435(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY435(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry436
 *
 * APBROM Mdab Romentry436 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry436
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry436_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry436_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry436 bdk_apbrom_mdabx_romentry436_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY436(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY436(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY436", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY436(a) bdk_apbrom_mdabx_romentry436_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY436(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY436(a) "APBROM_MDABX_ROMENTRY436"
#define busnum_BDK_APBROM_MDABX_ROMENTRY436(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY436(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry437
 *
 * APBROM Mdab Romentry437 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry437
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry437_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry437_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry437 bdk_apbrom_mdabx_romentry437_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY437(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY437(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY437", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY437(a) bdk_apbrom_mdabx_romentry437_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY437(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY437(a) "APBROM_MDABX_ROMENTRY437"
#define busnum_BDK_APBROM_MDABX_ROMENTRY437(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY437(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry438
 *
 * APBROM Mdab Romentry438 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry438
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry438_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry438_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry438 bdk_apbrom_mdabx_romentry438_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY438(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY438(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY438", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY438(a) bdk_apbrom_mdabx_romentry438_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY438(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY438(a) "APBROM_MDABX_ROMENTRY438"
#define busnum_BDK_APBROM_MDABX_ROMENTRY438(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY438(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry439
 *
 * APBROM Mdab Romentry439 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry439
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry439_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry439_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry439 bdk_apbrom_mdabx_romentry439_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY439(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY439(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY439", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY439(a) bdk_apbrom_mdabx_romentry439_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY439(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY439(a) "APBROM_MDABX_ROMENTRY439"
#define busnum_BDK_APBROM_MDABX_ROMENTRY439(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY439(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry44
 *
 * APBROM Mdab Romentry44 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry44
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry44_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry44_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry44 bdk_apbrom_mdabx_romentry44_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY44(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY44(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY44", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY44(a) bdk_apbrom_mdabx_romentry44_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY44(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY44(a) "APBROM_MDABX_ROMENTRY44"
#define busnum_BDK_APBROM_MDABX_ROMENTRY44(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY44(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry440
 *
 * APBROM Mdab Romentry440 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry440
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry440_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry440_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry440 bdk_apbrom_mdabx_romentry440_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY440(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY440(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY440", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY440(a) bdk_apbrom_mdabx_romentry440_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY440(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY440(a) "APBROM_MDABX_ROMENTRY440"
#define busnum_BDK_APBROM_MDABX_ROMENTRY440(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY440(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry441
 *
 * APBROM Mdab Romentry441 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry441
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry441_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry441_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry441 bdk_apbrom_mdabx_romentry441_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY441(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY441(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY441", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY441(a) bdk_apbrom_mdabx_romentry441_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY441(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY441(a) "APBROM_MDABX_ROMENTRY441"
#define busnum_BDK_APBROM_MDABX_ROMENTRY441(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY441(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry442
 *
 * APBROM Mdab Romentry442 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry442
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry442_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry442_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry442 bdk_apbrom_mdabx_romentry442_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY442(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY442(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY442", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY442(a) bdk_apbrom_mdabx_romentry442_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY442(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY442(a) "APBROM_MDABX_ROMENTRY442"
#define busnum_BDK_APBROM_MDABX_ROMENTRY442(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY442(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry443
 *
 * APBROM Mdab Romentry443 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry443
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry443_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry443_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry443 bdk_apbrom_mdabx_romentry443_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY443(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY443(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY443", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY443(a) bdk_apbrom_mdabx_romentry443_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY443(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY443(a) "APBROM_MDABX_ROMENTRY443"
#define busnum_BDK_APBROM_MDABX_ROMENTRY443(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY443(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry444
 *
 * APBROM Mdab Romentry444 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry444
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry444_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry444_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry444 bdk_apbrom_mdabx_romentry444_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY444(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY444(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY444", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY444(a) bdk_apbrom_mdabx_romentry444_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY444(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY444(a) "APBROM_MDABX_ROMENTRY444"
#define busnum_BDK_APBROM_MDABX_ROMENTRY444(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY444(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry445
 *
 * APBROM Mdab Romentry445 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry445
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry445_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry445_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry445 bdk_apbrom_mdabx_romentry445_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY445(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY445(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY445", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY445(a) bdk_apbrom_mdabx_romentry445_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY445(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY445(a) "APBROM_MDABX_ROMENTRY445"
#define busnum_BDK_APBROM_MDABX_ROMENTRY445(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY445(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry446
 *
 * APBROM Mdab Romentry446 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry446
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry446_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry446_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry446 bdk_apbrom_mdabx_romentry446_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY446(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY446(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY446", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY446(a) bdk_apbrom_mdabx_romentry446_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY446(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY446(a) "APBROM_MDABX_ROMENTRY446"
#define busnum_BDK_APBROM_MDABX_ROMENTRY446(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY446(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry447
 *
 * APBROM Mdab Romentry447 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry447
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry447_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry447_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry447 bdk_apbrom_mdabx_romentry447_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY447(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY447(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461106fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY447", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY447(a) bdk_apbrom_mdabx_romentry447_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY447(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY447(a) "APBROM_MDABX_ROMENTRY447"
#define busnum_BDK_APBROM_MDABX_ROMENTRY447(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY447(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry448
 *
 * APBROM Mdab Romentry448 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry448
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry448_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry448_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry448 bdk_apbrom_mdabx_romentry448_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY448(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY448(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110700 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY448", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY448(a) bdk_apbrom_mdabx_romentry448_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY448(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY448(a) "APBROM_MDABX_ROMENTRY448"
#define busnum_BDK_APBROM_MDABX_ROMENTRY448(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY448(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry449
 *
 * APBROM Mdab Romentry449 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry449
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry449_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry449_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry449 bdk_apbrom_mdabx_romentry449_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY449(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY449(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110704 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY449", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY449(a) bdk_apbrom_mdabx_romentry449_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY449(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY449(a) "APBROM_MDABX_ROMENTRY449"
#define busnum_BDK_APBROM_MDABX_ROMENTRY449(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY449(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry45
 *
 * APBROM Mdab Romentry45 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry45
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry45_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry45_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry45 bdk_apbrom_mdabx_romentry45_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY45(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY45(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY45", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY45(a) bdk_apbrom_mdabx_romentry45_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY45(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY45(a) "APBROM_MDABX_ROMENTRY45"
#define busnum_BDK_APBROM_MDABX_ROMENTRY45(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY45(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry450
 *
 * APBROM Mdab Romentry450 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry450
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry450_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry450_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry450 bdk_apbrom_mdabx_romentry450_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY450(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY450(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110708 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY450", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY450(a) bdk_apbrom_mdabx_romentry450_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY450(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY450(a) "APBROM_MDABX_ROMENTRY450"
#define busnum_BDK_APBROM_MDABX_ROMENTRY450(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY450(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry451
 *
 * APBROM Mdab Romentry451 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry451
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry451_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry451_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry451 bdk_apbrom_mdabx_romentry451_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY451(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY451(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611070c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY451", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY451(a) bdk_apbrom_mdabx_romentry451_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY451(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY451(a) "APBROM_MDABX_ROMENTRY451"
#define busnum_BDK_APBROM_MDABX_ROMENTRY451(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY451(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry452
 *
 * APBROM Mdab Romentry452 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry452
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry452_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry452_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry452 bdk_apbrom_mdabx_romentry452_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY452(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY452(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110710 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY452", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY452(a) bdk_apbrom_mdabx_romentry452_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY452(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY452(a) "APBROM_MDABX_ROMENTRY452"
#define busnum_BDK_APBROM_MDABX_ROMENTRY452(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY452(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry453
 *
 * APBROM Mdab Romentry453 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry453
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry453_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry453_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry453 bdk_apbrom_mdabx_romentry453_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY453(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY453(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110714 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY453", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY453(a) bdk_apbrom_mdabx_romentry453_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY453(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY453(a) "APBROM_MDABX_ROMENTRY453"
#define busnum_BDK_APBROM_MDABX_ROMENTRY453(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY453(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry454
 *
 * APBROM Mdab Romentry454 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry454
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry454_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry454_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry454 bdk_apbrom_mdabx_romentry454_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY454(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY454(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110718 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY454", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY454(a) bdk_apbrom_mdabx_romentry454_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY454(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY454(a) "APBROM_MDABX_ROMENTRY454"
#define busnum_BDK_APBROM_MDABX_ROMENTRY454(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY454(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry455
 *
 * APBROM Mdab Romentry455 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry455
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry455_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry455_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry455 bdk_apbrom_mdabx_romentry455_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY455(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY455(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611071c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY455", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY455(a) bdk_apbrom_mdabx_romentry455_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY455(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY455(a) "APBROM_MDABX_ROMENTRY455"
#define busnum_BDK_APBROM_MDABX_ROMENTRY455(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY455(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry456
 *
 * APBROM Mdab Romentry456 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry456
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry456_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry456_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry456 bdk_apbrom_mdabx_romentry456_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY456(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY456(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110720 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY456", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY456(a) bdk_apbrom_mdabx_romentry456_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY456(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY456(a) "APBROM_MDABX_ROMENTRY456"
#define busnum_BDK_APBROM_MDABX_ROMENTRY456(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY456(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry457
 *
 * APBROM Mdab Romentry457 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry457
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry457_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry457_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry457 bdk_apbrom_mdabx_romentry457_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY457(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY457(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110724 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY457", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY457(a) bdk_apbrom_mdabx_romentry457_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY457(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY457(a) "APBROM_MDABX_ROMENTRY457"
#define busnum_BDK_APBROM_MDABX_ROMENTRY457(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY457(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry458
 *
 * APBROM Mdab Romentry458 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry458
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry458_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry458_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry458 bdk_apbrom_mdabx_romentry458_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY458(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY458(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110728 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY458", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY458(a) bdk_apbrom_mdabx_romentry458_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY458(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY458(a) "APBROM_MDABX_ROMENTRY458"
#define busnum_BDK_APBROM_MDABX_ROMENTRY458(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY458(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry459
 *
 * APBROM Mdab Romentry459 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry459
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry459_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry459_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry459 bdk_apbrom_mdabx_romentry459_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY459(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY459(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611072c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY459", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY459(a) bdk_apbrom_mdabx_romentry459_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY459(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY459(a) "APBROM_MDABX_ROMENTRY459"
#define busnum_BDK_APBROM_MDABX_ROMENTRY459(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY459(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry46
 *
 * APBROM Mdab Romentry46 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry46
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry46_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry46_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry46 bdk_apbrom_mdabx_romentry46_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY46(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY46(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY46", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY46(a) bdk_apbrom_mdabx_romentry46_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY46(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY46(a) "APBROM_MDABX_ROMENTRY46"
#define busnum_BDK_APBROM_MDABX_ROMENTRY46(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY46(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry460
 *
 * APBROM Mdab Romentry460 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry460
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry460_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry460_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry460 bdk_apbrom_mdabx_romentry460_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY460(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY460(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110730 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY460", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY460(a) bdk_apbrom_mdabx_romentry460_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY460(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY460(a) "APBROM_MDABX_ROMENTRY460"
#define busnum_BDK_APBROM_MDABX_ROMENTRY460(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY460(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry461
 *
 * APBROM Mdab Romentry461 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry461
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry461_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry461_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry461 bdk_apbrom_mdabx_romentry461_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY461(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY461(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110734 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY461", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY461(a) bdk_apbrom_mdabx_romentry461_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY461(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY461(a) "APBROM_MDABX_ROMENTRY461"
#define busnum_BDK_APBROM_MDABX_ROMENTRY461(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY461(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry462
 *
 * APBROM Mdab Romentry462 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry462
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry462_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry462_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry462 bdk_apbrom_mdabx_romentry462_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY462(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY462(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110738 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY462", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY462(a) bdk_apbrom_mdabx_romentry462_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY462(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY462(a) "APBROM_MDABX_ROMENTRY462"
#define busnum_BDK_APBROM_MDABX_ROMENTRY462(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY462(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry463
 *
 * APBROM Mdab Romentry463 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry463
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry463_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry463_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry463 bdk_apbrom_mdabx_romentry463_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY463(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY463(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611073c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY463", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY463(a) bdk_apbrom_mdabx_romentry463_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY463(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY463(a) "APBROM_MDABX_ROMENTRY463"
#define busnum_BDK_APBROM_MDABX_ROMENTRY463(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY463(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry464
 *
 * APBROM Mdab Romentry464 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry464
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry464_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry464_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry464 bdk_apbrom_mdabx_romentry464_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY464(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY464(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110740 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY464", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY464(a) bdk_apbrom_mdabx_romentry464_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY464(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY464(a) "APBROM_MDABX_ROMENTRY464"
#define busnum_BDK_APBROM_MDABX_ROMENTRY464(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY464(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry465
 *
 * APBROM Mdab Romentry465 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry465
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry465_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry465_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry465 bdk_apbrom_mdabx_romentry465_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY465(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY465(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110744 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY465", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY465(a) bdk_apbrom_mdabx_romentry465_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY465(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY465(a) "APBROM_MDABX_ROMENTRY465"
#define busnum_BDK_APBROM_MDABX_ROMENTRY465(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY465(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry466
 *
 * APBROM Mdab Romentry466 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry466
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry466_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry466_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry466 bdk_apbrom_mdabx_romentry466_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY466(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY466(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110748 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY466", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY466(a) bdk_apbrom_mdabx_romentry466_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY466(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY466(a) "APBROM_MDABX_ROMENTRY466"
#define busnum_BDK_APBROM_MDABX_ROMENTRY466(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY466(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry467
 *
 * APBROM Mdab Romentry467 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry467
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry467_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry467_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry467 bdk_apbrom_mdabx_romentry467_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY467(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY467(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611074c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY467", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY467(a) bdk_apbrom_mdabx_romentry467_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY467(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY467(a) "APBROM_MDABX_ROMENTRY467"
#define busnum_BDK_APBROM_MDABX_ROMENTRY467(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY467(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry468
 *
 * APBROM Mdab Romentry468 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry468
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry468_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry468_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry468 bdk_apbrom_mdabx_romentry468_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY468(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY468(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110750 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY468", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY468(a) bdk_apbrom_mdabx_romentry468_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY468(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY468(a) "APBROM_MDABX_ROMENTRY468"
#define busnum_BDK_APBROM_MDABX_ROMENTRY468(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY468(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry469
 *
 * APBROM Mdab Romentry469 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry469
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry469_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry469_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry469 bdk_apbrom_mdabx_romentry469_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY469(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY469(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110754 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY469", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY469(a) bdk_apbrom_mdabx_romentry469_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY469(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY469(a) "APBROM_MDABX_ROMENTRY469"
#define busnum_BDK_APBROM_MDABX_ROMENTRY469(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY469(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry47
 *
 * APBROM Mdab Romentry47 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry47
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry47_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry47_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry47 bdk_apbrom_mdabx_romentry47_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY47(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY47(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY47", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY47(a) bdk_apbrom_mdabx_romentry47_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY47(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY47(a) "APBROM_MDABX_ROMENTRY47"
#define busnum_BDK_APBROM_MDABX_ROMENTRY47(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY47(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry470
 *
 * APBROM Mdab Romentry470 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry470
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry470_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry470_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry470 bdk_apbrom_mdabx_romentry470_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY470(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY470(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110758 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY470", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY470(a) bdk_apbrom_mdabx_romentry470_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY470(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY470(a) "APBROM_MDABX_ROMENTRY470"
#define busnum_BDK_APBROM_MDABX_ROMENTRY470(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY470(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry471
 *
 * APBROM Mdab Romentry471 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry471
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry471_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry471_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry471 bdk_apbrom_mdabx_romentry471_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY471(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY471(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611075c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY471", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY471(a) bdk_apbrom_mdabx_romentry471_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY471(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY471(a) "APBROM_MDABX_ROMENTRY471"
#define busnum_BDK_APBROM_MDABX_ROMENTRY471(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY471(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry472
 *
 * APBROM Mdab Romentry472 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry472
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry472_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry472_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry472 bdk_apbrom_mdabx_romentry472_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY472(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY472(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110760 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY472", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY472(a) bdk_apbrom_mdabx_romentry472_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY472(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY472(a) "APBROM_MDABX_ROMENTRY472"
#define busnum_BDK_APBROM_MDABX_ROMENTRY472(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY472(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry473
 *
 * APBROM Mdab Romentry473 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry473
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry473_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry473_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry473 bdk_apbrom_mdabx_romentry473_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY473(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY473(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110764 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY473", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY473(a) bdk_apbrom_mdabx_romentry473_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY473(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY473(a) "APBROM_MDABX_ROMENTRY473"
#define busnum_BDK_APBROM_MDABX_ROMENTRY473(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY473(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry474
 *
 * APBROM Mdab Romentry474 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry474
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry474_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry474_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry474 bdk_apbrom_mdabx_romentry474_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY474(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY474(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110768 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY474", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY474(a) bdk_apbrom_mdabx_romentry474_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY474(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY474(a) "APBROM_MDABX_ROMENTRY474"
#define busnum_BDK_APBROM_MDABX_ROMENTRY474(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY474(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry475
 *
 * APBROM Mdab Romentry475 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry475
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry475_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry475_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry475 bdk_apbrom_mdabx_romentry475_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY475(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY475(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611076c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY475", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY475(a) bdk_apbrom_mdabx_romentry475_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY475(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY475(a) "APBROM_MDABX_ROMENTRY475"
#define busnum_BDK_APBROM_MDABX_ROMENTRY475(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY475(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry476
 *
 * APBROM Mdab Romentry476 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry476
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry476_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry476_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry476 bdk_apbrom_mdabx_romentry476_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY476(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY476(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110770 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY476", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY476(a) bdk_apbrom_mdabx_romentry476_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY476(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY476(a) "APBROM_MDABX_ROMENTRY476"
#define busnum_BDK_APBROM_MDABX_ROMENTRY476(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY476(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry477
 *
 * APBROM Mdab Romentry477 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry477
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry477_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry477_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry477 bdk_apbrom_mdabx_romentry477_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY477(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY477(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110774 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY477", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY477(a) bdk_apbrom_mdabx_romentry477_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY477(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY477(a) "APBROM_MDABX_ROMENTRY477"
#define busnum_BDK_APBROM_MDABX_ROMENTRY477(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY477(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry478
 *
 * APBROM Mdab Romentry478 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry478
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry478_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry478_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry478 bdk_apbrom_mdabx_romentry478_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY478(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY478(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110778 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY478", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY478(a) bdk_apbrom_mdabx_romentry478_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY478(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY478(a) "APBROM_MDABX_ROMENTRY478"
#define busnum_BDK_APBROM_MDABX_ROMENTRY478(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY478(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry479
 *
 * APBROM Mdab Romentry479 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry479
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry479_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry479_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry479 bdk_apbrom_mdabx_romentry479_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY479(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY479(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611077c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY479", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY479(a) bdk_apbrom_mdabx_romentry479_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY479(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY479(a) "APBROM_MDABX_ROMENTRY479"
#define busnum_BDK_APBROM_MDABX_ROMENTRY479(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY479(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry48
 *
 * APBROM Mdab Romentry48 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry48
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry48_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry48 bdk_apbrom_mdabx_romentry48_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY48(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY48(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY48", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY48(a) bdk_apbrom_mdabx_romentry48_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY48(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY48(a) "APBROM_MDABX_ROMENTRY48"
#define busnum_BDK_APBROM_MDABX_ROMENTRY48(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY48(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry480
 *
 * APBROM Mdab Romentry480 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry480
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry480_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry480_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry480 bdk_apbrom_mdabx_romentry480_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY480(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY480(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110780 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY480", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY480(a) bdk_apbrom_mdabx_romentry480_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY480(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY480(a) "APBROM_MDABX_ROMENTRY480"
#define busnum_BDK_APBROM_MDABX_ROMENTRY480(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY480(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry481
 *
 * APBROM Mdab Romentry481 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry481
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry481_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry481_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry481 bdk_apbrom_mdabx_romentry481_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY481(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY481(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110784 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY481", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY481(a) bdk_apbrom_mdabx_romentry481_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY481(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY481(a) "APBROM_MDABX_ROMENTRY481"
#define busnum_BDK_APBROM_MDABX_ROMENTRY481(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY481(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry482
 *
 * APBROM Mdab Romentry482 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry482
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry482_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry482_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry482 bdk_apbrom_mdabx_romentry482_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY482(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY482(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110788 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY482", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY482(a) bdk_apbrom_mdabx_romentry482_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY482(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY482(a) "APBROM_MDABX_ROMENTRY482"
#define busnum_BDK_APBROM_MDABX_ROMENTRY482(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY482(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry483
 *
 * APBROM Mdab Romentry483 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry483
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry483_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry483_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry483 bdk_apbrom_mdabx_romentry483_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY483(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY483(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611078c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY483", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY483(a) bdk_apbrom_mdabx_romentry483_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY483(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY483(a) "APBROM_MDABX_ROMENTRY483"
#define busnum_BDK_APBROM_MDABX_ROMENTRY483(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY483(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry484
 *
 * APBROM Mdab Romentry484 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry484
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry484_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry484_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry484 bdk_apbrom_mdabx_romentry484_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY484(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY484(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110790 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY484", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY484(a) bdk_apbrom_mdabx_romentry484_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY484(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY484(a) "APBROM_MDABX_ROMENTRY484"
#define busnum_BDK_APBROM_MDABX_ROMENTRY484(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY484(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry485
 *
 * APBROM Mdab Romentry485 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry485
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry485_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry485_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry485 bdk_apbrom_mdabx_romentry485_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY485(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY485(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110794 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY485", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY485(a) bdk_apbrom_mdabx_romentry485_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY485(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY485(a) "APBROM_MDABX_ROMENTRY485"
#define busnum_BDK_APBROM_MDABX_ROMENTRY485(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY485(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry486
 *
 * APBROM Mdab Romentry486 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry486
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry486_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry486_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry486 bdk_apbrom_mdabx_romentry486_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY486(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY486(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110798 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY486", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY486(a) bdk_apbrom_mdabx_romentry486_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY486(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY486(a) "APBROM_MDABX_ROMENTRY486"
#define busnum_BDK_APBROM_MDABX_ROMENTRY486(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY486(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry487
 *
 * APBROM Mdab Romentry487 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry487
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry487_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry487_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry487 bdk_apbrom_mdabx_romentry487_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY487(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY487(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611079c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY487", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY487(a) bdk_apbrom_mdabx_romentry487_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY487(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY487(a) "APBROM_MDABX_ROMENTRY487"
#define busnum_BDK_APBROM_MDABX_ROMENTRY487(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY487(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry488
 *
 * APBROM Mdab Romentry488 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry488
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry488_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry488_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry488 bdk_apbrom_mdabx_romentry488_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY488(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY488(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107a0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY488", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY488(a) bdk_apbrom_mdabx_romentry488_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY488(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY488(a) "APBROM_MDABX_ROMENTRY488"
#define busnum_BDK_APBROM_MDABX_ROMENTRY488(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY488(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry489
 *
 * APBROM Mdab Romentry489 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry489
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry489_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry489_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry489 bdk_apbrom_mdabx_romentry489_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY489(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY489(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107a4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY489", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY489(a) bdk_apbrom_mdabx_romentry489_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY489(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY489(a) "APBROM_MDABX_ROMENTRY489"
#define busnum_BDK_APBROM_MDABX_ROMENTRY489(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY489(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry49
 *
 * APBROM Mdab Romentry49 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry49
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry49_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry49_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry49 bdk_apbrom_mdabx_romentry49_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY49(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY49(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY49", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY49(a) bdk_apbrom_mdabx_romentry49_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY49(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY49(a) "APBROM_MDABX_ROMENTRY49"
#define busnum_BDK_APBROM_MDABX_ROMENTRY49(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY49(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry490
 *
 * APBROM Mdab Romentry490 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry490
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry490_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry490_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry490 bdk_apbrom_mdabx_romentry490_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY490(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY490(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107a8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY490", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY490(a) bdk_apbrom_mdabx_romentry490_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY490(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY490(a) "APBROM_MDABX_ROMENTRY490"
#define busnum_BDK_APBROM_MDABX_ROMENTRY490(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY490(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry491
 *
 * APBROM Mdab Romentry491 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry491
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry491_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry491_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry491 bdk_apbrom_mdabx_romentry491_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY491(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY491(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107ac + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY491", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY491(a) bdk_apbrom_mdabx_romentry491_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY491(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY491(a) "APBROM_MDABX_ROMENTRY491"
#define busnum_BDK_APBROM_MDABX_ROMENTRY491(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY491(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry492
 *
 * APBROM Mdab Romentry492 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry492
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry492_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry492_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry492 bdk_apbrom_mdabx_romentry492_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY492(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY492(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107b0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY492", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY492(a) bdk_apbrom_mdabx_romentry492_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY492(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY492(a) "APBROM_MDABX_ROMENTRY492"
#define busnum_BDK_APBROM_MDABX_ROMENTRY492(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY492(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry493
 *
 * APBROM Mdab Romentry493 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry493
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry493_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry493_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry493 bdk_apbrom_mdabx_romentry493_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY493(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY493(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107b4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY493", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY493(a) bdk_apbrom_mdabx_romentry493_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY493(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY493(a) "APBROM_MDABX_ROMENTRY493"
#define busnum_BDK_APBROM_MDABX_ROMENTRY493(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY493(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry494
 *
 * APBROM Mdab Romentry494 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry494
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry494_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry494_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry494 bdk_apbrom_mdabx_romentry494_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY494(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY494(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107b8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY494", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY494(a) bdk_apbrom_mdabx_romentry494_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY494(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY494(a) "APBROM_MDABX_ROMENTRY494"
#define busnum_BDK_APBROM_MDABX_ROMENTRY494(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY494(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry495
 *
 * APBROM Mdab Romentry495 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry495
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry495_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry495_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry495 bdk_apbrom_mdabx_romentry495_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY495(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY495(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107bc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY495", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY495(a) bdk_apbrom_mdabx_romentry495_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY495(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY495(a) "APBROM_MDABX_ROMENTRY495"
#define busnum_BDK_APBROM_MDABX_ROMENTRY495(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY495(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry496
 *
 * APBROM Mdab Romentry496 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry496
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry496_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry496_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry496 bdk_apbrom_mdabx_romentry496_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY496(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY496(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107c0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY496", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY496(a) bdk_apbrom_mdabx_romentry496_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY496(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY496(a) "APBROM_MDABX_ROMENTRY496"
#define busnum_BDK_APBROM_MDABX_ROMENTRY496(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY496(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry497
 *
 * APBROM Mdab Romentry497 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry497
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry497_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry497_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry497 bdk_apbrom_mdabx_romentry497_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY497(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY497(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107c4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY497", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY497(a) bdk_apbrom_mdabx_romentry497_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY497(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY497(a) "APBROM_MDABX_ROMENTRY497"
#define busnum_BDK_APBROM_MDABX_ROMENTRY497(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY497(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry498
 *
 * APBROM Mdab Romentry498 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry498
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry498_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry498_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry498 bdk_apbrom_mdabx_romentry498_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY498(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY498(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY498", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY498(a) bdk_apbrom_mdabx_romentry498_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY498(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY498(a) "APBROM_MDABX_ROMENTRY498"
#define busnum_BDK_APBROM_MDABX_ROMENTRY498(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY498(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry499
 *
 * APBROM Mdab Romentry499 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry499
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry499_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry499_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry499 bdk_apbrom_mdabx_romentry499_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY499(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY499(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY499", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY499(a) bdk_apbrom_mdabx_romentry499_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY499(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY499(a) "APBROM_MDABX_ROMENTRY499"
#define busnum_BDK_APBROM_MDABX_ROMENTRY499(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY499(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry5
 *
 * APBROM Mdab Romentry5 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry5
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry5_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry5 bdk_apbrom_mdabx_romentry5_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110014 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY5(a) bdk_apbrom_mdabx_romentry5_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY5(a) "APBROM_MDABX_ROMENTRY5"
#define busnum_BDK_APBROM_MDABX_ROMENTRY5(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry50
 *
 * APBROM Mdab Romentry50 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry50
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry50_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry50_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry50 bdk_apbrom_mdabx_romentry50_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY50(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY50(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100c8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY50", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY50(a) bdk_apbrom_mdabx_romentry50_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY50(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY50(a) "APBROM_MDABX_ROMENTRY50"
#define busnum_BDK_APBROM_MDABX_ROMENTRY50(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY50(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry500
 *
 * APBROM Mdab Romentry500 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry500
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry500_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry500_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry500 bdk_apbrom_mdabx_romentry500_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY500(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY500(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY500", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY500(a) bdk_apbrom_mdabx_romentry500_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY500(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY500(a) "APBROM_MDABX_ROMENTRY500"
#define busnum_BDK_APBROM_MDABX_ROMENTRY500(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY500(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry501
 *
 * APBROM Mdab Romentry501 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry501
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry501_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry501_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry501 bdk_apbrom_mdabx_romentry501_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY501(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY501(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY501", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY501(a) bdk_apbrom_mdabx_romentry501_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY501(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY501(a) "APBROM_MDABX_ROMENTRY501"
#define busnum_BDK_APBROM_MDABX_ROMENTRY501(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY501(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry502
 *
 * APBROM Mdab Romentry502 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry502
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry502_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry502_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry502 bdk_apbrom_mdabx_romentry502_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY502(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY502(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY502", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY502(a) bdk_apbrom_mdabx_romentry502_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY502(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY502(a) "APBROM_MDABX_ROMENTRY502"
#define busnum_BDK_APBROM_MDABX_ROMENTRY502(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY502(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry503
 *
 * APBROM Mdab Romentry503 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry503
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry503_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry503_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry503 bdk_apbrom_mdabx_romentry503_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY503(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY503(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY503", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY503(a) bdk_apbrom_mdabx_romentry503_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY503(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY503(a) "APBROM_MDABX_ROMENTRY503"
#define busnum_BDK_APBROM_MDABX_ROMENTRY503(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY503(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry504
 *
 * APBROM Mdab Romentry504 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry504
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry504_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry504_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry504 bdk_apbrom_mdabx_romentry504_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY504(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY504(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY504", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY504(a) bdk_apbrom_mdabx_romentry504_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY504(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY504(a) "APBROM_MDABX_ROMENTRY504"
#define busnum_BDK_APBROM_MDABX_ROMENTRY504(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY504(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry505
 *
 * APBROM Mdab Romentry505 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry505
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry505_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry505_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry505 bdk_apbrom_mdabx_romentry505_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY505(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY505(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY505", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY505(a) bdk_apbrom_mdabx_romentry505_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY505(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY505(a) "APBROM_MDABX_ROMENTRY505"
#define busnum_BDK_APBROM_MDABX_ROMENTRY505(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY505(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry506
 *
 * APBROM Mdab Romentry506 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry506
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry506_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry506_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry506 bdk_apbrom_mdabx_romentry506_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY506(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY506(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY506", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY506(a) bdk_apbrom_mdabx_romentry506_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY506(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY506(a) "APBROM_MDABX_ROMENTRY506"
#define busnum_BDK_APBROM_MDABX_ROMENTRY506(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY506(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry507
 *
 * APBROM Mdab Romentry507 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry507
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry507_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry507_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry507 bdk_apbrom_mdabx_romentry507_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY507(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY507(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY507", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY507(a) bdk_apbrom_mdabx_romentry507_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY507(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY507(a) "APBROM_MDABX_ROMENTRY507"
#define busnum_BDK_APBROM_MDABX_ROMENTRY507(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY507(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry508
 *
 * APBROM Mdab Romentry508 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry508
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry508_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry508_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry508 bdk_apbrom_mdabx_romentry508_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY508(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY508(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY508", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY508(a) bdk_apbrom_mdabx_romentry508_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY508(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY508(a) "APBROM_MDABX_ROMENTRY508"
#define busnum_BDK_APBROM_MDABX_ROMENTRY508(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY508(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry509
 *
 * APBROM Mdab Romentry509 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry509
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry509_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry509_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry509 bdk_apbrom_mdabx_romentry509_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY509(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY509(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY509", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY509(a) bdk_apbrom_mdabx_romentry509_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY509(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY509(a) "APBROM_MDABX_ROMENTRY509"
#define busnum_BDK_APBROM_MDABX_ROMENTRY509(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY509(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry51
 *
 * APBROM Mdab Romentry51 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry51
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry51_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry51_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry51 bdk_apbrom_mdabx_romentry51_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY51(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY51(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100cc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY51", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY51(a) bdk_apbrom_mdabx_romentry51_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY51(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY51(a) "APBROM_MDABX_ROMENTRY51"
#define busnum_BDK_APBROM_MDABX_ROMENTRY51(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY51(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry510
 *
 * APBROM Mdab Romentry510 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry510
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry510_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry510_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry510 bdk_apbrom_mdabx_romentry510_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY510(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY510(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY510", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY510(a) bdk_apbrom_mdabx_romentry510_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY510(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY510(a) "APBROM_MDABX_ROMENTRY510"
#define busnum_BDK_APBROM_MDABX_ROMENTRY510(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY510(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry511
 *
 * APBROM Mdab Romentry511 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry511
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry511_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry511_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry511 bdk_apbrom_mdabx_romentry511_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY511(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY511(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461107fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY511", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY511(a) bdk_apbrom_mdabx_romentry511_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY511(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY511(a) "APBROM_MDABX_ROMENTRY511"
#define busnum_BDK_APBROM_MDABX_ROMENTRY511(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY511(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry52
 *
 * APBROM Mdab Romentry52 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry52
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry52_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry52_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry52 bdk_apbrom_mdabx_romentry52_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY52(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY52(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100d0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY52", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY52(a) bdk_apbrom_mdabx_romentry52_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY52(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY52(a) "APBROM_MDABX_ROMENTRY52"
#define busnum_BDK_APBROM_MDABX_ROMENTRY52(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY52(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry53
 *
 * APBROM Mdab Romentry53 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry53
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry53_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry53_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry53 bdk_apbrom_mdabx_romentry53_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY53(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY53(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100d4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY53", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY53(a) bdk_apbrom_mdabx_romentry53_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY53(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY53(a) "APBROM_MDABX_ROMENTRY53"
#define busnum_BDK_APBROM_MDABX_ROMENTRY53(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY53(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry54
 *
 * APBROM Mdab Romentry54 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry54
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry54_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry54_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry54 bdk_apbrom_mdabx_romentry54_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY54(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY54(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100d8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY54", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY54(a) bdk_apbrom_mdabx_romentry54_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY54(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY54(a) "APBROM_MDABX_ROMENTRY54"
#define busnum_BDK_APBROM_MDABX_ROMENTRY54(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY54(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry55
 *
 * APBROM Mdab Romentry55 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry55
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry55_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry55_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry55 bdk_apbrom_mdabx_romentry55_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY55(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY55(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100dc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY55", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY55(a) bdk_apbrom_mdabx_romentry55_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY55(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY55(a) "APBROM_MDABX_ROMENTRY55"
#define busnum_BDK_APBROM_MDABX_ROMENTRY55(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY55(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry56
 *
 * APBROM Mdab Romentry56 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry56
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry56_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry56 bdk_apbrom_mdabx_romentry56_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY56(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY56(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100e0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY56", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY56(a) bdk_apbrom_mdabx_romentry56_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY56(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY56(a) "APBROM_MDABX_ROMENTRY56"
#define busnum_BDK_APBROM_MDABX_ROMENTRY56(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY56(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry57
 *
 * APBROM Mdab Romentry57 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry57
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry57_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry57_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry57 bdk_apbrom_mdabx_romentry57_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY57(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY57(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100e4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY57", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY57(a) bdk_apbrom_mdabx_romentry57_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY57(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY57(a) "APBROM_MDABX_ROMENTRY57"
#define busnum_BDK_APBROM_MDABX_ROMENTRY57(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY57(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry58
 *
 * APBROM Mdab Romentry58 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry58
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry58_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry58_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry58 bdk_apbrom_mdabx_romentry58_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY58(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY58(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100e8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY58", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY58(a) bdk_apbrom_mdabx_romentry58_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY58(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY58(a) "APBROM_MDABX_ROMENTRY58"
#define busnum_BDK_APBROM_MDABX_ROMENTRY58(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY58(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry59
 *
 * APBROM Mdab Romentry59 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry59
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry59_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry59_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry59 bdk_apbrom_mdabx_romentry59_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY59(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY59(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100ec + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY59", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY59(a) bdk_apbrom_mdabx_romentry59_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY59(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY59(a) "APBROM_MDABX_ROMENTRY59"
#define busnum_BDK_APBROM_MDABX_ROMENTRY59(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY59(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry6
 *
 * APBROM Mdab Romentry6 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry6
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry6_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry6 bdk_apbrom_mdabx_romentry6_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110018 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY6(a) bdk_apbrom_mdabx_romentry6_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY6(a) "APBROM_MDABX_ROMENTRY6"
#define busnum_BDK_APBROM_MDABX_ROMENTRY6(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry60
 *
 * APBROM Mdab Romentry60 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry60
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry60_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry60_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry60 bdk_apbrom_mdabx_romentry60_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY60(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY60(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100f0 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY60", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY60(a) bdk_apbrom_mdabx_romentry60_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY60(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY60(a) "APBROM_MDABX_ROMENTRY60"
#define busnum_BDK_APBROM_MDABX_ROMENTRY60(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY60(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry61
 *
 * APBROM Mdab Romentry61 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry61
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry61_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry61_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry61 bdk_apbrom_mdabx_romentry61_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY61(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY61(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100f4 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY61", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY61(a) bdk_apbrom_mdabx_romentry61_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY61(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY61(a) "APBROM_MDABX_ROMENTRY61"
#define busnum_BDK_APBROM_MDABX_ROMENTRY61(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY61(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry62
 *
 * APBROM Mdab Romentry62 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry62
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry62_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry62_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry62 bdk_apbrom_mdabx_romentry62_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY62(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY62(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100f8 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY62", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY62(a) bdk_apbrom_mdabx_romentry62_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY62(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY62(a) "APBROM_MDABX_ROMENTRY62"
#define busnum_BDK_APBROM_MDABX_ROMENTRY62(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY62(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry63
 *
 * APBROM Mdab Romentry63 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry63
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry63_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry63_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry63 bdk_apbrom_mdabx_romentry63_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY63(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY63(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e0461100fc + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY63", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY63(a) bdk_apbrom_mdabx_romentry63_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY63(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY63(a) "APBROM_MDABX_ROMENTRY63"
#define busnum_BDK_APBROM_MDABX_ROMENTRY63(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY63(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry64
 *
 * APBROM Mdab Romentry64 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry64
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry64_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry64 bdk_apbrom_mdabx_romentry64_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY64(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY64(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110100 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY64", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY64(a) bdk_apbrom_mdabx_romentry64_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY64(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY64(a) "APBROM_MDABX_ROMENTRY64"
#define busnum_BDK_APBROM_MDABX_ROMENTRY64(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY64(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry65
 *
 * APBROM Mdab Romentry65 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry65
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry65_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry65_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry65 bdk_apbrom_mdabx_romentry65_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY65(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY65(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110104 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY65", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY65(a) bdk_apbrom_mdabx_romentry65_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY65(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY65(a) "APBROM_MDABX_ROMENTRY65"
#define busnum_BDK_APBROM_MDABX_ROMENTRY65(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY65(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry66
 *
 * APBROM Mdab Romentry66 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry66
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry66_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry66_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry66 bdk_apbrom_mdabx_romentry66_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY66(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY66(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110108 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY66", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY66(a) bdk_apbrom_mdabx_romentry66_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY66(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY66(a) "APBROM_MDABX_ROMENTRY66"
#define busnum_BDK_APBROM_MDABX_ROMENTRY66(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY66(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry67
 *
 * APBROM Mdab Romentry67 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry67
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry67_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry67_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry67 bdk_apbrom_mdabx_romentry67_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY67(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY67(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611010c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY67", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY67(a) bdk_apbrom_mdabx_romentry67_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY67(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY67(a) "APBROM_MDABX_ROMENTRY67"
#define busnum_BDK_APBROM_MDABX_ROMENTRY67(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY67(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry68
 *
 * APBROM Mdab Romentry68 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry68
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry68_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry68_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry68 bdk_apbrom_mdabx_romentry68_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY68(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY68(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110110 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY68", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY68(a) bdk_apbrom_mdabx_romentry68_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY68(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY68(a) "APBROM_MDABX_ROMENTRY68"
#define busnum_BDK_APBROM_MDABX_ROMENTRY68(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY68(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry69
 *
 * APBROM Mdab Romentry69 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry69
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry69_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry69_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry69 bdk_apbrom_mdabx_romentry69_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY69(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY69(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110114 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY69", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY69(a) bdk_apbrom_mdabx_romentry69_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY69(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY69(a) "APBROM_MDABX_ROMENTRY69"
#define busnum_BDK_APBROM_MDABX_ROMENTRY69(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY69(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry7
 *
 * APBROM Mdab Romentry7 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry7
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry7_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry7 bdk_apbrom_mdabx_romentry7_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611001c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY7(a) bdk_apbrom_mdabx_romentry7_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY7(a) "APBROM_MDABX_ROMENTRY7"
#define busnum_BDK_APBROM_MDABX_ROMENTRY7(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry70
 *
 * APBROM Mdab Romentry70 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry70
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry70_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry70_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry70 bdk_apbrom_mdabx_romentry70_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY70(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY70(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110118 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY70", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY70(a) bdk_apbrom_mdabx_romentry70_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY70(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY70(a) "APBROM_MDABX_ROMENTRY70"
#define busnum_BDK_APBROM_MDABX_ROMENTRY70(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY70(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry71
 *
 * APBROM Mdab Romentry71 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry71
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry71_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry71_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry71 bdk_apbrom_mdabx_romentry71_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY71(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY71(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611011c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY71", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY71(a) bdk_apbrom_mdabx_romentry71_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY71(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY71(a) "APBROM_MDABX_ROMENTRY71"
#define busnum_BDK_APBROM_MDABX_ROMENTRY71(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY71(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry72
 *
 * APBROM Mdab Romentry72 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry72
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry72_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry72 bdk_apbrom_mdabx_romentry72_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY72(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY72(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110120 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY72", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY72(a) bdk_apbrom_mdabx_romentry72_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY72(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY72(a) "APBROM_MDABX_ROMENTRY72"
#define busnum_BDK_APBROM_MDABX_ROMENTRY72(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY72(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry73
 *
 * APBROM Mdab Romentry73 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry73
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry73_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry73_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry73 bdk_apbrom_mdabx_romentry73_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY73(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY73(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110124 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY73", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY73(a) bdk_apbrom_mdabx_romentry73_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY73(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY73(a) "APBROM_MDABX_ROMENTRY73"
#define busnum_BDK_APBROM_MDABX_ROMENTRY73(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY73(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry74
 *
 * APBROM Mdab Romentry74 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry74
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry74_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry74_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry74 bdk_apbrom_mdabx_romentry74_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY74(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY74(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110128 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY74", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY74(a) bdk_apbrom_mdabx_romentry74_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY74(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY74(a) "APBROM_MDABX_ROMENTRY74"
#define busnum_BDK_APBROM_MDABX_ROMENTRY74(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY74(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry75
 *
 * APBROM Mdab Romentry75 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry75
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry75_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry75_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry75 bdk_apbrom_mdabx_romentry75_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY75(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY75(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611012c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY75", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY75(a) bdk_apbrom_mdabx_romentry75_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY75(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY75(a) "APBROM_MDABX_ROMENTRY75"
#define busnum_BDK_APBROM_MDABX_ROMENTRY75(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY75(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry76
 *
 * APBROM Mdab Romentry76 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry76
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry76_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry76_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry76 bdk_apbrom_mdabx_romentry76_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY76(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY76(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110130 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY76", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY76(a) bdk_apbrom_mdabx_romentry76_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY76(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY76(a) "APBROM_MDABX_ROMENTRY76"
#define busnum_BDK_APBROM_MDABX_ROMENTRY76(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY76(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry77
 *
 * APBROM Mdab Romentry77 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry77
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry77_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry77_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry77 bdk_apbrom_mdabx_romentry77_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY77(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY77(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110134 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY77", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY77(a) bdk_apbrom_mdabx_romentry77_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY77(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY77(a) "APBROM_MDABX_ROMENTRY77"
#define busnum_BDK_APBROM_MDABX_ROMENTRY77(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY77(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry78
 *
 * APBROM Mdab Romentry78 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry78
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry78_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry78_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry78 bdk_apbrom_mdabx_romentry78_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY78(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY78(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110138 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY78", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY78(a) bdk_apbrom_mdabx_romentry78_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY78(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY78(a) "APBROM_MDABX_ROMENTRY78"
#define busnum_BDK_APBROM_MDABX_ROMENTRY78(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY78(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry79
 *
 * APBROM Mdab Romentry79 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry79
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry79_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry79_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry79 bdk_apbrom_mdabx_romentry79_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY79(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY79(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611013c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY79", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY79(a) bdk_apbrom_mdabx_romentry79_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY79(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY79(a) "APBROM_MDABX_ROMENTRY79"
#define busnum_BDK_APBROM_MDABX_ROMENTRY79(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY79(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry8
 *
 * APBROM Mdab Romentry8 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry8
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry8_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry8 bdk_apbrom_mdabx_romentry8_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY8(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110020 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY8(a) bdk_apbrom_mdabx_romentry8_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY8(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY8(a) "APBROM_MDABX_ROMENTRY8"
#define busnum_BDK_APBROM_MDABX_ROMENTRY8(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry80
 *
 * APBROM Mdab Romentry80 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry80
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry80_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry80 bdk_apbrom_mdabx_romentry80_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY80(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY80(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110140 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY80", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY80(a) bdk_apbrom_mdabx_romentry80_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY80(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY80(a) "APBROM_MDABX_ROMENTRY80"
#define busnum_BDK_APBROM_MDABX_ROMENTRY80(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY80(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry81
 *
 * APBROM Mdab Romentry81 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry81
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry81_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry81_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry81 bdk_apbrom_mdabx_romentry81_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY81(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY81(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110144 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY81", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY81(a) bdk_apbrom_mdabx_romentry81_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY81(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY81(a) "APBROM_MDABX_ROMENTRY81"
#define busnum_BDK_APBROM_MDABX_ROMENTRY81(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY81(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry82
 *
 * APBROM Mdab Romentry82 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry82
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry82_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry82_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry82 bdk_apbrom_mdabx_romentry82_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY82(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY82(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110148 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY82", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY82(a) bdk_apbrom_mdabx_romentry82_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY82(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY82(a) "APBROM_MDABX_ROMENTRY82"
#define busnum_BDK_APBROM_MDABX_ROMENTRY82(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY82(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry83
 *
 * APBROM Mdab Romentry83 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry83
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry83_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry83_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry83 bdk_apbrom_mdabx_romentry83_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY83(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY83(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611014c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY83", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY83(a) bdk_apbrom_mdabx_romentry83_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY83(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY83(a) "APBROM_MDABX_ROMENTRY83"
#define busnum_BDK_APBROM_MDABX_ROMENTRY83(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY83(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry84
 *
 * APBROM Mdab Romentry84 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry84
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry84_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry84_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry84 bdk_apbrom_mdabx_romentry84_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY84(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY84(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110150 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY84", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY84(a) bdk_apbrom_mdabx_romentry84_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY84(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY84(a) "APBROM_MDABX_ROMENTRY84"
#define busnum_BDK_APBROM_MDABX_ROMENTRY84(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY84(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry85
 *
 * APBROM Mdab Romentry85 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry85
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry85_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry85_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry85 bdk_apbrom_mdabx_romentry85_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY85(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY85(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110154 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY85", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY85(a) bdk_apbrom_mdabx_romentry85_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY85(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY85(a) "APBROM_MDABX_ROMENTRY85"
#define busnum_BDK_APBROM_MDABX_ROMENTRY85(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY85(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry86
 *
 * APBROM Mdab Romentry86 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry86
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry86_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry86_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry86 bdk_apbrom_mdabx_romentry86_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY86(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY86(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110158 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY86", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY86(a) bdk_apbrom_mdabx_romentry86_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY86(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY86(a) "APBROM_MDABX_ROMENTRY86"
#define busnum_BDK_APBROM_MDABX_ROMENTRY86(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY86(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry87
 *
 * APBROM Mdab Romentry87 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry87
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry87_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry87_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry87 bdk_apbrom_mdabx_romentry87_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY87(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY87(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611015c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY87", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY87(a) bdk_apbrom_mdabx_romentry87_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY87(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY87(a) "APBROM_MDABX_ROMENTRY87"
#define busnum_BDK_APBROM_MDABX_ROMENTRY87(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY87(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry88
 *
 * APBROM Mdab Romentry88 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry88
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry88_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry88 bdk_apbrom_mdabx_romentry88_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY88(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY88(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110160 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY88", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY88(a) bdk_apbrom_mdabx_romentry88_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY88(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY88(a) "APBROM_MDABX_ROMENTRY88"
#define busnum_BDK_APBROM_MDABX_ROMENTRY88(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY88(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry89
 *
 * APBROM Mdab Romentry89 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry89
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry89_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry89_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry89 bdk_apbrom_mdabx_romentry89_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY89(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY89(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110164 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY89", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY89(a) bdk_apbrom_mdabx_romentry89_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY89(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY89(a) "APBROM_MDABX_ROMENTRY89"
#define busnum_BDK_APBROM_MDABX_ROMENTRY89(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY89(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry9
 *
 * APBROM Mdab Romentry9 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry9
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry9_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry9 bdk_apbrom_mdabx_romentry9_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY9(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY9(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110024 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY9(a) bdk_apbrom_mdabx_romentry9_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY9(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY9(a) "APBROM_MDABX_ROMENTRY9"
#define busnum_BDK_APBROM_MDABX_ROMENTRY9(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry90
 *
 * APBROM Mdab Romentry90 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry90
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry90_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry90_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry90 bdk_apbrom_mdabx_romentry90_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY90(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY90(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110168 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY90", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY90(a) bdk_apbrom_mdabx_romentry90_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY90(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY90(a) "APBROM_MDABX_ROMENTRY90"
#define busnum_BDK_APBROM_MDABX_ROMENTRY90(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY90(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry91
 *
 * APBROM Mdab Romentry91 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry91
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry91_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry91_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry91 bdk_apbrom_mdabx_romentry91_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY91(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY91(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611016c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY91", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY91(a) bdk_apbrom_mdabx_romentry91_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY91(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY91(a) "APBROM_MDABX_ROMENTRY91"
#define busnum_BDK_APBROM_MDABX_ROMENTRY91(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY91(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry92
 *
 * APBROM Mdab Romentry92 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry92
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry92_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry92_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry92 bdk_apbrom_mdabx_romentry92_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY92(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY92(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110170 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY92", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY92(a) bdk_apbrom_mdabx_romentry92_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY92(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY92(a) "APBROM_MDABX_ROMENTRY92"
#define busnum_BDK_APBROM_MDABX_ROMENTRY92(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY92(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry93
 *
 * APBROM Mdab Romentry93 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry93
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry93_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry93_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry93 bdk_apbrom_mdabx_romentry93_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY93(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY93(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110174 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY93", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY93(a) bdk_apbrom_mdabx_romentry93_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY93(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY93(a) "APBROM_MDABX_ROMENTRY93"
#define busnum_BDK_APBROM_MDABX_ROMENTRY93(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY93(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry94
 *
 * APBROM Mdab Romentry94 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry94
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry94_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry94_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry94 bdk_apbrom_mdabx_romentry94_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY94(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY94(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110178 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY94", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY94(a) bdk_apbrom_mdabx_romentry94_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY94(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY94(a) "APBROM_MDABX_ROMENTRY94"
#define busnum_BDK_APBROM_MDABX_ROMENTRY94(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY94(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry95
 *
 * APBROM Mdab Romentry95 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry95
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry95_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry95_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry95 bdk_apbrom_mdabx_romentry95_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY95(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY95(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611017c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY95", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY95(a) bdk_apbrom_mdabx_romentry95_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY95(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY95(a) "APBROM_MDABX_ROMENTRY95"
#define busnum_BDK_APBROM_MDABX_ROMENTRY95(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY95(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry96
 *
 * APBROM Mdab Romentry96 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry96
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry96_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry96 bdk_apbrom_mdabx_romentry96_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY96(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY96(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110180 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY96", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY96(a) bdk_apbrom_mdabx_romentry96_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY96(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY96(a) "APBROM_MDABX_ROMENTRY96"
#define busnum_BDK_APBROM_MDABX_ROMENTRY96(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY96(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry97
 *
 * APBROM Mdab Romentry97 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry97
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry97_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry97_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry97 bdk_apbrom_mdabx_romentry97_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY97(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY97(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110184 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY97", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY97(a) bdk_apbrom_mdabx_romentry97_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY97(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY97(a) "APBROM_MDABX_ROMENTRY97"
#define busnum_BDK_APBROM_MDABX_ROMENTRY97(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY97(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry98
 *
 * APBROM Mdab Romentry98 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry98
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry98_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry98_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry98 bdk_apbrom_mdabx_romentry98_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY98(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY98(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e046110188 + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY98", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY98(a) bdk_apbrom_mdabx_romentry98_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY98(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY98(a) "APBROM_MDABX_ROMENTRY98"
#define busnum_BDK_APBROM_MDABX_ROMENTRY98(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY98(a) (a),-1,-1,-1

/**
 * Register (RSL32b) apbrom_mdab#_romentry99
 *
 * APBROM Mdab Romentry99 Register
 * Each register contains a descripter of a CoreSight component in the system. All ROM
 * table entries conform to the same format.
 */
union bdk_apbrom_mdabx_romentry99
{
    uint32_t u;
    struct bdk_apbrom_mdabx_romentry99_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
#else /* Word 0 - Little Endian */
        uint32_t present               : 2;  /**< [  1:  0](RO) Indicates whether the ROM table entry is present. */
        uint32_t power_domain_id_valid : 1;  /**< [  2:  2](RO) Indicates whether there is a power domain ID specified in the ROM table entry. */
        uint32_t sbz_0                 : 1;  /**< [  3:  3](RO) Software should write the field as all 0s. */
        uint32_t power_domain_id       : 5;  /**< [  8:  4](RO) Indicates the power domain ID of the component. Only valid if bit 2 is set. If
                                                                 bit 2 is clear then this field has a value of 0. Possible values are 0 to 31,
                                                                 representing the 32 DBGPWRUPREQ/ACK interface pins of the component. */
        uint32_t sbz_1                 : 3;  /**< [ 11:  9](RO) Software should write the field as all 0s. */
        uint32_t base_addr             : 20; /**< [ 31: 12](RO) Base address of component. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_apbrom_mdabx_romentry99_s cn; */
};
typedef union bdk_apbrom_mdabx_romentry99 bdk_apbrom_mdabx_romentry99_t;

static inline uint64_t BDK_APBROM_MDABX_ROMENTRY99(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_APBROM_MDABX_ROMENTRY99(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=15))
        return 0x87e04611018c + ((a>>2)*0x100000+(a&0x3)*0x10000);
    __bdk_csr_fatal("APBROM_MDABX_ROMENTRY99", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_APBROM_MDABX_ROMENTRY99(a) bdk_apbrom_mdabx_romentry99_t
#define bustype_BDK_APBROM_MDABX_ROMENTRY99(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_APBROM_MDABX_ROMENTRY99(a) "APBROM_MDABX_ROMENTRY99"
#define busnum_BDK_APBROM_MDABX_ROMENTRY99(a) (a)
#define arguments_BDK_APBROM_MDABX_ROMENTRY99(a) (a),-1,-1,-1

#endif /* __BDK_CSRS_APBROM_MDAB_H__ */
