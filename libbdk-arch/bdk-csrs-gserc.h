#ifndef __BDK_CSRS_GSERC_H__
#define __BDK_CSRS_GSERC_H__
/* This file is auto-generated. Do not edit */

/***********************license start***********************************
* Copyright (C) 2019 Marvell International Ltd.
* SPDX-License-Identifier: BSD-3-Clause
* https://spdx.org/licenses
***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * OcteonTX GSERC.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration gserc_bar_e
 *
 * GSERC Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define BDK_GSERC_BAR_E_GSERCX_PF_BAR0(a) (0x87e0a8000000ll + 0x1000000ll * (a))
#define BDK_GSERC_BAR_E_GSERCX_PF_BAR0_SIZE 0x100000ull

/**
 * Enumeration gserc_psb_acc_e
 *
 * GSERC Power Serial Bus Accumulator Enumeration
 * Enumerates the GSERC accumulators for LMC slaves, which correspond to index {b} of
 * PSBS_SYS()_ACCUM().
 */
#define BDK_GSERC_PSB_ACC_E_TBD0 (0)
#define BDK_GSERC_PSB_ACC_E_TBD1 (1)
#define BDK_GSERC_PSB_ACC_E_TBD2 (2)
#define BDK_GSERC_PSB_ACC_E_TBD3 (3)

/**
 * Enumeration gserc_psb_event_e
 *
 * GSERC Power Serial Bus Event Enumeration
 * Enumerates the event numbers for GSERC slaves, which correspond to index {b} of
 * PSBS_SYS()_EVENT()_CFG.
 */
#define BDK_GSERC_PSB_EVENT_E_CYCLE_COUNT (0xc)
#define BDK_GSERC_PSB_EVENT_E_LANEX_LANE_UP(a) (2 + 3 * (a))
#define BDK_GSERC_PSB_EVENT_E_LANEX_PLL_TX_UP(a) (1 + 3 * (a))
#define BDK_GSERC_PSB_EVENT_E_LANEX_PLL_UP(a) (0 + 3 * (a))

/**
 * Register (RSL32b) gserc#_cm0_feature_cal_en_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Cal En Cfg0 Register
 */
union bdk_gsercx_cm0_feature_cal_en_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_cal_en_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t icc_offset2_en        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t rext2_en              : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t icc_offset1_en        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rext1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t icv_offset_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t icv_offset_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rext1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t icc_offset1_en        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rext2_en              : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t icc_offset2_en        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_cal_en_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_cal_en_cfg0_rsvd bdk_gsercx_cm0_feature_cal_en_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e000ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(a) bdk_gsercx_cm0_feature_cal_en_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_cal_en_cfg1_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Cal En Cfg1 Register
 */
union bdk_gsercx_cm0_feature_cal_en_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_cal_en_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t ple_blw_en            : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t tx_term_en            : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t calcomp_high2_en      : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t calcomp_low2_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t calcomp_high1_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t calcomp_low1_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t calcomp_low1_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t calcomp_high1_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t calcomp_low2_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t calcomp_high2_en      : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tx_term_en            : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ple_blw_en            : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_cal_en_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_cal_en_cfg1_rsvd bdk_gsercx_cm0_feature_cal_en_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e008ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) bdk_gsercx_cm0_feature_cal_en_cfg1_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) "GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_CAL_EN_CFG1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_pll2_cal_en_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Pll2 Cal En Cfg0 Register
 */
union bdk_gsercx_cm0_feature_pll2_cal_en_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_pll2_cal_en_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t vco_freq_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cpm_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cpm_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t vco_freq_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_pll2_cal_en_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_pll2_cal_en_cfg0_rsvd bdk_gsercx_cm0_feature_pll2_cal_en_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e020ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(a) bdk_gsercx_cm0_feature_pll2_cal_en_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_PLL2_CAL_EN_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_pll2_lockd_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Pll2 Lockd Cfg0 Register
 */
union bdk_gsercx_cm0_feature_pll2_lockd_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_pll2_lockd_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_us               : 7;  /**< [  7:  1](R/W/H) Reserved. */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t wait_us               : 7;  /**< [  7:  1](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_pll2_lockd_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_pll2_lockd_cfg0_rsvd bdk_gsercx_cm0_feature_pll2_lockd_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e048ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(a) bdk_gsercx_cm0_feature_pll2_lockd_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_PLL2_LOCKD_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_pll_cal_en_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Pll Cal En Cfg0 Register
 */
union bdk_gsercx_cm0_feature_pll_cal_en_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_pll_cal_en_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t vco_buff_swing2_en    : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t vco_buff_res_freq2_en : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t vco_swing2_en         : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t vco_freq1_en          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t vco_buff_swing1_en    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t vco_buff_res_freq1_en : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t vco_swing1_en         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cpm_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cpm_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t vco_swing1_en         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_buff_res_freq1_en : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t vco_buff_swing1_en    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t vco_freq1_en          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t vco_swing2_en         : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t vco_buff_res_freq2_en : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t vco_buff_swing2_en    : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_pll_cal_en_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_pll_cal_en_cfg0_rsvd bdk_gsercx_cm0_feature_pll_cal_en_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e010ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(a) bdk_gsercx_cm0_feature_pll_cal_en_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_pll_cal_en_cfg1_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Pll Cal En Cfg1 Register
 */
union bdk_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t vco_dosc_temp_skew    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t vco_freq3_en          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_freq2_en          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t vco_freq2_en          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t vco_freq3_en          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_dosc_temp_skew    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd bdk_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e018ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) bdk_gsercx_cm0_feature_pll_cal_en_cfg1_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) "GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_PLL_CAL_EN_CFG1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_pll_lockd_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Pll Lockd Cfg0 Register
 */
union bdk_gsercx_cm0_feature_pll_lockd_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_pll_lockd_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_us               : 7;  /**< [  7:  1](R/W/H) Reserved. */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t wait_us               : 7;  /**< [  7:  1](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_pll_lockd_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_pll_lockd_cfg0_rsvd bdk_gsercx_cm0_feature_pll_lockd_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e040ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(a) bdk_gsercx_cm0_feature_pll_lockd_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_PLL_LOCKD_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_rext_result_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Rext Result Cfg0 Register
 */
union bdk_gsercx_cm0_feature_rext_result_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_rext_result_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t refclk_term_en        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txtc_rdac_en          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t bias_icc_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_icc_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t txtc_rdac_en          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t refclk_term_en        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_rext_result_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_rext_result_cfg0_rsvd bdk_gsercx_cm0_feature_rext_result_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e050ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(a) bdk_gsercx_cm0_feature_rext_result_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_REXT_RESULT_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg0_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg0 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg0_rsvd bdk_gsercx_cm0_feature_spare_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e080ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg0_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg1_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg1 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg1_rsvd bdk_gsercx_cm0_feature_spare_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e088ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg1_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg2_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg2 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg2_rsvd bdk_gsercx_cm0_feature_spare_cfg2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e090ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg2_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg3_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg3 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg3_rsvd bdk_gsercx_cm0_feature_spare_cfg3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e098ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg3_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg4_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg4 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg4_rsvd bdk_gsercx_cm0_feature_spare_cfg4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e0a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg4_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg5_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg5 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg5_rsvd bdk_gsercx_cm0_feature_spare_cfg5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e0a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg5_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg6_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg6 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg6_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg6_rsvd bdk_gsercx_cm0_feature_spare_cfg6_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e0b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg6_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG6_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_feature_spare_cfg7_rsvd
 *
 * INTERNAL: GSERC Cm0 Feature Spare Cfg7 Register
 */
union bdk_gsercx_cm0_feature_spare_cfg7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_feature_spare_cfg7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_feature_spare_cfg7_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_feature_spare_cfg7_rsvd bdk_gsercx_cm0_feature_spare_cfg7_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800e0b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(a) bdk_gsercx_cm0_feature_spare_cfg7_rsvd_t
#define bustype_BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(a) "GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD"
#define device_bar_BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_FEATURE_SPARE_CFG7_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_avg_up_cnt_status0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Avg Up Cnt Status0 Register
 */
union bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status0_rsvd bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d890ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a) bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a) "GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_avg_up_cnt_status1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Avg Up Cnt Status1 Register
 */
union bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t bit_8                 : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bit_8                 : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status1_rsvd bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d898ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a) bdk_gsercx_cm0_gcfsm2_avg_up_cnt_status1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a) "GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_cmd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Cmd Ctrl0 Register
 */
union bdk_gsercx_cm0_gcfsm2_cmd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_cmd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_cmd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_cmd_ctrl0_rsvd bdk_gsercx_cm0_gcfsm2_cmd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d800ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(a) bdk_gsercx_cm0_gcfsm2_cmd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(a) "GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_cmd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Cmd Ctrl1 Register
 */
union bdk_gsercx_cm0_gcfsm2_cmd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_cmd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmd                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmd                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_cmd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_cmd_ctrl1_rsvd bdk_gsercx_cm0_gcfsm2_cmd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d808ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(a) bdk_gsercx_cm0_gcfsm2_cmd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(a) "GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_cmd_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Cmd Ctrl2 Register
 */
union bdk_gsercx_cm0_gcfsm2_cmd_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_cmd_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t addr                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_cmd_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_cmd_ctrl2_rsvd bdk_gsercx_cm0_gcfsm2_cmd_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d810ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(a) bdk_gsercx_cm0_gcfsm2_cmd_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(a) "GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_CMD_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_cmd_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Cmd Status Register
 */
union bdk_gsercx_cm0_gcfsm2_cmd_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_cmd_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t code                  : 4;  /**< [  4:  1](RO/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t code                  : 4;  /**< [  4:  1](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_cmd_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_cmd_status_rsvd bdk_gsercx_cm0_gcfsm2_cmd_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d818ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(a) bdk_gsercx_cm0_gcfsm2_cmd_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(a) "GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_CMD_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl0 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t width                 : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t type_val              : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t type_val              : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t width                 : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl0_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d900ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl1 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t start_7_0             : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t start_7_0             : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl1_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d908ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl2 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t start_11_8            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t start_11_8            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl2_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d910ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl3 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t min_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t min_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl3_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d918ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl4 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t min_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t min_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl4_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d920ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl5 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t max_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl5_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d928ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_data_ctrl6_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Data Ctrl6 Register
 */
union bdk_gsercx_cm0_gcfsm2_data_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_data_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t max_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t max_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_data_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_data_ctrl6_rsvd bdk_gsercx_cm0_gcfsm2_data_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d930ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(a) bdk_gsercx_cm0_gcfsm2_data_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(a) "GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_DATA_CTRL6_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_feedback_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Feedback Ctrl0 Register
 */
union bdk_gsercx_cm0_gcfsm2_feedback_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_feedback_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t len_wait_afe_up       : 4;  /**< [  4:  1](R/W/H) Reserved. */
        uint32_t invert_afe_up         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t invert_afe_up         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t len_wait_afe_up       : 4;  /**< [  4:  1](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_feedback_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_feedback_ctrl0_rsvd bdk_gsercx_cm0_gcfsm2_feedback_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(a) bdk_gsercx_cm0_gcfsm2_feedback_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(a) "GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_feedback_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Feedback Ctrl1 Register
 */
union bdk_gsercx_cm0_gcfsm2_feedback_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_feedback_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_avg_afe_up        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_avg_afe_up        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_feedback_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_feedback_ctrl1_rsvd bdk_gsercx_cm0_gcfsm2_feedback_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da88ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(a) bdk_gsercx_cm0_gcfsm2_feedback_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(a) "GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_FEEDBACK_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_param_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Param Ctrl0 Register
 */
union bdk_gsercx_cm0_gcfsm2_param_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_param_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t step_size             : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t step_size             : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_param_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_param_ctrl0_rsvd bdk_gsercx_cm0_gcfsm2_param_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d980ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(a) bdk_gsercx_cm0_gcfsm2_param_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(a) "GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_param_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Param Ctrl1 Register
 */
union bdk_gsercx_cm0_gcfsm2_param_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_param_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t coarse_bounce_num     : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t bounce_num            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bounce_num            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t coarse_bounce_num     : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_param_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_param_ctrl1_rsvd bdk_gsercx_cm0_gcfsm2_param_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d988ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(a) bdk_gsercx_cm0_gcfsm2_param_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(a) "GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_param_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Param Ctrl2 Register
 */
union bdk_gsercx_cm0_gcfsm2_param_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_param_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t settle_on_lowest_avg_en : 1;/**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t settle_on_lowest_avg_en : 1;/**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_param_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_param_ctrl2_rsvd bdk_gsercx_cm0_gcfsm2_param_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d990ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(a) bdk_gsercx_cm0_gcfsm2_param_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(a) "GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_PARAM_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_read_shadow_data_status0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Read Shadow Data Status0 Register
 */
union bdk_gsercx_cm0_gcfsm2_read_shadow_data_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_read_shadow_data_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_read_shadow_data_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_read_shadow_data_status0_rsvd bdk_gsercx_cm0_gcfsm2_read_shadow_data_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d880ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a) bdk_gsercx_cm0_gcfsm2_read_shadow_data_status0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a) "GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_read_shadow_data_status1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Read Shadow Data Status1 Register
 */
union bdk_gsercx_cm0_gcfsm2_read_shadow_data_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_read_shadow_data_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t bits_11_8             : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_11_8             : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_read_shadow_data_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_read_shadow_data_status1_rsvd bdk_gsercx_cm0_gcfsm2_read_shadow_data_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d888ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a) bdk_gsercx_cm0_gcfsm2_read_shadow_data_status1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a) "GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl0 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t len_delay_afe_en      : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_delay_afe_en      : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl0_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl1 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_1st_latch_settle_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_1st_latch_settle_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl1_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl2 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_1st_latch_settle_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_1st_latch_settle_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl2_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da10ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl3 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_latch_settle  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_latch_settle  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl3_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da18ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl4 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_cmp_7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_cmp_7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl4_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da20ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl5 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_cmp_15_8      : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_cmp_15_8      : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl5_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl6_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl6 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_coarse_bounce_afe_cmp_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_coarse_bounce_afe_cmp_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl6_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da30ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL6_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl7_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl7 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_coarse_bounce_afe_cmp_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_coarse_bounce_afe_cmp_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl7_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da38ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL7_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_gcfsm2_wait_ctrl8_rsvd
 *
 * INTERNAL: GSERC Cm0 Gcfsm2 Wait Ctrl8 Register
 */
union bdk_gsercx_cm0_gcfsm2_wait_ctrl8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_gcfsm2_wait_ctrl8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t wait_mode             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_mode             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_gcfsm2_wait_ctrl8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_gcfsm2_wait_ctrl8_rsvd bdk_gsercx_cm0_gcfsm2_wait_ctrl8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800da40ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(a) bdk_gsercx_cm0_gcfsm2_wait_ctrl8_rsvd_t
#define bustype_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(a) "GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD"
#define device_bar_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_GCFSM2_WAIT_CTRL8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_clkdiv_ctrl0
 *
 * GSERC Cm0 Pll Afe Clkdiv Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_clkdiv_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_clkdiv_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmpll_ndiv            : 7;  /**< [  6:  0](R/W/H) PLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_ndiv            : 7;  /**< [  6:  0](R/W/H) PLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_clkdiv_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_clkdiv_ctrl0 bdk_gsercx_cm0_pll_afe_clkdiv_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c818ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) bdk_gsercx_cm0_pll_afe_clkdiv_ctrl0_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) "GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_clkdiv_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Clkdiv Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_afe_clkdiv_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_clkdiv_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cmpll_fbkclk_div      : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_fbkclk_div      : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_clkdiv_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_clkdiv_ctrl2_rsvd bdk_gsercx_cm0_pll_afe_clkdiv_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c828ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(a) bdk_gsercx_cm0_pll_afe_clkdiv_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(a) "GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_CLKDIV_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmpll_spare           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_spare           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_afe_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_toggle_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_toggle_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_ctrl1_rsvd bdk_gsercx_cm0_pll_afe_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_afe_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(a) "GSERCX_CM0_PLL_AFE_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_fracn_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Fracn Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_fracn_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_fracn_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_fracdiv_en      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_fracdiv_en      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_fracn_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_fracn_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_fracn_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_fracn_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_FRACN_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_int_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Int Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_int_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_int_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cmpll_ifilt           : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t cmpll_ihiz            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll_idropi          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_idropi          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t cmpll_ihiz            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll_ifilt           : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_int_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_int_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_int_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c888ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_int_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_int_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Int Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_afe_int_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_int_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cmpll_icpcal_en       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t cmpll_icp_trim        : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_icp_trim        : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t cmpll_icpcal_en       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_int_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_int_ctrl1_rsvd bdk_gsercx_cm0_pll_afe_int_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c890ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_afe_int_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(a) "GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_int_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Int Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_afe_int_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_int_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_izero           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_izero           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_int_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_int_ctrl2_rsvd bdk_gsercx_cm0_pll_afe_int_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c898ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(a) bdk_gsercx_cm0_pll_afe_int_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(a) "GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_int_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Int Ctrl3 Register
 */
union bdk_gsercx_cm0_pll_afe_int_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_int_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmpll_ikvco           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_ikvco           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_int_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_int_ctrl3_rsvd bdk_gsercx_cm0_pll_afe_int_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) bdk_gsercx_cm0_pll_afe_int_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) "GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_INT_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Pd Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pd_cmpll_reg          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmpll              : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_cmpll              : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t pd_cmpll_reg          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_pd_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c800ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PD_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_pfd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Pfd Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_pfd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_pfd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cmpll_pfd_pw          : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_pfd_pw          : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_pfd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_pfd_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_pfd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c858ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_pfd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_pfd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Pfd Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_afe_pfd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_pfd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmpll_pfd_force_dn    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t cmpll_pfd_force_up    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll_mute            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_mute            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t cmpll_pfd_force_up    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll_pfd_force_dn    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_pfd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_pfd_ctrl1_rsvd bdk_gsercx_cm0_pll_afe_pfd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c860ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_afe_pfd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(a) "GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PFD_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_prop_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Prop Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_prop_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_prop_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmpll_pfilt           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_pfilt           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_prop_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_prop_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_prop_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c868ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_prop_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_prop_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Prop Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_afe_prop_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_prop_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_pzero           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_pzero           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_prop_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_prop_ctrl1_rsvd bdk_gsercx_cm0_pll_afe_prop_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c870ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_afe_prop_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(a) "GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_prop_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Prop Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_afe_prop_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_prop_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmpll_pkvco_gain_dn   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t cmpll_pkvco_gain_up   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_pkvco_gain_up   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t cmpll_pkvco_gain_dn   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_prop_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_prop_ctrl2_rsvd bdk_gsercx_cm0_pll_afe_prop_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c878ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(a) bdk_gsercx_cm0_pll_afe_prop_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(a) "GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_prop_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Prop Ctrl3 Register
 */
union bdk_gsercx_cm0_pll_afe_prop_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_prop_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmpll_pkvco_bias_dn   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t cmpll_pkvco_bias_up   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_pkvco_bias_up   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t cmpll_pkvco_bias_dn   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_prop_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_prop_ctrl3_rsvd bdk_gsercx_cm0_pll_afe_prop_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c880ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(a) bdk_gsercx_cm0_pll_afe_prop_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(a) "GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_PROP_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_reg_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Reg Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_reg_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_reg_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t reg_vco_trickle       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reg_vco_trim          : 3;  /**< [  3:  1](R/W/H) Reserved. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t reg_vco_trim          : 3;  /**< [  3:  1](R/W/H) Reserved. */
        uint32_t reg_vco_trickle       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_reg_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_reg_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_reg_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c810ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_reg_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_reg_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Reg Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_afe_reg_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_reg_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pd_cmpll_cntrl_reg    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cmpll_cntrl_reg_trim  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_cntrl_reg_trim  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t pd_cmpll_cntrl_reg    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_reg_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_reg_ctrl1_rsvd bdk_gsercx_cm0_pll_afe_reg_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cad0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_afe_reg_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(a) "GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_reg_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Reg Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_afe_reg_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_reg_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmpll_cntrl_reg_spare : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_1_3          : 3;
        uint32_t cmpll_cntrl_reg_bleed_en : 1;/**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_cntrl_reg_bleed_en : 1;/**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_3          : 3;
        uint32_t cmpll_cntrl_reg_spare : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_reg_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_reg_ctrl2_rsvd bdk_gsercx_cm0_pll_afe_reg_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cad8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(a) bdk_gsercx_cm0_pll_afe_reg_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(a) "GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_REG_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_rpll_ctrl0
 *
 * GSERC Cm0 Pll Afe Rpll Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_rpll_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_rpll_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmpll_ndiv_ref        : 7;  /**< [  6:  0](R/W/H) Second LCPLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 This leads to a possible division ratios from 2 to 129

                                                                 Note that LCPLL prescaler setting needs to be determined by rate1. Since there
                                                                 is only one common pre-scaler.
                                                                 The second identical programmable integer divider is intended to provide
                                                                 increased flexibility for the reference clock rate of the RPLL. The highest
                                                                 possible internal reference clock rate is best in terms of RPLL jitter
                                                                 performance. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_ndiv_ref        : 7;  /**< [  6:  0](R/W/H) Second LCPLL Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 This leads to a possible division ratios from 2 to 129

                                                                 Note that LCPLL prescaler setting needs to be determined by rate1. Since there
                                                                 is only one common pre-scaler.
                                                                 The second identical programmable integer divider is intended to provide
                                                                 increased flexibility for the reference clock rate of the RPLL. The highest
                                                                 possible internal reference clock rate is best in terms of RPLL jitter
                                                                 performance. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_rpll_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_rpll_ctrl0 bdk_gsercx_cm0_pll_afe_rpll_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_RPLL_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) bdk_gsercx_cm0_pll_afe_rpll_ctrl0_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) "GSERCX_CM0_PLL_AFE_RPLL_CTRL0"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_RPLL_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_rst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Rst Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_rst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_rst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rst_cmpll_fracn_n     : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rst_cmpll_divn_ref_n  : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmpll_clkdiv_n    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_cmpll_clkdiv_n    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rst_cmpll_divn_ref_n  : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmpll_fracn_n     : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_rst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_rst_ctrl0_rsvd bdk_gsercx_cm0_pll_afe_rst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c808ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_afe_rst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(a) "GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_RST_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Status Register
 */
union bdk_gsercx_cm0_pll_afe_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_qsample         : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_qsample         : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_status_rsvd bdk_gsercx_cm0_pll_afe_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c838ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(a) bdk_gsercx_cm0_pll_afe_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(a) "GSERCX_CM0_PLL_AFE_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_vco_buf_ctrl_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Vco Buf Ctrl Register
 */
union bdk_gsercx_cm0_pll_afe_vco_buf_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_vco_buf_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmpll_buf_bw          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_buf_bw          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_vco_buf_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_vco_buf_ctrl_rsvd bdk_gsercx_cm0_pll_afe_vco_buf_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c8e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(a) bdk_gsercx_cm0_pll_afe_vco_buf_ctrl_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(a) "GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_VCO_BUF_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_vco_ctrl0
 *
 * GSERC Cm0 Pll Afe Vco Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_afe_vco_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_vco_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll_vco_select      : 1;  /**< [  0:  0](R/W/H) Selects one of the two LC-VCO cores depending on the desired data rate

                                                                 0x0 = select VCO0
                                                                 0x1 = select VCO1

                                                                 For 30G cores, VCO0 is used for 20-24.9Gbps data rates and VCO1 for 25-30Gbps data rates.
                                                                 For 16G cores, VCO0 is used for 9.8-12.0Gbps data rates and VCO1 for 13.5-16.0Gbps data rates. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_vco_select      : 1;  /**< [  0:  0](R/W/H) Selects one of the two LC-VCO cores depending on the desired data rate

                                                                 0x0 = select VCO0
                                                                 0x1 = select VCO1

                                                                 For 30G cores, VCO0 is used for 20-24.9Gbps data rates and VCO1 for 25-30Gbps data rates.
                                                                 For 16G cores, VCO0 is used for 9.8-12.0Gbps data rates and VCO1 for 13.5-16.0Gbps data rates. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_vco_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_vco_ctrl0 bdk_gsercx_cm0_pll_afe_vco_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c848ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_VCO_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) bdk_gsercx_cm0_pll_afe_vco_ctrl0_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) "GSERCX_CM0_PLL_AFE_VCO_CTRL0"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_afe_vco_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Afe Vco Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_afe_vco_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_afe_vco_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cmpll_envdet_en       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t cmpll_intvar_zero     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cmpll_intvar_sel      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll_intvar_sel      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t cmpll_intvar_zero     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cmpll_envdet_en       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_afe_vco_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_afe_vco_ctrl1_rsvd bdk_gsercx_cm0_pll_afe_vco_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c850ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_afe_vco_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(a) "GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_AFE_VCO_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_bounce_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Bounce Register
 */
union bdk_gsercx_cm0_pll_fcal_bounce_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_bounce_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t limit                 : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t coarse_limit          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t coarse_limit          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t limit                 : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_bounce_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_bounce_rsvd bdk_gsercx_cm0_pll_fcal_bounce_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c928ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(a) bdk_gsercx_cm0_pll_fcal_bounce_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(a) "GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_BOUNCE_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_cmd_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Cmd Register
 */
union bdk_gsercx_cm0_pll_fcal_cmd_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_cmd_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ack                   : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint32_t reserved_5_6          : 2;
        uint32_t req                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t cmd_i                 : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmd_i                 : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t req                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_6          : 2;
        uint32_t ack                   : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_cmd_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_cmd_rsvd bdk_gsercx_cm0_pll_fcal_cmd_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c998ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_CMD_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(a) bdk_gsercx_cm0_pll_fcal_cmd_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(a) "GSERCX_CM0_PLL_FCAL_CMD_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_CMD_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_div_threshold_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Div Threshold 11 8 Register
 */
union bdk_gsercx_cm0_pll_fcal_div_threshold_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_div_threshold_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_div_threshold_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_div_threshold_11_8_rsvd bdk_gsercx_cm0_pll_fcal_div_threshold_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c988ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) bdk_gsercx_cm0_pll_fcal_div_threshold_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) "GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_div_threshold_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Div Threshold 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_div_threshold_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_div_threshold_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_div_threshold_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_div_threshold_7_0_rsvd bdk_gsercx_cm0_pll_fcal_div_threshold_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c980ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_div_threshold_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_dosc_max_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Dosc Max Register
 */
union bdk_gsercx_cm0_pll_fcal_dosc_max_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_dosc_max_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_dosc_max_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_dosc_max_rsvd bdk_gsercx_cm0_pll_fcal_dosc_max_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c900ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(a) bdk_gsercx_cm0_pll_fcal_dosc_max_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(a) "GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MAX_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_dosc_min_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Dosc Min Register
 */
union bdk_gsercx_cm0_pll_fcal_dosc_min_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_dosc_min_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_dosc_min_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_dosc_min_rsvd bdk_gsercx_cm0_pll_fcal_dosc_min_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c908ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(a) bdk_gsercx_cm0_pll_fcal_dosc_min_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(a) "GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DOSC_MIN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_dosc_start_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Dosc Start Register
 */
union bdk_gsercx_cm0_pll_fcal_dosc_start_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_dosc_start_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_dosc_start_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_dosc_start_rsvd bdk_gsercx_cm0_pll_fcal_dosc_start_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c910ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(a) bdk_gsercx_cm0_pll_fcal_dosc_start_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(a) "GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DOSC_START_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_dosc_step_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Dosc Step Register
 */
union bdk_gsercx_cm0_pll_fcal_dosc_step_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_dosc_step_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_dosc_step_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_dosc_step_rsvd bdk_gsercx_cm0_pll_fcal_dosc_step_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c918ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(a) bdk_gsercx_cm0_pll_fcal_dosc_step_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(a) "GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DOSC_STEP_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_downcount_delta_11_8_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Downcount Delta 11 8 Status Register
 */
union bdk_gsercx_cm0_pll_fcal_downcount_delta_11_8_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_downcount_delta_11_8_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_downcount_delta_11_8_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_downcount_delta_11_8_status_rsvd bdk_gsercx_cm0_pll_fcal_downcount_delta_11_8_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) bdk_gsercx_cm0_pll_fcal_downcount_delta_11_8_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) "GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_downcount_delta_7_0_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Downcount Delta 7 0 Status Register
 */
union bdk_gsercx_cm0_pll_fcal_downcount_delta_7_0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_downcount_delta_7_0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_downcount_delta_7_0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_downcount_delta_7_0_status_rsvd bdk_gsercx_cm0_pll_fcal_downcount_delta_7_0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) bdk_gsercx_cm0_pll_fcal_downcount_delta_7_0_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) "GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_exit_threshold_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Exit Threshold 11 8 Register
 */
union bdk_gsercx_cm0_pll_fcal_exit_threshold_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_exit_threshold_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_exit_threshold_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_exit_threshold_11_8_rsvd bdk_gsercx_cm0_pll_fcal_exit_threshold_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c978ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) bdk_gsercx_cm0_pll_fcal_exit_threshold_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) "GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_exit_threshold_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Exit Threshold 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_exit_threshold_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_exit_threshold_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_exit_threshold_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_exit_threshold_7_0_rsvd bdk_gsercx_cm0_pll_fcal_exit_threshold_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c970ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_exit_threshold_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_freq_status0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Freq Status0 Register
 */
union bdk_gsercx_cm0_pll_fcal_freq_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_freq_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ref_downcount_sign    : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t vco_downcount_sign    : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t freq_polarity         : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_polarity         : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t vco_downcount_sign    : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t ref_downcount_sign    : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_freq_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_freq_status0_rsvd bdk_gsercx_cm0_pll_fcal_freq_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(a) bdk_gsercx_cm0_pll_fcal_freq_status0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(a) "GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_freq_status1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Freq Status1 Register
 */
union bdk_gsercx_cm0_pll_fcal_freq_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_freq_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dosc_average          : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dosc_average          : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_freq_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_freq_status1_rsvd bdk_gsercx_cm0_pll_fcal_freq_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(a) bdk_gsercx_cm0_pll_fcal_freq_status1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(a) "GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_FREQ_STATUS1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_ref_decr_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Ref Decr 11 8 Register
 */
union bdk_gsercx_cm0_pll_fcal_ref_decr_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_ref_decr_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_ref_decr_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_ref_decr_11_8_rsvd bdk_gsercx_cm0_pll_fcal_ref_decr_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c968ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(a) bdk_gsercx_cm0_pll_fcal_ref_decr_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(a) "GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_ref_decr_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Ref Decr 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_ref_decr_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_ref_decr_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_ref_decr_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_ref_decr_7_0_rsvd bdk_gsercx_cm0_pll_fcal_ref_decr_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c960ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_ref_decr_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_REF_DECR_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_ref_downcount_11_8_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Ref Downcount 11 8 Status Register
 */
union bdk_gsercx_cm0_pll_fcal_ref_downcount_11_8_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_ref_downcount_11_8_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_ref_downcount_11_8_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_ref_downcount_11_8_status_rsvd bdk_gsercx_cm0_pll_fcal_ref_downcount_11_8_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) bdk_gsercx_cm0_pll_fcal_ref_downcount_11_8_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) "GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_ref_downcount_7_0_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Ref Downcount 7 0 Status Register
 */
union bdk_gsercx_cm0_pll_fcal_ref_downcount_7_0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_ref_downcount_7_0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_ref_downcount_7_0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_ref_downcount_7_0_status_rsvd bdk_gsercx_cm0_pll_fcal_ref_downcount_7_0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) bdk_gsercx_cm0_pll_fcal_ref_downcount_7_0_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) "GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_ref_load_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Ref Load 11 8 Register
 */
union bdk_gsercx_cm0_pll_fcal_ref_load_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_ref_load_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_ref_load_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_ref_load_11_8_rsvd bdk_gsercx_cm0_pll_fcal_ref_load_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c958ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(a) bdk_gsercx_cm0_pll_fcal_ref_load_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(a) "GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_ref_load_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Ref Load 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_ref_load_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_ref_load_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_ref_load_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_ref_load_7_0_rsvd bdk_gsercx_cm0_pll_fcal_ref_load_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c950ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_ref_load_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_REF_LOAD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_settle_count_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Settle Count 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_settle_count_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_settle_count_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_settle_count_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_settle_count_7_0_rsvd bdk_gsercx_cm0_pll_fcal_settle_count_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c990ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_settle_count_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_clk_div_ratio_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Clk Div Ratio Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_clk_div_ratio_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_clk_div_ratio_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_clk_div_ratio_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_clk_div_ratio_rsvd bdk_gsercx_cm0_pll_fcal_vco_clk_div_ratio_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c920ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_clk_div_ratio_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_decr_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Decr 11 8 Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_decr_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_decr_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_decr_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_decr_11_8_rsvd bdk_gsercx_cm0_pll_fcal_vco_decr_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c948ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_decr_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_decr_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Decr 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_decr_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_decr_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_decr_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_decr_7_0_rsvd bdk_gsercx_cm0_pll_fcal_vco_decr_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c940ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_decr_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_DECR_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_downcount_11_8_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Downcount 11 8 Status Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_downcount_11_8_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_downcount_11_8_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_downcount_11_8_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_downcount_11_8_status_rsvd bdk_gsercx_cm0_pll_fcal_vco_downcount_11_8_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_downcount_11_8_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_downcount_7_0_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Downcount 7 0 Status Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_downcount_7_0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_downcount_7_0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_downcount_7_0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_downcount_7_0_status_rsvd bdk_gsercx_cm0_pll_fcal_vco_downcount_7_0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c9a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_downcount_7_0_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_load_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Load 11 8 Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_load_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_load_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_load_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_load_11_8_rsvd bdk_gsercx_cm0_pll_fcal_vco_load_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c938ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_load_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fcal_vco_load_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fcal Vco Load 7 0 Register
 */
union bdk_gsercx_cm0_pll_fcal_vco_load_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fcal_vco_load_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fcal_vco_load_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fcal_vco_load_7_0_rsvd bdk_gsercx_cm0_pll_fcal_vco_load_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c930ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(a) bdk_gsercx_cm0_pll_fcal_vco_load_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(a) "GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FCAL_VCO_LOAD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl0
 *
 * GSERC Cm0 Pll Fracn Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_fracn_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fracn_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fracn_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fracn_ctrl0 bdk_gsercx_cm0_pll_fracn_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800caa0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FRACN_CTRL0(a) bdk_gsercx_cm0_pll_fracn_ctrl0_t
#define bustype_BDK_GSERCX_CM0_PLL_FRACN_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FRACN_CTRL0(a) "GSERCX_CM0_PLL_FRACN_CTRL0"
#define device_bar_BDK_GSERCX_CM0_PLL_FRACN_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FRACN_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FRACN_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl1
 *
 * GSERC Cm0 Pll Fracn Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_fracn_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fracn_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fracn_ctrl1_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fracn_ctrl1 bdk_gsercx_cm0_pll_fracn_ctrl1_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800caa8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FRACN_CTRL1(a) bdk_gsercx_cm0_pll_fracn_ctrl1_t
#define bustype_BDK_GSERCX_CM0_PLL_FRACN_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FRACN_CTRL1(a) "GSERCX_CM0_PLL_FRACN_CTRL1"
#define device_bar_BDK_GSERCX_CM0_PLL_FRACN_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FRACN_CTRL1(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FRACN_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl2
 *
 * GSERC Cm0 Pll Fracn Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_fracn_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fracn_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fracn_ctrl2_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fracn_ctrl2 bdk_gsercx_cm0_pll_fracn_ctrl2_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cab0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FRACN_CTRL2(a) bdk_gsercx_cm0_pll_fracn_ctrl2_t
#define bustype_BDK_GSERCX_CM0_PLL_FRACN_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FRACN_CTRL2(a) "GSERCX_CM0_PLL_FRACN_CTRL2"
#define device_bar_BDK_GSERCX_CM0_PLL_FRACN_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FRACN_CTRL2(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FRACN_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl3
 *
 * GSERC Cm0 Pll Fracn Ctrl3 Register
 */
union bdk_gsercx_cm0_pll_fracn_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fracn_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fracn_ctrl3_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fracn_ctrl3 bdk_gsercx_cm0_pll_fracn_ctrl3_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cab8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FRACN_CTRL3(a) bdk_gsercx_cm0_pll_fracn_ctrl3_t
#define bustype_BDK_GSERCX_CM0_PLL_FRACN_CTRL3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FRACN_CTRL3(a) "GSERCX_CM0_PLL_FRACN_CTRL3"
#define device_bar_BDK_GSERCX_CM0_PLL_FRACN_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FRACN_CTRL3(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FRACN_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fracn Ctrl4 Register
 */
union bdk_gsercx_cm0_pll_fracn_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fracn_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t fdiv_load             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_load             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fracn_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fracn_ctrl4_rsvd bdk_gsercx_cm0_pll_fracn_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cac0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(a) bdk_gsercx_cm0_pll_fracn_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(a) "GSERCX_CM0_PLL_FRACN_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FRACN_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_fracn_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Fracn Ctrl5 Register
 */
union bdk_gsercx_cm0_pll_fracn_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_fracn_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t test_in               : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t test_ctrl             : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t test_ctrl             : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t test_in               : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_fracn_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_fracn_ctrl5_rsvd bdk_gsercx_cm0_pll_fracn_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cac8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_FRACN_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(a) bdk_gsercx_cm0_pll_fracn_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(a) "GSERCX_CM0_PLL_FRACN_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_FRACN_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_lockdet_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Lockdet Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_lockdet_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_lockdet_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_lockdet_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_lockdet_ctrl0_rsvd bdk_gsercx_cm0_pll_lockdet_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca20ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_lockdet_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(a) "GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_lockdet_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Lockdet Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_lockdet_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_lockdet_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t lockdet_en            : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_2_5          : 4;
        uint32_t num_cycles_9_8        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_9_8        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_5          : 4;
        uint32_t lockdet_en            : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_lockdet_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_lockdet_ctrl1_rsvd bdk_gsercx_cm0_pll_lockdet_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_lockdet_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(a) "GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_LOCKDET_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_lockdet_status
 *
 * GSERC Cm0 Pll Lockdet Status Register
 */
union bdk_gsercx_cm0_pll_lockdet_status
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_lockdet_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
#else /* Word 0 - Little Endian */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_lockdet_status_s cn; */
};
typedef union bdk_gsercx_cm0_pll_lockdet_status bdk_gsercx_cm0_pll_lockdet_status_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca30ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_LOCKDET_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(a) bdk_gsercx_cm0_pll_lockdet_status_t
#define bustype_BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(a) "GSERCX_CM0_PLL_LOCKDET_STATUS"
#define device_bar_BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_LOCKDET_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_pll_spare0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Pll Spare0 Register
 */
union bdk_gsercx_cm0_pll_pll_spare0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_pll_spare0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_pll_spare0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_pll_spare0_rsvd bdk_gsercx_cm0_pll_pll_spare0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cae0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_PLL_SPARE0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(a) bdk_gsercx_cm0_pll_pll_spare0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(a) "GSERCX_CM0_PLL_PLL_SPARE0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_PLL_SPARE0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_pll_spare1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Pll Spare1 Register
 */
union bdk_gsercx_cm0_pll_pll_spare1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_pll_spare1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_pll_spare1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_pll_spare1_rsvd bdk_gsercx_cm0_pll_pll_spare1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800cae8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_PLL_SPARE1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(a) bdk_gsercx_cm0_pll_pll_spare1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(a) "GSERCX_CM0_PLL_PLL_SPARE1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_PLL_SPARE1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl0
 *
 * GSERC Cm0 Pll Ssc Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_ssc_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_ctrl0 bdk_gsercx_cm0_pll_ssc_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_CTRL0(a) bdk_gsercx_cm0_pll_ssc_ctrl0_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_CTRL0(a) "GSERCX_CM0_PLL_SSC_CTRL0"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl1
 *
 * GSERC Cm0 Pll Ssc Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_ssc_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
#else /* Word 0 - Little Endian */
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_ctrl1_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_ctrl1 bdk_gsercx_cm0_pll_ssc_ctrl1_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca88ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_CTRL1(a) bdk_gsercx_cm0_pll_ssc_ctrl1_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_CTRL1(a) "GSERCX_CM0_PLL_SSC_CTRL1"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_CTRL1(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl2
 *
 * GSERC Cm0 Pll Ssc Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_ssc_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
#else /* Word 0 - Little Endian */
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_ctrl2_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_ctrl2 bdk_gsercx_cm0_pll_ssc_ctrl2_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca90ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_CTRL2(a) bdk_gsercx_cm0_pll_ssc_ctrl2_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_CTRL2(a) "GSERCX_CM0_PLL_SSC_CTRL2"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_CTRL2(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_ctrl3
 *
 * GSERC Cm0 Pll Ssc Ctrl3 Register
 */
union bdk_gsercx_cm0_pll_ssc_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
#else /* Word 0 - Little Endian */
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_ctrl3_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_ctrl3 bdk_gsercx_cm0_pll_ssc_ctrl3_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_CTRL3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca98ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_CTRL3(a) bdk_gsercx_cm0_pll_ssc_ctrl3_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_CTRL3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_CTRL3(a) "GSERCX_CM0_PLL_SSC_CTRL3"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_CTRL3(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_gen_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Ssc Gen Ctrl0 Register
 */
union bdk_gsercx_cm0_pll_ssc_gen_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_gen_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t match_val_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t match_val_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_gen_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_gen_ctrl0_rsvd bdk_gsercx_cm0_pll_ssc_gen_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca48ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(a) bdk_gsercx_cm0_pll_ssc_gen_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(a) "GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_gen_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Ssc Gen Ctrl1 Register
 */
union bdk_gsercx_cm0_pll_ssc_gen_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_gen_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t match_val_15_8        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t match_val_15_8        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_gen_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_gen_ctrl1_rsvd bdk_gsercx_cm0_pll_ssc_gen_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca50ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(a) bdk_gsercx_cm0_pll_ssc_gen_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(a) "GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_gen_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Ssc Gen Ctrl2 Register
 */
union bdk_gsercx_cm0_pll_ssc_gen_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_gen_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t match_val_19_16       : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t match_val_19_16       : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_gen_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_gen_ctrl2_rsvd bdk_gsercx_cm0_pll_ssc_gen_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca58ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(a) bdk_gsercx_cm0_pll_ssc_gen_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(a) "GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_gen_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Ssc Gen Ctrl3 Register
 */
union bdk_gsercx_cm0_pll_ssc_gen_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_gen_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t inc_val_7_0           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t inc_val_7_0           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_gen_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_gen_ctrl3_rsvd bdk_gsercx_cm0_pll_ssc_gen_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca60ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(a) bdk_gsercx_cm0_pll_ssc_gen_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(a) "GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_gen_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Ssc Gen Ctrl4 Register
 */
union bdk_gsercx_cm0_pll_ssc_gen_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_gen_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t inc_val_15_8          : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t inc_val_15_8          : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_gen_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_gen_ctrl4_rsvd bdk_gsercx_cm0_pll_ssc_gen_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca68ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(a) bdk_gsercx_cm0_pll_ssc_gen_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(a) "GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_pll_ssc_gen_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Pll Ssc Gen Ctrl5 Register
 */
union bdk_gsercx_cm0_pll_ssc_gen_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_pll_ssc_gen_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ssc_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t updown_en             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t updown_en             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ssc_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_pll_ssc_gen_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_pll_ssc_gen_ctrl5_rsvd bdk_gsercx_cm0_pll_ssc_gen_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800ca70ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(a) bdk_gsercx_cm0_pll_ssc_gen_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(a) "GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_PLL_SSC_GEN_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_bias_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Bias Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_bias_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_bias_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_bias_lpf       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_bias_lpf       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_bias_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_bias_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_bias_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d0a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_bias_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_BIAS_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clkdiv_ctrl0
 *
 * GSERC Cm0 Rpll Afe Clkdiv Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmpll2_ndiv           : 7;  /**< [  6:  0](R/W/H) PLL2 Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_ndiv           : 7;  /**< [  6:  0](R/W/H) PLL2 Feedback path programmable integer divider division control.

                                                                 Division ratio = register value + 2.
                                                                 Valid range of division ratios is from 4 to 129 */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl0 bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d028ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl0_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) "GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clkdiv_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Clkdiv Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cmpll2_fbkclk_div     : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_fbkclk_div     : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl1_rsvd bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d030ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clkdiv_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Clkdiv Ctrl2 Register
 */
union bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_clkdiv_psel    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_clkdiv_psel    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl2_rsvd bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d038ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(a) bdk_gsercx_cm0_rpll_afe_clkdiv_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(a) "GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clkdiv_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Clkdiv Status Register
 */
union bdk_gsercx_cm0_rpll_afe_clkdiv_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_clkdiv_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_clkdiv_qsample : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_clkdiv_qsample : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_clkdiv_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_clkdiv_status_rsvd bdk_gsercx_cm0_rpll_afe_clkdiv_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d048ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_afe_clkdiv_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(a) "GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CLKDIV_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_clock_ctrl0
 *
 * GSERC Cm0 Rpll Afe Clock Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_clock_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_clock_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_refclk_sel     : 1;  /**< [  0:  0](R/W/H) Reference clock input source selection for RPLL.
                                                                 0 = external refclk
                                                                 1 = divided refclk from LCPLL */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_refclk_sel     : 1;  /**< [  0:  0](R/W/H) Reference clock input source selection for RPLL.
                                                                 0 = external refclk
                                                                 1 = divided refclk from LCPLL */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_clock_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_clock_ctrl0 bdk_gsercx_cm0_rpll_afe_clock_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d018ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) bdk_gsercx_cm0_rpll_afe_clock_ctrl0_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) "GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CLOCK_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_toggle_en      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_toggle_en      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d0a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_afe_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmpll2_spare          : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_spare          : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_ctrl1_rsvd bdk_gsercx_cm0_rpll_afe_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d0b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_afe_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_AFE_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_fracn_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Fracn Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_fracn_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_fracn_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_fracdiv_en     : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_fracdiv_en     : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_fracn_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_fracn_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_fracn_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d098ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_fracn_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_FRACN_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_int_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Int Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_int_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_int_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cmpll2_ifilt          : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t cmpll2_ihiz           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll2_idropi         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_idropi         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t cmpll2_ihiz           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll2_ifilt          : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_int_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_int_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_int_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d070ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_int_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_int_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Int Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_afe_int_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_int_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t cmpll2_icpcal_en      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t cmpll2_icp_trim       : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_icp_trim       : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t cmpll2_icpcal_en      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_int_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_int_ctrl1_rsvd bdk_gsercx_cm0_rpll_afe_int_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d078ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_afe_int_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_int_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Int Ctrl2 Register
 */
union bdk_gsercx_cm0_rpll_afe_int_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_int_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_izero          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_izero          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_int_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_int_ctrl2_rsvd bdk_gsercx_cm0_rpll_afe_int_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d080ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(a) bdk_gsercx_cm0_rpll_afe_int_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(a) "GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_int_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Int Ctrl3 Register
 */
union bdk_gsercx_cm0_rpll_afe_int_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_int_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmpll2_ikvco          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_ikvco          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_int_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_int_ctrl3_rsvd bdk_gsercx_cm0_rpll_afe_int_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d088ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(a) bdk_gsercx_cm0_rpll_afe_int_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(a) "GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_int_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Int Ctrl4 Register
 */
union bdk_gsercx_cm0_rpll_afe_int_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_int_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t cmpll2_v2i_gain       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t cmpll2_v2i_lpf        : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cmpll2_v2i_cap        : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_v2i_cap        : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t cmpll2_v2i_lpf        : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cmpll2_v2i_gain       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_int_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_int_ctrl4_rsvd bdk_gsercx_cm0_rpll_afe_int_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d090ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(a) bdk_gsercx_cm0_rpll_afe_int_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(a) "GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_INT_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Pd Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t pd_cmpll2             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_cmpll2             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_pd_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d000ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_PD_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_pfd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Pfd Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_pfd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_pfd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cmpll2_pfd_pw         : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_pfd_pw         : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_pfd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_pfd_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_pfd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d050ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_pfd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_pfd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Pfd Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_afe_pfd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_pfd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmpll2_pfd_force_dn   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t cmpll2_pfd_force_up   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll2_mute           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_mute           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t cmpll2_pfd_force_up   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cmpll2_pfd_force_dn   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_pfd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_pfd_ctrl1_rsvd bdk_gsercx_cm0_rpll_afe_pfd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d058ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_afe_pfd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_PFD_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_prop_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Prop Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_prop_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_prop_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cmpll2_pcp_trim       : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t cmpll2_pfilt          : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_pfilt          : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t cmpll2_pcp_trim       : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_prop_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_prop_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_prop_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d060ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_prop_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_prop_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Prop Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_afe_prop_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_prop_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cmpll2_pkvco          : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_pkvco          : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_prop_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_prop_ctrl1_rsvd bdk_gsercx_cm0_rpll_afe_prop_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d068ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_afe_prop_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_PROP_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_reg_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Reg Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_reg_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_reg_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmpll2_reg_trickle    : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t cmpll2_reg_trim       : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_reg_trim       : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t cmpll2_reg_trickle    : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_reg_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_reg_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_reg_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d010ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_reg_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_REG_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_rst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Rst Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_rst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_rst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rst_cmpll2_div4p125_n : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rst_cmpll2_fracn_n    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmpll2_clkdiv_n   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_cmpll2_clkdiv_n   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rst_cmpll2_fracn_n    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmpll2_div4p125_n : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_rst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_rst_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_rst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d008ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_rst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_RST_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Status Register
 */
union bdk_gsercx_cm0_rpll_afe_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmpll2_qsample        : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_qsample        : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_status_rsvd bdk_gsercx_cm0_rpll_afe_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d040ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_afe_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(a) "GSERCX_CM0_RPLL_AFE_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_afe_vco_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Afe Vco Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_afe_vco_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_afe_vco_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t cmpll2_bias_trim      : 5;  /**< [  5:  1](R/W/H) Reserved. */
        uint32_t cmpll2_vco_kick       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmpll2_vco_kick       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t cmpll2_bias_trim      : 5;  /**< [  5:  1](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_afe_vco_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_afe_vco_ctrl0_rsvd bdk_gsercx_cm0_rpll_afe_vco_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d020ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_afe_vco_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_AFE_VCO_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_bounce_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Bounce Register
 */
union bdk_gsercx_cm0_rpll_fcal_bounce_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_bounce_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t limit                 : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t coarse_limit          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t coarse_limit          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t limit                 : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_bounce_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_bounce_rsvd bdk_gsercx_cm0_rpll_fcal_bounce_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d128ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(a) bdk_gsercx_cm0_rpll_fcal_bounce_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(a) "GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_BOUNCE_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_div_threshold_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Div Threshold 11 8 Register
 */
union bdk_gsercx_cm0_rpll_fcal_div_threshold_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_div_threshold_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_div_threshold_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_div_threshold_11_8_rsvd bdk_gsercx_cm0_rpll_fcal_div_threshold_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d188ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) bdk_gsercx_cm0_rpll_fcal_div_threshold_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_div_threshold_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Div Threshold 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_div_threshold_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_div_threshold_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_div_threshold_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_div_threshold_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_div_threshold_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d180ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_div_threshold_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DIV_THRESHOLD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_dosc_max_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Dosc Max Register
 */
union bdk_gsercx_cm0_rpll_fcal_dosc_max_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_dosc_max_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_dosc_max_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_dosc_max_rsvd bdk_gsercx_cm0_rpll_fcal_dosc_max_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d100ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(a) bdk_gsercx_cm0_rpll_fcal_dosc_max_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MAX_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_dosc_min_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Dosc Min Register
 */
union bdk_gsercx_cm0_rpll_fcal_dosc_min_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_dosc_min_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_dosc_min_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_dosc_min_rsvd bdk_gsercx_cm0_rpll_fcal_dosc_min_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d108ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(a) bdk_gsercx_cm0_rpll_fcal_dosc_min_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_MIN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_dosc_start_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Dosc Start Register
 */
union bdk_gsercx_cm0_rpll_fcal_dosc_start_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_dosc_start_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_dosc_start_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_dosc_start_rsvd bdk_gsercx_cm0_rpll_fcal_dosc_start_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d110ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(a) bdk_gsercx_cm0_rpll_fcal_dosc_start_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_START_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_dosc_step_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Dosc Step Register
 */
union bdk_gsercx_cm0_rpll_fcal_dosc_step_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_dosc_step_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_dosc_step_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_dosc_step_rsvd bdk_gsercx_cm0_rpll_fcal_dosc_step_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d118ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(a) bdk_gsercx_cm0_rpll_fcal_dosc_step_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DOSC_STEP_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Downcount Delta 11 8 Status Register
 */
union bdk_gsercx_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd bdk_gsercx_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_fcal_downcount_delta_11_8_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_11_8_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Downcount Delta 7 0 Status Register
 */
union bdk_gsercx_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd bdk_gsercx_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_fcal_downcount_delta_7_0_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) "GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_DOWNCOUNT_DELTA_7_0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_exit_threshold_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Exit Threshold 11 8 Register
 */
union bdk_gsercx_cm0_rpll_fcal_exit_threshold_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_exit_threshold_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_exit_threshold_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_exit_threshold_11_8_rsvd bdk_gsercx_cm0_rpll_fcal_exit_threshold_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d178ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) bdk_gsercx_cm0_rpll_fcal_exit_threshold_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) "GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_exit_threshold_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Exit Threshold 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_exit_threshold_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_exit_threshold_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_exit_threshold_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_exit_threshold_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_exit_threshold_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d170ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_exit_threshold_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_EXIT_THRESHOLD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_freq_status0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Freq Status0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_freq_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_freq_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ref_downcount_sign    : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t vco_downcount_sign    : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t freq_polarity         : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_polarity         : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t vco_downcount_sign    : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t ref_downcount_sign    : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_freq_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_freq_status0_rsvd bdk_gsercx_cm0_rpll_fcal_freq_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_freq_status0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_FREQ_STATUS0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_ref_decr_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Ref Decr 11 8 Register
 */
union bdk_gsercx_cm0_rpll_fcal_ref_decr_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_ref_decr_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_ref_decr_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_ref_decr_11_8_rsvd bdk_gsercx_cm0_rpll_fcal_ref_decr_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d168ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(a) bdk_gsercx_cm0_rpll_fcal_ref_decr_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(a) "GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_ref_decr_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Ref Decr 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_ref_decr_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_ref_decr_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_ref_decr_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_ref_decr_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_ref_decr_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d160ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_ref_decr_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_REF_DECR_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Ref Downcount 11 8 Status Register
 */
union bdk_gsercx_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd bdk_gsercx_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_fcal_ref_downcount_11_8_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) "GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_11_8_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Ref Downcount 7 0 Status Register
 */
union bdk_gsercx_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd bdk_gsercx_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_fcal_ref_downcount_7_0_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) "GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_REF_DOWNCOUNT_7_0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_ref_load_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Ref Load 11 8 Register
 */
union bdk_gsercx_cm0_rpll_fcal_ref_load_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_ref_load_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_ref_load_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_ref_load_11_8_rsvd bdk_gsercx_cm0_rpll_fcal_ref_load_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d158ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(a) bdk_gsercx_cm0_rpll_fcal_ref_load_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(a) "GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_ref_load_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Ref Load 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_ref_load_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_ref_load_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_ref_load_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_ref_load_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_ref_load_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d150ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_ref_load_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_REF_LOAD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_settle_count_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Settle Count 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_settle_count_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_settle_count_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_settle_count_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_settle_count_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_settle_count_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d190ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_settle_count_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_SETTLE_COUNT_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_clk_div_ratio_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Clk Div Ratio Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_clk_div_ratio_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_clk_div_ratio_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_clk_div_ratio_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_clk_div_ratio_rsvd bdk_gsercx_cm0_rpll_fcal_vco_clk_div_ratio_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d120ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_clk_div_ratio_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_CLK_DIV_RATIO_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_decr_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Decr 11 8 Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_decr_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_decr_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_decr_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_decr_11_8_rsvd bdk_gsercx_cm0_rpll_fcal_vco_decr_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d148ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_decr_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_decr_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Decr 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_decr_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_decr_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_decr_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_decr_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_vco_decr_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d140ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_decr_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DECR_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Downcount 11 8 Status Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd bdk_gsercx_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_downcount_11_8_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_11_8_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Downcount 7 0 Status Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd bdk_gsercx_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d1a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_downcount_7_0_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_DOWNCOUNT_7_0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_load_11_8_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Load 11 8 Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_load_11_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_load_11_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_load_11_8_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_load_11_8_rsvd bdk_gsercx_cm0_rpll_fcal_vco_load_11_8_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d138ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_load_11_8_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_11_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fcal_vco_load_7_0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fcal Vco Load 7 0 Register
 */
union bdk_gsercx_cm0_rpll_fcal_vco_load_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fcal_vco_load_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fcal_vco_load_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fcal_vco_load_7_0_rsvd bdk_gsercx_cm0_rpll_fcal_vco_load_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d130ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(a) bdk_gsercx_cm0_rpll_fcal_vco_load_7_0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(a) "GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FCAL_VCO_LOAD_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl0
 *
 * GSERC Cm0 Rpll Fracn Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_fracn_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fracn_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Fractional division and SSC enable. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fracn_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fracn_ctrl0 bdk_gsercx_cm0_rpll_fracn_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(a) bdk_gsercx_cm0_rpll_fracn_ctrl0_t
#define bustype_BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(a) "GSERCX_CM0_RPLL_FRACN_CTRL0"
#define device_bar_BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FRACN_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl1
 *
 * GSERC Cm0 Rpll Fracn Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_fracn_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fracn_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_7_0              : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 7-0 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fracn_ctrl1_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fracn_ctrl1 bdk_gsercx_cm0_rpll_fracn_ctrl1_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(a) bdk_gsercx_cm0_rpll_fracn_ctrl1_t
#define bustype_BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(a) "GSERCX_CM0_RPLL_FRACN_CTRL1"
#define device_bar_BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FRACN_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl2
 *
 * GSERC Cm0 Rpll Fracn Ctrl2 Register
 */
union bdk_gsercx_cm0_rpll_fracn_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fracn_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_15_8             : 8;  /**< [  7:  0](R/W/H) Fractional division value bits 15-8 L of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fracn_ctrl2_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fracn_ctrl2 bdk_gsercx_cm0_rpll_fracn_ctrl2_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(a) bdk_gsercx_cm0_rpll_fracn_ctrl2_t
#define bustype_BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(a) "GSERCX_CM0_RPLL_FRACN_CTRL2"
#define device_bar_BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FRACN_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl3
 *
 * GSERC Cm0 Rpll Fracn Ctrl3 Register
 */
union bdk_gsercx_cm0_rpll_fracn_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fracn_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_19_16            : 4;  /**< [  3:  0](R/W/H) Fractional division value 19-16 of 20-bit value.
                                                                 Value is a 2's compliment number.
                                                                 Note that if SSC is also enabled then this is the center frequency around which
                                                                 SSC modulation occurs. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fracn_ctrl3_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fracn_ctrl3 bdk_gsercx_cm0_rpll_fracn_ctrl3_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(a) bdk_gsercx_cm0_rpll_fracn_ctrl3_t
#define bustype_BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(a) "GSERCX_CM0_RPLL_FRACN_CTRL3"
#define device_bar_BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FRACN_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fracn Ctrl4 Register
 */
union bdk_gsercx_cm0_rpll_fracn_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fracn_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t fdiv_load             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t fdiv_load             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fracn_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fracn_ctrl4_rsvd bdk_gsercx_cm0_rpll_fracn_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(a) bdk_gsercx_cm0_rpll_fracn_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(a) "GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FRACN_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_fracn_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Fracn Ctrl5 Register
 */
union bdk_gsercx_cm0_rpll_fracn_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_fracn_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t test_in               : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t test_ctrl             : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t test_ctrl             : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t test_in               : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_fracn_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_fracn_ctrl5_rsvd bdk_gsercx_cm0_rpll_fracn_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(a) bdk_gsercx_cm0_rpll_fracn_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(a) "GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_FRACN_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_lockdet_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Lockdet Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_lockdet_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_lockdet_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_lockdet_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_lockdet_ctrl0_rsvd bdk_gsercx_cm0_rpll_lockdet_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d220ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_lockdet_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_lockdet_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Lockdet Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_lockdet_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_lockdet_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t lockdet_en            : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_2_5          : 4;
        uint32_t num_cycles_9_8        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_9_8        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_5          : 4;
        uint32_t lockdet_en            : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_lockdet_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_lockdet_ctrl1_rsvd bdk_gsercx_cm0_rpll_lockdet_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d228ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_lockdet_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_LOCKDET_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_lockdet_status
 *
 * GSERC Cm0 Rpll Lockdet Status Register
 */
union bdk_gsercx_cm0_rpll_lockdet_status
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_lockdet_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL2 lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
#else /* Word 0 - Little Endian */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) PLL2 lock detection status signal
                                                                 0 = lock detection logic indicates that PLL is not locked
                                                                 1 = lock detection logic indicates that PLL is locked */
        uint32_t toggled               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_lockdet_status_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_lockdet_status bdk_gsercx_cm0_rpll_lockdet_status_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d230ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_LOCKDET_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) bdk_gsercx_cm0_rpll_lockdet_status_t
#define bustype_BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) "GSERCX_CM0_RPLL_LOCKDET_STATUS"
#define device_bar_BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_LOCKDET_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_pll_spare0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Pll Spare0 Register
 */
union bdk_gsercx_cm0_rpll_pll_spare0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_pll_spare0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_pll_spare0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_pll_spare0_rsvd bdk_gsercx_cm0_rpll_pll_spare0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_PLL_SPARE0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(a) bdk_gsercx_cm0_rpll_pll_spare0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(a) "GSERCX_CM0_RPLL_PLL_SPARE0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_PLL_SPARE0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_pll_spare1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Pll Spare1 Register
 */
union bdk_gsercx_cm0_rpll_pll_spare1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_pll_spare1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_pll_spare1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_pll_spare1_rsvd bdk_gsercx_cm0_rpll_pll_spare1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d2e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_PLL_SPARE1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(a) bdk_gsercx_cm0_rpll_pll_spare1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(a) "GSERCX_CM0_RPLL_PLL_SPARE1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_PLL_SPARE1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl0
 *
 * GSERC Cm0 Rpll Ssc Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_ssc_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Spread Spectrum Clocking SSC enable
                                                                 Note that to enable SSC the fractional division enable also needs to be asserted
                                                                 fracn_ctrl0 field en needs to be asserted. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_ctrl0 bdk_gsercx_cm0_rpll_ssc_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d280ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_CTRL0(a) bdk_gsercx_cm0_rpll_ssc_ctrl0_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_CTRL0(a) "GSERCX_CM0_RPLL_SSC_CTRL0"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl1
 *
 * GSERC Cm0 Rpll Ssc Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_ssc_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
#else /* Word 0 - Little Endian */
        uint32_t magnitude             : 8;  /**< [  7:  0](R/W/H) SSC modulation magnitude in units of Parts Per Million PPM.
                                                                 Register value is intepreted as PPM magnitude in steps of 20ppm 1LSB = 20ppm. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_ctrl1_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_ctrl1 bdk_gsercx_cm0_rpll_ssc_ctrl1_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d288ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_CTRL1(a) bdk_gsercx_cm0_rpll_ssc_ctrl1_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_CTRL1(a) "GSERCX_CM0_RPLL_SSC_CTRL1"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_CTRL1(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl2
 *
 * GSERC Cm0 Rpll Ssc Ctrl2 Register
 */
union bdk_gsercx_cm0_rpll_ssc_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
#else /* Word 0 - Little Endian */
        uint32_t freq                  : 8;  /**< [  7:  0](R/W/H) SSC modulation frequency.
                                                                 Sets the SSC modulation frequency in steps of 250Hz 1LSB = 250Hz. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_ctrl2_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_ctrl2 bdk_gsercx_cm0_rpll_ssc_ctrl2_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d290ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_CTRL2(a) bdk_gsercx_cm0_rpll_ssc_ctrl2_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_CTRL2(a) "GSERCX_CM0_RPLL_SSC_CTRL2"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_CTRL2(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_ctrl3
 *
 * GSERC Cm0 Rpll Ssc Ctrl3 Register
 */
union bdk_gsercx_cm0_rpll_ssc_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
#else /* Word 0 - Little Endian */
        uint32_t updown                : 1;  /**< [  0:  0](R/W/H) SSC modulation spreading type.
                                                                 0 = down spreading only SSC modulation is only below the center frequency
                                                                 1 = both up and down spreading SSC modulation spreads equally above and below the center frequency */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_ctrl3_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_ctrl3 bdk_gsercx_cm0_rpll_ssc_ctrl3_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_CTRL3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d298ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_CTRL3(a) bdk_gsercx_cm0_rpll_ssc_ctrl3_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_CTRL3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_CTRL3(a) "GSERCX_CM0_RPLL_SSC_CTRL3"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_CTRL3(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_gen_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Ssc Gen Ctrl0 Register
 */
union bdk_gsercx_cm0_rpll_ssc_gen_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t match_val_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t match_val_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_gen_ctrl0_rsvd bdk_gsercx_cm0_rpll_ssc_gen_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d248ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(a) bdk_gsercx_cm0_rpll_ssc_gen_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(a) "GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_gen_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Ssc Gen Ctrl1 Register
 */
union bdk_gsercx_cm0_rpll_ssc_gen_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t match_val_15_8        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t match_val_15_8        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_gen_ctrl1_rsvd bdk_gsercx_cm0_rpll_ssc_gen_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d250ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(a) bdk_gsercx_cm0_rpll_ssc_gen_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(a) "GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_gen_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Ssc Gen Ctrl2 Register
 */
union bdk_gsercx_cm0_rpll_ssc_gen_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t match_val_19_16       : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t match_val_19_16       : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_gen_ctrl2_rsvd bdk_gsercx_cm0_rpll_ssc_gen_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d258ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(a) bdk_gsercx_cm0_rpll_ssc_gen_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(a) "GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_gen_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Ssc Gen Ctrl3 Register
 */
union bdk_gsercx_cm0_rpll_ssc_gen_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t inc_val_7_0           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t inc_val_7_0           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_gen_ctrl3_rsvd bdk_gsercx_cm0_rpll_ssc_gen_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d260ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(a) bdk_gsercx_cm0_rpll_ssc_gen_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(a) "GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_gen_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Ssc Gen Ctrl4 Register
 */
union bdk_gsercx_cm0_rpll_ssc_gen_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t inc_val_15_8          : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t inc_val_15_8          : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_gen_ctrl4_rsvd bdk_gsercx_cm0_rpll_ssc_gen_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d268ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(a) bdk_gsercx_cm0_rpll_ssc_gen_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(a) "GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_rpll_ssc_gen_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Rpll Ssc Gen Ctrl5 Register
 */
union bdk_gsercx_cm0_rpll_ssc_gen_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ssc_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t updown_en             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t updown_en             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ssc_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_rpll_ssc_gen_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_rpll_ssc_gen_ctrl5_rsvd bdk_gsercx_cm0_rpll_ssc_gen_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800d270ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(a) bdk_gsercx_cm0_rpll_ssc_gen_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(a) "GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_RPLL_SSC_GEN_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_bias_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Bias Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_bias_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_bias_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t bias_icvcal_en        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t bias_icccal_en        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_icccal_en        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t bias_icvcal_en        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_bias_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_bias_ctrl0_rsvd bdk_gsercx_cm0_top_afe_bias_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c038ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(a) bdk_gsercx_cm0_top_afe_bias_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(a) "GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_bias_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Bias Ctrl1 Register
 */
union bdk_gsercx_cm0_top_afe_bias_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_bias_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t bias_icv_trim         : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_icv_trim         : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_bias_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_bias_ctrl1_rsvd bdk_gsercx_cm0_top_afe_bias_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c040ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(a) bdk_gsercx_cm0_top_afe_bias_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(a) "GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_bias_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Bias Ctrl2 Register
 */
union bdk_gsercx_cm0_top_afe_bias_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_bias_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t bias_bgstart_byp      : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t bias_icc_trim         : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_icc_trim         : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t bias_bgstart_byp      : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_bias_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_bias_ctrl2_rsvd bdk_gsercx_cm0_top_afe_bias_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c048ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(a) bdk_gsercx_cm0_top_afe_bias_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(a) "GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_bias_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Bias Ctrl3 Register
 */
union bdk_gsercx_cm0_top_afe_bias_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_bias_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t bias_icc_rext         : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_icc_rext         : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_bias_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_bias_ctrl3_rsvd bdk_gsercx_cm0_top_afe_bias_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c050ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(a) bdk_gsercx_cm0_top_afe_bias_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(a) "GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_bias_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Bias Ctrl4 Register
 */
union bdk_gsercx_cm0_top_afe_bias_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_bias_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bias_spare            : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_spare            : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_bias_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_bias_ctrl4_rsvd bdk_gsercx_cm0_top_afe_bias_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c058ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(a) bdk_gsercx_cm0_top_afe_bias_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(a) "GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_BIAS_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl0
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmcp_clkdiv_pll_div2  : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL post-divider division control. This division setting
                                                                 applies to all PLL aka rate1, LCPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL post-divider division control. This division setting
                                                                 applies to all PLL aka rate1, LCPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
        uint32_t cmcp_clkdiv_pll_div2  : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl0 bdk_gsercx_cm0_top_afe_cmcp_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c100ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl0_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL0"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl1
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl1 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_clkdiv_plldiv    : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_plldiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll       : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL word clock to DPL programmable divider division control.
                                                                 This divider affecs the output clock clk_pll.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv_pll       : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL word clock to DPL programmable divider division control.
                                                                 This divider affecs the output clock clk_pll.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_plldiv    : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_plldiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl1_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl1 bdk_gsercx_cm0_top_afe_cmcp_ctrl1_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c108ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl1_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL1"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl2
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl2 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cmcp_clkdiv_pll3_div2 : 1;  /**< [  3:  3](R/W/H) CMU clock path CMCP PLL3 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv_pll2_div2 : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL2 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv2          : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL2 post-divider division control. This division setting
                                                                 applies to all PLL2 aka rate2, RPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv2          : 2;  /**< [  1:  0](R/W/H) CMU clock path CMCP PLL2 post-divider division control. This division setting
                                                                 applies to all PLL2 aka rate2, RPLL clock paths.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = reserved */
        uint32_t cmcp_clkdiv_pll2_div2 : 1;  /**< [  2:  2](R/W/H) CMU clock path CMCP PLL2 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t cmcp_clkdiv_pll3_div2 : 1;  /**< [  3:  3](R/W/H) CMU clock path CMCP PLL3 word clock to DPL DIV1/DIV2 pre-scaler division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl2_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl2 bdk_gsercx_cm0_top_afe_cmcp_ctrl2_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c110ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl2_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL2"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl3
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl3 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_clkdiv_pll2div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll2      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL2 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll2.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv_pll2      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL2 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll2.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16 default for 32-bit parallel interface
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll2div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20 default for 40-bit parallel interface via gearbox
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl3_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl3 bdk_gsercx_cm0_top_afe_cmcp_ctrl3_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c118ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl3_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL3"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl4
 *
 * GSERC Cm0 Top Afe Cmcp Ctrl4 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_clkdiv_pll3div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV5
                                                                 0x1 = DIV10 default for 40-bit parallel interface via gearbox
                                                                 0x2 = DIV2.5
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll3      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL3 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll3.
                                                                 0x0 = DIV4
                                                                 0x1 = DIV8 default for 32-bit parallel interface
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_clkdiv_pll3      : 4;  /**< [  3:  0](R/W/H) CMU clock path CMCP PLL3 word clock to DPL programmable divider division
                                                                 control. This divider affecs the output clock clk_pll3.
                                                                 0x0 = DIV4
                                                                 0x1 = DIV8 default for 32-bit parallel interface
                                                                 others = reserved */
        uint32_t cmcp_clkdiv_pll3div   : 4;  /**< [  7:  4](R/W/H) CMU clock path CMCP PLL2 word clock to DPL additional programmable divider
                                                                 division control. This divider affecs the output clock clk_pll2div.
                                                                 0x0 = DIV5
                                                                 0x1 = DIV10 default for 40-bit parallel interface via gearbox
                                                                 0x2 = DIV2.5
                                                                 others = reserved */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl4_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl4 bdk_gsercx_cm0_top_afe_cmcp_ctrl4_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c120ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl4_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL4"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Cmcp Ctrl5 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmcp_txclk_swing      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_txclk_swing      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl5_rsvd bdk_gsercx_cm0_top_afe_cmcp_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c128ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_cmcp_ctrl6_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Cmcp Ctrl6 Register
 */
union bdk_gsercx_cm0_top_afe_cmcp_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_cmcp_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cmcp_tx2clk_swing     : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_tx2clk_swing     : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_cmcp_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_cmcp_ctrl6_rsvd bdk_gsercx_cm0_top_afe_cmcp_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c130ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(a) bdk_gsercx_cm0_top_afe_cmcp_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(a) "GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_CMCP_CTRL6_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_misc_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Misc Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_misc_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_misc_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cmcp_spare            : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_spare            : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_misc_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_misc_ctrl0_rsvd bdk_gsercx_cm0_top_afe_misc_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c138ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(a) bdk_gsercx_cm0_top_afe_misc_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(a) "GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_MISC_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Pd Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pd_refclk             : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t pd_bias               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t pd_bias_icc           : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_bias_icv           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t pd_bias_icv           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_bias_icc           : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_bias               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t pd_refclk             : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_pd_ctrl0_rsvd bdk_gsercx_cm0_top_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c000ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(a) bdk_gsercx_cm0_top_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(a) "GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_pd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Pd Ctrl1 Register
 */
union bdk_gsercx_cm0_top_afe_pd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_pd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_cmcp_txclk_right   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_cmcp_txclk_left    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmcp               : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_cmcp               : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t pd_cmcp_txclk_left    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmcp_txclk_right   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_pd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_pd_ctrl1_rsvd bdk_gsercx_cm0_top_afe_pd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c008ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(a) bdk_gsercx_cm0_top_afe_pd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(a) "GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_pd_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Pd Ctrl2 Register
 */
union bdk_gsercx_cm0_top_afe_pd_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_pd_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_cmcp_tx2clk_right  : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_cmcp_tx2clk_left   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmcp_pll2          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_cmcp_pll2          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t pd_cmcp_tx2clk_left   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmcp_tx2clk_right  : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_pd_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_pd_ctrl2_rsvd bdk_gsercx_cm0_top_afe_pd_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c010ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(a) bdk_gsercx_cm0_top_afe_pd_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(a) "GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_pd_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Pd Ctrl3 Register
 */
union bdk_gsercx_cm0_top_afe_pd_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_pd_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_cmcp_tx3clk_right  : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_cmcp_tx3clk_left   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmcp_pll3          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_cmcp_pll3          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t pd_cmcp_tx3clk_left   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_cmcp_tx3clk_right  : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_pd_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_pd_ctrl3_rsvd bdk_gsercx_cm0_top_afe_pd_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c018ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(a) bdk_gsercx_cm0_top_afe_pd_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(a) "GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_PD_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_refclk_ctrl0
 *
 * GSERC Cm0 Top Afe Refclk Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_refclk_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_refclk_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t refclk_dpl_div        : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t refclk_div            : 2;  /**< [  1:  0](R/W/H) Reference clock input buffer division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV3
                                                                 0x3 = DIV4 */
#else /* Word 0 - Little Endian */
        uint32_t refclk_div            : 2;  /**< [  1:  0](R/W/H) Reference clock input buffer division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV3
                                                                 0x3 = DIV4 */
        uint32_t refclk_dpl_div        : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_refclk_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_refclk_ctrl0 bdk_gsercx_cm0_top_afe_refclk_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c0d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_REFCLK_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) bdk_gsercx_cm0_top_afe_refclk_ctrl0_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) "GSERCX_CM0_TOP_AFE_REFCLK_CTRL0"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_refclk_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Refclk Ctrl1 Register
 */
union bdk_gsercx_cm0_top_afe_refclk_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_refclk_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t refclk_term           : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t refclk_term           : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_refclk_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_refclk_ctrl1_rsvd bdk_gsercx_cm0_top_afe_refclk_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c0d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(a) bdk_gsercx_cm0_top_afe_refclk_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(a) "GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_refclk_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Refclk Ctrl2 Register
 */
union bdk_gsercx_cm0_top_afe_refclk_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_refclk_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t refclk_spare          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t refclk_spare          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_refclk_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_refclk_ctrl2_rsvd bdk_gsercx_cm0_top_afe_refclk_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c0f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(a) bdk_gsercx_cm0_top_afe_refclk_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(a) "GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_REFCLK_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_rst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Rst Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_rst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_rst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rst_cmcp_clk_plldiv_n : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmcp_clk_pll_n    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_cmcp_clk_pll_n    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rst_cmcp_clk_plldiv_n : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_rst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_rst_ctrl0_rsvd bdk_gsercx_cm0_top_afe_rst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c020ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(a) bdk_gsercx_cm0_top_afe_rst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(a) "GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_rst_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Rst Ctrl1 Register
 */
union bdk_gsercx_cm0_top_afe_rst_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_rst_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rst_cmcp_clk_pll2div_n : 1; /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmcp_clk_pll2_n   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_cmcp_clk_pll2_n   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rst_cmcp_clk_pll2div_n : 1; /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_rst_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_rst_ctrl1_rsvd bdk_gsercx_cm0_top_afe_rst_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c028ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(a) bdk_gsercx_cm0_top_afe_rst_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(a) "GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_rst_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Rst Ctrl2 Register
 */
union bdk_gsercx_cm0_top_afe_rst_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_rst_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rst_cmcp_clk_pll3div_n : 1; /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_cmcp_clk_pll3_n   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_cmcp_clk_pll3_n   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rst_cmcp_clk_pll3div_n : 1; /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_rst_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_rst_ctrl2_rsvd bdk_gsercx_cm0_top_afe_rst_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c030ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(a) bdk_gsercx_cm0_top_afe_rst_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(a) "GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_RST_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_toggle_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Toggle Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_toggle_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_toggle_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t cmcp_toggle_en        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t clk_toggle_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t clk_toggle_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t cmcp_toggle_en        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_toggle_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_toggle_ctrl0_rsvd bdk_gsercx_cm0_top_afe_toggle_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c148ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(a) bdk_gsercx_cm0_top_afe_toggle_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(a) "GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TOGGLE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_tstclk_ctrl0
 *
 * GSERC Cm0 Top Afe Tstclk Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_tstclk_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_tstclk_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cmcp_tstclk_div       : 4;  /**< [  6:  3](R/W/H) CMU test clock path division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t cmcp_tstclk_mux       : 3;  /**< [  2:  0](R/W/H) CMU test clock selection. Further descriptions will be provided in future updates.
                                                                 0x0 = power down test clock path
                                                                 0x1 = input refclk to PLL i.e., LCPLL
                                                                 0x2 = input refclk to PLL2 i.e. RPLL
                                                                 0x3 = life clock
                                                                 0x4 = clk_pll
                                                                 0x5 = clk_plldiv
                                                                 0x6 = clk_pll2
                                                                 0x7 = clk_pll2div */
#else /* Word 0 - Little Endian */
        uint32_t cmcp_tstclk_mux       : 3;  /**< [  2:  0](R/W/H) CMU test clock selection. Further descriptions will be provided in future updates.
                                                                 0x0 = power down test clock path
                                                                 0x1 = input refclk to PLL i.e., LCPLL
                                                                 0x2 = input refclk to PLL2 i.e. RPLL
                                                                 0x3 = life clock
                                                                 0x4 = clk_pll
                                                                 0x5 = clk_plldiv
                                                                 0x6 = clk_pll2
                                                                 0x7 = clk_pll2div */
        uint32_t cmcp_tstclk_div       : 4;  /**< [  6:  3](R/W/H) CMU test clock path division control.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 others = reserved */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_tstclk_ctrl0_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_tstclk_ctrl0 bdk_gsercx_cm0_top_afe_tstclk_ctrl0_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c150ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) bdk_gsercx_cm0_top_afe_tstclk_ctrl0_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) "GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TSTCLK_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_txtc_ctrl0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Txtc Ctrl0 Register
 */
union bdk_gsercx_cm0_top_afe_txtc_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_txtc_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txtc_caln_x1_fixed    : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txtc_caln_x1          : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txtc_caln_x1          : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txtc_caln_x1_fixed    : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_txtc_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_txtc_ctrl0_rsvd bdk_gsercx_cm0_top_afe_txtc_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c180ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(a) bdk_gsercx_cm0_top_afe_txtc_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(a) "GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_txtc_ctrl1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Txtc Ctrl1 Register
 */
union bdk_gsercx_cm0_top_afe_txtc_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_txtc_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t txtc_caln_xp5_fixed   : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txtc_caln_x2          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txtc_caln_x2          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txtc_caln_xp5_fixed   : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_txtc_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_txtc_ctrl1_rsvd bdk_gsercx_cm0_top_afe_txtc_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c188ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(a) bdk_gsercx_cm0_top_afe_txtc_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(a) "GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_txtc_ctrl2_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Txtc Ctrl2 Register
 */
union bdk_gsercx_cm0_top_afe_txtc_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_txtc_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txtc_calp_x1_fixed    : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txtc_calp_x1          : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txtc_calp_x1          : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txtc_calp_x1_fixed    : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_txtc_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_txtc_ctrl2_rsvd bdk_gsercx_cm0_top_afe_txtc_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c190ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(a) bdk_gsercx_cm0_top_afe_txtc_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(a) "GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_txtc_ctrl3_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Txtc Ctrl3 Register
 */
union bdk_gsercx_cm0_top_afe_txtc_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_txtc_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t txtc_calp_xp5_fixed   : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txtc_calp_x2          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txtc_calp_x2          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txtc_calp_xp5_fixed   : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_txtc_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_txtc_ctrl3_rsvd bdk_gsercx_cm0_top_afe_txtc_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c198ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(a) bdk_gsercx_cm0_top_afe_txtc_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(a) "GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_txtc_ctrl4_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Txtc Ctrl4 Register
 */
union bdk_gsercx_cm0_top_afe_txtc_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_txtc_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txtc_rdac_ncal        : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txtc_rdac_ncal        : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_txtc_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_txtc_ctrl4_rsvd bdk_gsercx_cm0_top_afe_txtc_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c1a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(a) bdk_gsercx_cm0_top_afe_txtc_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(a) "GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_afe_txtc_ctrl5_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Afe Txtc Ctrl5 Register
 */
union bdk_gsercx_cm0_top_afe_txtc_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_afe_txtc_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txtc_rdac_pcal        : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txtc_rdac_pcal        : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_afe_txtc_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_afe_txtc_ctrl5_rsvd bdk_gsercx_cm0_top_afe_txtc_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c1a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(a) bdk_gsercx_cm0_top_afe_txtc_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(a) "GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_AFE_TXTC_CTRL5_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_ctrl_ovr1
 *
 * GSERC Cm0 Top Cmu Ctrl Ovr1 Register
 */
union bdk_gsercx_cm0_top_cmu_ctrl_ovr1
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_cmu_ctrl_ovr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for HSS_CM0_IDDQ_I cmu_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for HSS_CM0_RST_N_I cmu_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for HSS_CM0_PD_I[1:0] cmu_pd_i[1:0].  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for cmu_pd_i[1:0] and cmu_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for cmu_pd_i[1:0] and cmu_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for HSS_CM0_PD_I[1:0] cmu_pd_i[1:0].  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for HSS_CM0_RST_N_I cmu_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for HSS_CM0_IDDQ_I cmu_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_cmu_ctrl_ovr1_s cn; */
};
typedef union bdk_gsercx_cm0_top_cmu_ctrl_ovr1 bdk_gsercx_cm0_top_cmu_ctrl_ovr1_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c460ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_CMU_CTRL_OVR1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) bdk_gsercx_cm0_top_cmu_ctrl_ovr1_t
#define bustype_BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) "GSERCX_CM0_TOP_CMU_CTRL_OVR1"
#define device_bar_BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_CMU_CTRL_OVR1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_stat_ctrl_ovr_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Cmu Stat Ctrl Ovr Register
 */
union bdk_gsercx_cm0_top_cmu_stat_ctrl_ovr_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_cmu_stat_ctrl_ovr_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t state_chng_rdy        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t state_chng_rdy        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_cmu_stat_ctrl_ovr_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_cmu_stat_ctrl_ovr_rsvd bdk_gsercx_cm0_top_cmu_stat_ctrl_ovr_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c450ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(a) bdk_gsercx_cm0_top_cmu_stat_ctrl_ovr_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(a) "GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_CMU_STAT_CTRL_OVR_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_stat_status0
 *
 * GSERC Cm0 Top Cmu Stat Status0 Register
 */
union bdk_gsercx_cm0_top_cmu_stat_status0
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_cmu_stat_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of HSS_CM0_state_chng_rdy_O cmu_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of HSS_CM0_state_chng_rdy_O cmu_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_cmu_stat_status0_s cn; */
};
typedef union bdk_gsercx_cm0_top_cmu_stat_status0 bdk_gsercx_cm0_top_cmu_stat_status0_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c458ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_CMU_STAT_STATUS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) bdk_gsercx_cm0_top_cmu_stat_status0_t
#define bustype_BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) "GSERCX_CM0_TOP_CMU_STAT_STATUS0"
#define device_bar_BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_CMU_STAT_STATUS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_top_spare0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Cmu Top Spare0 Register
 */
union bdk_gsercx_cm0_top_cmu_top_spare0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_cmu_top_spare0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_cmu_top_spare0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_cmu_top_spare0_rsvd bdk_gsercx_cm0_top_cmu_top_spare0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c2c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(a) bdk_gsercx_cm0_top_cmu_top_spare0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(a) "GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_cmu_top_spare1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Cmu Top Spare1 Register
 */
union bdk_gsercx_cm0_top_cmu_top_spare1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_cmu_top_spare1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_cmu_top_spare1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_cmu_top_spare1_rsvd bdk_gsercx_cm0_top_cmu_top_spare1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c2c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(a) bdk_gsercx_cm0_top_cmu_top_spare1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(a) "GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_CMU_TOP_SPARE1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_err_ctrl1
 *
 * GSERC Cm0 Top Err Ctrl1 Register
 */
union bdk_gsercx_cm0_top_err_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_err_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code lower 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code lower 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_err_ctrl1_s cn; */
};
typedef union bdk_gsercx_cm0_top_err_ctrl1 bdk_gsercx_cm0_top_err_ctrl1_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_ERR_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_ERR_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c400ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_ERR_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_ERR_CTRL1(a) bdk_gsercx_cm0_top_err_ctrl1_t
#define bustype_BDK_GSERCX_CM0_TOP_ERR_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_ERR_CTRL1(a) "GSERCX_CM0_TOP_ERR_CTRL1"
#define device_bar_BDK_GSERCX_CM0_TOP_ERR_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_ERR_CTRL1(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_ERR_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_err_ctrl2
 *
 * GSERC Cm0 Top Err Ctrl2 Register
 */
union bdk_gsercx_cm0_top_err_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_err_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code higher 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) CMU top-level firmware error code higher 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_err_ctrl2_s cn; */
};
typedef union bdk_gsercx_cm0_top_err_ctrl2 bdk_gsercx_cm0_top_err_ctrl2_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_ERR_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_ERR_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c408ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_ERR_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_ERR_CTRL2(a) bdk_gsercx_cm0_top_err_ctrl2_t
#define bustype_BDK_GSERCX_CM0_TOP_ERR_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_ERR_CTRL2(a) "GSERCX_CM0_TOP_ERR_CTRL2"
#define device_bar_BDK_GSERCX_CM0_TOP_ERR_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_ERR_CTRL2(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_ERR_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_err_ctrl3
 *
 * GSERC Cm0 Top Err Ctrl3 Register
 */
union bdk_gsercx_cm0_top_err_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_err_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t critical_err          : 1;  /**< [  0:  0](R/W/H) CMU critical error status.
                                                                 1 indicates that a critical error has occurred. cm0_ok_o is gated when this is set to 1 */
#else /* Word 0 - Little Endian */
        uint32_t critical_err          : 1;  /**< [  0:  0](R/W/H) CMU critical error status.
                                                                 1 indicates that a critical error has occurred. cm0_ok_o is gated when this is set to 1 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_err_ctrl3_s cn; */
};
typedef union bdk_gsercx_cm0_top_err_ctrl3 bdk_gsercx_cm0_top_err_ctrl3_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_ERR_CTRL3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_ERR_CTRL3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c410ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_ERR_CTRL3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_ERR_CTRL3(a) bdk_gsercx_cm0_top_err_ctrl3_t
#define bustype_BDK_GSERCX_CM0_TOP_ERR_CTRL3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_ERR_CTRL3(a) "GSERCX_CM0_TOP_ERR_CTRL3"
#define device_bar_BDK_GSERCX_CM0_TOP_ERR_CTRL3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_ERR_CTRL3(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_ERR_CTRL3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_phy_if_status
 *
 * GSERC Cm0 Top Phy If Status Register
 */
union bdk_gsercx_cm0_top_phy_if_status
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_phy_if_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cmu_ok                : 1;  /**< [  0:  0](RO/H) CMU OK status. */
#else /* Word 0 - Little Endian */
        uint32_t cmu_ok                : 1;  /**< [  0:  0](RO/H) CMU OK status. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_phy_if_status_s cn; */
};
typedef union bdk_gsercx_cm0_top_phy_if_status bdk_gsercx_cm0_top_phy_if_status_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c290ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_PHY_IF_STATUS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(a) bdk_gsercx_cm0_top_phy_if_status_t
#define bustype_BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(a) "GSERCX_CM0_TOP_PHY_IF_STATUS"
#define device_bar_BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_PHY_IF_STATUS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_pwr_state_ack_ctrl_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Pwr State Ack Ctrl Register
 */
union bdk_gsercx_cm0_top_pwr_state_ack_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_pwr_state_ack_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t delay_len             : 3;  /**< [  6:  4](R/W/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t state                 : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t state                 : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t delay_len             : 3;  /**< [  6:  4](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_pwr_state_ack_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_pwr_state_ack_ctrl_rsvd bdk_gsercx_cm0_top_pwr_state_ack_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c288ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(a) bdk_gsercx_cm0_top_pwr_state_ack_ctrl_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(a) "GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_PWR_STATE_ACK_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_pwr_state_req_status_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Pwr State Req Status Register
 */
union bdk_gsercx_cm0_top_pwr_state_req_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_pwr_state_req_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t req                   : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t state                 : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t state                 : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t req                   : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_pwr_state_req_status_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_pwr_state_req_status_rsvd bdk_gsercx_cm0_top_pwr_state_req_status_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c280ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(a) bdk_gsercx_cm0_top_pwr_state_req_status_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(a) "GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_PWR_STATE_REQ_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_txtc_status0_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Txtc Status0 Register
 */
union bdk_gsercx_cm0_top_txtc_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_txtc_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pull_up_result0       : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pull_up_result0       : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_txtc_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_txtc_status0_rsvd bdk_gsercx_cm0_top_txtc_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c1b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_TXTC_STATUS0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(a) bdk_gsercx_cm0_top_txtc_status0_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(a) "GSERCX_CM0_TOP_TXTC_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_TXTC_STATUS0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_txtc_status1_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Txtc Status1 Register
 */
union bdk_gsercx_cm0_top_txtc_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_txtc_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pull_up_result1       : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pull_up_result1       : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_txtc_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_txtc_status1_rsvd bdk_gsercx_cm0_top_txtc_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c1b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_TXTC_STATUS1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(a) bdk_gsercx_cm0_top_txtc_status1_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(a) "GSERCX_CM0_TOP_TXTC_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_TXTC_STATUS1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_txtc_status2_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Txtc Status2 Register
 */
union bdk_gsercx_cm0_top_txtc_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_txtc_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pull_dn_result0       : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pull_dn_result0       : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_txtc_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_txtc_status2_rsvd bdk_gsercx_cm0_top_txtc_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c1c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_TXTC_STATUS2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(a) bdk_gsercx_cm0_top_txtc_status2_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(a) "GSERCX_CM0_TOP_TXTC_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_TXTC_STATUS2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_cm0_top_txtc_status3_rsvd
 *
 * INTERNAL: GSERC Cm0 Top Txtc Status3 Register
 */
union bdk_gsercx_cm0_top_txtc_status3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_cm0_top_txtc_status3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pull_dn_result1       : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pull_dn_result1       : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_cm0_top_txtc_status3_rsvd_s cn; */
};
typedef union bdk_gsercx_cm0_top_txtc_status3_rsvd bdk_gsercx_cm0_top_txtc_status3_rsvd_t;

static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a800c1c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CM0_TOP_TXTC_STATUS3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(a) bdk_gsercx_cm0_top_txtc_status3_rsvd_t
#define bustype_BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(a) "GSERCX_CM0_TOP_TXTC_STATUS3_RSVD"
#define device_bar_BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(a) (a)
#define arguments_BDK_GSERCX_CM0_TOP_TXTC_STATUS3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_ctrl_bcfg
 *
 * GSERC PHY Common Control Register
 */
union bdk_gsercx_common_phy_ctrl_bcfg
{
    uint64_t u;
    struct bdk_gsercx_common_phy_ctrl_bcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_47_63        : 17;
        uint64_t refclk_override       : 1;  /**< [ 46: 46](R/W) During a cold reset, the following fields are populated by HW.   When
                                                                 REFCLK_OVERRIDE=0, writes to these fields are ignored.
                                                                 When REFCLK_OVERRIDE=1, writes to these fields are applied. For diagnostic use only.

                                                                   REFCLK_A_OE_L.
                                                                   REFCLK_A_OE_R.
                                                                   REFCLK_B_OE_L.
                                                                   REFCLK_B_OE_R.
                                                                   REFCLK_RIGHT_OUTPUT_SEL.
                                                                   REFCLK_LEFT_OUTPUT_SEL.
                                                                   PHY_REXT_MASTER. */
        uint64_t apb_reset             : 1;  /**< [ 45: 45](R/W) Reset for CPU's APB bus. Must be set to zero prior to accessing APB bus via JTAG or RSL.
                                                                   0x0 = APB bus reset deasserted.
                                                                   0x1 = APB bus reset asserted.

                                                                 Internal:
                                                                 When APB_RESET=1, an RSL access to an APB register address will return an RSL
                                                                 error. */
        uint64_t dis_apb_csr_addr_filter : 1;/**< [ 44: 44](R/W) Reserved.
                                                                 Internal:
                                                                 Set to 1 to disable the address filter that nomally blocks APB accesses for
                                                                 addresses that are not documented in this csr file. This provides a mechanism to
                                                                 allow RSL access to APB registers that may exist in the phy vendor IP, but which
                                                                 are not documented in the vendor-provided IPXACT register description file which
                                                                 was imported to form the APB subblock of this csr file. Note that setting this
                                                                 bit may result in somewhat unexpected behavior in the RSL bus, since the IP's
                                                                 APB bus will direcyl control the response to commands, including error any
                                                                 indications. */
        uint64_t pmem_wr_prot          : 1;  /**< [ 43: 43](R/W) Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit may be written
                                                                 to 0x0 or 0x1 by software as necessary.
                                                                   0x0 = Program Memory may be written (not write protected).
                                                                   0x1 = Program Memory cannot be written (write protected). */
        uint64_t reserved_41_42        : 2;
        uint64_t phy_rext_master       : 1;  /**< [ 40: 40](R/W/H) REXT master select:
                                                                   0x0 = PHY is a slave.
                                                                   0x1 = PHY is the master. */
        uint64_t refclk_a_oe_l         : 1;  /**< [ 39: 39](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_b_oe_l         : 1;  /**< [ 38: 38](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_a_oe_r         : 1;  /**< [ 37: 37](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the top of the AFE macro, active high. */
        uint64_t refclk_b_oe_r         : 1;  /**< [ 36: 36](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the top of the AFE macro, active high. */
        uint64_t refclk_pad_ena        : 1;  /**< [ 35: 35](R/W) Output enable for the cm0_refclk_pad_o output clock.  This signal
                                                                 should not change outside of the POR CMU power state:
                                                                   0x0 = The cm0_refclk_pad output will be held low.
                                                                   0x1 = The ref clk driven into the refclkp/m bumps will be driven
                                                                         out of the CMOS cm0_refclk_pad output to the DPL in all CMU
                                                                         power states including POR. */
        uint64_t refclk_hiz_ena        : 1;  /**< [ 34: 34](R/W) High impedance enable for the reclkp/m bumps:
                                                                   0x0 = The bumps are terminated with a differential 100 ohm resistance.
                                                                   0x1 = The bumps are unterminated. */
        uint64_t refclk_right_output_sel : 4;/**< [ 33: 30](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the top of the AFE macro at die edge:

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 - Choose clk_ref_b_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_b_r_o source from clk_ref_b_r_i.
                                                                     0x2 - Choose clk_ref_b_r_o source from clk_ref_b_l_i.
                                                                     0x3 - Choose clk_ref_b_r_o source from refclk_pads.

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 - Choose clk_ref_a_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_a_r_o source from clk_ref_a_r_i.
                                                                     0x2 - Choose clk_ref_a_r_o source from clk_ref_a_l_i.
                                                                     0x3 - Choose clk_ref_a_r_o source from refclk_pads. */
        uint64_t refclk_left_output_sel : 4; /**< [ 29: 26](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the bottom of the AFE macro at die edge:
                                                                   REFCLK_LEFT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 = Choose clk_ref_b_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_b_l_o source from clk_ref_b_l_i.
                                                                     0x2 = Choose clk_ref_b_l_o source from clk_ref_b_r_i.
                                                                     0x3 = Choose clk_ref_b_l_o source from refclk_pads.

                                                                   REFCLK_LEFT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 = Choose clk_ref_a_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_a_l_o source from clk_ref_a_l_i.
                                                                     0x2 = Choose clk_ref_a_l_o source from clk_ref_a_r_i.
                                                                     0x3 = Choose clk_ref_a_l_o source from refclk_pads. */
        uint64_t refclk_input_sel      : 3;  /**< [ 25: 23](R/W) CMU reference clock input select:
                                                                   0x0,0x3,0x4,0x7 = Ext ref clock from refclkp/m pads.
                                                                   0x1 = Ref clock from on-chip CML source, clk_ref_a_l_i.
                                                                   0x2 = Ref clock from on-chip CML source, clk_ref_a_r_i.
                                                                   0x5 = Ref clock from on-chip CML source, clk_ref_b_l_i.
                                                                   0x6 = Ref clock from on-chip CML source, clk_ref_b_r_i. */
        uint64_t cpu_reset             : 1;  /**< [ 22: 22](R/W) CPU reset. Active-high CPU reset. When asserted, CPU is halted and reset. When
                                                                 deasserted, CPU will execute its program. */
        uint64_t cm0_pd                : 2;  /**< [ 21: 20](R/W) CMU macro power down control:
                                                                   0x0 = Normal/active.
                                                                   0x1 = Partial power down.
                                                                   0x2 = Near complete power down (sleep state).
                                                                   0x3 = Reserved. */
        uint64_t reserved_19           : 1;
        uint64_t cm0_rst               : 1;  /**< [ 18: 18](R/W) CMU reset, active high. */
        uint64_t phy_ctrl_rate2        : 6;  /**< [ 17: 12](R/W) Phy configuration for rate 2.
                                                                   CPRI Rates:
                                                                   0x11 = 6.144 Gbps.
                                                                   0x12 = 9.8304 Gbps.
                                                                   Ethernet Rates:
                                                                   0x23 = 10.3125 Gbps (Default).
                                                                   0x24 = 10.20 Gbps (At-speed scan mode).
                                                                   0x26 = 8.5 Gbps.
                                                                   0x28 = 6.25 Gbps.
                                                                   0x2A = 5 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate1        : 6;  /**< [ 11:  6](R/W) Phy configuration for rate 1.
                                                                   Ethernet Rates:
                                                                   0x00 = 30 Gbps.
                                                                   0x01 = 28.05 Gbps.
                                                                   0x0B = 28 Gbps.
                                                                   0x02 = 27.34375 Gbps.
                                                                   0x03 = 25.78125 Gbps (Default).
                                                                   0x04 = 21.875 Gbps.
                                                                   0x05 = 20.625 Gbps.
                                                                   0x06 = 26.5625 Gbps.
                                                                   0x07 = 25 Gbps.
                                                                   0x08 = 28.125 Gbps.
                                                                   0x09 = 15 Gbps.
                                                                   0x21 = 12.5 Gbps.
                                                                   0x22 = 10.9375 Gbps.
                                                                   0x23 = 10.3125 Gbps.
                                                                   0x25 = 10 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_refclk       : 5;  /**< [  5:  1](R/W) Phy configuration for the ref clock frequency:
                                                                   0x0A = 212.5 MHz.
                                                                   0x0E = 156.25 MHz Ethernet (Default).
                                                                   0x15 = 245.76 MHz.
                                                                   0x14 = 122.88 MHz CPRI.
                                                                   Ox13 = 200 MHz.
                                                                   _ Others = Reserved. */
        uint64_t por                   : 1;  /**< [  0:  0](R/W) Power on reset signal, active high. */
#else /* Word 0 - Little Endian */
        uint64_t por                   : 1;  /**< [  0:  0](R/W) Power on reset signal, active high. */
        uint64_t phy_ctrl_refclk       : 5;  /**< [  5:  1](R/W) Phy configuration for the ref clock frequency:
                                                                   0x0A = 212.5 MHz.
                                                                   0x0E = 156.25 MHz Ethernet (Default).
                                                                   0x15 = 245.76 MHz.
                                                                   0x14 = 122.88 MHz CPRI.
                                                                   Ox13 = 200 MHz.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate1        : 6;  /**< [ 11:  6](R/W) Phy configuration for rate 1.
                                                                   Ethernet Rates:
                                                                   0x00 = 30 Gbps.
                                                                   0x01 = 28.05 Gbps.
                                                                   0x0B = 28 Gbps.
                                                                   0x02 = 27.34375 Gbps.
                                                                   0x03 = 25.78125 Gbps (Default).
                                                                   0x04 = 21.875 Gbps.
                                                                   0x05 = 20.625 Gbps.
                                                                   0x06 = 26.5625 Gbps.
                                                                   0x07 = 25 Gbps.
                                                                   0x08 = 28.125 Gbps.
                                                                   0x09 = 15 Gbps.
                                                                   0x21 = 12.5 Gbps.
                                                                   0x22 = 10.9375 Gbps.
                                                                   0x23 = 10.3125 Gbps.
                                                                   0x25 = 10 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t phy_ctrl_rate2        : 6;  /**< [ 17: 12](R/W) Phy configuration for rate 2.
                                                                   CPRI Rates:
                                                                   0x11 = 6.144 Gbps.
                                                                   0x12 = 9.8304 Gbps.
                                                                   Ethernet Rates:
                                                                   0x23 = 10.3125 Gbps (Default).
                                                                   0x24 = 10.20 Gbps (At-speed scan mode).
                                                                   0x26 = 8.5 Gbps.
                                                                   0x28 = 6.25 Gbps.
                                                                   0x2A = 5 Gbps.
                                                                   _ Others = Reserved. */
        uint64_t cm0_rst               : 1;  /**< [ 18: 18](R/W) CMU reset, active high. */
        uint64_t reserved_19           : 1;
        uint64_t cm0_pd                : 2;  /**< [ 21: 20](R/W) CMU macro power down control:
                                                                   0x0 = Normal/active.
                                                                   0x1 = Partial power down.
                                                                   0x2 = Near complete power down (sleep state).
                                                                   0x3 = Reserved. */
        uint64_t cpu_reset             : 1;  /**< [ 22: 22](R/W) CPU reset. Active-high CPU reset. When asserted, CPU is halted and reset. When
                                                                 deasserted, CPU will execute its program. */
        uint64_t refclk_input_sel      : 3;  /**< [ 25: 23](R/W) CMU reference clock input select:
                                                                   0x0,0x3,0x4,0x7 = Ext ref clock from refclkp/m pads.
                                                                   0x1 = Ref clock from on-chip CML source, clk_ref_a_l_i.
                                                                   0x2 = Ref clock from on-chip CML source, clk_ref_a_r_i.
                                                                   0x5 = Ref clock from on-chip CML source, clk_ref_b_l_i.
                                                                   0x6 = Ref clock from on-chip CML source, clk_ref_b_r_i. */
        uint64_t refclk_left_output_sel : 4; /**< [ 29: 26](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the bottom of the AFE macro at die edge:
                                                                   REFCLK_LEFT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 = Choose clk_ref_b_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_b_l_o source from clk_ref_b_l_i.
                                                                     0x2 = Choose clk_ref_b_l_o source from clk_ref_b_r_i.
                                                                     0x3 = Choose clk_ref_b_l_o source from refclk_pads.

                                                                   REFCLK_LEFT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 = Choose clk_ref_a_l_o source from refclk_pads.
                                                                     0x1 = Choose clk_ref_a_l_o source from clk_ref_a_l_i.
                                                                     0x2 = Choose clk_ref_a_l_o source from clk_ref_a_r_i.
                                                                     0x3 = Choose clk_ref_a_l_o source from refclk_pads. */
        uint64_t refclk_right_output_sel : 4;/**< [ 33: 30](R/W/H) CMU reference clock output select for the CML distribution buffers driving
                                                                 out of the top of the AFE macro at die edge:

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<3:2\>:
                                                                     0x0 - Choose clk_ref_b_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_b_r_o source from clk_ref_b_r_i.
                                                                     0x2 - Choose clk_ref_b_r_o source from clk_ref_b_l_i.
                                                                     0x3 - Choose clk_ref_b_r_o source from refclk_pads.

                                                                   REFCLK_RIGHT_OUTPUT_SEL\<1:0\>:
                                                                     0x0 - Choose clk_ref_a_r_o source from refclk_pads.
                                                                     0x1 - Choose clk_ref_a_r_o source from clk_ref_a_r_i.
                                                                     0x2 - Choose clk_ref_a_r_o source from clk_ref_a_l_i.
                                                                     0x3 - Choose clk_ref_a_r_o source from refclk_pads. */
        uint64_t refclk_hiz_ena        : 1;  /**< [ 34: 34](R/W) High impedance enable for the reclkp/m bumps:
                                                                   0x0 = The bumps are terminated with a differential 100 ohm resistance.
                                                                   0x1 = The bumps are unterminated. */
        uint64_t refclk_pad_ena        : 1;  /**< [ 35: 35](R/W) Output enable for the cm0_refclk_pad_o output clock.  This signal
                                                                 should not change outside of the POR CMU power state:
                                                                   0x0 = The cm0_refclk_pad output will be held low.
                                                                   0x1 = The ref clk driven into the refclkp/m bumps will be driven
                                                                         out of the CMOS cm0_refclk_pad output to the DPL in all CMU
                                                                         power states including POR. */
        uint64_t refclk_b_oe_r         : 1;  /**< [ 36: 36](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the top of the AFE macro, active high. */
        uint64_t refclk_a_oe_r         : 1;  /**< [ 37: 37](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the top of the AFE macro, active high. */
        uint64_t refclk_b_oe_l         : 1;  /**< [ 38: 38](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "B" out of the bottom of the AFE macro, active high. */
        uint64_t refclk_a_oe_l         : 1;  /**< [ 39: 39](R/W/H) Output enables for the CML output buffers that drive reference
                                                                 clock "A" out of the bottom of the AFE macro, active high. */
        uint64_t phy_rext_master       : 1;  /**< [ 40: 40](R/W/H) REXT master select:
                                                                   0x0 = PHY is a slave.
                                                                   0x1 = PHY is the master. */
        uint64_t reserved_41_42        : 2;
        uint64_t pmem_wr_prot          : 1;  /**< [ 43: 43](R/W) Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit may be written
                                                                 to 0x0 or 0x1 by software as necessary.
                                                                   0x0 = Program Memory may be written (not write protected).
                                                                   0x1 = Program Memory cannot be written (write protected). */
        uint64_t dis_apb_csr_addr_filter : 1;/**< [ 44: 44](R/W) Reserved.
                                                                 Internal:
                                                                 Set to 1 to disable the address filter that nomally blocks APB accesses for
                                                                 addresses that are not documented in this csr file. This provides a mechanism to
                                                                 allow RSL access to APB registers that may exist in the phy vendor IP, but which
                                                                 are not documented in the vendor-provided IPXACT register description file which
                                                                 was imported to form the APB subblock of this csr file. Note that setting this
                                                                 bit may result in somewhat unexpected behavior in the RSL bus, since the IP's
                                                                 APB bus will direcyl control the response to commands, including error any
                                                                 indications. */
        uint64_t apb_reset             : 1;  /**< [ 45: 45](R/W) Reset for CPU's APB bus. Must be set to zero prior to accessing APB bus via JTAG or RSL.
                                                                   0x0 = APB bus reset deasserted.
                                                                   0x1 = APB bus reset asserted.

                                                                 Internal:
                                                                 When APB_RESET=1, an RSL access to an APB register address will return an RSL
                                                                 error. */
        uint64_t refclk_override       : 1;  /**< [ 46: 46](R/W) During a cold reset, the following fields are populated by HW.   When
                                                                 REFCLK_OVERRIDE=0, writes to these fields are ignored.
                                                                 When REFCLK_OVERRIDE=1, writes to these fields are applied. For diagnostic use only.

                                                                   REFCLK_A_OE_L.
                                                                   REFCLK_A_OE_R.
                                                                   REFCLK_B_OE_L.
                                                                   REFCLK_B_OE_R.
                                                                   REFCLK_RIGHT_OUTPUT_SEL.
                                                                   REFCLK_LEFT_OUTPUT_SEL.
                                                                   PHY_REXT_MASTER. */
        uint64_t reserved_47_63        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_common_phy_ctrl_bcfg_s cn; */
};
typedef union bdk_gsercx_common_phy_ctrl_bcfg bdk_gsercx_common_phy_ctrl_bcfg_t;

static inline uint64_t BDK_GSERCX_COMMON_PHY_CTRL_BCFG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_COMMON_PHY_CTRL_BCFG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80800a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_COMMON_PHY_CTRL_BCFG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_COMMON_PHY_CTRL_BCFG(a) bdk_gsercx_common_phy_ctrl_bcfg_t
#define bustype_BDK_GSERCX_COMMON_PHY_CTRL_BCFG(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_COMMON_PHY_CTRL_BCFG(a) "GSERCX_COMMON_PHY_CTRL_BCFG"
#define device_bar_BDK_GSERCX_COMMON_PHY_CTRL_BCFG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_COMMON_PHY_CTRL_BCFG(a) (a)
#define arguments_BDK_GSERCX_COMMON_PHY_CTRL_BCFG(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_ctrl_prot
 *
 * GSERC PHY Common Control Protection Register
 */
union bdk_gsercx_common_phy_ctrl_prot
{
    uint64_t u;
    struct bdk_gsercx_common_phy_ctrl_prot_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t pmem_wr_prot_stky     : 1;  /**< [  0:  0](R/W1S) Sticky Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit cannot be
                                                                 cleared by writing, only cleared upon reset.
                                                                   0x0 = Program memory may be written (not write protected).
                                                                   0x1 = Program memory cannot be written (write protected). */
#else /* Word 0 - Little Endian */
        uint64_t pmem_wr_prot_stky     : 1;  /**< [  0:  0](R/W1S) Sticky Write Protect for CPU Program Memory. If write protection is desired on PMEM,
                                                                 this bit should be set to 0x1 prior to asserting POR or CPU_RESET. This bit cannot be
                                                                 cleared by writing, only cleared upon reset.
                                                                   0x0 = Program memory may be written (not write protected).
                                                                   0x1 = Program memory cannot be written (write protected). */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_common_phy_ctrl_prot_s cn; */
};
typedef union bdk_gsercx_common_phy_ctrl_prot bdk_gsercx_common_phy_ctrl_prot_t;

static inline uint64_t BDK_GSERCX_COMMON_PHY_CTRL_PROT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_COMMON_PHY_CTRL_PROT(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80800b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_COMMON_PHY_CTRL_PROT", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_COMMON_PHY_CTRL_PROT(a) bdk_gsercx_common_phy_ctrl_prot_t
#define bustype_BDK_GSERCX_COMMON_PHY_CTRL_PROT(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_COMMON_PHY_CTRL_PROT(a) "GSERCX_COMMON_PHY_CTRL_PROT"
#define device_bar_BDK_GSERCX_COMMON_PHY_CTRL_PROT(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_COMMON_PHY_CTRL_PROT(a) (a)
#define arguments_BDK_GSERCX_COMMON_PHY_CTRL_PROT(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_ctrl_stall
 *
 * GSERC PHY Common Control Stall Register
 */
union bdk_gsercx_common_phy_ctrl_stall
{
    uint64_t u;
    struct bdk_gsercx_common_phy_ctrl_stall_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_2_63         : 62;
        uint64_t csr_force_stall       : 1;  /**< [  1:  1](R/W) CSR controlled stall for accesses to CPU program and data memory.
                                                                   0x0 = Does not assert stall to CPU program and data memory.
                                                                   0x1 = Asserts stall stall to CPU program and data memory. */
        uint64_t csr_mask_stall        : 1;  /**< [  0:  0](R/W) Hardware stall mask control for accesses to CPU program and data memory.
                                                                   0x0 = Hardware stall from RSL access is enabled.
                                                                   0x1 = Hardware stall from RSL access is disabled (masked). */
#else /* Word 0 - Little Endian */
        uint64_t csr_mask_stall        : 1;  /**< [  0:  0](R/W) Hardware stall mask control for accesses to CPU program and data memory.
                                                                   0x0 = Hardware stall from RSL access is enabled.
                                                                   0x1 = Hardware stall from RSL access is disabled (masked). */
        uint64_t csr_force_stall       : 1;  /**< [  1:  1](R/W) CSR controlled stall for accesses to CPU program and data memory.
                                                                   0x0 = Does not assert stall to CPU program and data memory.
                                                                   0x1 = Asserts stall stall to CPU program and data memory. */
        uint64_t reserved_2_63         : 62;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_common_phy_ctrl_stall_s cn; */
};
typedef union bdk_gsercx_common_phy_ctrl_stall bdk_gsercx_common_phy_ctrl_stall_t;

static inline uint64_t BDK_GSERCX_COMMON_PHY_CTRL_STALL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_COMMON_PHY_CTRL_STALL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80800c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_COMMON_PHY_CTRL_STALL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_COMMON_PHY_CTRL_STALL(a) bdk_gsercx_common_phy_ctrl_stall_t
#define bustype_BDK_GSERCX_COMMON_PHY_CTRL_STALL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_COMMON_PHY_CTRL_STALL(a) "GSERCX_COMMON_PHY_CTRL_STALL"
#define device_bar_BDK_GSERCX_COMMON_PHY_CTRL_STALL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_COMMON_PHY_CTRL_STALL(a) (a)
#define arguments_BDK_GSERCX_COMMON_PHY_CTRL_STALL(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_common_phy_status_bsts
 *
 * GSERC PHY Common Status Register
 */
union bdk_gsercx_common_phy_status_bsts
{
    uint64_t u;
    struct bdk_gsercx_common_phy_status_bsts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_16_63        : 48;
        uint64_t dtest                 : 12; /**< [ 15:  4](RO/H) DTEST test output value */
        uint64_t reserved_3            : 1;
        uint64_t cm0_ok                : 1;  /**< [  2:  2](RO/H) CMU OK signal, asserted after CMU macro successfully reaches the
                                                                 Active power state, the CMU PLL has locked to the ref clock, and
                                                                 all output clocks are the correct frequency.  Signal is only valid
                                                                 on initial assertion, not a PLL lock indicator. */
        uint64_t cm0_state_chng_rdy    : 1;  /**< [  1:  1](RO/H) CMU reset and power state ready status:
                                                                   0x0 = PHY is performing a power state transition, signals cm0_rst_n
                                                                         and cm0_pd should not be changed.
                                                                   0x1 = PHY has successfully completed the last power state transition
                                                                         request and is ready to respond to cm0_rst_n, cm0_iddq, and
                                                                         cm0_pd changes. */
        uint64_t phy_error             : 1;  /**< [  0:  0](RO/H) PHY error status:
                                                                   0x0 = No error.
                                                                   0x1 = PHY has an internal error. */
#else /* Word 0 - Little Endian */
        uint64_t phy_error             : 1;  /**< [  0:  0](RO/H) PHY error status:
                                                                   0x0 = No error.
                                                                   0x1 = PHY has an internal error. */
        uint64_t cm0_state_chng_rdy    : 1;  /**< [  1:  1](RO/H) CMU reset and power state ready status:
                                                                   0x0 = PHY is performing a power state transition, signals cm0_rst_n
                                                                         and cm0_pd should not be changed.
                                                                   0x1 = PHY has successfully completed the last power state transition
                                                                         request and is ready to respond to cm0_rst_n, cm0_iddq, and
                                                                         cm0_pd changes. */
        uint64_t cm0_ok                : 1;  /**< [  2:  2](RO/H) CMU OK signal, asserted after CMU macro successfully reaches the
                                                                 Active power state, the CMU PLL has locked to the ref clock, and
                                                                 all output clocks are the correct frequency.  Signal is only valid
                                                                 on initial assertion, not a PLL lock indicator. */
        uint64_t reserved_3            : 1;
        uint64_t dtest                 : 12; /**< [ 15:  4](RO/H) DTEST test output value */
        uint64_t reserved_16_63        : 48;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_common_phy_status_bsts_s cn; */
};
typedef union bdk_gsercx_common_phy_status_bsts bdk_gsercx_common_phy_status_bsts_t;

static inline uint64_t BDK_GSERCX_COMMON_PHY_STATUS_BSTS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_COMMON_PHY_STATUS_BSTS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8081020ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_COMMON_PHY_STATUS_BSTS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_COMMON_PHY_STATUS_BSTS(a) bdk_gsercx_common_phy_status_bsts_t
#define bustype_BDK_GSERCX_COMMON_PHY_STATUS_BSTS(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_COMMON_PHY_STATUS_BSTS(a) "GSERCX_COMMON_PHY_STATUS_BSTS"
#define device_bar_BDK_GSERCX_COMMON_PHY_STATUS_BSTS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_COMMON_PHY_STATUS_BSTS(a) (a)
#define arguments_BDK_GSERCX_COMMON_PHY_STATUS_BSTS(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_const
 *
 * GSERC CONST Register
 */
union bdk_gsercx_const
{
    uint64_t u;
    struct bdk_gsercx_const_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 61; /**< [ 63:  3](RO) Reserved. */
        uint64_t nr_lanes              : 3;  /**< [  2:  0](RO) Number of lanes in this module. */
#else /* Word 0 - Little Endian */
        uint64_t nr_lanes              : 3;  /**< [  2:  0](RO) Number of lanes in this module. */
        uint64_t data                  : 61; /**< [ 63:  3](RO) Reserved. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_const_s cn; */
};
typedef union bdk_gsercx_const bdk_gsercx_const_t;

static inline uint64_t BDK_GSERCX_CONST(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_CONST(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8080090ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_CONST", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_CONST(a) bdk_gsercx_const_t
#define bustype_BDK_GSERCX_CONST(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_CONST(a) "GSERCX_CONST"
#define device_bar_BDK_GSERCX_CONST(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_CONST(a) (a)
#define arguments_BDK_GSERCX_CONST(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_dmem#
 *
 * GSERC Data Memory (36kB) Registers
 */
union bdk_gsercx_dmemx
{
    uint32_t u;
    struct bdk_gsercx_dmemx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Data memory for GSERC microcontroller. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Data memory for GSERC microcontroller. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_dmemx_s cn; */
};
typedef union bdk_gsercx_dmemx bdk_gsercx_dmemx_t;

static inline uint64_t BDK_GSERCX_DMEMX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_DMEMX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=4607)))
        return 0x87e0a8090000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1fff);
    __bdk_csr_fatal("GSERCX_DMEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_DMEMX(a,b) bdk_gsercx_dmemx_t
#define bustype_BDK_GSERCX_DMEMX(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_DMEMX(a,b) "GSERCX_DMEMX"
#define device_bar_BDK_GSERCX_DMEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_DMEMX(a,b) (a)
#define arguments_BDK_GSERCX_DMEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_domain_rst_en
 *
 * Domain Reset Enable Register
 */
union bdk_gsercx_domain_rst_en
{
    uint64_t u;
    struct bdk_gsercx_domain_rst_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_1_63         : 63;
        uint64_t en                    : 1;  /**< [  0:  0](R/W) Domain reset enable.
                                                                     0 = Prevent resetting lane logic with domain reset.
                                                                     1 = Enable resetting all lane logic, except CSRCOLD CSR subblock registers, with domain reset.

                                                                 Internal:
                                                                 For PCIe configurations, set to 1 for a root complex and to 0 for an
                                                                 endpoint. For ethernet configurations, set to 1. */
#else /* Word 0 - Little Endian */
        uint64_t en                    : 1;  /**< [  0:  0](R/W) Domain reset enable.
                                                                     0 = Prevent resetting lane logic with domain reset.
                                                                     1 = Enable resetting all lane logic, except CSRCOLD CSR subblock registers, with domain reset.

                                                                 Internal:
                                                                 For PCIe configurations, set to 1 for a root complex and to 0 for an
                                                                 endpoint. For ethernet configurations, set to 1. */
        uint64_t reserved_1_63         : 63;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_domain_rst_en_s cn; */
};
typedef union bdk_gsercx_domain_rst_en bdk_gsercx_domain_rst_en_t;

static inline uint64_t BDK_GSERCX_DOMAIN_RST_EN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_DOMAIN_RST_EN(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8080080ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_DOMAIN_RST_EN", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_DOMAIN_RST_EN(a) bdk_gsercx_domain_rst_en_t
#define bustype_BDK_GSERCX_DOMAIN_RST_EN(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_DOMAIN_RST_EN(a) "GSERCX_DOMAIN_RST_EN"
#define device_bar_BDK_GSERCX_DOMAIN_RST_EN(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_DOMAIN_RST_EN(a) (a)
#define arguments_BDK_GSERCX_DOMAIN_RST_EN(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_eco
 *
 * INTERNAL: GSERC ECO Register
 */
union bdk_gsercx_eco
{
    uint64_t u;
    struct bdk_gsercx_eco_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t eco_rw                : 64; /**< [ 63:  0](R/W) Reserved for ECO use. */
#else /* Word 0 - Little Endian */
        uint64_t eco_rw                : 64; /**< [ 63:  0](R/W) Reserved for ECO use. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_eco_s cn; */
};
typedef union bdk_gsercx_eco bdk_gsercx_eco_t;

static inline uint64_t BDK_GSERCX_ECO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_ECO(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8080060ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_ECO", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_ECO(a) bdk_gsercx_eco_t
#define bustype_BDK_GSERCX_ECO(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_ECO(a) "GSERCX_ECO"
#define device_bar_BDK_GSERCX_ECO(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_ECO(a) (a)
#define arguments_BDK_GSERCX_ECO(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_lane#_btsclk_cfg
 *
 * GSERC Lane BTS Synchronous Ethernet Clock Control Register
 * Register controls settings for providing a clock output from the lane which is
 * synchronous to the clock recovered from the received data stream.
 */
union bdk_gsercx_lanex_btsclk_cfg
{
    uint64_t u;
    struct bdk_gsercx_lanex_btsclk_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_25_63        : 39;
        uint64_t en                    : 1;  /**< [ 24: 24](R/W) Enable driving the clock output from the lane. This bit should be set low before
                                                                 changing [DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_18_23        : 6;
        uint64_t dratio                : 2;  /**< [ 17: 16](R/W) Divider ratio for the clock output from the lane relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
        uint64_t reserved_9_15         : 7;
        uint64_t mio_en                : 1;  /**< [  8:  8](R/W) Enable driving the clock output from the lane to MIO. This bit should be set low before
                                                                 changing [MIO_DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_2_7          : 6;
        uint64_t mio_dratio            : 2;  /**< [  1:  0](R/W) Divider ratio for the clock output from the lane to MIO relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
#else /* Word 0 - Little Endian */
        uint64_t mio_dratio            : 2;  /**< [  1:  0](R/W) Divider ratio for the clock output from the lane to MIO relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
        uint64_t reserved_2_7          : 6;
        uint64_t mio_en                : 1;  /**< [  8:  8](R/W) Enable driving the clock output from the lane to MIO. This bit should be set low before
                                                                 changing [MIO_DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_9_15         : 7;
        uint64_t dratio                : 2;  /**< [ 17: 16](R/W) Divider ratio for the clock output from the lane relative to the clock for the
                                                                 parallel receive data.
                                                                 0x0 = Divide by 1, i.e., no division.
                                                                 0x1 = Divide by 2.
                                                                 0x2 = Divide by 4.
                                                                 0x3 = Divide by 8. */
        uint64_t reserved_18_23        : 6;
        uint64_t en                    : 1;  /**< [ 24: 24](R/W) Enable driving the clock output from the lane. This bit should be set low before
                                                                 changing [DRATIO]; it may be written to 1 in the same cycle that [DRATIO] is
                                                                 written. */
        uint64_t reserved_25_63        : 39;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lanex_btsclk_cfg_s cn; */
};
typedef union bdk_gsercx_lanex_btsclk_cfg bdk_gsercx_lanex_btsclk_cfg_t;

static inline uint64_t BDK_GSERCX_LANEX_BTSCLK_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LANEX_BTSCLK_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80810b0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LANEX_BTSCLK_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LANEX_BTSCLK_CFG(a,b) bdk_gsercx_lanex_btsclk_cfg_t
#define bustype_BDK_GSERCX_LANEX_BTSCLK_CFG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_LANEX_BTSCLK_CFG(a,b) "GSERCX_LANEX_BTSCLK_CFG"
#define device_bar_BDK_GSERCX_LANEX_BTSCLK_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LANEX_BTSCLK_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LANEX_BTSCLK_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_lane#_control_bcfg
 *
 * GSERC PHY Lane Control Register
 */
union bdk_gsercx_lanex_control_bcfg
{
    uint64_t u;
    struct bdk_gsercx_lanex_control_bcfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t cpri_txclk_bist_ovrd  : 2;  /**< [ 47: 46](R/W) Overrides the CPRI TXCLK MUX:
                                                                   0x0 = Standard operation.
                                                                   0x1 = Select div2 txclk.
                                                                   0x2 = Reserved.
                                                                   0x3 = Select div4 txclk. */
        uint64_t rx_bitstrip_mode      : 1;  /**< [ 45: 45](R/W) Selects the bitstrip div mode.
                                                                   0x0 = Div 2 bitstripping.
                                                                   0x1 = Div 4 bitstripping. */
        uint64_t cfg_cpri              : 1;  /**< [ 44: 44](R/W) Select for the lane tx clock and data muxes:
                                                                   0x0 = Ethernet ln_txclk and ln_txdata.
                                                                   0x1 = CPRI ln_txclk and ln_txdata. */
        uint64_t rx_bitstrip_cfg       : 1;  /**< [ 43: 43](R/W) Configures the sampling position for the div 4 bit stripping logic at the 2.4576Gbps CPRI rate:
                                                                   0x0 = 135 degree sample.
                                                                   0x1 = 225 degree sample. */
        uint64_t rx_bitstrip_en        : 1;  /**< [ 42: 42](R/W) Enables the bit stripping logic used in the 2.4576Gbps CPRI rate.  Clear to a 0
                                                                 to reset the bit strip
                                                                 pattern lock FSM. */
        uint64_t rx_wpk_order          : 1;  /**< [ 41: 41](R/W) Receiver word packing order. Used when the GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH]
                                                                 is set to 0x3 to configure the GSERC PHY to 20-bit receive path data width
                                                                 for the 10.3125Gbuad and lower Ethernet data rates.
                                                                 When [RX_WPK_ORDER] is set to 1 the first (earliest) 20-bit word received from the GSERC PHY
                                                                 is packed into the lower 20-bit word position of the 40-bit word and the second (later)
                                                                 20-bit word received is packed into the upper 20-bit word position of the 40-bit word.
                                                                 When [RX_WPK_ORDER] is cleared to 0 the 20-bit word packing order within the 40-bit word
                                                                 is swapped. Set [RX_WUP_ORDER] to 1 for normal Ethernet receive data to the CGX Ethernet MAC.
                                                                 For diagnostic use only. */
        uint64_t tx_wup_order          : 1;  /**< [ 40: 40](RAZ) Reserved.
                                                                 Internal:
                                                                 40b20b gearbox deprecated. */
        uint64_t rx_wpk_20b40b         : 1;  /**< [ 39: 39](RAZ) Reserved.
                                                                 Internal:
                                                                 This field deprecated.
                                                                 The Rx word packing 20-bit to 40-bit gearbox is enabled in hardware when
                                                                 GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH] is set to 0x3 to configure the
                                                                 PHY for 20 bit receive data width. When
                                                                 GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH] is set to 0x5 40-bit (or any other Rx
                                                                 lane width other than 16-bit width) the gearbox is bypassed. */
        uint64_t tx_wup_40b20b         : 1;  /**< [ 38: 38](RAZ) Reserved.
                                                                 Internal:
                                                                 40b20b gearbox deprecated. */
        uint64_t reverse_rx_bit_order  : 1;  /**< [ 37: 37](R/W) When set to 1, reverses the bit order in the 40-bit receive word
                                                                 from the GSERC PHY to the CGX MAC. This control must be set to 1
                                                                 for normal Ethernet receive data.
                                                                 For diagnostic use only. */
        uint64_t reverse_tx_bit_order  : 1;  /**< [ 36: 36](R/W) When set to 1, reverses the bit order in the 40-bit transmit word
                                                                 from the CGX MAC to the GSERC PHY. This control must be set to 1
                                                                 for normal Ethernet transmit data.
                                                                 For diagnostic use only. */
        uint64_t cgx_quad              : 1;  /**< [ 35: 35](R/W) When set, indicates the QLM is in CGX quad aggregation mode. [CGX_QUAD] must only be
                                                                 set when GSERN()_LANE()_SRCMX_BCFG[TX_DATA_SEL]=CGX is set and
                                                                 GSERN()_LANE()_SRCMX_BCFG[TX_CTRL_SEL]=CGX is set and [CGX_DUAL] is clear.

                                                                 When [CGX_QUAD] is set, GSERC bundles all four lanes for one CGX controller.
                                                                 [CGX_QUAD] must only be set for the XAUI/DXAUI, XLAUI, and CAUI protocols. */
        uint64_t cgx_dual              : 1;  /**< [ 34: 34](R/W) When set, indicates the QLM is in CGX dual aggregation mode. [CGX_DUAL] must only be
                                                                 set when GSERN()_LANE()_SRCMX_BCFG[TX_DATA_SEL]=CGX is set and
                                                                 GSERN()_LANE()_SRCMX_BCFG[TX_CTRL_SEL]=CGX is set and [CGX_QUAD] is clear.

                                                                 When [CGX_DUAL] is set, GSERC bundles lanes 0 and 1 for one CGX controller and bundles
                                                                 lanes 2 and 3 for another CGX controller. [CGX_DUAL] must only be set for the RXAUI
                                                                 protocol. */
        uint64_t cfg_cgx               : 1;  /**< [ 33: 33](R/W) Enables SCLK to the CGX TX and RX data path to CGX in Ethernet mode.
                                                                 For CPRI set CFG_CGX = 0. */
        uint64_t reserved_32           : 1;
        uint64_t ln_tx_clk_gate_en     : 1;  /**< [ 31: 31](R/W) When set to 0 disables the ln_tx_clk clock from the ln_tx_clk clock mux.
                                                                 Use to disable the ln_tx_clk for power savings.
                                                                 For normal operation set [LN_TX_CLK_GATE_EN] to 1. */
        uint64_t tx_clk_mux_sel        : 5;  /**< [ 30: 26](R/W) Selects the clock source for ln_tx_clk input:
                                                                   0x0 = 25G, 50G, and 100G data rates. Also for
                                                                         10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                         Also for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = XAUI data rate.
                                                                   0x6 = SGMII data rate
                                                                   All other selections reserved.

                                                                 Internal:
                                                                 Selects the clock source for ln_tx_clk input:
                                                                   0x0 = cm0_clk_rate1 for the 25G, 50G, and 100G data rates
                                                                         and for 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = cm0_clk_rate2 for 10G,40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps lane data rate.
                                                                         Also programmed for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = cm0_clk_rate2_divided_by_2 for XAUI data rate.
                                                                   0x6 = cm0_clk_rate3 for SGMII data rate.
                                                                   All other selections reserved. */
        uint64_t reserved_25           : 1;
        uint64_t ln_link_stat          : 5;  /**< [ 24: 20](R/W) Reserved.
                                                                 Internal:
                                                                 Link status that encodes the technology ability bit number (A0-A24) in
                                                                 the base page:
                                                                   0x0 = 1G_KX.
                                                                   0x1 = Reserved.
                                                                   0x2 = 10G_KR.
                                                                   0x3 = 40G_KR4.
                                                                   0x4 = 40G_CR4.
                                                                   0x5 = 100G_CR10.
                                                                   0x6 = 100G_KP4.
                                                                   0x7 = 100G_KR4.
                                                                   0x8 = 100G_CR4.
                                                                   0x9 = Reserved.
                                                                   0xA = 25G_GR.
                                                                   0xB = 25G_KR.
                                                                   0xC = 25G_CR.
                                                                   0xD = 50G_KR2.
                                                                   0xE = 50G_CR2. */
        uint64_t ln_an_cfg             : 2;  /**< [ 19: 18](R/W) Reserved.
                                                                 Internal:
                                                                 Encodes the lane bonding and auto-negotiation configuration:
                                                                   0x0 = Not auto-negotiation controlled, lane will be manually controlled via
                                                                         LN_PD and LN_RST.
                                                                   0x1 = Auto-negotiation controlled, but auto-negotiation is not run on the
                                                                         lane (AN-slave lane).
                                                                   0x2 = Auto-negotiation controlled, but auto-negotiation is run on the
                                                                         lane (AN-master lane).
                                                                   0x3 = Reserved. */
        uint64_t ln_rate_chng          : 1;  /**< [ 17: 17](R/W) Rate change handshake signal.  Phy transitions to rates set in LN_CTRL_RX_RATE and
                                                                 LN_CTRL_TX_RATE when asserted.  De-assertion indicates to the PHY that rate
                                                                 configuration adjustments have been completed. */
        uint64_t ln_ctrl_rxpolarity    : 1;  /**< [ 16: 16](R/W) RX data polarity inversion:
                                                                   0x0 = No polarity inversion.
                                                                   0x1 = Polarity inversion. */
        uint64_t ln_ctrl_rx_width      : 3;  /**< [ 15: 13](R/W) RX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit Reserved.
                                                                   0x3 = 20 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII.
                                                                   0x4 = 32 bit Reserved.
                                                                   0x5 = 40 bit 25G,50G,100G data rates (Default).
                                                                   Others = Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_tx_width      : 3;  /**< [ 12: 10](R/W) TX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII
                                                                   0x3 = 20 bit Reserved.
                                                                   0x4 = 32 bit 25G,50G,100G data rate (Default).
                                                                   0x5 = 40 bit Reserved.
                                                                   Others - Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_rx_rate       : 3;  /**< [  9:  7](R/W) RX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for the 9.8304 Gbps, 6.144Gbps, and 2.4576Gbps rates.
                                                                   0x5 = Divided-by-2 of Rate 2 for the 4.9152 Gbps, and 3.072 Gbps rates. */
        uint64_t ln_ctrl_tx_rate       : 3;  /**< [  6:  4](R/W) TX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for all CPRI rates. */
        uint64_t ln_ctrl_tx_en         : 1;  /**< [  3:  3](R/W) Transmit enable:
                                                                   0x0 = Data on LN_TXDATA will not be transmitted, transmitter placed into
                                                                         electrical idle.
                                                                   0x1 = Data on the active bits, set by LN_CTRL_RX/TX_WIDTH, of LN_TXDATA
                                                                         will be transmitted. */
        uint64_t ln_pd                 : 2;  /**< [  2:  1](R/W) Lane macro power down control:
                                                                   0x0 = Nomral/active.
                                                                   0x1 = Partial power down.
                                                                   0x2,0x3 = Most blocks powered down (Sleep mode). */
        uint64_t ln_rst                : 1;  /**< [  0:  0](R/W) Lane reset control, active high. */
#else /* Word 0 - Little Endian */
        uint64_t ln_rst                : 1;  /**< [  0:  0](R/W) Lane reset control, active high. */
        uint64_t ln_pd                 : 2;  /**< [  2:  1](R/W) Lane macro power down control:
                                                                   0x0 = Nomral/active.
                                                                   0x1 = Partial power down.
                                                                   0x2,0x3 = Most blocks powered down (Sleep mode). */
        uint64_t ln_ctrl_tx_en         : 1;  /**< [  3:  3](R/W) Transmit enable:
                                                                   0x0 = Data on LN_TXDATA will not be transmitted, transmitter placed into
                                                                         electrical idle.
                                                                   0x1 = Data on the active bits, set by LN_CTRL_RX/TX_WIDTH, of LN_TXDATA
                                                                         will be transmitted. */
        uint64_t ln_ctrl_tx_rate       : 3;  /**< [  6:  4](R/W) TX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for all CPRI rates. */
        uint64_t ln_ctrl_rx_rate       : 3;  /**< [  9:  7](R/W) RX data rate selector:
                                                                   0x0 = Rate 1 (PHY_CTRL_RATE1).
                                                                   0x1 = Rate 2 (PHY_CTRL_RATE2).
                                                                   0x2 = Rate 3 (Reserved for 1.25Gbps Ethernet).
                                                                   0x4 = Divide-by-2 of Rate 1.
                                                                   0x5 = Divide-by-2 of Rate 2.
                                                                   0x6 = Divide-by-2 of Rate 3.
                                                                   Others = Reserved.
                                                                   For CPRI select:
                                                                   0x1 = Rate 2 for the 9.8304 Gbps, 6.144Gbps, and 2.4576Gbps rates.
                                                                   0x5 = Divided-by-2 of Rate 2 for the 4.9152 Gbps, and 3.072 Gbps rates. */
        uint64_t ln_ctrl_tx_width      : 3;  /**< [ 12: 10](R/W) TX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII
                                                                   0x3 = 20 bit Reserved.
                                                                   0x4 = 32 bit 25G,50G,100G data rate (Default).
                                                                   0x5 = 40 bit Reserved.
                                                                   Others - Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_rx_width      : 3;  /**< [ 15: 13](R/W) RX data word width selector:
                                                                   0x1 = 10 bit Reserved.
                                                                   0x2 = 16 bit Reserved.
                                                                   0x3 = 20 bit 40G,10G,DXAUI,RXAUI,XAUI,QSGMII,SGMII.
                                                                   0x4 = 32 bit Reserved.
                                                                   0x5 = 40 bit 25G,50G,100G data rates (Default).
                                                                   Others = Reserved.
                                                                   For CPRI select 0x3 = 20 bit. */
        uint64_t ln_ctrl_rxpolarity    : 1;  /**< [ 16: 16](R/W) RX data polarity inversion:
                                                                   0x0 = No polarity inversion.
                                                                   0x1 = Polarity inversion. */
        uint64_t ln_rate_chng          : 1;  /**< [ 17: 17](R/W) Rate change handshake signal.  Phy transitions to rates set in LN_CTRL_RX_RATE and
                                                                 LN_CTRL_TX_RATE when asserted.  De-assertion indicates to the PHY that rate
                                                                 configuration adjustments have been completed. */
        uint64_t ln_an_cfg             : 2;  /**< [ 19: 18](R/W) Reserved.
                                                                 Internal:
                                                                 Encodes the lane bonding and auto-negotiation configuration:
                                                                   0x0 = Not auto-negotiation controlled, lane will be manually controlled via
                                                                         LN_PD and LN_RST.
                                                                   0x1 = Auto-negotiation controlled, but auto-negotiation is not run on the
                                                                         lane (AN-slave lane).
                                                                   0x2 = Auto-negotiation controlled, but auto-negotiation is run on the
                                                                         lane (AN-master lane).
                                                                   0x3 = Reserved. */
        uint64_t ln_link_stat          : 5;  /**< [ 24: 20](R/W) Reserved.
                                                                 Internal:
                                                                 Link status that encodes the technology ability bit number (A0-A24) in
                                                                 the base page:
                                                                   0x0 = 1G_KX.
                                                                   0x1 = Reserved.
                                                                   0x2 = 10G_KR.
                                                                   0x3 = 40G_KR4.
                                                                   0x4 = 40G_CR4.
                                                                   0x5 = 100G_CR10.
                                                                   0x6 = 100G_KP4.
                                                                   0x7 = 100G_KR4.
                                                                   0x8 = 100G_CR4.
                                                                   0x9 = Reserved.
                                                                   0xA = 25G_GR.
                                                                   0xB = 25G_KR.
                                                                   0xC = 25G_CR.
                                                                   0xD = 50G_KR2.
                                                                   0xE = 50G_CR2. */
        uint64_t reserved_25           : 1;
        uint64_t tx_clk_mux_sel        : 5;  /**< [ 30: 26](R/W) Selects the clock source for ln_tx_clk input:
                                                                   0x0 = 25G, 50G, and 100G data rates. Also for
                                                                         10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                         Also for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = XAUI data rate.
                                                                   0x6 = SGMII data rate
                                                                   All other selections reserved.

                                                                 Internal:
                                                                 Selects the clock source for ln_tx_clk input:
                                                                   0x0 = cm0_clk_rate1 for the 25G, 50G, and 100G data rates
                                                                         and for 10G, 40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE1] is
                                                                         configured for the 10.3125Gbps data rate.
                                                                   0x1 = cm0_clk_rate2 for 10G,40G data rates if GSERC()_PHY_CTRL_BCFG[PHY_CTRL_RATE2] is
                                                                         configured for the 10.3125Gbps lane data rate.
                                                                         Also programmed for RXAUI, DXAUI, and QSGMII data rates.
                                                                   0x4 = cm0_clk_rate2_divided_by_2 for XAUI data rate.
                                                                   0x6 = cm0_clk_rate3 for SGMII data rate.
                                                                   All other selections reserved. */
        uint64_t ln_tx_clk_gate_en     : 1;  /**< [ 31: 31](R/W) When set to 0 disables the ln_tx_clk clock from the ln_tx_clk clock mux.
                                                                 Use to disable the ln_tx_clk for power savings.
                                                                 For normal operation set [LN_TX_CLK_GATE_EN] to 1. */
        uint64_t reserved_32           : 1;
        uint64_t cfg_cgx               : 1;  /**< [ 33: 33](R/W) Enables SCLK to the CGX TX and RX data path to CGX in Ethernet mode.
                                                                 For CPRI set CFG_CGX = 0. */
        uint64_t cgx_dual              : 1;  /**< [ 34: 34](R/W) When set, indicates the QLM is in CGX dual aggregation mode. [CGX_DUAL] must only be
                                                                 set when GSERN()_LANE()_SRCMX_BCFG[TX_DATA_SEL]=CGX is set and
                                                                 GSERN()_LANE()_SRCMX_BCFG[TX_CTRL_SEL]=CGX is set and [CGX_QUAD] is clear.

                                                                 When [CGX_DUAL] is set, GSERC bundles lanes 0 and 1 for one CGX controller and bundles
                                                                 lanes 2 and 3 for another CGX controller. [CGX_DUAL] must only be set for the RXAUI
                                                                 protocol. */
        uint64_t cgx_quad              : 1;  /**< [ 35: 35](R/W) When set, indicates the QLM is in CGX quad aggregation mode. [CGX_QUAD] must only be
                                                                 set when GSERN()_LANE()_SRCMX_BCFG[TX_DATA_SEL]=CGX is set and
                                                                 GSERN()_LANE()_SRCMX_BCFG[TX_CTRL_SEL]=CGX is set and [CGX_DUAL] is clear.

                                                                 When [CGX_QUAD] is set, GSERC bundles all four lanes for one CGX controller.
                                                                 [CGX_QUAD] must only be set for the XAUI/DXAUI, XLAUI, and CAUI protocols. */
        uint64_t reverse_tx_bit_order  : 1;  /**< [ 36: 36](R/W) When set to 1, reverses the bit order in the 40-bit transmit word
                                                                 from the CGX MAC to the GSERC PHY. This control must be set to 1
                                                                 for normal Ethernet transmit data.
                                                                 For diagnostic use only. */
        uint64_t reverse_rx_bit_order  : 1;  /**< [ 37: 37](R/W) When set to 1, reverses the bit order in the 40-bit receive word
                                                                 from the GSERC PHY to the CGX MAC. This control must be set to 1
                                                                 for normal Ethernet receive data.
                                                                 For diagnostic use only. */
        uint64_t tx_wup_40b20b         : 1;  /**< [ 38: 38](RAZ) Reserved.
                                                                 Internal:
                                                                 40b20b gearbox deprecated. */
        uint64_t rx_wpk_20b40b         : 1;  /**< [ 39: 39](RAZ) Reserved.
                                                                 Internal:
                                                                 This field deprecated.
                                                                 The Rx word packing 20-bit to 40-bit gearbox is enabled in hardware when
                                                                 GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH] is set to 0x3 to configure the
                                                                 PHY for 20 bit receive data width. When
                                                                 GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH] is set to 0x5 40-bit (or any other Rx
                                                                 lane width other than 16-bit width) the gearbox is bypassed. */
        uint64_t tx_wup_order          : 1;  /**< [ 40: 40](RAZ) Reserved.
                                                                 Internal:
                                                                 40b20b gearbox deprecated. */
        uint64_t rx_wpk_order          : 1;  /**< [ 41: 41](R/W) Receiver word packing order. Used when the GSERC()_LANE()_CONTROL_BCFG[LN_CTRL_RX_WIDTH]
                                                                 is set to 0x3 to configure the GSERC PHY to 20-bit receive path data width
                                                                 for the 10.3125Gbuad and lower Ethernet data rates.
                                                                 When [RX_WPK_ORDER] is set to 1 the first (earliest) 20-bit word received from the GSERC PHY
                                                                 is packed into the lower 20-bit word position of the 40-bit word and the second (later)
                                                                 20-bit word received is packed into the upper 20-bit word position of the 40-bit word.
                                                                 When [RX_WPK_ORDER] is cleared to 0 the 20-bit word packing order within the 40-bit word
                                                                 is swapped. Set [RX_WUP_ORDER] to 1 for normal Ethernet receive data to the CGX Ethernet MAC.
                                                                 For diagnostic use only. */
        uint64_t rx_bitstrip_en        : 1;  /**< [ 42: 42](R/W) Enables the bit stripping logic used in the 2.4576Gbps CPRI rate.  Clear to a 0
                                                                 to reset the bit strip
                                                                 pattern lock FSM. */
        uint64_t rx_bitstrip_cfg       : 1;  /**< [ 43: 43](R/W) Configures the sampling position for the div 4 bit stripping logic at the 2.4576Gbps CPRI rate:
                                                                   0x0 = 135 degree sample.
                                                                   0x1 = 225 degree sample. */
        uint64_t cfg_cpri              : 1;  /**< [ 44: 44](R/W) Select for the lane tx clock and data muxes:
                                                                   0x0 = Ethernet ln_txclk and ln_txdata.
                                                                   0x1 = CPRI ln_txclk and ln_txdata. */
        uint64_t rx_bitstrip_mode      : 1;  /**< [ 45: 45](R/W) Selects the bitstrip div mode.
                                                                   0x0 = Div 2 bitstripping.
                                                                   0x1 = Div 4 bitstripping. */
        uint64_t cpri_txclk_bist_ovrd  : 2;  /**< [ 47: 46](R/W) Overrides the CPRI TXCLK MUX:
                                                                   0x0 = Standard operation.
                                                                   0x1 = Select div2 txclk.
                                                                   0x2 = Reserved.
                                                                   0x3 = Select div4 txclk. */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lanex_control_bcfg_s cn; */
};
typedef union bdk_gsercx_lanex_control_bcfg bdk_gsercx_lanex_control_bcfg_t;

static inline uint64_t BDK_GSERCX_LANEX_CONTROL_BCFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LANEX_CONTROL_BCFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8081030ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LANEX_CONTROL_BCFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LANEX_CONTROL_BCFG(a,b) bdk_gsercx_lanex_control_bcfg_t
#define bustype_BDK_GSERCX_LANEX_CONTROL_BCFG(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_LANEX_CONTROL_BCFG(a,b) "GSERCX_LANEX_CONTROL_BCFG"
#define device_bar_BDK_GSERCX_LANEX_CONTROL_BCFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LANEX_CONTROL_BCFG(a,b) (a)
#define arguments_BDK_GSERCX_LANEX_CONTROL_BCFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_lane#_status_bsts
 *
 * GSERC PHY Lane Status Register
 */
union bdk_gsercx_lanex_status_bsts
{
    uint64_t u;
    struct bdk_gsercx_lanex_status_bsts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_22_63        : 42;
        uint64_t ln_rx_bitstrip_err    : 1;  /**< [ 21: 21](RO/H) Sticky bit that signals when the rx div4 fail counter has saturated when
                                                                 trying to lock to the bit stuffed rxdata. */
        uint64_t ln_rx_fifo_full       : 1;  /**< [ 20: 20](RO/H) Reserved.
                                                                 Internal:
                                                                 When set indicates that the RX FIFO between the PHY SerDes and CGX if full. Indicates the
                                                                 RX FIFO is overflowing.  This signal is not latched.  Used to debug cases in which the
                                                                 sclk frequency may be set too low and CGX is not keeping up with the RX FIFO in GSERR.
                                                                 For debug use only. */
        uint64_t ln_tx_fifo_empty      : 1;  /**< [ 19: 19](RO/H) Reserved.
                                                                 Internal:
                                                                 When set indicates that the TX FIFO between the PHY SerDes and CGX if empty. Indicates the
                                                                 TX FIFO is underflowing.  This signal is not latched.  Used to debug cases in which the
                                                                 sclk frequency may be set too low and CGX is not keeping up with the TX FIFO in GSERR.
                                                                 For debug use only. */
        uint64_t ln_an_stat_resolved   : 1;  /**< [ 18: 18](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates auto-negotiation has compledted the resolution of technology, pause enable,
                                                                 and FEC enable.  When asserted, [LN_AN_SEL[4:0]], [LN_AN_TX/RX_PAUSE_EN], [LN_AN_RS_FEC_EN],
                                                                 [LN_AN_BASE_FEC_EN], [LN_AN_RS_FEC_EN] are valid. */
        uint64_t ln_an_scan_for_carrier : 1; /**< [ 17: 17](RO/H) Reserved.
                                                                 Internal:
                                                                 Scan for carrier indicator.  When asserted, indicates that PHY auto-negotiation logic
                                                                 is currently in ABILITY_DETECT state, and CGX can scan for carrier. */
        uint64_t ln_an_link_sel        : 5;  /**< [ 16: 12](RO/H) Reserved.
                                                                 Internal:
                                                                 Encodes the technology ability bit number (A0-A24) that was resolved through auto-negotiation:
                                                                   0x0 = 1G_KX.
                                                                   0x1 = Reserved.
                                                                   0x2 = 10G_KR.
                                                                   0x3 = 40G_KR4.
                                                                   0x4 = 40G_CR4.
                                                                   0x5 = 100G_CR10.
                                                                   0x6 = 100G_KP4.
                                                                   0x7 = 100G_KR4.
                                                                   0x8 = 100G_CR4.
                                                                   0x9 = Reserved.
                                                                   0xA = 25G_GR.
                                                                   0xB = 25G_KR.
                                                                   0xC = 25G_CR.
                                                                   0xD = 50G_KR2.
                                                                   0xE = 50G_CR2. */
        uint64_t ln_an_rs_fec_en       : 1;  /**< [ 11: 11](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated output enable for Reed-Solomon FEC:
                                                                   0x0 = RS FEC must be switched off and muxed out of RX/TX paths.
                                                                   0x1 = RS FEC must be switched on and muxed into the RX/TX paths. */
        uint64_t ln_an_base_fec_en     : 1;  /**< [ 10: 10](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated output enable for Base-R FEC:
                                                                   0x0 = Base FEC must be switched off and muxed out of RX/TX paths.
                                                                   0x1 = Base FEC must be switched on and muxed into the RX/TX paths. */
        uint64_t ln_an_rx_pause_en     : 1;  /**< [  9:  9](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated enable signal to allow pause control packets that have arrived at the
                                                                 receiver to be detected in CGX and used to supsend the transmitter:
                                                                   0x0 = Pause control packets have no effect on the transmitter.
                                                                   0x1 = Pause control packets suspend the transmitter. */
        uint64_t ln_an_tx_pause_en     : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated enable signal to allow pause control packets to be generated in CGX and
                                                                 transmitted:
                                                                   0x0 = Prevents pause control packets from being generated.
                                                                   0x1 = Pause control packets can be sent via the transmitter. */
        uint64_t ln_an_dme_tx          : 1;  /**< [  7:  7](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates when AN circuit is transmitting valid DME pages, active high. */
        uint64_t ln_an_stat_good       : 1;  /**< [  6:  6](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates when AN is completed, active high. */
        uint64_t ln_lt_sigdet          : 1;  /**< [  5:  5](RO/H) Link training signal detect, active high. */
        uint64_t ln_stat_rxvalid       : 1;  /**< [  4:  4](RO/H) Lane RX valid, indicates when CDR has locked to data and all RX
                                                                 equalization has completed, active high. */
        uint64_t ln_stat_los           : 1;  /**< [  3:  3](RO/H) Loss of signal indicator:
                                                                   0x0 = Signal detected on LN_RXP/M pins.
                                                                   0x1 = No signal detected on LN_RXP/M pins. */
        uint64_t ln_rx_rdy             : 1;  /**< [  2:  2](RO/H) Lane RX ready indicator, active high. */
        uint64_t ln_tx_rdy             : 1;  /**< [  1:  1](RO/H) Lane TX ready indicator, active high. */
        uint64_t ln_state_chng_rdy     : 1;  /**< [  0:  0](RO/H) Lane reset, rate, and power state change ready status:
                                                                   0x0 = PHY is currently performing a power or rate transition so LN_RST,
                                                                         LN_CTRL_TX_RATE, LN_CTRL_RX_RATE, and LN_PD should not be changed.
                                                                   0x1 = PHY has completed the last transition and is ready for the next
                                                                         request. */
#else /* Word 0 - Little Endian */
        uint64_t ln_state_chng_rdy     : 1;  /**< [  0:  0](RO/H) Lane reset, rate, and power state change ready status:
                                                                   0x0 = PHY is currently performing a power or rate transition so LN_RST,
                                                                         LN_CTRL_TX_RATE, LN_CTRL_RX_RATE, and LN_PD should not be changed.
                                                                   0x1 = PHY has completed the last transition and is ready for the next
                                                                         request. */
        uint64_t ln_tx_rdy             : 1;  /**< [  1:  1](RO/H) Lane TX ready indicator, active high. */
        uint64_t ln_rx_rdy             : 1;  /**< [  2:  2](RO/H) Lane RX ready indicator, active high. */
        uint64_t ln_stat_los           : 1;  /**< [  3:  3](RO/H) Loss of signal indicator:
                                                                   0x0 = Signal detected on LN_RXP/M pins.
                                                                   0x1 = No signal detected on LN_RXP/M pins. */
        uint64_t ln_stat_rxvalid       : 1;  /**< [  4:  4](RO/H) Lane RX valid, indicates when CDR has locked to data and all RX
                                                                 equalization has completed, active high. */
        uint64_t ln_lt_sigdet          : 1;  /**< [  5:  5](RO/H) Link training signal detect, active high. */
        uint64_t ln_an_stat_good       : 1;  /**< [  6:  6](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates when AN is completed, active high. */
        uint64_t ln_an_dme_tx          : 1;  /**< [  7:  7](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates when AN circuit is transmitting valid DME pages, active high. */
        uint64_t ln_an_tx_pause_en     : 1;  /**< [  8:  8](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated enable signal to allow pause control packets to be generated in CGX and
                                                                 transmitted:
                                                                   0x0 = Prevents pause control packets from being generated.
                                                                   0x1 = Pause control packets can be sent via the transmitter. */
        uint64_t ln_an_rx_pause_en     : 1;  /**< [  9:  9](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated enable signal to allow pause control packets that have arrived at the
                                                                 receiver to be detected in CGX and used to supsend the transmitter:
                                                                   0x0 = Pause control packets have no effect on the transmitter.
                                                                   0x1 = Pause control packets suspend the transmitter. */
        uint64_t ln_an_base_fec_en     : 1;  /**< [ 10: 10](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated output enable for Base-R FEC:
                                                                   0x0 = Base FEC must be switched off and muxed out of RX/TX paths.
                                                                   0x1 = Base FEC must be switched on and muxed into the RX/TX paths. */
        uint64_t ln_an_rs_fec_en       : 1;  /**< [ 11: 11](RO/H) Reserved.
                                                                 Internal:
                                                                 Negotiated output enable for Reed-Solomon FEC:
                                                                   0x0 = RS FEC must be switched off and muxed out of RX/TX paths.
                                                                   0x1 = RS FEC must be switched on and muxed into the RX/TX paths. */
        uint64_t ln_an_link_sel        : 5;  /**< [ 16: 12](RO/H) Reserved.
                                                                 Internal:
                                                                 Encodes the technology ability bit number (A0-A24) that was resolved through auto-negotiation:
                                                                   0x0 = 1G_KX.
                                                                   0x1 = Reserved.
                                                                   0x2 = 10G_KR.
                                                                   0x3 = 40G_KR4.
                                                                   0x4 = 40G_CR4.
                                                                   0x5 = 100G_CR10.
                                                                   0x6 = 100G_KP4.
                                                                   0x7 = 100G_KR4.
                                                                   0x8 = 100G_CR4.
                                                                   0x9 = Reserved.
                                                                   0xA = 25G_GR.
                                                                   0xB = 25G_KR.
                                                                   0xC = 25G_CR.
                                                                   0xD = 50G_KR2.
                                                                   0xE = 50G_CR2. */
        uint64_t ln_an_scan_for_carrier : 1; /**< [ 17: 17](RO/H) Reserved.
                                                                 Internal:
                                                                 Scan for carrier indicator.  When asserted, indicates that PHY auto-negotiation logic
                                                                 is currently in ABILITY_DETECT state, and CGX can scan for carrier. */
        uint64_t ln_an_stat_resolved   : 1;  /**< [ 18: 18](RO/H) Reserved.
                                                                 Internal:
                                                                 Indicates auto-negotiation has compledted the resolution of technology, pause enable,
                                                                 and FEC enable.  When asserted, [LN_AN_SEL[4:0]], [LN_AN_TX/RX_PAUSE_EN], [LN_AN_RS_FEC_EN],
                                                                 [LN_AN_BASE_FEC_EN], [LN_AN_RS_FEC_EN] are valid. */
        uint64_t ln_tx_fifo_empty      : 1;  /**< [ 19: 19](RO/H) Reserved.
                                                                 Internal:
                                                                 When set indicates that the TX FIFO between the PHY SerDes and CGX if empty. Indicates the
                                                                 TX FIFO is underflowing.  This signal is not latched.  Used to debug cases in which the
                                                                 sclk frequency may be set too low and CGX is not keeping up with the TX FIFO in GSERR.
                                                                 For debug use only. */
        uint64_t ln_rx_fifo_full       : 1;  /**< [ 20: 20](RO/H) Reserved.
                                                                 Internal:
                                                                 When set indicates that the RX FIFO between the PHY SerDes and CGX if full. Indicates the
                                                                 RX FIFO is overflowing.  This signal is not latched.  Used to debug cases in which the
                                                                 sclk frequency may be set too low and CGX is not keeping up with the RX FIFO in GSERR.
                                                                 For debug use only. */
        uint64_t ln_rx_bitstrip_err    : 1;  /**< [ 21: 21](RO/H) Sticky bit that signals when the rx div4 fail counter has saturated when
                                                                 trying to lock to the bit stuffed rxdata. */
        uint64_t reserved_22_63        : 42;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lanex_status_bsts_s cn; */
};
typedef union bdk_gsercx_lanex_status_bsts bdk_gsercx_lanex_status_bsts_t;

static inline uint64_t BDK_GSERCX_LANEX_STATUS_BSTS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LANEX_STATUS_BSTS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8081070ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LANEX_STATUS_BSTS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LANEX_STATUS_BSTS(a,b) bdk_gsercx_lanex_status_bsts_t
#define bustype_BDK_GSERCX_LANEX_STATUS_BSTS(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_LANEX_STATUS_BSTS(a,b) "GSERCX_LANEX_STATUS_BSTS"
#define device_bar_BDK_GSERCX_LANEX_STATUS_BSTS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LANEX_STATUS_BSTS(a,b) (a)
#define arguments_BDK_GSERCX_LANEX_STATUS_BSTS(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_lane#_txclk_ctr
 *
 * GSERC Reference Clock Cycle Counter Register
 * A free-running cycle counter of the TX Clock Mux Output to enable rough
 * confirmation of tx clock frequency via software. Read the counter; wait some
 * time, e.g., 100ms; read the counter; calculate frequency based on the difference in
 * values during the known wait time.
 */
union bdk_gsercx_lanex_txclk_ctr
{
    uint64_t u;
    struct bdk_gsercx_lanex_txclk_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running cycle count of the TX Clock Mux Output. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running cycle count of the TX Clock Mux Output. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lanex_txclk_ctr_s cn; */
};
typedef union bdk_gsercx_lanex_txclk_ctr bdk_gsercx_lanex_txclk_ctr_t;

static inline uint64_t BDK_GSERCX_LANEX_TXCLK_CTR(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LANEX_TXCLK_CTR(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8081090ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LANEX_TXCLK_CTR", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LANEX_TXCLK_CTR(a,b) bdk_gsercx_lanex_txclk_ctr_t
#define bustype_BDK_GSERCX_LANEX_TXCLK_CTR(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_LANEX_TXCLK_CTR(a,b) "GSERCX_LANEX_TXCLK_CTR"
#define device_bar_BDK_GSERCX_LANEX_TXCLK_CTR(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LANEX_TXCLK_CTR(a,b) (a)
#define arguments_BDK_GSERCX_LANEX_TXCLK_CTR(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page0
 *
 * GSERC Ln Aneg Base Page0 Register
 */
union bdk_gsercx_lnx_aneg_base_page0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Echoed Nonce Field bits 2-0.  AN controller generates it. */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Technology Select Field. */
#else /* Word 0 - Little Endian */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Technology Select Field. */
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Echoed Nonce Field bits 2-0.  AN controller generates it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page0 bdk_gsercx_lnx_aneg_base_page0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) bdk_gsercx_lnx_aneg_base_page0_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) "GSERCX_LNX_ANEG_BASE_PAGE0"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page1
 *
 * GSERC Ln Aneg Base Page1 Register
 */
union bdk_gsercx_lnx_aneg_base_page1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](R/W/H) Next Page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_6            : 1;
        uint32_t remote_fault          : 1;  /**< [  5:  5](R/W/H) Remote Fault Local Device
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t c2                    : 1;  /**< [  4:  4](R/W/H) Reserved always 0. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](R/W/H) Pause ASM_DIR advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t pause                 : 1;  /**< [  2:  2](R/W/H) Pause advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Echoed Nonce Field bits 4-3.    AN controller generates it. */
#else /* Word 0 - Little Endian */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Echoed Nonce Field bits 4-3.    AN controller generates it. */
        uint32_t pause                 : 1;  /**< [  2:  2](R/W/H) Pause advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](R/W/H) Pause ASM_DIR advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t c2                    : 1;  /**< [  4:  4](R/W/H) Reserved always 0. */
        uint32_t remote_fault          : 1;  /**< [  5:  5](R/W/H) Remote Fault Local Device
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_6            : 1;
        uint32_t next_page             : 1;  /**< [  7:  7](R/W/H) Next Page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page1 bdk_gsercx_lnx_aneg_base_page1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) bdk_gsercx_lnx_aneg_base_page1_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) "GSERCX_LNX_ANEG_BASE_PAGE1"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page2
 *
 * GSERC Ln Aneg Base Page2 Register
 */
union bdk_gsercx_lnx_aneg_base_page2
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field.  It is generated in hardware. */
#else /* Word 0 - Little Endian */
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field.  It is generated in hardware. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page2_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page2 bdk_gsercx_lnx_aneg_base_page2_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) bdk_gsercx_lnx_aneg_base_page2_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) "GSERCX_LNX_ANEG_BASE_PAGE2"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_fec
 *
 * GSERC Ln Aneg Base Page Fec Register
 */
union bdk_gsercx_lnx_aneg_base_page_fec
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page_fec_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](R/W/H) Base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-GR-S 25G-
                                                                 KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For prior
                                                                 versions, it corresponds to A24 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](R/W/H) Base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A23 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fec_req               : 1;  /**< [  1:  1](R/W/H) Base page bit F1.  It requests FEC to be turned on when supported at the both ends of link.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fec_ability           : 1;  /**< [  0:  0](R/W/H) Base page bit F0.  It advertises FEC ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t fec_ability           : 1;  /**< [  0:  0](R/W/H) Base page bit F0.  It advertises FEC ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fec_req               : 1;  /**< [  1:  1](R/W/H) Base page bit F1.  It requests FEC to be turned on when supported at the both ends of link.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](R/W/H) Base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A23 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](R/W/H) Base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-GR-S 25G-
                                                                 KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For prior
                                                                 versions, it corresponds to A24 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page_fec_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page_fec bdk_gsercx_lnx_aneg_base_page_fec_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cf0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_FEC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) bdk_gsercx_lnx_aneg_base_page_fec_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_FEC"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE_FEC(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_tech0
 *
 * GSERC Ln Aneg Base Page Tech0 Register
 */
union bdk_gsercx_lnx_aneg_base_page_tech0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page_tech0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) 100GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) 100GBase-KP4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) 100GBase-CR10 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) 40GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) 40GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) 10GBase-KR technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) 10GBase-KX4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) 1000Base-KX technology advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) 1000Base-KX technology advertised ability
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) 10GBase-KX4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) 10GBase-KR technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) 40GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) 40GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) 100GBase-CR10 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) 100GBase-KP4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) 100GBase-KR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page_tech0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page_tech0 bdk_gsercx_lnx_aneg_base_page_tech0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_TECH0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) bdk_gsercx_lnx_aneg_base_page_tech0_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_TECH0"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_tech1
 *
 * GSERC Ln Aneg Base Page Tech1 Register
 */
union bdk_gsercx_lnx_aneg_base_page_tech1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page_tech1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](R/W/H) Technology advertised ability Field A15-A11.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) 25GBase-GR KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A10 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) 25GBase-GR-S KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A9 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) 100GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) 100GBase-CR4 technology advertised ability.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) 25GBase-GR-S KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A9 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) 25GBase-GR KR or CR technology advertised ability.  It is defined in IEEE
                                                                 802.3by.  For prior versions, it corresponds to A10 in base page.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](R/W/H) Technology advertised ability Field A15-A11.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page_tech1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page_tech1 bdk_gsercx_lnx_aneg_base_page_tech1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ce0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_TECH1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) bdk_gsercx_lnx_aneg_base_page_tech1_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_TECH1"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_base_page_tech2
 *
 * GSERC Ln Aneg Base Page Tech2 Register
 */
union bdk_gsercx_lnx_aneg_base_page_tech2
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_base_page_tech2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](R/W/H) Technology advertised ability Field A22-A16.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](R/W/H) Technology advertised ability Field A22-A16.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_base_page_tech2_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_base_page_tech2 bdk_gsercx_lnx_aneg_base_page_tech2_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ce8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_BASE_PAGE_TECH2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) bdk_gsercx_lnx_aneg_base_page_tech2_t
#define bustype_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) "GSERCX_LNX_ANEG_BASE_PAGE_TECH2"
#define device_bar_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_BASE_PAGE_TECH2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg0 Register
 */
union bdk_gsercx_lnx_aneg_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t page_rx_limit         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t np_loaded_limit       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t np_loaded_limit       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t page_rx_limit         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg0_rsvd bdk_gsercx_lnx_aneg_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG0_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG0_RSVD(a,b) "GSERCX_LNX_ANEG_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg10
 *
 * GSERC Ln Aneg Cfg10 Register
 */
union bdk_gsercx_lnx_aneg_cfg10
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t nonce_seed            : 8;  /**< [  7:  0](R/W/H) Seed provided to the transmit nonce generator polynomial. */
#else /* Word 0 - Little Endian */
        uint32_t nonce_seed            : 8;  /**< [  7:  0](R/W/H) Seed provided to the transmit nonce generator polynomial. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg10_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg10 bdk_gsercx_lnx_aneg_cfg10_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG10(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG10(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG10", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG10(a,b) bdk_gsercx_lnx_aneg_cfg10_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG10(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG10(a,b) "GSERCX_LNX_ANEG_CFG10"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG10(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG10(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG10(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg11
 *
 * GSERC Ln Aneg Cfg11 Register
 */
union bdk_gsercx_lnx_aneg_cfg11
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t pseudo_sel            : 1;  /**< [  0:  0](R/W/H) Selector for the DME page bit 49 pseudo-random generator. */
#else /* Word 0 - Little Endian */
        uint32_t pseudo_sel            : 1;  /**< [  0:  0](R/W/H) Selector for the DME page bit 49 pseudo-random generator. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg11_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg11 bdk_gsercx_lnx_aneg_cfg11_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG11(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG11(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG11", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG11(a,b) bdk_gsercx_lnx_aneg_cfg11_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG11(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG11(a,b) "GSERCX_LNX_ANEG_CFG11"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG11(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG11(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG11(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg1 Register
 */
union bdk_gsercx_lnx_aneg_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_1ms_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t timer_1ms_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg1_rsvd bdk_gsercx_lnx_aneg_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG1_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG1_RSVD(a,b) "GSERCX_LNX_ANEG_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg2_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg2 Register
 */
union bdk_gsercx_lnx_aneg_cfg2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_1ms_15_8        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t timer_1ms_15_8        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg2_rsvd bdk_gsercx_lnx_aneg_cfg2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG2_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg2_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG2_RSVD(a,b) "GSERCX_LNX_ANEG_CFG2_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg3_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg3 Register
 */
union bdk_gsercx_lnx_aneg_cfg3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_complete_ack_3_0 : 4; /**< [  7:  4](R/W/H) Reserved. */
        uint32_t timer_1ms_19_16       : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t timer_1ms_19_16       : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t timer_complete_ack_3_0 : 4; /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg3_rsvd bdk_gsercx_lnx_aneg_cfg3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG3_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg3_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG3_RSVD(a,b) "GSERCX_LNX_ANEG_CFG3_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg4_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg4 Register
 */
union bdk_gsercx_lnx_aneg_cfg4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_complete_ack_11_4 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t timer_complete_ack_11_4 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg4_rsvd bdk_gsercx_lnx_aneg_cfg4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG4_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg4_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG4_RSVD(a,b) "GSERCX_LNX_ANEG_CFG4_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg5_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg5 Register
 */
union bdk_gsercx_lnx_aneg_cfg5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t num_ms_an_wait_timer  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_ms_an_wait_timer  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg5_rsvd bdk_gsercx_lnx_aneg_cfg5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG5_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg5_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG5_RSVD(a,b) "GSERCX_LNX_ANEG_CFG5_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg6_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg6 Register
 */
union bdk_gsercx_lnx_aneg_cfg6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t num_ms_break_link_timer : 7;/**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_ms_break_link_timer : 7;/**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg6_rsvd bdk_gsercx_lnx_aneg_cfg6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG6_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg6_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG6_RSVD(a,b) "GSERCX_LNX_ANEG_CFG6_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg7_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg7 Register
 */
union bdk_gsercx_lnx_aneg_cfg7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t num_ms_link_fail_inhibit_timer_kx : 6;/**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_ms_link_fail_inhibit_timer_kx : 6;/**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg7_rsvd bdk_gsercx_lnx_aneg_cfg7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG7_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg7_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG7_RSVD(a,b) "GSERCX_LNX_ANEG_CFG7_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg8_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg8 Register
 */
union bdk_gsercx_lnx_aneg_cfg8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_ms_link_fail_inhibit_timer_non_kx_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_ms_link_fail_inhibit_timer_non_kx_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg8_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg8_rsvd bdk_gsercx_lnx_aneg_cfg8_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG8_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG8_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG8_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg8_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG8_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG8_RSVD(a,b) "GSERCX_LNX_ANEG_CFG8_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG8_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_cfg9_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Cfg9 Register
 */
union bdk_gsercx_lnx_aneg_cfg9_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_cfg9_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t num_ms_link_fail_inhibit_timer_non_kx_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_ms_link_fail_inhibit_timer_non_kx_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_cfg9_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_cfg9_rsvd bdk_gsercx_lnx_aneg_cfg9_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG9_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CFG9_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CFG9_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CFG9_RSVD(a,b) bdk_gsercx_lnx_aneg_cfg9_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CFG9_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CFG9_RSVD(a,b) "GSERCX_LNX_ANEG_CFG9_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CFG9_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CFG9_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CFG9_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_ctrl0
 *
 * GSERC Ln Aneg Ctrl0 Register
 */
union bdk_gsercx_lnx_aneg_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
#else /* Word 0 - Little Endian */
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    struct bdk_gsercx_lnx_aneg_ctrl0_cn
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t reserved_1_7          : 7;
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
#else /* Word 0 - Little Endian */
        uint32_t autoneg_restart       : 1;  /**< [  0:  0](R/W/H) Restarts AN that is already in progress or otherwise completed.  Reset is
                                                                 triggered by rising edge of this signal.  Not self clearing. */
        uint32_t reserved_1_7          : 7;
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } cn;
};
typedef union bdk_gsercx_lnx_aneg_ctrl0 bdk_gsercx_lnx_aneg_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CTRL0(a,b) bdk_gsercx_lnx_aneg_ctrl0_t
#define bustype_BDK_GSERCX_LNX_ANEG_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CTRL0(a,b) "GSERCX_LNX_ANEG_CTRL0"
#define device_bar_BDK_GSERCX_LNX_ANEG_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Ctrl1 Register
 */
union bdk_gsercx_lnx_aneg_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t autoneg_reset         : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_5_6          : 2;
        uint32_t autoneg_enable        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_0_3          : 4;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_3          : 4;
        uint32_t autoneg_enable        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_6          : 2;
        uint32_t autoneg_reset         : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_ctrl1_rsvd bdk_gsercx_lnx_aneg_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(a,b) bdk_gsercx_lnx_aneg_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(a,b) "GSERCX_LNX_ANEG_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Ctrl2 Register
 */
union bdk_gsercx_lnx_aneg_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t wait_ack2_update      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_ack2_update      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_ctrl2_rsvd bdk_gsercx_lnx_aneg_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(a,b) bdk_gsercx_lnx_aneg_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(a,b) "GSERCX_LNX_ANEG_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_eee_ability0_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Eee Ability0 Register
 */
union bdk_gsercx_lnx_aneg_eee_ability0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_eee_ability0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_eee_ability0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_eee_ability0_rsvd bdk_gsercx_lnx_aneg_eee_ability0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(a,b) bdk_gsercx_lnx_aneg_eee_ability0_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(a,b) "GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_EEE_ABILITY0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_eee_ability1_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Eee Ability1 Register
 */
union bdk_gsercx_lnx_aneg_eee_ability1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_eee_ability1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_eee_ability1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_eee_ability1_rsvd bdk_gsercx_lnx_aneg_eee_ability1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(a,b) bdk_gsercx_lnx_aneg_eee_ability1_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(a,b) "GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_EEE_ABILITY1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_extended0
 *
 * GSERC Ln Aneg Extended0 Register
 */
union bdk_gsercx_lnx_aneg_extended0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_extended0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Extended advertised FEC field 3.  It requests Fire code FEC to be turned on when
                                                                 supported at the both ends of link for 25G/50G consortium specification non-
                                                                 IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Extended advertised FEC field 2.  It requests Reed-Solomon FEC to be turned on
                                                                 when supported at the both ends of link for 25G/50G consortium specification
                                                                 non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Extended advertised FEC field 1.  It advertises Fire code FEC CL74 ability for
                                                                 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Extended advertised FEC field 0.  It advertises Reed-Solomon FEC CL91 ability
                                                                 for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) 50GBase-CR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) 50GBase-KR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) 25GBase-CR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) 25GBase-KR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) 25GBase-KR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) 25GBase-CR technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) 50GBase-KR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) 50GBase-CR2 technology advertised ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Extended advertised FEC field 0.  It advertises Reed-Solomon FEC CL91 ability
                                                                 for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Extended advertised FEC field 1.  It advertises Fire code FEC CL74 ability for
                                                                 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Extended advertised FEC field 2.  It requests Reed-Solomon FEC to be turned on
                                                                 when supported at the both ends of link for 25G/50G consortium specification
                                                                 non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Extended advertised FEC field 3.  It requests Fire code FEC to be turned on when
                                                                 supported at the both ends of link for 25G/50G consortium specification non-
                                                                 IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_extended0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_extended0 bdk_gsercx_lnx_aneg_extended0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_EXTENDED0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_EXTENDED0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010cf8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_EXTENDED0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_EXTENDED0(a,b) bdk_gsercx_lnx_aneg_extended0_t
#define bustype_BDK_GSERCX_LNX_ANEG_EXTENDED0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_EXTENDED0(a,b) "GSERCX_LNX_ANEG_EXTENDED0"
#define device_bar_BDK_GSERCX_LNX_ANEG_EXTENDED0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_EXTENDED0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_EXTENDED0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_link_status0
 *
 * GSERC Ln Aneg Link Status0 Register
 */
union bdk_gsercx_lnx_aneg_link_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_link_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link status for 100GBase-KR4. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link status for 100GBase-KP4. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link status for 100GBase-CR10. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link status for 40GBase-CR4. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link status for 40GBase-KR4. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link status for 10GBase-KR. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link status for 10GBase-KX4. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link status for 1000Base-KX. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link status for 1000Base-KX. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link status for 10GBase-KX4. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link status for 10GBase-KR. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link status for 40GBase-KR4. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link status for 40GBase-CR4. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link status for 100GBase-CR10. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link status for 100GBase-KP4. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link status for 100GBase-KR4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_link_status0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_link_status0 bdk_gsercx_lnx_aneg_link_status0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LINK_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LINK_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010df0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LINK_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) bdk_gsercx_lnx_aneg_link_status0_t
#define bustype_BDK_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) "GSERCX_LNX_ANEG_LINK_STATUS0"
#define device_bar_BDK_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LINK_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_link_status1
 *
 * GSERC Ln Aneg Link Status1 Register
 */
union bdk_gsercx_lnx_aneg_link_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_link_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](RO/H) Link status for 50GBase-CR2. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](RO/H) Link status for 50GBase-KR2. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](RO/H) Link status for 25GBase-CR4. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](RO/H) Link status for 25GBase-KR. */
        uint32_t reserved_2            : 1;
        uint32_t ability_25g_gr        : 1;  /**< [  1:  1](RO/H) Link status for 25GBase-GR KR/CR or 25GBase-GR-S KR-S/CR-S. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link status for 100GBase-CR4. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link status for 100GBase-CR4. */
        uint32_t ability_25g_gr        : 1;  /**< [  1:  1](RO/H) Link status for 25GBase-GR KR/CR or 25GBase-GR-S KR-S/CR-S. */
        uint32_t reserved_2            : 1;
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](RO/H) Link status for 25GBase-KR. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](RO/H) Link status for 25GBase-CR4. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](RO/H) Link status for 50GBase-KR2. */
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](RO/H) Link status for 50GBase-CR2. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_link_status1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_link_status1 bdk_gsercx_lnx_aneg_link_status1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LINK_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LINK_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010df8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LINK_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) bdk_gsercx_lnx_aneg_link_status1_t
#define bustype_BDK_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) "GSERCX_LNX_ANEG_LINK_STATUS1"
#define device_bar_BDK_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LINK_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page0
 *
 * GSERC Ln Aneg Lp Base Page0 Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Link partner Echoed Nonce Field bits 2-0. */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Link partner technology Select Field. */
#else /* Word 0 - Little Endian */
        uint32_t selector              : 5;  /**< [  4:  0](RO/H) Link partner technology Select Field. */
        uint32_t echoed_nonce_2_0      : 3;  /**< [  7:  5](RO/H) Link partner Echoed Nonce Field bits 2-0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page0 bdk_gsercx_lnx_aneg_lp_base_page0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) bdk_gsercx_lnx_aneg_lp_base_page0_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE0"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page1
 *
 * GSERC Ln Aneg Lp Base Page1 Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner Next Page. */
        uint32_t ack                   : 1;  /**< [  6:  6](RO/H) Link partner Acknowledge always 0. */
        uint32_t remote_fault          : 1;  /**< [  5:  5](RO/H) Link partner Remote Fault. */
        uint32_t c2                    : 1;  /**< [  4:  4](RO/H) Link partner C2 field always 0. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](RO/H) Link partner Pause ASM_DIR advertised ability. */
        uint32_t pause                 : 1;  /**< [  2:  2](RO/H) Link partner Pause advertised ability. */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Link partner Echoed Nonce Field bits 4-3. */
#else /* Word 0 - Little Endian */
        uint32_t echoed_nonce_4_3      : 2;  /**< [  1:  0](RO/H) Link partner Echoed Nonce Field bits 4-3. */
        uint32_t pause                 : 1;  /**< [  2:  2](RO/H) Link partner Pause advertised ability. */
        uint32_t asm_dir               : 1;  /**< [  3:  3](RO/H) Link partner Pause ASM_DIR advertised ability. */
        uint32_t c2                    : 1;  /**< [  4:  4](RO/H) Link partner C2 field always 0. */
        uint32_t remote_fault          : 1;  /**< [  5:  5](RO/H) Link partner Remote Fault. */
        uint32_t ack                   : 1;  /**< [  6:  6](RO/H) Link partner Acknowledge always 0. */
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner Next Page. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page1 bdk_gsercx_lnx_aneg_lp_base_page1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) bdk_gsercx_lnx_aneg_lp_base_page1_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE1"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page2
 *
 * GSERC Ln Aneg Lp Base Page2 Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page2
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field from Link partner. */
#else /* Word 0 - Little Endian */
        uint32_t tx_nonce              : 5;  /**< [  4:  0](RO/H) Transmitted Nonce Field from Link partner. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page2_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page2 bdk_gsercx_lnx_aneg_lp_base_page2_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) bdk_gsercx_lnx_aneg_lp_base_page2_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE2"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_fec
 *
 * GSERC Ln Aneg Lp Base Page Fec Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page_fec
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page_fec_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](RO/H) Link partner base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-
                                                                 GR-S 25G-KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For
                                                                 prior versions, it corresponds to A24 in base page. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](RO/H) Link partner base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.
                                                                 It is defined in IEEE 802.3by.  For prior versions, it corresponds to A23 in
                                                                 base page. */
        uint32_t fec_req               : 1;  /**< [  1:  1](RO/H) Link partner base page bit F1.  It requests FEC to be turned on when supported
                                                                 at the both ends of link. */
        uint32_t fec_ability           : 1;  /**< [  0:  0](RO/H) Link partner base page bit F0.  It advertises FEC ability. */
#else /* Word 0 - Little Endian */
        uint32_t fec_ability           : 1;  /**< [  0:  0](RO/H) Link partner base page bit F0.  It advertises FEC ability. */
        uint32_t fec_req               : 1;  /**< [  1:  1](RO/H) Link partner base page bit F1.  It requests FEC to be turned on when supported
                                                                 at the both ends of link. */
        uint32_t rs_fec_req_25g        : 1;  /**< [  2:  2](RO/H) Link partner base page bit F2.  It requests RS-FEC for 25G-GR 25G-KR/-CR link.
                                                                 It is defined in IEEE 802.3by.  For prior versions, it corresponds to A23 in
                                                                 base page. */
        uint32_t fc_fec_req_25g        : 1;  /**< [  3:  3](RO/H) Link partner base page bit F3.  It requests FC-FEC Base-R FEC for 25G-GR or 25G-
                                                                 GR-S 25G-KR/-CR or 25G-KR-S/-CR-S link.  It is defined in IEEE 802.3by.  For
                                                                 prior versions, it corresponds to A24 in base page. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page_fec_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page_fec bdk_gsercx_lnx_aneg_lp_base_page_fec_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) bdk_gsercx_lnx_aneg_lp_base_page_fec_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_FEC(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_tech0
 *
 * GSERC Ln Aneg Lp Base Page Tech0 Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page_tech0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page_tech0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link partner 100GBase-KR4 technology advertised ability. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link partner 100GBase-KP4 technology advertised ability. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link partner 100GBase-CR10 technology advertised ability. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link partner 40GBase-CR4 technology advertised ability. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link partner 40GBase-KR4 technology advertised ability. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link partner 10GBase-KR technology advertised ability. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link partner 10GBase-KX4 technology advertised ability. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link partner 1000Base-KX technology advertised ability. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](RO/H) Link partner 1000Base-KX technology advertised ability. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](RO/H) Link partner 10GBase-KX4 technology advertised ability. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](RO/H) Link partner 10GBase-KR technology advertised ability. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](RO/H) Link partner 40GBase-KR4 technology advertised ability. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](RO/H) Link partner 40GBase-CR4 technology advertised ability. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](RO/H) Link partner 100GBase-CR10 technology advertised ability. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](RO/H) Link partner 100GBase-KP4 technology advertised ability. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](RO/H) Link partner 100GBase-KR4 technology advertised ability. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page_tech0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page_tech0 bdk_gsercx_lnx_aneg_lp_base_page_tech0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) bdk_gsercx_lnx_aneg_lp_base_page_tech0_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_tech1
 *
 * GSERC Ln Aneg Lp Base Page Tech1 Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page_tech1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page_tech1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](RO/H) Link partner technology advertised ability Field A15-A11. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](RO/H) Link partner 25GBase-GR KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A10 in base page. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](RO/H) Link partner 25GBase-GR-S KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A9 in base page. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link partner 100GBase-CR4 technology advertised ability. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](RO/H) Link partner 100GBase-CR4 technology advertised ability. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](RO/H) Link partner 25GBase-GR-S KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A9 in base page. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](RO/H) Link partner 25GBase-GR KR or CR technology advertised ability.  It is defined
                                                                 in IEEE 802.3by.  For prior versions, it corresponds to A10 in base page. */
        uint32_t ability_a15_a11       : 5;  /**< [  7:  3](RO/H) Link partner technology advertised ability Field A15-A11. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page_tech1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page_tech1 bdk_gsercx_lnx_aneg_lp_base_page_tech1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) bdk_gsercx_lnx_aneg_lp_base_page_tech1_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_base_page_tech2
 *
 * GSERC Ln Aneg Lp Base Page Tech2 Register
 */
union bdk_gsercx_lnx_aneg_lp_base_page_tech2
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_base_page_tech2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](RO/H) Link partner technology advertised ability Field A22-A16. */
#else /* Word 0 - Little Endian */
        uint32_t ability_a22_a16       : 7;  /**< [  6:  0](RO/H) Link partner technology advertised ability Field A22-A16. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_base_page_tech2_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_base_page_tech2 bdk_gsercx_lnx_aneg_lp_base_page_tech2_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) bdk_gsercx_lnx_aneg_lp_base_page_tech2_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) "GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_BASE_PAGE_TECH2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_eee_ability0_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Lp Eee Ability0 Register
 */
union bdk_gsercx_lnx_aneg_lp_eee_ability0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_eee_ability0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_eee_ability0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_eee_ability0_rsvd bdk_gsercx_lnx_aneg_lp_eee_ability0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010db0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(a,b) bdk_gsercx_lnx_aneg_lp_eee_ability0_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(a,b) "GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_eee_ability1_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Lp Eee Ability1 Register
 */
union bdk_gsercx_lnx_aneg_lp_eee_ability1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_eee_ability1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_eee_ability1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_eee_ability1_rsvd bdk_gsercx_lnx_aneg_lp_eee_ability1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010db8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(a,b) bdk_gsercx_lnx_aneg_lp_eee_ability1_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(a,b) "GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_EEE_ABILITY1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_extended0
 *
 * GSERC Ln Aneg Lp Extended0 Register
 */
union bdk_gsercx_lnx_aneg_lp_extended0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_extended0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Link partner extended advertised FEC field 3.  It requests Fire code FEC to be
                                                                 turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Link partner extended advertised FEC field 2.  It requests Reed-Solomon FEC to
                                                                 be turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Link partner extended advertised FEC field 1.  It advertises Fire code FEC CL74
                                                                 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Link partner extended advertised FEC field 0.  It advertises Reed-Solomon FEC
                                                                 CL91 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) Link partner 50GBase-CR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) Link partner 50GBase-KR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) Link partner 25GBase-CR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) Link partner 25GBase-KR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_25g_kr        : 1;  /**< [  0:  0](R/W/H) Link partner 25GBase-KR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  1:  1](R/W/H) Link partner 25GBase-CR technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  2:  2](R/W/H) Link partner 50GBase-KR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  3:  3](R/W/H) Link partner 50GBase-CR2 technology advertised ability for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_ability        : 1;  /**< [  4:  4](R/W/H) Link partner extended advertised FEC field 0.  It advertises Reed-Solomon FEC
                                                                 CL91 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_ability        : 1;  /**< [  5:  5](R/W/H) Link partner extended advertised FEC field 1.  It advertises Fire code FEC CL74
                                                                 ability for 25G/50G consortium specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t rs_fec_req            : 1;  /**< [  6:  6](R/W/H) Link partner extended advertised FEC field 2.  It requests Reed-Solomon FEC to
                                                                 be turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t fc_fec_req            : 1;  /**< [  7:  7](R/W/H) Link partner extended advertised FEC field 3.  It requests Fire code FEC to be
                                                                 turned on when supported at the both ends of link for 25G/50G consortium
                                                                 specification non-IEEE.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_extended0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_extended0 bdk_gsercx_lnx_aneg_lp_extended0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d78ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_EXTENDED0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) bdk_gsercx_lnx_aneg_lp_extended0_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) "GSERCX_LNX_ANEG_LP_EXTENDED0"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_EXTENDED0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data0
 *
 * GSERC Ln Aneg Lp Np Data0 Register
 */
union bdk_gsercx_lnx_aneg_lp_np_data0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_np_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 7-0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 7-0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_np_data0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_np_data0 bdk_gsercx_lnx_aneg_lp_np_data0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) bdk_gsercx_lnx_aneg_lp_np_data0_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA0"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_NP_DATA0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data1
 *
 * GSERC Ln Aneg Lp Np Data1 Register
 */
union bdk_gsercx_lnx_aneg_lp_np_data1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_np_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner next page codeword field 'Next Page'. */
        uint32_t reserved_6            : 1;
        uint32_t msg_page              : 1;  /**< [  5:  5](RO/H) Link partner next page codeword field 'Massage Page'. */
        uint32_t ack2                  : 1;  /**< [  4:  4](RO/H) Link partner next page codeword field 'ACK2'. */
        uint32_t toggle                : 1;  /**< [  3:  3](RO/H) Link partner next page codeword field 'Toggle'. */
        uint32_t d10_d8                : 3;  /**< [  2:  0](RO/H) Link partner next page codeword bits 10-8. */
#else /* Word 0 - Little Endian */
        uint32_t d10_d8                : 3;  /**< [  2:  0](RO/H) Link partner next page codeword bits 10-8. */
        uint32_t toggle                : 1;  /**< [  3:  3](RO/H) Link partner next page codeword field 'Toggle'. */
        uint32_t ack2                  : 1;  /**< [  4:  4](RO/H) Link partner next page codeword field 'ACK2'. */
        uint32_t msg_page              : 1;  /**< [  5:  5](RO/H) Link partner next page codeword field 'Massage Page'. */
        uint32_t reserved_6            : 1;
        uint32_t next_page             : 1;  /**< [  7:  7](RO/H) Link partner next page codeword field 'Next Page'. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_np_data1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_np_data1 bdk_gsercx_lnx_aneg_lp_np_data1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) bdk_gsercx_lnx_aneg_lp_np_data1_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA1"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_NP_DATA1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data2
 *
 * GSERC Ln Aneg Lp Np Data2 Register
 */
union bdk_gsercx_lnx_aneg_lp_np_data2
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_np_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 23-16. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 23-16. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_np_data2_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_np_data2 bdk_gsercx_lnx_aneg_lp_np_data2_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) bdk_gsercx_lnx_aneg_lp_np_data2_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA2"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_NP_DATA2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data3
 *
 * GSERC Ln Aneg Lp Np Data3 Register
 */
union bdk_gsercx_lnx_aneg_lp_np_data3
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_np_data3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 31-24. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 31-24. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_np_data3_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_np_data3 bdk_gsercx_lnx_aneg_lp_np_data3_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) bdk_gsercx_lnx_aneg_lp_np_data3_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA3"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_NP_DATA3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data4
 *
 * GSERC Ln Aneg Lp Np Data4 Register
 */
union bdk_gsercx_lnx_aneg_lp_np_data4
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_np_data4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword  bits 39-32. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword  bits 39-32. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_np_data4_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_np_data4 bdk_gsercx_lnx_aneg_lp_np_data4_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010da0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) bdk_gsercx_lnx_aneg_lp_np_data4_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA4"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_NP_DATA4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_lp_np_data5
 *
 * GSERC Ln Aneg Lp Np Data5 Register
 */
union bdk_gsercx_lnx_aneg_lp_np_data5
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_lp_np_data5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 47-40. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Link partner next page codeword bits 47-40. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_lp_np_data5_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_lp_np_data5 bdk_gsercx_lnx_aneg_lp_np_data5_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010da8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_LP_NP_DATA5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) bdk_gsercx_lnx_aneg_lp_np_data5_t
#define bustype_BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) "GSERCX_LNX_ANEG_LP_NP_DATA5"
#define device_bar_BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_LP_NP_DATA5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_np_data0_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Np Data0 Register
 */
union bdk_gsercx_lnx_aneg_np_data0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_np_data0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_np_data0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_np_data0_rsvd bdk_gsercx_lnx_aneg_np_data0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_NP_DATA0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(a,b) bdk_gsercx_lnx_aneg_np_data0_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(a,b) "GSERCX_LNX_ANEG_NP_DATA0_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_NP_DATA0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_np_data1_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Np Data1 Register
 */
union bdk_gsercx_lnx_aneg_np_data1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_np_data1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t next_page             : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t msg_page              : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t ack2                  : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t toggle                : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t d10_d8                : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t d10_d8                : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t toggle                : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t ack2                  : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t msg_page              : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t next_page             : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_np_data1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_np_data1_rsvd bdk_gsercx_lnx_aneg_np_data1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_NP_DATA1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(a,b) bdk_gsercx_lnx_aneg_np_data1_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(a,b) "GSERCX_LNX_ANEG_NP_DATA1_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_NP_DATA1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_np_data2_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Np Data2 Register
 */
union bdk_gsercx_lnx_aneg_np_data2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_np_data2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_np_data2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_np_data2_rsvd bdk_gsercx_lnx_aneg_np_data2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_NP_DATA2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(a,b) bdk_gsercx_lnx_aneg_np_data2_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(a,b) "GSERCX_LNX_ANEG_NP_DATA2_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_NP_DATA2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_np_data3_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Np Data3 Register
 */
union bdk_gsercx_lnx_aneg_np_data3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_np_data3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_np_data3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_np_data3_rsvd bdk_gsercx_lnx_aneg_np_data3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_NP_DATA3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(a,b) bdk_gsercx_lnx_aneg_np_data3_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(a,b) "GSERCX_LNX_ANEG_NP_DATA3_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_NP_DATA3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_np_data4_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Np Data4 Register
 */
union bdk_gsercx_lnx_aneg_np_data4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_np_data4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_np_data4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_np_data4_rsvd bdk_gsercx_lnx_aneg_np_data4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_NP_DATA4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(a,b) bdk_gsercx_lnx_aneg_np_data4_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(a,b) "GSERCX_LNX_ANEG_NP_DATA4_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_NP_DATA4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_np_data5_rsvd
 *
 * INTERNAL: GSERC Ln Aneg Np Data5 Register
 */
union bdk_gsercx_lnx_aneg_np_data5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_np_data5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_np_data5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_np_data5_rsvd bdk_gsercx_lnx_aneg_np_data5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_NP_DATA5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(a,b) bdk_gsercx_lnx_aneg_np_data5_rsvd_t
#define bustype_BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(a,b) "GSERCX_LNX_ANEG_NP_DATA5_RSVD"
#define device_bar_BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_NP_DATA5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_eee
 *
 * GSERC Ln Aneg Resolution Eee Register
 */
union bdk_gsercx_lnx_aneg_resolution_eee
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_resolution_eee_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Resolution result for EEE.  It is 1 if both the local device and the link
                                                                 partner advertise the EEE capability for the resolved PHY type.  It is 0
                                                                 otherwise.  It is valid when status0.an_link_good is 1.
                                                                 Note that it indicates EEE deep sleep capability. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Resolution result for EEE.  It is 1 if both the local device and the link
                                                                 partner advertise the EEE capability for the resolved PHY type.  It is 0
                                                                 otherwise.  It is valid when status0.an_link_good is 1.
                                                                 Note that it indicates EEE deep sleep capability. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_resolution_eee_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_resolution_eee bdk_gsercx_lnx_aneg_resolution_eee_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010de0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_EEE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) bdk_gsercx_lnx_aneg_resolution_eee_t
#define bustype_BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) "GSERCX_LNX_ANEG_RESOLUTION_EEE"
#define device_bar_BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_RESOLUTION_EEE(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_fec
 *
 * GSERC Ln Aneg Resolution Fec Register
 */
union bdk_gsercx_lnx_aneg_resolution_fec
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_resolution_fec_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fc                    : 1;  /**< [  1:  1](R/W/H) Resolution result for Firecode base page FEC.  It is valid when status0.an_link_good is 1. */
        uint32_t rs                    : 1;  /**< [  0:  0](R/W/H) Resolution result for Reed-Solomon FEC.  It is valid when status0.an_link_good is 1. */
#else /* Word 0 - Little Endian */
        uint32_t rs                    : 1;  /**< [  0:  0](R/W/H) Resolution result for Reed-Solomon FEC.  It is valid when status0.an_link_good is 1. */
        uint32_t fc                    : 1;  /**< [  1:  1](R/W/H) Resolution result for Firecode base page FEC.  It is valid when status0.an_link_good is 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_resolution_fec_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_resolution_fec bdk_gsercx_lnx_aneg_resolution_fec_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_FEC", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) bdk_gsercx_lnx_aneg_resolution_fec_t
#define bustype_BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) "GSERCX_LNX_ANEG_RESOLUTION_FEC"
#define device_bar_BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_RESOLUTION_FEC(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_pause
 *
 * GSERC Ln Aneg Resolution Pause Register
 */
union bdk_gsercx_lnx_aneg_resolution_pause
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_resolution_pause_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tx                    : 1;  /**< [  1:  1](RO/H) Resolution result for TX PAUSE enable.    It is valid when status0.an_link_good is 1. */
        uint32_t rx                    : 1;  /**< [  0:  0](RO/H) Resolution result for RX PAUSE enable.    It is valid when status0.an_link_good is 1. */
#else /* Word 0 - Little Endian */
        uint32_t rx                    : 1;  /**< [  0:  0](RO/H) Resolution result for RX PAUSE enable.    It is valid when status0.an_link_good is 1. */
        uint32_t tx                    : 1;  /**< [  1:  1](RO/H) Resolution result for TX PAUSE enable.    It is valid when status0.an_link_good is 1. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_resolution_pause_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_resolution_pause bdk_gsercx_lnx_aneg_resolution_pause_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_PAUSE", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) bdk_gsercx_lnx_aneg_resolution_pause_t
#define bustype_BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) "GSERCX_LNX_ANEG_RESOLUTION_PAUSE"
#define device_bar_BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_RESOLUTION_PAUSE(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_tech0
 *
 * GSERC Ln Aneg Resolution Tech0 Register
 */
union bdk_gsercx_lnx_aneg_resolution_tech0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_resolution_tech0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Resolution result for 100GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Resolution result for 100GBase-KP4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Resolution result for 100GBase-CR10.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Resolution result for 40GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Resolution result for 40GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 10GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Resolution result for 10GBase-KX4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Resolution result for 1000Base-KX.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_1g_kx         : 1;  /**< [  0:  0](R/W/H) Resolution result for 1000Base-KX.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kx4       : 1;  /**< [  1:  1](R/W/H) Resolution result for 10GBase-KX4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_10g_kr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 10GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_kr4       : 1;  /**< [  3:  3](R/W/H) Resolution result for 40GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_40g_cr4       : 1;  /**< [  4:  4](R/W/H) Resolution result for 40GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr10     : 1;  /**< [  5:  5](R/W/H) Resolution result for 100GBase-CR10.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kp4      : 1;  /**< [  6:  6](R/W/H) Resolution result for 100GBase-KP4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_kr4      : 1;  /**< [  7:  7](R/W/H) Resolution result for 100GBase-KR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_resolution_tech0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_resolution_tech0 bdk_gsercx_lnx_aneg_resolution_tech0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_TECH0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) bdk_gsercx_lnx_aneg_resolution_tech0_t
#define bustype_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) "GSERCX_LNX_ANEG_RESOLUTION_TECH0"
#define device_bar_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_resolution_tech1
 *
 * GSERC Ln Aneg Resolution Tech1 Register
 */
union bdk_gsercx_lnx_aneg_resolution_tech1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_resolution_tech1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Resolution result for 50GBase-CR2.  It is valid when status0.an_link_good is 1. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Resolution result for 50GBase-KR2.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Resolution result for 25GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Resolution result for 25GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 25GBase-GR KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Resolution result for 25GBase-GR-S KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Resolution result for 100GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t ability_100g_cr4      : 1;  /**< [  0:  0](R/W/H) Resolution result for 100GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr_s      : 1;  /**< [  1:  1](R/W/H) Resolution result for 25GBase-GR-S KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_gr        : 1;  /**< [  2:  2](R/W/H) Resolution result for 25GBase-GR KR or CR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_kr        : 1;  /**< [  3:  3](R/W/H) Resolution result for 25GBase-KR.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_25g_cr        : 1;  /**< [  4:  4](R/W/H) Resolution result for 25GBase-CR4.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_kr2       : 1;  /**< [  5:  5](R/W/H) Resolution result for 50GBase-KR2.  It is valid when status0.an_link_good is 1.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t ability_50g_cr2       : 1;  /**< [  6:  6](R/W/H) Resolution result for 50GBase-CR2.  It is valid when status0.an_link_good is 1. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_resolution_tech1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_resolution_tech1 bdk_gsercx_lnx_aneg_resolution_tech1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010dc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_RESOLUTION_TECH1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) bdk_gsercx_lnx_aneg_resolution_tech1_t
#define bustype_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) "GSERCX_LNX_ANEG_RESOLUTION_TECH1"
#define device_bar_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_RESOLUTION_TECH1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status0
 *
 * GSERC Ln Aneg Status0 Register
 */
union bdk_gsercx_lnx_aneg_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t autoneg_complete      : 1;  /**< [  5:  5](RO/H) Autoneg has completed and autoneg arbitration FSM is in AN GOOD state. */
        uint32_t autoneg_remote_fault  : 1;  /**< [  4:  4](RO/H) Remote Fault. */
        uint32_t autoneg_ability       : 1;  /**< [  3:  3](RO/H) Autoneg ability.  When read as a one, it indicates that the PMA/PMD has the
                                                                 ability to perform Auto-Negotiation.  When read as a zero, it indicates that the
                                                                 PMA/PMD lacks the ability to perform Auto-Negotiation. */
        uint32_t link_status           : 1;  /**< [  2:  2](RO/H) Local link Status.  When read as a one, it indicates that the PMA/PMD has
                                                                 determined that a valid link has been established i.e. link_status[HDC] equals
                                                                 OK. When read as a zero, it indicates that the link is not valid. */
        uint32_t reserved_1            : 1;
        uint32_t lp_autoneg_able       : 1;  /**< [  0:  0](RO/H) The link partner Auto-Negotiation ability bit shall be set to one to indicate
                                                                 that the link partner is able to
                                                                 participate in the Auto-Negotiation function. This bit shall be reset to zero if
                                                                 the link partner is not Auto-
                                                                 Negotiation able. */
#else /* Word 0 - Little Endian */
        uint32_t lp_autoneg_able       : 1;  /**< [  0:  0](RO/H) The link partner Auto-Negotiation ability bit shall be set to one to indicate
                                                                 that the link partner is able to
                                                                 participate in the Auto-Negotiation function. This bit shall be reset to zero if
                                                                 the link partner is not Auto-
                                                                 Negotiation able. */
        uint32_t reserved_1            : 1;
        uint32_t link_status           : 1;  /**< [  2:  2](RO/H) Local link Status.  When read as a one, it indicates that the PMA/PMD has
                                                                 determined that a valid link has been established i.e. link_status[HDC] equals
                                                                 OK. When read as a zero, it indicates that the link is not valid. */
        uint32_t autoneg_ability       : 1;  /**< [  3:  3](RO/H) Autoneg ability.  When read as a one, it indicates that the PMA/PMD has the
                                                                 ability to perform Auto-Negotiation.  When read as a zero, it indicates that the
                                                                 PMA/PMD lacks the ability to perform Auto-Negotiation. */
        uint32_t autoneg_remote_fault  : 1;  /**< [  4:  4](RO/H) Remote Fault. */
        uint32_t autoneg_complete      : 1;  /**< [  5:  5](RO/H) Autoneg has completed and autoneg arbitration FSM is in AN GOOD state. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_status0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_status0 bdk_gsercx_lnx_aneg_status0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_STATUS0(a,b) bdk_gsercx_lnx_aneg_status0_t
#define bustype_BDK_GSERCX_LNX_ANEG_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_STATUS0(a,b) "GSERCX_LNX_ANEG_STATUS0"
#define device_bar_BDK_GSERCX_LNX_ANEG_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status1
 *
 * GSERC Ln Aneg Status1 Register
 */
union bdk_gsercx_lnx_aneg_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t resolve_handshake     : 1;  /**< [  5:  5](R/W1C/H) Reserved. */
        uint32_t init_handshake        : 1;  /**< [  4:  4](R/W1C/H) Reserved. */
        uint32_t np_loaded             : 1;  /**< [  3:  3](RO/H) MR_NP_LOADED status. */
        uint32_t parallel_det_fault    : 1;  /**< [  2:  2](R/W1C/H) Autoneg Parallel Detection Fault.  Write 1 to clear it. */
        uint32_t an_link_good          : 1;  /**< [  1:  1](RO/H) Autoneg has completed and autoneg arbitration FSM is in either AN GOOD CHECK or AN GOOD state. */
        uint32_t page_rx               : 1;  /**< [  0:  0](R/W1C/H) Page Received.   To clear it, write 1 to it.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
#else /* Word 0 - Little Endian */
        uint32_t page_rx               : 1;  /**< [  0:  0](R/W1C/H) Page Received.   To clear it, write 1 to it.
                                                                 Note that it is controlled by the PHY firmware.  Therefore user should not write it. */
        uint32_t an_link_good          : 1;  /**< [  1:  1](RO/H) Autoneg has completed and autoneg arbitration FSM is in either AN GOOD CHECK or AN GOOD state. */
        uint32_t parallel_det_fault    : 1;  /**< [  2:  2](R/W1C/H) Autoneg Parallel Detection Fault.  Write 1 to clear it. */
        uint32_t np_loaded             : 1;  /**< [  3:  3](RO/H) MR_NP_LOADED status. */
        uint32_t init_handshake        : 1;  /**< [  4:  4](R/W1C/H) Reserved. */
        uint32_t resolve_handshake     : 1;  /**< [  5:  5](R/W1C/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_status1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_status1 bdk_gsercx_lnx_aneg_status1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010c88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_STATUS1(a,b) bdk_gsercx_lnx_aneg_status1_t
#define bustype_BDK_GSERCX_LNX_ANEG_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_STATUS1(a,b) "GSERCX_LNX_ANEG_STATUS1"
#define device_bar_BDK_GSERCX_LNX_ANEG_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status_dbg0
 *
 * GSERC Ln Aneg Status Dbg0 Register
 */
union bdk_gsercx_lnx_aneg_status_dbg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_status_dbg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t state_one_hot_sticky_7_0 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 7-0. */
#else /* Word 0 - Little Endian */
        uint32_t state_one_hot_sticky_7_0 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 7-0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_status_dbg0_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_status_dbg0 bdk_gsercx_lnx_aneg_status_dbg0_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS_DBG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS_DBG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_STATUS_DBG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) bdk_gsercx_lnx_aneg_status_dbg0_t
#define bustype_BDK_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) "GSERCX_LNX_ANEG_STATUS_DBG0"
#define device_bar_BDK_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_STATUS_DBG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_aneg_status_dbg1
 *
 * GSERC Ln Aneg Status Dbg1 Register
 */
union bdk_gsercx_lnx_aneg_status_dbg1
{
    uint32_t u;
    struct bdk_gsercx_lnx_aneg_status_dbg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t state_one_hot_sticky_15_8 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 15-8. */
#else /* Word 0 - Little Endian */
        uint32_t state_one_hot_sticky_15_8 : 8;/**< [  7:  0](RO/H) One-hot sticky capture of AN FSM states.  Bits 15-8. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_aneg_status_dbg1_s cn; */
};
typedef union bdk_gsercx_lnx_aneg_status_dbg1 bdk_gsercx_lnx_aneg_status_dbg1_t;

static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS_DBG1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_ANEG_STATUS_DBG1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_ANEG_STATUS_DBG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) bdk_gsercx_lnx_aneg_status_dbg1_t
#define bustype_BDK_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) "GSERCX_LNX_ANEG_STATUS_DBG1"
#define device_bar_BDK_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_ANEG_STATUS_DBG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status0
 *
 * GSERC Ln Bist Rx Ber Status0 Register
 */
union bdk_gsercx_lnx_bist_rx_ber_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ber_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_count_7_0   : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_count_7_0   : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ber_status0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ber_status0 bdk_gsercx_lnx_bist_rx_ber_status0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013040ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) bdk_gsercx_lnx_bist_rx_ber_status0_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS0"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_BER_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status1
 *
 * GSERC Ln Bist Rx Ber Status1 Register
 */
union bdk_gsercx_lnx_bist_rx_ber_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ber_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_count_15_8  : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_count_15_8  : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ber_status1_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ber_status1 bdk_gsercx_lnx_bist_rx_ber_status1_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013048ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) bdk_gsercx_lnx_bist_rx_ber_status1_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS1"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_BER_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status2
 *
 * GSERC Ln Bist Rx Ber Status2 Register
 */
union bdk_gsercx_lnx_bist_rx_ber_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ber_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_count_23_16 : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_count_23_16 : 8;  /**< [  7:  0](RO/H) Number of bit errors. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ber_status2_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ber_status2 bdk_gsercx_lnx_bist_rx_ber_status2_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013050ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) bdk_gsercx_lnx_bist_rx_ber_status2_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS2"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_BER_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status4
 *
 * GSERC Ln Bist Rx Ber Status4 Register
 */
union bdk_gsercx_lnx_bist_rx_ber_status4
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ber_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cycle_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
#else /* Word 0 - Little Endian */
        uint32_t cycle_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ber_status4_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ber_status4 bdk_gsercx_lnx_bist_rx_ber_status4_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013060ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) bdk_gsercx_lnx_bist_rx_ber_status4_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS4"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_BER_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status5
 *
 * GSERC Ln Bist Rx Ber Status5 Register
 */
union bdk_gsercx_lnx_bist_rx_ber_status5
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ber_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cycle_count_15_8      : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
#else /* Word 0 - Little Endian */
        uint32_t cycle_count_15_8      : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ber_status5_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ber_status5 bdk_gsercx_lnx_bist_rx_ber_status5_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) bdk_gsercx_lnx_bist_rx_ber_status5_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS5"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_BER_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ber_status6
 *
 * GSERC Ln Bist Rx Ber Status6 Register
 */
union bdk_gsercx_lnx_bist_rx_ber_status6
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ber_status6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cycle_count_23_16     : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
#else /* Word 0 - Little Endian */
        uint32_t cycle_count_23_16     : 8;  /**< [  7:  0](RO/H) Number of cycles that errors have been counted. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ber_status6_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ber_status6 bdk_gsercx_lnx_bist_rx_ber_status6_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013070ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_BER_STATUS6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) bdk_gsercx_lnx_bist_rx_ber_status6_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) "GSERCX_LNX_BIST_RX_BER_STATUS6"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_BER_STATUS6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_ctrl
 *
 * GSERC Ln Bist Rx Ctrl Register
 */
union bdk_gsercx_lnx_bist_rx_ctrl
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t force_lfsr_with_rxdata : 1; /**< [  7:  7](R/W/H) Forces the PRBS LFSR to reseed with Rx data every cycle.  This will cause the
                                                                 bit error counter to be inaccurate. */
        uint32_t stop_error_count      : 1;  /**< [  6:  6](R/W/H) Stops the error count from incrementing.  Can be used to read back the BER data coherently. */
        uint32_t clear_ber             : 1;  /**< [  5:  5](R/W/H) Clears the bit error counter. */
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Selects the pattern to search for:
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x8 = Auto-detect */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Rx data checking. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Rx data checking. */
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Selects the pattern to search for:
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x8 = Auto-detect */
        uint32_t clear_ber             : 1;  /**< [  5:  5](R/W/H) Clears the bit error counter. */
        uint32_t stop_error_count      : 1;  /**< [  6:  6](R/W/H) Stops the error count from incrementing.  Can be used to read back the BER data coherently. */
        uint32_t force_lfsr_with_rxdata : 1; /**< [  7:  7](R/W/H) Forces the PRBS LFSR to reseed with Rx data every cycle.  This will cause the
                                                                 bit error counter to be inaccurate. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_ctrl_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_ctrl bdk_gsercx_lnx_bist_rx_ctrl_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_CTRL(a,b) bdk_gsercx_lnx_bist_rx_ctrl_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_CTRL(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_CTRL(a,b) "GSERCX_LNX_BIST_RX_CTRL"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_CTRL(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl0
 *
 * GSERC Ln Bist Rx Lock Ctrl0 Register
 */
union bdk_gsercx_lnx_bist_rx_lock_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_lock_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_lock_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_lock_ctrl0 bdk_gsercx_lnx_bist_rx_lock_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) bdk_gsercx_lnx_bist_rx_lock_ctrl0_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL0"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl1
 *
 * GSERC Ln Bist Rx Lock Ctrl1 Register
 */
union bdk_gsercx_lnx_bist_rx_lock_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_lock_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_lock_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_lock_ctrl1 bdk_gsercx_lnx_bist_rx_lock_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) bdk_gsercx_lnx_bist_rx_lock_ctrl1_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL1"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl2
 *
 * GSERC Ln Bist Rx Lock Ctrl2 Register
 */
union bdk_gsercx_lnx_bist_rx_lock_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_lock_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t max_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_lock_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_lock_ctrl2 bdk_gsercx_lnx_bist_rx_lock_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) bdk_gsercx_lnx_bist_rx_lock_ctrl2_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL2"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_lock_ctrl3
 *
 * GSERC Ln Bist Rx Lock Ctrl3 Register
 */
union bdk_gsercx_lnx_bist_rx_lock_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_lock_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
#else /* Word 0 - Little Endian */
        uint32_t max_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Maximum number of errors allowed to trigger pattern lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_lock_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_lock_ctrl3 bdk_gsercx_lnx_bist_rx_lock_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80130b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOCK_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) bdk_gsercx_lnx_bist_rx_lock_ctrl3_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) "GSERCX_LNX_BIST_RX_LOCK_CTRL3"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOCK_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl0
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl0 Register
 */
union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_7_0        : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl0 bdk_gsercx_lnx_bist_rx_loss_lock_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) bdk_gsercx_lnx_bist_rx_loss_lock_ctrl0_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl1
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl1 Register
 */
union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t num_cycles_15_8       : 8;  /**< [  7:  0](R/W/H) Size of error sampling window to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl1 bdk_gsercx_lnx_bist_rx_loss_lock_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) bdk_gsercx_lnx_bist_rx_loss_lock_ctrl1_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl2
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl2 Register
 */
union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t min_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t min_errors_7_0        : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl2 bdk_gsercx_lnx_bist_rx_loss_lock_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) bdk_gsercx_lnx_bist_rx_loss_lock_ctrl2_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl3
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl3 Register
 */
union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t min_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
#else /* Word 0 - Little Endian */
        uint32_t min_errors_15_8       : 8;  /**< [  7:  0](R/W/H) Minimum number of errors allowed to trigger pattern loss-of-lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl3 bdk_gsercx_lnx_bist_rx_loss_lock_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013118ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) bdk_gsercx_lnx_bist_rx_loss_lock_ctrl3_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_loss_lock_ctrl4
 *
 * GSERC Ln Bist Rx Loss Lock Ctrl4 Register
 */
union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t stop_on_loss_lock     : 1;  /**< [  0:  0](R/W/H) Stops pattern from being re-locked when loss-of-lock occurs. */
#else /* Word 0 - Little Endian */
        uint32_t stop_on_loss_lock     : 1;  /**< [  0:  0](R/W/H) Stops pattern from being re-locked when loss-of-lock occurs. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_loss_lock_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_loss_lock_ctrl4 bdk_gsercx_lnx_bist_rx_loss_lock_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) bdk_gsercx_lnx_bist_rx_loss_lock_ctrl4_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) "GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_LOSS_LOCK_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_status
 *
 * GSERC Ln Bist Rx Status Register
 */
union bdk_gsercx_lnx_bist_rx_status
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t pattern_det           : 4;  /**< [  6:  3](RO/H) Indicates the pattern  detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP */
        uint32_t state                 : 3;  /**< [  2:  0](RO/H) State of the BIST checker:
                                                                 0x0 = Off
                                                                 0x1 = Searching for pattern
                                                                 0x2 = Waiting for pattern lock conditions
                                                                 0x3 = Pattern lock acquired
                                                                 0x4 = Pattern lock lost */
#else /* Word 0 - Little Endian */
        uint32_t state                 : 3;  /**< [  2:  0](RO/H) State of the BIST checker:
                                                                 0x0 = Off
                                                                 0x1 = Searching for pattern
                                                                 0x2 = Waiting for pattern lock conditions
                                                                 0x3 = Pattern lock acquired
                                                                 0x4 = Pattern lock lost */
        uint32_t pattern_det           : 4;  /**< [  6:  3](RO/H) Indicates the pattern  detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_status_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_status bdk_gsercx_lnx_bist_rx_status_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013020ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_STATUS(a,b) bdk_gsercx_lnx_bist_rx_status_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_STATUS(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_STATUS(a,b) "GSERCX_LNX_BIST_RX_STATUS"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_STATUS(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_103_96
 *
 * GSERC Ln Bist Rx Udp 103 96 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_103_96
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_103_96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_103_96_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_103_96 bdk_gsercx_lnx_bist_rx_udp_103_96_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_103_96(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_103_96(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_103_96", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) bdk_gsercx_lnx_bist_rx_udp_103_96_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) "GSERCX_LNX_BIST_RX_UDP_103_96"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_103_96(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_111_104
 *
 * GSERC Ln Bist Rx Udp 111 104 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_111_104
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_111_104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_111_104_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_111_104 bdk_gsercx_lnx_bist_rx_udp_111_104_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_111_104(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_111_104(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_111_104", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) bdk_gsercx_lnx_bist_rx_udp_111_104_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) "GSERCX_LNX_BIST_RX_UDP_111_104"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_111_104(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_119_112
 *
 * GSERC Ln Bist Rx Udp 119 112 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_119_112
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_119_112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_119_112_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_119_112 bdk_gsercx_lnx_bist_rx_udp_119_112_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_119_112(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_119_112(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_119_112", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) bdk_gsercx_lnx_bist_rx_udp_119_112_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) "GSERCX_LNX_BIST_RX_UDP_119_112"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_119_112(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_127_120
 *
 * GSERC Ln Bist Rx Udp 127 120 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_127_120
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_127_120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_127_120_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_127_120 bdk_gsercx_lnx_bist_rx_udp_127_120_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_127_120(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_127_120(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_127_120", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) bdk_gsercx_lnx_bist_rx_udp_127_120_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) "GSERCX_LNX_BIST_RX_UDP_127_120"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_127_120(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_135_128
 *
 * GSERC Ln Bist Rx Udp 135 128 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_135_128
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_135_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_135_128_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_135_128 bdk_gsercx_lnx_bist_rx_udp_135_128_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_135_128(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_135_128(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_135_128", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) bdk_gsercx_lnx_bist_rx_udp_135_128_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) "GSERCX_LNX_BIST_RX_UDP_135_128"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_135_128(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_143_136
 *
 * GSERC Ln Bist Rx Udp 143 136 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_143_136
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_143_136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_143_136_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_143_136 bdk_gsercx_lnx_bist_rx_udp_143_136_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_143_136(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_143_136(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_143_136", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) bdk_gsercx_lnx_bist_rx_udp_143_136_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) "GSERCX_LNX_BIST_RX_UDP_143_136"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_143_136(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_151_144
 *
 * GSERC Ln Bist Rx Udp 151 144 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_151_144
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_151_144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_151_144_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_151_144 bdk_gsercx_lnx_bist_rx_udp_151_144_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_151_144(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_151_144(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_151_144", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) bdk_gsercx_lnx_bist_rx_udp_151_144_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) "GSERCX_LNX_BIST_RX_UDP_151_144"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_151_144(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_159_152
 *
 * GSERC Ln Bist Rx Udp 159 152 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_159_152
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_159_152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_159_152_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_159_152 bdk_gsercx_lnx_bist_rx_udp_159_152_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_159_152(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_159_152(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013238ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_159_152", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) bdk_gsercx_lnx_bist_rx_udp_159_152_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) "GSERCX_LNX_BIST_RX_UDP_159_152"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_159_152(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_15_8
 *
 * GSERC Ln Bist Rx Udp 15 8 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_15_8
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_15_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_15_8_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_15_8 bdk_gsercx_lnx_bist_rx_udp_15_8_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_15_8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_15_8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_15_8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) bdk_gsercx_lnx_bist_rx_udp_15_8_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) "GSERCX_LNX_BIST_RX_UDP_15_8"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_15_8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_167_160
 *
 * GSERC Ln Bist Rx Udp 167 160 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_167_160
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_167_160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_167_160_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_167_160 bdk_gsercx_lnx_bist_rx_udp_167_160_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_167_160(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_167_160(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013240ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_167_160", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) bdk_gsercx_lnx_bist_rx_udp_167_160_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) "GSERCX_LNX_BIST_RX_UDP_167_160"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_167_160(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_175_168
 *
 * GSERC Ln Bist Rx Udp 175 168 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_175_168
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_175_168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_175_168_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_175_168 bdk_gsercx_lnx_bist_rx_udp_175_168_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_175_168(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_175_168(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013248ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_175_168", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) bdk_gsercx_lnx_bist_rx_udp_175_168_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) "GSERCX_LNX_BIST_RX_UDP_175_168"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_175_168(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_183_176
 *
 * GSERC Ln Bist Rx Udp 183 176 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_183_176
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_183_176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_183_176_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_183_176 bdk_gsercx_lnx_bist_rx_udp_183_176_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_183_176(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_183_176(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013250ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_183_176", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) bdk_gsercx_lnx_bist_rx_udp_183_176_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) "GSERCX_LNX_BIST_RX_UDP_183_176"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_183_176(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_191_184
 *
 * GSERC Ln Bist Rx Udp 191 184 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_191_184
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_191_184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_191_184_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_191_184 bdk_gsercx_lnx_bist_rx_udp_191_184_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_191_184(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_191_184(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013258ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_191_184", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) bdk_gsercx_lnx_bist_rx_udp_191_184_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) "GSERCX_LNX_BIST_RX_UDP_191_184"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_191_184(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_199_192
 *
 * GSERC Ln Bist Rx Udp 199 192 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_199_192
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_199_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_199_192_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_199_192 bdk_gsercx_lnx_bist_rx_udp_199_192_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_199_192(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_199_192(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013260ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_199_192", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) bdk_gsercx_lnx_bist_rx_udp_199_192_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) "GSERCX_LNX_BIST_RX_UDP_199_192"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_199_192(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_23_16
 *
 * GSERC Ln Bist Rx Udp 23 16 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_23_16
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_23_16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_23_16_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_23_16 bdk_gsercx_lnx_bist_rx_udp_23_16_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_23_16(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_23_16(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_23_16", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) bdk_gsercx_lnx_bist_rx_udp_23_16_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) "GSERCX_LNX_BIST_RX_UDP_23_16"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_23_16(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_31_24
 *
 * GSERC Ln Bist Rx Udp 31 24 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_31_24
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_31_24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_31_24_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_31_24 bdk_gsercx_lnx_bist_rx_udp_31_24_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_31_24(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_31_24(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_31_24", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) bdk_gsercx_lnx_bist_rx_udp_31_24_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) "GSERCX_LNX_BIST_RX_UDP_31_24"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_31_24(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_39_32
 *
 * GSERC Ln Bist Rx Udp 39 32 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_39_32
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_39_32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_39_32_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_39_32 bdk_gsercx_lnx_bist_rx_udp_39_32_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_39_32(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_39_32(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_39_32", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) bdk_gsercx_lnx_bist_rx_udp_39_32_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) "GSERCX_LNX_BIST_RX_UDP_39_32"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_39_32(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_47_40
 *
 * GSERC Ln Bist Rx Udp 47 40 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_47_40
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_47_40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_47_40_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_47_40 bdk_gsercx_lnx_bist_rx_udp_47_40_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_47_40(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_47_40(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_47_40", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) bdk_gsercx_lnx_bist_rx_udp_47_40_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) "GSERCX_LNX_BIST_RX_UDP_47_40"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_47_40(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_55_48
 *
 * GSERC Ln Bist Rx Udp 55 48 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_55_48
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_55_48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_55_48_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_55_48 bdk_gsercx_lnx_bist_rx_udp_55_48_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_55_48(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_55_48(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_55_48", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) bdk_gsercx_lnx_bist_rx_udp_55_48_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) "GSERCX_LNX_BIST_RX_UDP_55_48"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_55_48(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_63_56
 *
 * GSERC Ln Bist Rx Udp 63 56 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_63_56
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_63_56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_63_56_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_63_56 bdk_gsercx_lnx_bist_rx_udp_63_56_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_63_56(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_63_56(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_63_56", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) bdk_gsercx_lnx_bist_rx_udp_63_56_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) "GSERCX_LNX_BIST_RX_UDP_63_56"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_63_56(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_71_64
 *
 * GSERC Ln Bist Rx Udp 71 64 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_71_64
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_71_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_71_64_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_71_64 bdk_gsercx_lnx_bist_rx_udp_71_64_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_71_64(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_71_64(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_71_64", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) bdk_gsercx_lnx_bist_rx_udp_71_64_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) "GSERCX_LNX_BIST_RX_UDP_71_64"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_71_64(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_79_72
 *
 * GSERC Ln Bist Rx Udp 79 72 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_79_72
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_79_72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_79_72_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_79_72 bdk_gsercx_lnx_bist_rx_udp_79_72_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_79_72(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_79_72(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_79_72", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) bdk_gsercx_lnx_bist_rx_udp_79_72_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) "GSERCX_LNX_BIST_RX_UDP_79_72"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_79_72(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_7_0
 *
 * GSERC Ln Bist Rx Udp 7 0 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_7_0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_7_0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_7_0 bdk_gsercx_lnx_bist_rx_udp_7_0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_7_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_7_0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_7_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) bdk_gsercx_lnx_bist_rx_udp_7_0_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) "GSERCX_LNX_BIST_RX_UDP_7_0"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_7_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_87_80
 *
 * GSERC Ln Bist Rx Udp 87 80 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_87_80
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_87_80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_87_80_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_87_80 bdk_gsercx_lnx_bist_rx_udp_87_80_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_87_80(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_87_80(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_87_80", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) bdk_gsercx_lnx_bist_rx_udp_87_80_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) "GSERCX_LNX_BIST_RX_UDP_87_80"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_87_80(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_95_88
 *
 * GSERC Ln Bist Rx Udp 95 88 Register
 */
union bdk_gsercx_lnx_bist_rx_udp_95_88
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_95_88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_95_88_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_95_88 bdk_gsercx_lnx_bist_rx_udp_95_88_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_95_88(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_95_88(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80131f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_95_88", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) bdk_gsercx_lnx_bist_rx_udp_95_88_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) "GSERCX_LNX_BIST_RX_UDP_95_88"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_95_88(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_rx_udp_shift_amount
 *
 * GSERC Ln Bist Rx Udp Shift Amount Register
 */
union bdk_gsercx_lnx_bist_rx_udp_shift_amount
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_rx_udp_shift_amount_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_rx_udp_shift_amount_s cn; */
};
typedef union bdk_gsercx_lnx_bist_rx_udp_shift_amount bdk_gsercx_lnx_bist_rx_udp_shift_amount_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) bdk_gsercx_lnx_bist_rx_udp_shift_amount_t
#define bustype_BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) "GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT"
#define device_bar_BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_RX_UDP_SHIFT_AMOUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl0
 *
 * GSERC Ln Bist Tx Ber Ctrl0 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t mode                  : 2;  /**< [  1:  0](R/W/H) Controls what type of error injection is used:
                                                                 0x0 = None
                                                                 0x1 = Single cycle error
                                                                 0x2 = Timer based */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 2;  /**< [  1:  0](R/W/H) Controls what type of error injection is used:
                                                                 0x0 = None
                                                                 0x1 = Single cycle error
                                                                 0x2 = Timer based */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl0 bdk_gsercx_lnx_bist_tx_ber_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl0_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL0"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl1
 *
 * GSERC Ln Bist Tx Ber Ctrl1 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_7_0             : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
#else /* Word 0 - Little Endian */
        uint32_t timer_7_0             : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl1 bdk_gsercx_lnx_bist_tx_ber_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl1_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL1"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl2
 *
 * GSERC Ln Bist Tx Ber Ctrl2 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timer_15_8            : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
#else /* Word 0 - Little Endian */
        uint32_t timer_15_8            : 8;  /**< [  7:  0](R/W/H) Number of cycles between single bit-error injection. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl2 bdk_gsercx_lnx_bist_tx_ber_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl2_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL2"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl3
 *
 * GSERC Ln Bist Tx Ber Ctrl3 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_7_0   : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_7_0   : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl3 bdk_gsercx_lnx_bist_tx_ber_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl3_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL3"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl4
 *
 * GSERC Ln Bist Tx Ber Ctrl4 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_15_8  : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_15_8  : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl4 bdk_gsercx_lnx_bist_tx_ber_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl4_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL4"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl5
 *
 * GSERC Ln Bist Tx Ber Ctrl5 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl5
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_23_16 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_23_16 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl5_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl5 bdk_gsercx_lnx_bist_tx_ber_ctrl5_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl5_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL5"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl6
 *
 * GSERC Ln Bist Tx Ber Ctrl6 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl6
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_31_24 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_31_24 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl6_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl6 bdk_gsercx_lnx_bist_tx_ber_ctrl6_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl6_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL6"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ber_ctrl7
 *
 * GSERC Ln Bist Tx Ber Ctrl7 Register
 */
union bdk_gsercx_lnx_bist_tx_ber_ctrl7
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ber_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit_error_field_39_32 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
#else /* Word 0 - Little Endian */
        uint32_t bit_error_field_39_32 : 8;  /**< [  7:  0](R/W/H) Sets the Tx data bits to be flipped. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ber_ctrl7_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ber_ctrl7 bdk_gsercx_lnx_bist_tx_ber_ctrl7_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_BER_CTRL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) bdk_gsercx_lnx_bist_tx_ber_ctrl7_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) "GSERCX_LNX_BIST_TX_BER_CTRL7"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_BER_CTRL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_ctrl
 *
 * GSERC Ln Bist Tx Ctrl Register
 */
union bdk_gsercx_lnx_bist_tx_ctrl
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Indicates the pattern to detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x9 = MAC Tx data */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Tx data generation. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables BIST Tx data generation. */
        uint32_t pattern_sel           : 4;  /**< [  4:  1](R/W/H) Indicates the pattern to detected:
                                                                 0x0 = No pattern detected
                                                                 0x1 = PRBS 0xC1
                                                                 0x2 = PRBS 0x221
                                                                 0x3 = PRBS 0xA01
                                                                 0x4 = PRBS 0xC001
                                                                 0x5 = PRBS 0x840001
                                                                 0x6 = PRBS 0x90000001
                                                                 0x7 = User defined pattern UDP
                                                                 0x9 = MAC Tx data */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_ctrl_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_ctrl bdk_gsercx_lnx_bist_tx_ctrl_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_CTRL(a,b) bdk_gsercx_lnx_bist_tx_ctrl_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_CTRL(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_CTRL(a,b) "GSERCX_LNX_BIST_TX_CTRL"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_CTRL(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl0
 *
 * GSERC Ln Bist Tx Prbs Ctrl0 Register
 */
union bdk_gsercx_lnx_bist_tx_prbs_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_prbs_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_prbs_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_prbs_ctrl0 bdk_gsercx_lnx_bist_tx_prbs_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) bdk_gsercx_lnx_bist_tx_prbs_ctrl0_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL0"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl1
 *
 * GSERC Ln Bist Tx Prbs Ctrl1 Register
 */
union bdk_gsercx_lnx_bist_tx_prbs_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_prbs_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_15_8             : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_15_8             : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_prbs_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_prbs_ctrl1 bdk_gsercx_lnx_bist_tx_prbs_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) bdk_gsercx_lnx_bist_tx_prbs_ctrl1_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL1"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl2
 *
 * GSERC Ln Bist Tx Prbs Ctrl2 Register
 */
union bdk_gsercx_lnx_bist_tx_prbs_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_prbs_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_23_16            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_23_16            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_prbs_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_prbs_ctrl2 bdk_gsercx_lnx_bist_tx_prbs_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) bdk_gsercx_lnx_bist_tx_prbs_ctrl2_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL2"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_prbs_ctrl3
 *
 * GSERC Ln Bist Tx Prbs Ctrl3 Register
 */
union bdk_gsercx_lnx_bist_tx_prbs_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_prbs_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_31_24            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
#else /* Word 0 - Little Endian */
        uint32_t seed_31_24            : 8;  /**< [  7:  0](R/W/H) Controls the initial seed of the PRBS generator.  Do not set to all zero. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_prbs_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_prbs_ctrl3 bdk_gsercx_lnx_bist_tx_prbs_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_PRBS_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) bdk_gsercx_lnx_bist_tx_prbs_ctrl3_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) "GSERCX_LNX_BIST_TX_PRBS_CTRL3"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_PRBS_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_103_96
 *
 * GSERC Ln Bist Tx Udp 103 96 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_103_96
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_103_96_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_103_96_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_103_96 bdk_gsercx_lnx_bist_tx_udp_103_96_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_103_96(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_103_96(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_103_96", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) bdk_gsercx_lnx_bist_tx_udp_103_96_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) "GSERCX_LNX_BIST_TX_UDP_103_96"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_103_96(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_111_104
 *
 * GSERC Ln Bist Tx Udp 111 104 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_111_104
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_111_104_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_111_104_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_111_104 bdk_gsercx_lnx_bist_tx_udp_111_104_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_111_104(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_111_104(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_111_104", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) bdk_gsercx_lnx_bist_tx_udp_111_104_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) "GSERCX_LNX_BIST_TX_UDP_111_104"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_111_104(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_119_112
 *
 * GSERC Ln Bist Tx Udp 119 112 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_119_112
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_119_112_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_119_112_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_119_112 bdk_gsercx_lnx_bist_tx_udp_119_112_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_119_112(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_119_112(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_119_112", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) bdk_gsercx_lnx_bist_tx_udp_119_112_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) "GSERCX_LNX_BIST_TX_UDP_119_112"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_119_112(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_127_120
 *
 * GSERC Ln Bist Tx Udp 127 120 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_127_120
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_127_120_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_127_120_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_127_120 bdk_gsercx_lnx_bist_tx_udp_127_120_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_127_120(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_127_120(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_127_120", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) bdk_gsercx_lnx_bist_tx_udp_127_120_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) "GSERCX_LNX_BIST_TX_UDP_127_120"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_127_120(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_135_128
 *
 * GSERC Ln Bist Tx Udp 135 128 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_135_128
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_135_128_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_135_128_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_135_128 bdk_gsercx_lnx_bist_tx_udp_135_128_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_135_128(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_135_128(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012da0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_135_128", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) bdk_gsercx_lnx_bist_tx_udp_135_128_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) "GSERCX_LNX_BIST_TX_UDP_135_128"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_135_128(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_143_136
 *
 * GSERC Ln Bist Tx Udp 143 136 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_143_136
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_143_136_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_143_136_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_143_136 bdk_gsercx_lnx_bist_tx_udp_143_136_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_143_136(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_143_136(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012da8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_143_136", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) bdk_gsercx_lnx_bist_tx_udp_143_136_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) "GSERCX_LNX_BIST_TX_UDP_143_136"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_143_136(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_151_144
 *
 * GSERC Ln Bist Tx Udp 151 144 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_151_144
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_151_144_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_151_144_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_151_144 bdk_gsercx_lnx_bist_tx_udp_151_144_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_151_144(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_151_144(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012db0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_151_144", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) bdk_gsercx_lnx_bist_tx_udp_151_144_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) "GSERCX_LNX_BIST_TX_UDP_151_144"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_151_144(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_159_152
 *
 * GSERC Ln Bist Tx Udp 159 152 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_159_152
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_159_152_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_159_152_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_159_152 bdk_gsercx_lnx_bist_tx_udp_159_152_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_159_152(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_159_152(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012db8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_159_152", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) bdk_gsercx_lnx_bist_tx_udp_159_152_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) "GSERCX_LNX_BIST_TX_UDP_159_152"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_159_152(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_15_8
 *
 * GSERC Ln Bist Tx Udp 15 8 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_15_8
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_15_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_15_8_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_15_8 bdk_gsercx_lnx_bist_tx_udp_15_8_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_15_8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_15_8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_15_8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) bdk_gsercx_lnx_bist_tx_udp_15_8_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) "GSERCX_LNX_BIST_TX_UDP_15_8"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_15_8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_167_160
 *
 * GSERC Ln Bist Tx Udp 167 160 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_167_160
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_167_160_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_167_160_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_167_160 bdk_gsercx_lnx_bist_tx_udp_167_160_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_167_160(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_167_160(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dc0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_167_160", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) bdk_gsercx_lnx_bist_tx_udp_167_160_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) "GSERCX_LNX_BIST_TX_UDP_167_160"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_167_160(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_175_168
 *
 * GSERC Ln Bist Tx Udp 175 168 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_175_168
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_175_168_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_175_168_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_175_168 bdk_gsercx_lnx_bist_tx_udp_175_168_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_175_168(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_175_168(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dc8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_175_168", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) bdk_gsercx_lnx_bist_tx_udp_175_168_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) "GSERCX_LNX_BIST_TX_UDP_175_168"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_175_168(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_183_176
 *
 * GSERC Ln Bist Tx Udp 183 176 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_183_176
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_183_176_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_183_176_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_183_176 bdk_gsercx_lnx_bist_tx_udp_183_176_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_183_176(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_183_176(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dd0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_183_176", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) bdk_gsercx_lnx_bist_tx_udp_183_176_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) "GSERCX_LNX_BIST_TX_UDP_183_176"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_183_176(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_191_184
 *
 * GSERC Ln Bist Tx Udp 191 184 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_191_184
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_191_184_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_191_184_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_191_184 bdk_gsercx_lnx_bist_tx_udp_191_184_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_191_184(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_191_184(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012dd8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_191_184", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) bdk_gsercx_lnx_bist_tx_udp_191_184_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) "GSERCX_LNX_BIST_TX_UDP_191_184"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_191_184(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_199_192
 *
 * GSERC Ln Bist Tx Udp 199 192 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_199_192
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_199_192_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern extension bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_199_192_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_199_192 bdk_gsercx_lnx_bist_tx_udp_199_192_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_199_192(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_199_192(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012de0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_199_192", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) bdk_gsercx_lnx_bist_tx_udp_199_192_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) "GSERCX_LNX_BIST_TX_UDP_199_192"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_199_192(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_23_16
 *
 * GSERC Ln Bist Tx Udp 23 16 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_23_16
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_23_16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_23_16_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_23_16 bdk_gsercx_lnx_bist_tx_udp_23_16_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_23_16(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_23_16(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_23_16", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) bdk_gsercx_lnx_bist_tx_udp_23_16_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) "GSERCX_LNX_BIST_TX_UDP_23_16"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_23_16(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_31_24
 *
 * GSERC Ln Bist Tx Udp 31 24 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_31_24
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_31_24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_31_24_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_31_24 bdk_gsercx_lnx_bist_tx_udp_31_24_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_31_24(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_31_24(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_31_24", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) bdk_gsercx_lnx_bist_tx_udp_31_24_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) "GSERCX_LNX_BIST_TX_UDP_31_24"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_31_24(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_39_32
 *
 * GSERC Ln Bist Tx Udp 39 32 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_39_32
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_39_32_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_39_32_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_39_32 bdk_gsercx_lnx_bist_tx_udp_39_32_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_39_32(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_39_32(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_39_32", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) bdk_gsercx_lnx_bist_tx_udp_39_32_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) "GSERCX_LNX_BIST_TX_UDP_39_32"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_39_32(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_47_40
 *
 * GSERC Ln Bist Tx Udp 47 40 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_47_40
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_47_40_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_47_40_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_47_40 bdk_gsercx_lnx_bist_tx_udp_47_40_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_47_40(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_47_40(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_47_40", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) bdk_gsercx_lnx_bist_tx_udp_47_40_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) "GSERCX_LNX_BIST_TX_UDP_47_40"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_47_40(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_55_48
 *
 * GSERC Ln Bist Tx Udp 55 48 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_55_48
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_55_48_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_55_48_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_55_48 bdk_gsercx_lnx_bist_tx_udp_55_48_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_55_48(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_55_48(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_55_48", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) bdk_gsercx_lnx_bist_tx_udp_55_48_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) "GSERCX_LNX_BIST_TX_UDP_55_48"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_55_48(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_63_56
 *
 * GSERC Ln Bist Tx Udp 63 56 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_63_56
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_63_56_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_63_56_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_63_56 bdk_gsercx_lnx_bist_tx_udp_63_56_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_63_56(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_63_56(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d58ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_63_56", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) bdk_gsercx_lnx_bist_tx_udp_63_56_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) "GSERCX_LNX_BIST_TX_UDP_63_56"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_63_56(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_71_64
 *
 * GSERC Ln Bist Tx Udp 71 64 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_71_64
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_71_64_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_71_64_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_71_64 bdk_gsercx_lnx_bist_tx_udp_71_64_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_71_64(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_71_64(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d60ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_71_64", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) bdk_gsercx_lnx_bist_tx_udp_71_64_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) "GSERCX_LNX_BIST_TX_UDP_71_64"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_71_64(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_79_72
 *
 * GSERC Ln Bist Tx Udp 79 72 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_79_72
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_79_72_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_79_72_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_79_72 bdk_gsercx_lnx_bist_tx_udp_79_72_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_79_72(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_79_72(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d68ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_79_72", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) bdk_gsercx_lnx_bist_tx_udp_79_72_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) "GSERCX_LNX_BIST_TX_UDP_79_72"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_79_72(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_7_0
 *
 * GSERC Ln Bist Tx Udp 7 0 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_7_0
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_7_0_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_7_0 bdk_gsercx_lnx_bist_tx_udp_7_0_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_7_0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_7_0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_7_0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) bdk_gsercx_lnx_bist_tx_udp_7_0_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) "GSERCX_LNX_BIST_TX_UDP_7_0"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_7_0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_87_80
 *
 * GSERC Ln Bist Tx Udp 87 80 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_87_80
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_87_80_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_87_80_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_87_80 bdk_gsercx_lnx_bist_tx_udp_87_80_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_87_80(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_87_80(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d70ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_87_80", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) bdk_gsercx_lnx_bist_tx_udp_87_80_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) "GSERCX_LNX_BIST_TX_UDP_87_80"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_87_80(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_95_88
 *
 * GSERC Ln Bist Tx Udp 95 88 Register
 */
union bdk_gsercx_lnx_bist_tx_udp_95_88
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_95_88_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) User defined pattern. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_95_88_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_95_88 bdk_gsercx_lnx_bist_tx_udp_95_88_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_95_88(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_95_88(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d78ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_95_88", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) bdk_gsercx_lnx_bist_tx_udp_95_88_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) "GSERCX_LNX_BIST_TX_UDP_95_88"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_95_88(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_bist_tx_udp_shift_amount
 *
 * GSERC Ln Bist Tx Udp Shift Amount Register
 */
union bdk_gsercx_lnx_bist_tx_udp_shift_amount
{
    uint32_t u;
    struct bdk_gsercx_lnx_bist_tx_udp_shift_amount_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Determines the length of the UDP.  Must be set to d160 modulus udp_length. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_bist_tx_udp_shift_amount_s cn; */
};
typedef union bdk_gsercx_lnx_bist_tx_udp_shift_amount bdk_gsercx_lnx_bist_tx_udp_shift_amount_t;

static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) bdk_gsercx_lnx_bist_tx_udp_shift_amount_t
#define bustype_BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) "GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT"
#define device_bar_BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) (a)
#define arguments_BDK_GSERCX_LNX_BIST_TX_UDP_SHIFT_AMOUNT(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_cal_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Cal Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxcdr_vcocal_div4     : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rxcdr_cal_en          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_cal_en          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxcdr_vcocal_div4     : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl0_rsvd bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010900ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_cal_ctrl1
 *
 * GSERC Ln Cdr Refclk Afe Cal Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxcdr_vcocal_load_val_11_8 : 4;/**< [  3:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. MSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_vcocal_load_val_11_8 : 4;/**< [  3:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. MSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl1 bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010908ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl1_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_cal_ctrl2
 *
 * GSERC Ln Cdr Refclk Afe Cal Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rxcdr_vcocal_load_val_7_0 : 8;/**< [  7:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. LSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_vcocal_load_val_7_0 : 8;/**< [  7:  0](R/W/H) CDR VCO calibration frequency counter load value aka starting value. LSB bits of 12-bit load value.
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It is then used during the
                                                                 PHY RESET--    ACTIVE power state as part of CDR VCO frequency calibration. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl2 bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010910ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) bdk_gsercx_lnx_cdr_refclk_afe_cal_ctrl2_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CAL_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_ctrl0
 *
 * GSERC Ln Cdr Refclk Afe Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxcdr_clkdiv          : 2;  /**< [  6:  5](R/W/H) Control for CDR clock divider
                                                                 0 = DIV1
                                                                 1 = DIV2
                                                                 2 = DIV4
                                                                 3 = DIV8
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It may then later by
                                                                 adjusted by firmware during the RESET--      ACTIVE power state sequence during
                                                                 CDR VCO frequency calibration. This occurs only if frequency calibration at the
                                                                 starting division setting is not able to reach the target VCO frequency. */
        uint32_t rxcdr_bbstep          : 5;  /**< [  4:  0](R/W/H) CDR proportional path gain adjustment.
                                                                 This signal controls the bang-bang step size of the CDR phase detector, which
                                                                 acts as a proportional path gain adjustment. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_bbstep          : 5;  /**< [  4:  0](R/W/H) CDR proportional path gain adjustment.
                                                                 This signal controls the bang-bang step size of the CDR phase detector, which
                                                                 acts as a proportional path gain adjustment. */
        uint32_t rxcdr_clkdiv          : 2;  /**< [  6:  5](R/W/H) Control for CDR clock divider
                                                                 0 = DIV1
                                                                 1 = DIV2
                                                                 2 = DIV4
                                                                 3 = DIV8
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. It may then later by
                                                                 adjusted by firmware during the RESET--      ACTIVE power state sequence during
                                                                 CDR VCO frequency calibration. This occurs only if frequency calibration at the
                                                                 starting division setting is not able to reach the target VCO frequency. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_ctrl0 bdk_gsercx_lnx_cdr_refclk_afe_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010880ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) bdk_gsercx_lnx_cdr_refclk_afe_ctrl0_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CTRL0"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxcdr_spare           : 4;  /**< [  6:  3](R/W/H) Reserved. */
        uint32_t rxcdr_toggle_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxcdr_clkdiv_swing    : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_clkdiv_swing    : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t rxcdr_toggle_en       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxcdr_spare           : 4;  /**< [  6:  3](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd bdk_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010888ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Pd Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t pd_rxcdr_pi           : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t pd_rxcdr_clkdiv       : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t pd_rxcdr_vco          : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxcdr_vco          : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t pd_rxcdr_clkdiv       : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t pd_rxcdr_pi           : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl0_rsvd bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010800ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Pd Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pd_rxcdr_eye          : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxcdr_eye          : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl1_rsvd bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010808ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_pd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PD_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_phd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Phd Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_phd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_phd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxcdr_phd_en          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_phd_en          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_phd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_phd_ctrl0_rsvd bdk_gsercx_lnx_cdr_refclk_afe_phd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010830ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_phd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PHD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl0
 *
 * GSERC Ln Cdr Refclk Afe Pi Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clkq input to AFE.
                                                                 0 = rxcdr_hscan_clkq fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t rxcdr_hscan_clkq      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR quadrature clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_hscan_clkq      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR quadrature clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clkq input to AFE.
                                                                 0 = rxcdr_hscan_clkq fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl0 bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl0_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl1
 *
 * GSERC Ln Cdr Refclk Afe Pi Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clki input to AFE.
                                                                 0 = rxcdr_hscan_clki fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t rxcdr_hscan_clki      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR in-phase clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_hscan_clki      : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR in-phase clock. This adjusts the in-
                                                                 phase to quadrature clock relationship, which in turn adjusts the timing between
                                                                 the DFE data and edge slicers.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence as part of CDR I/Q calibration. It may then also be controlled by
                                                                 firmware once the PHY is in the ACTIVE power state if CDR sampling phase
                                                                 adaptation is enabled. */
        uint32_t src_sel               : 1;  /**< [  7:  7](R/W/H) Mux select for rxcdr_hsacn_clki input to AFE.
                                                                 0 = rxcdr_hscan_clki fields of this register drive AFE
                                                                 1 = calibration block directly drives AFE */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl1 bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl1_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl2
 *
 * GSERC Ln Cdr Refclk Afe Pi Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxcdr_hscan_eye       : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR eye monitor clock.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence, as part of some AFE calibrations. It may thenalso be controlled
                                                                 by firmware once the PHY is in the ACTIVE power state as part of some adaptive
                                                                 equalization algorithms if they are enabled, or part of an eye monitor or eye
                                                                 monitor LOS operation. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_hscan_eye       : 7;  /**< [  6:  0](R/W/H) Horizontal scan control setting for CDR eye monitor clock.
                                                                 This register is controlled by firmware during the RESET--      ACTIVE power
                                                                 state sequence, as part of some AFE calibrations. It may thenalso be controlled
                                                                 by firmware once the PHY is in the ACTIVE power state as part of some adaptive
                                                                 equalization algorithms if they are enabled, or part of an eye monitor or eye
                                                                 monitor LOS operation. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl2 bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl2_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_pi_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Pi Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxcdr_pi_swing        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_pi_swing        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80108d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_pi_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_PI_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_rst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Rst Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_rst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_rst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rst_rxcdr_phd_n       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_rxcdr_phd_n       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_rst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_rst_ctrl0_rsvd bdk_gsercx_lnx_cdr_refclk_afe_rst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010820ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_rst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_RST_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_vco_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Vco Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxcdr_vco_kick        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_vco_kick        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl0_rsvd bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010850ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_vco_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Vco Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxcdr_refdac_gain     : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t rxcdr_em_sense        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_em_sense        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t rxcdr_refdac_gain     : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl1_rsvd bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010858ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_vco_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Vco Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxcdr_dosc            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_dosc            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl2_rsvd bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010860ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_vco_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCO_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_afe_vcocal_status0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Afe Vcocal Status0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_afe_vcocal_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_afe_vcocal_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxcdr_vco_em          : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t rxcdr_vcocal_up       : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxcdr_vcocal_up       : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t rxcdr_vco_em          : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_afe_vcocal_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_afe_vcocal_status0_rsvd bdk_gsercx_lnx_cdr_refclk_afe_vcocal_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010928ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_afe_vcocal_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_AFE_VCOCAL_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_cdr_vcocal_ctrl0
 *
 * GSERC Ln Cdr Refclk Cdr Vcocal Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timing_window_15_8    : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. MSB of 16-bit value. */
#else /* Word 0 - Little Endian */
        uint32_t timing_window_15_8    : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. MSB of 16-bit value. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0 bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010918ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl0_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) "GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_cdr_vcocal_ctrl1
 *
 * GSERC Ln Cdr Refclk Cdr Vcocal Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timing_window_7_0     : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. LSB of 16-bit value. */
#else /* Word 0 - Little Endian */
        uint32_t timing_window_7_0     : 8;  /**< [  7:  0](R/W/H) CDR VCO frequency calibraiton timing window. LSB of 16-bit value. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1 bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010920ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) bdk_gsercx_lnx_cdr_refclk_cdr_vcocal_ctrl1_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) "GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_CDR_VCOCAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Refclk Rxcdr Hscan Eye Cfg Register
 */
union bdk_gsercx_lnx_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t zero_phase            : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t zero_phase            : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd bdk_gsercx_lnx_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010980ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(a,b) bdk_gsercx_lnx_cdr_refclk_rxcdr_hscan_eye_cfg_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(a,b) "GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_REFCLK_RXCDR_HSCAN_EYE_CFG_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_first_peak_status0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum First Peak Status0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t val_7_0               : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t val_7_0               : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status0_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010750ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_first_peak_status1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum First Peak Status1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t val_15_8              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t val_15_8              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status1_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010758ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_first_peak_status2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum First Peak Status2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t val_19_16             : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t val_19_16             : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status2_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010760ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_first_peak_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_FIRST_PEAK_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_last_peak_status0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Last Peak Status0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t val_7_0               : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t val_7_0               : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status0_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010768ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_last_peak_status1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Last Peak Status1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t val_15_8              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t val_15_8              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status1_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010770ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_last_peak_status2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Last Peak Status2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t val_19_16             : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t val_19_16             : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status2_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010778ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_last_peak_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_LAST_PEAK_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_peak_detect_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Peak Detect Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010708ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_peak_detect_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Peak Detect Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_peaks             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t sample_drop_bits      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sample_drop_bits      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t num_peaks             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010710ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_peak_detect_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Peak Detect Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t peak2peak_period_min  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t peak2peak_period_min  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl2_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010718ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_peak_detect_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Peak Detect Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t peak2peak_period_max  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t peak2peak_period_max  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl3_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010740ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_accum_peak_detect_status0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Accum Peak Detect Status0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t slow                  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t noisy                 : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t done                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t done                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t noisy                 : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t slow                  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_status0_rsvd bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010748ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_accum_peak_detect_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_ACCUM_PEAK_DETECT_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_cal_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Cal Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_cal_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_cal_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dlpf_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_cal_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_cal_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_cal_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010480ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_cal_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_cal_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Cal Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_cal_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_cal_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cfg_dosc_min          : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cfg_dosc_min          : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_cal_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_cal_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_cal_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010488ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_cal_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_CAL_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl0
 *
 * GSERC Ln Cdr Rxclk Dlpf Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t num_dither_bits       : 4;  /**< [  3:  0](R/W/H) CDR integral path gain control.
                                                                 Controls the number of dither bits in the digital low-pass filter DLPF accumulator. */
#else /* Word 0 - Little Endian */
        uint32_t num_dither_bits       : 4;  /**< [  3:  0](R/W/H) CDR integral path gain control.
                                                                 Controls the number of dither bits in the digital low-pass filter DLPF accumulator. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl0 bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl0_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t high_threshold_7_0    : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t high_threshold_7_0    : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010588ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t high_threshold_8      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t high_threshold_8      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl2_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010590ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t high_count            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t high_count            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl3_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl4 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t low_threshold_7_0     : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t low_threshold_7_0     : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl4_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl5 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t low_threshold_8       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t low_threshold_8       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl5_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl6 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t low_count             : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t low_count             : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl6_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl7_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl7 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t low_en                : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t high_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t lockl_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t lock_en               : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t lock_en               : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t lockl_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t high_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t low_en                : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl7_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl8_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl8 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t output_sample_period  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t output_sample_period  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl8_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_ctrl9_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Ctrl9 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl9_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl9_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t mode_ovr_val          : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mode_ovr_val          : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl9_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl9_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl9_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_ctrl9_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_CTRL9_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Status0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t grey_val_7_0          : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t grey_val_7_0          : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_status0_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Dlpf Status1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t grey_val_8            : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t grey_val_8            : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_status1_rsvd bdk_gsercx_lnx_cdr_rxclk_dlpf_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status2
 *
 * GSERC Ln Cdr Rxclk Dlpf Status2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t binary_val_7_0        : 8;  /**< [  7:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
#else /* Word 0 - Little Endian */
        uint32_t binary_val_7_0        : 8;  /**< [  7:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status2_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_status2 bdk_gsercx_lnx_cdr_rxclk_dlpf_status2_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80105f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_status2_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status3
 *
 * GSERC Ln Cdr Rxclk Dlpf Status3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t binary_val_8          : 1;  /**< [  0:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
#else /* Word 0 - Little Endian */
        uint32_t binary_val_8          : 1;  /**< [  0:  0](RO/H) Binary-coded DLPF.  Need to read dlpf_status3 first and then read dlpf_status2.
                                                                 The buffered DLPF value is held constant when dlpf_status3 is read until
                                                                 dlpf_status2 is read. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status3_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_status3 bdk_gsercx_lnx_cdr_rxclk_dlpf_status3_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010600ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_status3_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status4
 *
 * GSERC Ln Cdr Rxclk Dlpf Status4 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_status4
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t lock_lost             : 1;  /**< [  2:  2](RO/H) 1 indicates lock has been lost.
                                                                 This is sticky until cleared by disabling the loss-of-lock detector i.e. set lock_en_i to 0. */
        uint32_t dlpf_too_low          : 1;  /**< [  1:  1](RO/H) Indicates that DLPF is too low. */
        uint32_t dlpf_too_high         : 1;  /**< [  0:  0](RO/H) Indicates that DLPF is too high. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_too_high         : 1;  /**< [  0:  0](RO/H) Indicates that DLPF is too high. */
        uint32_t dlpf_too_low          : 1;  /**< [  1:  1](RO/H) Indicates that DLPF is too low. */
        uint32_t lock_lost             : 1;  /**< [  2:  2](RO/H) 1 indicates lock has been lost.
                                                                 This is sticky until cleared by disabling the loss-of-lock detector i.e. set lock_en_i to 0. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status4_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_status4 bdk_gsercx_lnx_cdr_rxclk_dlpf_status4_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010608ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_status4_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_dlpf_status5
 *
 * GSERC Ln Cdr Rxclk Dlpf Status5 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_dlpf_status5
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) 1 indicates lock has been detected.
                                                                 It is cleared when lock detector is disabled detector i.e. set lock_en_i to 0. */
#else /* Word 0 - Little Endian */
        uint32_t locked                : 1;  /**< [  0:  0](RO/H) 1 indicates lock has been detected.
                                                                 It is cleared when lock detector is disabled detector i.e. set lock_en_i to 0. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_dlpf_status5_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_dlpf_status5 bdk_gsercx_lnx_cdr_rxclk_dlpf_status5_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010620ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) bdk_gsercx_lnx_cdr_rxclk_dlpf_status5_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) "GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_DLPF_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_force_mode_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Force Mode Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dlpf_val_7_0          : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_val_7_0          : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010550ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_force_mode_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Force Mode Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dlpf_val_8            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_val_8            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010558ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_force_mode_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Force Mode Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl2_rsvd bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010568ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_force_mode_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Force Mode Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t dlpf_mode_val         : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_mode_val         : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl3_rsvd bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010570ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_force_mode_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_FORCE_MODE_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_integral_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Integral Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_integral_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_integral_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t dlpf_mode             : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t decimation_mode       : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t decimation_mode       : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t dlpf_mode             : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_integral_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_integral_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_integral_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010508ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_integral_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_integral_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Integral Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_integral_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_integral_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pd_out_mask           : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_out_mask           : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_integral_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_integral_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_integral_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010510ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_integral_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_integral_status0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Integral Status0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_integral_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_integral_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t accumulator_7_0       : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t accumulator_7_0       : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_integral_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_integral_status0_rsvd bdk_gsercx_lnx_cdr_rxclk_integral_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010628ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_integral_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_integral_status1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Integral Status1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_integral_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_integral_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t accumulator_15_8      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t accumulator_15_8      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_integral_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_integral_status1_rsvd bdk_gsercx_lnx_cdr_rxclk_integral_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010630ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_integral_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_integral_status2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Integral Status2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_integral_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_integral_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t accumulator_19_16     : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t accumulator_19_16     : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_integral_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_integral_status2_rsvd bdk_gsercx_lnx_cdr_rxclk_integral_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010640ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_integral_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_INTEGRAL_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_load_mode_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Load Mode Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dlpf_val_7_0          : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_val_7_0          : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010530ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_load_mode_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Load Mode Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dlpf_val_8            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_val_8            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010538ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_load_mode_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Load Mode Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dlpf_dither_val_7_0   : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_dither_val_7_0   : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl2_rsvd bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010540ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_load_mode_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Load Mode Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t dlpf_dither_val_10_8  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_dither_val_10_8  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl3_rsvd bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010548ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_load_mode_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOAD_MODE_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockd Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sample_period         : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t dither_bits           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dither_bits           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t sample_period         : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010648ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockd Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_samples           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_samples           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010650ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockd_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockd Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t slope_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t slope_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl2_rsvd bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010658ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockd_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockd Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t range_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t range_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl3_rsvd bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010660ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockd_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKD_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockl_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockl Ctrl0 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sample_period         : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t dither_bits           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dither_bits           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t sample_period         : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl0_rsvd bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010668ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockl_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockl Ctrl1 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_samples           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_samples           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl1_rsvd bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010670ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockl_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockl Ctrl2 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t slope_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t slope_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl2_rsvd bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010678ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_cdr_rxclk_lockl_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Cdr Rxclk Lockl Ctrl3 Register
 */
union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t range_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t range_threshold       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl3_rsvd bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010700ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(a,b) bdk_gsercx_lnx_cdr_rxclk_lockl_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(a,b) "GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_CDR_RXCLK_LOCKL_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_clk_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Clk Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rxdfe_clkdiv_ovr      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t rxdfe_clk_delay_data  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_clk_delay_data  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t rxdfe_clkdiv_ovr      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012060ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_clk_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Clk Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxdfe_clk_delay_edge  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_clk_delay_edge  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl1_rsvd bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_clk_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CLK_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_cml_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Cml Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_cml_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_cml_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rxdfe_cmlr_ltch       : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t rxdfe_cmlr            : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t rxdfe_cmli            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_cmli            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t rxdfe_cmlr            : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t rxdfe_cmlr_ltch       : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_cml_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_cml_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_cml_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012080ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_cml_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_CML_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_eye_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Eye Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_eye_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_eye_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxdfe_vscani_loadsw   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_vscani_loadsw   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_eye_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_eye_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_eye_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012078ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_eye_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_eyeclk_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Eyeclk Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_eyeclk_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_eyeclk_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rxdfe_clkdiveye_ovr   : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t rxdfe_eyeclk_delay    : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_eyeclk_delay    : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t rxdfe_clkdiveye_ovr   : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_eyeclk_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_eyeclk_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_eyeclk_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012070ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_eyeclk_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_EYECLK_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_misc_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Misc Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_misc_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_misc_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxdfe_lpm             : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdfe_ldr             : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t rxdfe_sumgain         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_sumgain         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxdfe_ldr             : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t rxdfe_lpm             : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_misc_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_misc_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_misc_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012090ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_misc_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_mute_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Mute Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_mute_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_mute_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rxdfe_edge_mute       : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t rxdfe_mute_eye        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_mute_eye        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxdfe_edge_mute       : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_mute_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_mute_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_mute_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012050ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_mute_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_MUTE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_negc_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Negc Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_negc_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_negc_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxdfe_negc_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_negc_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_negc_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_negc_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_negc_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012040ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_negc_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Pd Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pd_rxdfe              : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxdfe              : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_pd_ctrl1
 *
 * GSERC Ln Dfe Refclk Afe Pd Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t pd_rxdfe_tap          : 8;  /**< [  7:  0](R/W/H) DFE tap power down control. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxdfe_tap          : 8;  /**< [  7:  0](R/W/H) DFE tap power down control. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl1 bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012008ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl1_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_pd_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Pd Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pd_rxdfe_odd_path     : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t pd_rxdfe_even_path    : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxdfe_even_path    : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t pd_rxdfe_odd_path     : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl2_rsvd bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012010ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_pd_ctrl3
 *
 * GSERC Ln Dfe Refclk Afe Pd Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_rxdfe_eye          : 3;  /**< [  2:  0](R/W/H) DFE eye monitor power down control
                                                                 0   0    0     100% active
                                                                 1   0    0     80% active
                                                                 1   0    1     66% active power-ramp-up state
                                                                 1   1    1     33% active power-ramp-up state
                                                                 1   1    0     off */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxdfe_eye          : 3;  /**< [  2:  0](R/W/H) DFE eye monitor power down control
                                                                 0   0    0     100% active
                                                                 1   0    0     80% active
                                                                 1   0    1     66% active power-ramp-up state
                                                                 1   1    1     33% active power-ramp-up state
                                                                 1   1    0     off */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl3 bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012018ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) bdk_gsercx_lnx_dfe_refclk_afe_pd_ctrl3_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_PD_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_qsample_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Qsample Status0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_qsample_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_qsample_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t rxdfe_clkdiveye_qsample : 4;/**< [  4:  1](RO/H) Reserved. */
        uint32_t rxdfe_clkdiv_qsample  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_clkdiv_qsample  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t rxdfe_clkdiveye_qsample : 4;/**< [  4:  1](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_qsample_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_qsample_status0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_qsample_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_qsample_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_QSAMPLE_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_rst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Rst Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_rst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_rst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rst_rxdfe_n           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_rxdfe_n           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_rst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_rst_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_rst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012020ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_rst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_RST_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_spare_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Spare Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_spare_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_spare_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rxdfe_spare           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_spare           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_spare_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_spare_rsvd bdk_gsercx_lnx_dfe_refclk_afe_spare_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_spare_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_SPARE_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_afe_toggle_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Afe Toggle Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_afe_toggle_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_afe_toggle_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxdfe_toggle_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdfe_toggle_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_afe_toggle_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_afe_toggle_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_afe_toggle_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012030ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_afe_toggle_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_AFE_TOGGLE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_eye_tap1_ctrl0
 *
 * GSERC Ln Dfe Refclk Eye Tap1 Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t pol                   : 1;  /**< [  7:  7](R/W/H) Eye monitor tap1 polarity control 0 = negative, 1 = positive. */
        uint32_t mag                   : 7;  /**< [  6:  0](R/W/H) Eye monitor tap1 magnitude control. */
#else /* Word 0 - Little Endian */
        uint32_t mag                   : 7;  /**< [  6:  0](R/W/H) Eye monitor tap1 magnitude control. */
        uint32_t pol                   : 1;  /**< [  7:  7](R/W/H) Eye monitor tap1 polarity control 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0 bdk_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) bdk_gsercx_lnx_dfe_refclk_eye_tap1_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_EYE_TAP1_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_eye_vscan_ctrl0
 *
 * GSERC Ln Dfe Refclk Eye Vscan Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mag                   : 8;  /**< [  7:  0](R/W/H) Eye monitor vertical scan magnitude control. */
#else /* Word 0 - Little Endian */
        uint32_t mag                   : 8;  /**< [  7:  0](R/W/H) Eye monitor vertical scan magnitude control. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0 bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_eye_vscan_ctrl1
 *
 * GSERC Ln Dfe Refclk Eye Vscan Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t pol                   : 1;  /**< [  0:  0](R/W/H) Eye monitor vertical scan polarity control 0 = negative, 1 = positive. */
#else /* Word 0 - Little Endian */
        uint32_t pol                   : 1;  /**< [  0:  0](R/W/H) Eye monitor vertical scan polarity control 0 = negative, 1 = positive. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1 bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80120c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) bdk_gsercx_lnx_dfe_refclk_eye_vscan_ctrl1_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_EYE_VSCAN_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl0
 *
 * GSERC Ln Dfe Refclk Fsm Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t drive_before_eval     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t finish                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t cmd                   : 5;  /**< [  5:  1](R/W/H) FSM Command to run:
                                                                 0x00 = LOAD_ONLY
                                                                 0x02 = EYE_PHASE_ADAPTATION
                                                                 0x04 = LOAD_EVAL_ONLY
                                                                 0x08 = LOAD_EVAL_CONVRG_ONLY
                                                                 0x10 = LOAD_EVAL_CONVRG_ALL_COMP */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Firmware request for DFE. */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Firmware request for DFE. */
        uint32_t cmd                   : 5;  /**< [  5:  1](R/W/H) FSM Command to run:
                                                                 0x00 = LOAD_ONLY
                                                                 0x02 = EYE_PHASE_ADAPTATION
                                                                 0x04 = LOAD_EVAL_ONLY
                                                                 0x08 = LOAD_EVAL_CONVRG_ONLY
                                                                 0x10 = LOAD_EVAL_CONVRG_ALL_COMP */
        uint32_t finish                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t drive_before_eval     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl0 bdk_gsercx_lnx_dfe_refclk_fsm_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t ctrl_en               : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t next_state            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t next_state            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t ctrl_en               : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl1_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_1_timer7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_1_timer7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl2_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t wait_1_timer9_8       : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_1_timer9_8       : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl3_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012118ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_2_timer7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_2_timer7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl4_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t wait_2_timer9_8       : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_2_timer9_8       : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl5_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012128ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl6 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap_delay_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap_delay_7_0         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl6_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012130ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_ctrl7_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Fsm Ctrl7 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap_delay_9_8         : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap_delay_9_8         : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_ctrl7_rsvd bdk_gsercx_lnx_dfe_refclk_fsm_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012138ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_CTRL7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_fsm_status0
 *
 * GSERC Ln Dfe Refclk Fsm Status0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_fsm_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_fsm_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t afe_drv_ack           : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t err_func_ack          : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t slicer_ofst_ack       : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Acknowledge from DFE. */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Acknowledge from DFE. */
        uint32_t slicer_ofst_ack       : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t err_func_ack          : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t afe_drv_ack           : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_fsm_status0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_fsm_status0 bdk_gsercx_lnx_dfe_refclk_fsm_status0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012140ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_FSM_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) bdk_gsercx_lnx_dfe_refclk_fsm_status0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) "GSERCX_LNX_DFE_REFCLK_FSM_STATUS0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_FSM_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eye_en                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t odd_edge_en           : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t even_edge_en          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t odd1_data_en          : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t odd0_data_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t even1_data_en         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t even0_data_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even0_data_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t even1_data_en         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t odd0_data_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t odd1_data_en          : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t even_edge_en          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t odd_edge_en           : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t eye_en                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012280ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t limit                 : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl1_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012288ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t max_bounces           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t max_bounces           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl2_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012290ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Source Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eye                   : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t odd_edge              : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t even_edge             : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t odd1_data             : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t odd0_data             : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t even1_data            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t even0_data            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even0_data            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t even1_data            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t odd0_data             : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t odd1_data             : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t even_edge             : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t odd_edge              : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t eye                   : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012318ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_source_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_SOURCE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t even0_data            : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even0_data            : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012298ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t even1_data            : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even1_data            : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t odd0_data             : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t odd0_data             : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t odd1_data             : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t odd1_data             : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t even_edge             : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even_edge             : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t odd_edge              : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t odd_edge              : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Load Val Ctrl6 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t eye                   : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eye                   : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_load_val_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_LOAD_VAL_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Status0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t dec                   : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t inc                   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t err_o                 : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t err_o                 : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t inc                   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t dec                   : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status0_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012320ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Status1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eye                   : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint32_t odd_edge              : 1;  /**< [  5:  5](RO/H) Reserved. */
        uint32_t even_edge             : 1;  /**< [  4:  4](RO/H) Reserved. */
        uint32_t odd1_data             : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t odd0_data             : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t even1_data            : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t even0_data            : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even0_data            : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t even1_data            : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t odd0_data             : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t odd1_data             : 1;  /**< [  3:  3](RO/H) Reserved. */
        uint32_t even_edge             : 1;  /**< [  4:  4](RO/H) Reserved. */
        uint32_t odd_edge              : 1;  /**< [  5:  5](RO/H) Reserved. */
        uint32_t eye                   : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status1_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012328ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t even0_data            : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even0_data            : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status0_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t even1_data            : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even1_data            : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status1_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t odd0_data             : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t odd0_data             : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status2_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t odd1_data             : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t odd1_data             : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status3_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status4 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t even_edge             : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t even_edge             : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status4_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80122f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status5 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t odd_edge              : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t odd_edge              : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status5_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012300ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_slicer_ofst_val_status6_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Refclk Slicer Ofst Val Status6 Register
 */
union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t eye                   : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eye                   : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status6_rsvd bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012308ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(a,b) bdk_gsercx_lnx_dfe_refclk_slicer_ofst_val_status6_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(a,b) "GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_SLICER_OFST_VAL_STATUS6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_ctrl0
 *
 * GSERC Ln Dfe Refclk Tap Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap1_odd_en           : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 1 Odd Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap1_even_en          : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 1 Even Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even_en          : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 1 Even Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap1_odd_en           : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 1 Odd Path during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_ctrl0 bdk_gsercx_lnx_dfe_refclk_tap_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012148ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) bdk_gsercx_lnx_dfe_refclk_tap_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_ctrl1
 *
 * GSERC Ln Dfe Refclk Tap Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t tap8_en               : 1;  /**< [  6:  6](R/W/H) Enables updating Tap 8 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap7_en               : 1;  /**< [  5:  5](R/W/H) Enables updating Tap 7 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap6_en               : 1;  /**< [  4:  4](R/W/H) Enables updating Tap 6 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap5_en               : 1;  /**< [  3:  3](R/W/H) Enables updating Tap 5 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap4_en               : 1;  /**< [  2:  2](R/W/H) Enables updating Tap 4 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap3_en               : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 3 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap2_en               : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 2 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
#else /* Word 0 - Little Endian */
        uint32_t tap2_en               : 1;  /**< [  0:  0](R/W/H) Enables updating Tap 2 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap3_en               : 1;  /**< [  1:  1](R/W/H) Enables updating Tap 3 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap4_en               : 1;  /**< [  2:  2](R/W/H) Enables updating Tap 4 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap5_en               : 1;  /**< [  3:  3](R/W/H) Enables updating Tap 5 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap6_en               : 1;  /**< [  4:  4](R/W/H) Enables updating Tap 6 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap7_en               : 1;  /**< [  5:  5](R/W/H) Enables updating Tap 7 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t tap8_en               : 1;  /**< [  6:  6](R/W/H) Enables updating Tap 8 during FSM LOAD_*** commands
                                                                 0 = Disabled
                                                                 1 = Enabled */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_ctrl1 bdk_gsercx_lnx_dfe_refclk_tap_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) bdk_gsercx_lnx_dfe_refclk_tap_ctrl1_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_CTRL1"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl0
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Even Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Even Path for Tap Adaptations. */
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl1
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Odd Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Loading value for Tap 1 Odd Path for Tap Adaptations. */
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl1_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl2
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_6            : 1;
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Loading value for Tap 2 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Loading value for Tap 2 for Tap Adaptations. */
        uint32_t reserved_6            : 1;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl2_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl3
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Loading value for Tap 3 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Loading value for Tap 3 for Tap Adaptations. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl3_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl4
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 4 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 4 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl4_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl5
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 5 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 5 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl5_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl6
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl6 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 6 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Loading value for Tap 6 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl6_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl7
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl7 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 7 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 7 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl7_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_load_val_ctrl8
 *
 * GSERC Ln Dfe Refclk Tap Load Val Ctrl8 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 8 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Loading value for Tap 8 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8 bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) bdk_gsercx_lnx_dfe_refclk_tap_load_val_ctrl8_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_LOAD_VAL_CTRL8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl0
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Even Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even             : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Even Path for Tap Adaptations. */
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012158ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl1
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Odd Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](R/W/H) Starting value for Tap 1 Odd Path for Tap Adaptations. */
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012160ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl1_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl2
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_6            : 1;
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Starting value for Tap 2 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap2                  : 6;  /**< [  5:  0](R/W/H) Starting value for Tap 2 for Tap Adaptations. */
        uint32_t reserved_6            : 1;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012168ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl2_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl3
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Starting value for Tap 3 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap3                  : 5;  /**< [  4:  0](R/W/H) Starting value for Tap 3 for Tap Adaptations. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012170ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl3_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl4
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 4 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap4                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 4 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012178ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl4_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl5
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 5 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap5                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 5 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl5_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl6
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl6 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 6 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap6                  : 4;  /**< [  3:  0](R/W/H) Starting value for Tap 6 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012188ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl6_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl7
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl7 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 7 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap7                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 7 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012190ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl7_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_start_val_ctrl8
 *
 * GSERC Ln Dfe Refclk Tap Start Val Ctrl8 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 8 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap8                  : 3;  /**< [  2:  0](R/W/H) Starting value for Tap 8 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](R/W/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8 bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012198ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) bdk_gsercx_lnx_dfe_refclk_tap_start_val_ctrl8_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_START_VAL_CTRL8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status0
 *
 * GSERC Ln Dfe Refclk Tap Val Status0 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_even             : 7;  /**< [  6:  0](RO/H) Binary value for Tap 1 Even Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_even             : 7;  /**< [  6:  0](RO/H) Binary value for Tap 1 Even Path for Tap Adaptations. */
        uint32_t tap1_even_polarity    : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status0_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status0 bdk_gsercx_lnx_dfe_refclk_tap_val_status0_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status0_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status1
 *
 * GSERC Ln Dfe Refclk Tap Val Status1 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](RO/H) Binary  value for Tap 1 Odd Path for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_odd              : 7;  /**< [  6:  0](RO/H) Binary  value for Tap 1 Odd Path for Tap Adaptations. */
        uint32_t tap1_odd_polarity     : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status1_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status1 bdk_gsercx_lnx_dfe_refclk_tap_val_status1_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status1_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status2
 *
 * GSERC Ln Dfe Refclk Tap Val Status2 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_6            : 1;
        uint32_t tap2                  : 6;  /**< [  5:  0](RO/H) Binary  value for Tap 2 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap2                  : 6;  /**< [  5:  0](RO/H) Binary  value for Tap 2 for Tap Adaptations. */
        uint32_t reserved_6            : 1;
        uint32_t tap2_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status2_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status2 bdk_gsercx_lnx_dfe_refclk_tap_val_status2_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80121f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status2_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status3
 *
 * GSERC Ln Dfe Refclk Tap Val Status3 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3                  : 5;  /**< [  4:  0](RO/H) Binary  value for Tap 3 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap3                  : 5;  /**< [  4:  0](RO/H) Binary  value for Tap 3 for Tap Adaptations. */
        uint32_t reserved_5_6          : 2;
        uint32_t tap3_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status3_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status3 bdk_gsercx_lnx_dfe_refclk_tap_val_status3_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status3_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status4
 *
 * GSERC Ln Dfe Refclk Tap Val Status4 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status4
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 4 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap4                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 4 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap4_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status4_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status4 bdk_gsercx_lnx_dfe_refclk_tap_val_status4_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status4_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status5
 *
 * GSERC Ln Dfe Refclk Tap Val Status5 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status5
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 5 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap5                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 5 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap5_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status5_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status5 bdk_gsercx_lnx_dfe_refclk_tap_val_status5_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status5_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status6
 *
 * GSERC Ln Dfe Refclk Tap Val Status6 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status6
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 6 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap6                  : 4;  /**< [  3:  0](RO/H) Binary  value for Tap 6 for Tap Adaptations. */
        uint32_t reserved_4_6          : 3;
        uint32_t tap6_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status6_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status6 bdk_gsercx_lnx_dfe_refclk_tap_val_status6_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status6_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status7
 *
 * GSERC Ln Dfe Refclk Tap Val Status7 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status7
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 7 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap7                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 7 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap7_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status7_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status7 bdk_gsercx_lnx_dfe_refclk_tap_val_status7_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status7_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS7(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_refclk_tap_val_status8
 *
 * GSERC Ln Dfe Refclk Tap Val Status8 Register
 */
union bdk_gsercx_lnx_dfe_refclk_tap_val_status8
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_refclk_tap_val_status8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 8 for Tap Adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t tap8                  : 3;  /**< [  2:  0](RO/H) Binary  value for Tap 8 for Tap Adaptations. */
        uint32_t reserved_3_6          : 4;
        uint32_t tap8_polarity         : 1;  /**< [  7:  7](RO/H) Polarity 0 = negative, 1 = positive. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_refclk_tap_val_status8_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_refclk_tap_val_status8 bdk_gsercx_lnx_dfe_refclk_tap_val_status8_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) bdk_gsercx_lnx_dfe_refclk_tap_val_status8_t
#define bustype_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) "GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8"
#define device_bar_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_REFCLK_TAP_VAL_STATUS8(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_adapt_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Adapt Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pbzf_en               : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t sslms_en              : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sslms_en              : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t pbzf_en               : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl0_rsvd bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012480ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_adapt_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Adapt Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t clear_err             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t clear_err             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl1_rsvd bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012488ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_adapt_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Adapt Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t avg_err_threshold     : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t avg_err_threshold     : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl2_rsvd bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012490ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_adapt_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ADAPT_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t edge_val              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t edge_val              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_ctrl0_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012430ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_samples_7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_samples_7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_ctrl1_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012438ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t num_samples_9_8       : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_samples_9_8       : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_ctrl2_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012440ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Status0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t status                : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t status                : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_status0_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012448ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Status1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t up_count_7_0          : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t up_count_7_0          : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_status1_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012450ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_status2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Status2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t up_count_9_8          : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t up_count_9_8          : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_status2_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012458ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_status3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Status3 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_status3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_status3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t down_count_7_0        : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t down_count_7_0        : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_status3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_status3_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_status3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012460ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_status3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_dll_status4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Dll Status4 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_dll_status4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_dll_status4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t down_count_9_8        : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t down_count_9_8        : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_dll_status4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_dll_status4_rsvd bdk_gsercx_lnx_dfe_rxclk_dll_status4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012468ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_dll_status4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_DLL_STATUS4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t run                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t run                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl0_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012700ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_count_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_count_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl1_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012708ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_count_15_8       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_count_15_8       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl2_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012710ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_count_23_16      : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_count_23_16      : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl3_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012718ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_count_31_24      : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_count_31_24      : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl4_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012720ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_count_39_32      : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_count_39_32      : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl5_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012728ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Status0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t errs_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t errs_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_status0_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012730ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Status1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t errs_15_8             : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t errs_15_8             : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_status1_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012738ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_status2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Status2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t errs_23_16            : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t errs_23_16            : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_status2_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012740ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_status3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Status3 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_status3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_status3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t errs_31_24            : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t errs_31_24            : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_status3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_status3_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_status3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012748ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_status3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_status4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Status4 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_status4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_status4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t errs_39_32            : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t errs_39_32            : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_status4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_status4_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_status4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012750ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_status4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_err_count_status5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Err Count Status5 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_err_count_status5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_err_count_status5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dirty                 : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dirty                 : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_err_count_status5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_err_count_status5_rsvd bdk_gsercx_lnx_dfe_rxclk_err_count_status5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012758ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_err_count_status5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_ERR_COUNT_STATUS5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t training_patt_7_0     : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t training_patt_7_0     : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl0_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t training_patt_12_8    : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t training_patt_12_8    : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl1_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t training_patt_mask_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t training_patt_mask_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl2_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t training_patt_mask_12_8 : 5;/**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t training_patt_mask_12_8 : 5;/**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl3_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eye_patt_mask_7_0     : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eye_patt_mask_7_0     : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl4_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eye_patt_mask_15_8    : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eye_patt_mask_15_8    : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl5_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl6 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eye_patt_mask_23_16   : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eye_patt_mask_23_16   : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl6_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pattern_ctrl7_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pattern Ctrl7 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eye_patt_mask_31_24   : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eye_patt_mask_31_24   : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl7_rsvd bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80124e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pattern_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PATTERN_CTRL7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pbzf_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pbzf Status0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pbzf_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pbzf_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t avg_err               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t valid_result          : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t valid_result          : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t avg_err               : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pbzf_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pbzf_status0_rsvd bdk_gsercx_lnx_dfe_rxclk_pbzf_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80126b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pbzf_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pbzf_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pbzf Status1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pbzf_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pbzf_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_ones              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_ones              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pbzf_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pbzf_status1_rsvd bdk_gsercx_lnx_dfe_rxclk_pbzf_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80126b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pbzf_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_pbzf_status2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Pbzf Status2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_pbzf_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_pbzf_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_zeros             : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_zeros             : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_pbzf_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_pbzf_status2_rsvd bdk_gsercx_lnx_dfe_rxclk_pbzf_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80126c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_pbzf_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_PBZF_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_slicer_ofst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Slicer Ofst Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ofst_err_threshold_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ofst_err_threshold_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl0_rsvd bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_slicer_ofst_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Slicer Ofst Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ofst_err_threshold_8_8 : 1; /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ofst_err_threshold_8_8 : 1; /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl1_rsvd bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_slicer_ofst_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Slicer Ofst Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t invert                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t e_shift               : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_3_4          : 2;
        uint32_t sel                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sel                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_4          : 2;
        uint32_t e_shift               : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t invert                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl2_rsvd bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_slicer_ofst_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SLICER_OFST_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mask_tapm12           : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t cur_prev_mask         : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t cur_prev_pattern      : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cur_prev_pattern      : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t cur_prev_mask         : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t mask_tapm12           : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl0_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012500ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mask_tap1             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t mask_dlev             : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mask_dlev             : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t mask_tap1             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl1_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012508ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mask_tap3             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t mask_tap2             : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mask_tap2             : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t mask_tap3             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl2_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012510ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl3 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mask_tap5             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t mask_tap4             : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mask_tap4             : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t mask_tap5             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl3_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012518ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl4 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mask_tap7             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t mask_tap6             : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mask_tap6             : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t mask_tap7             : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl4_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012520ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl5 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mask_tap8             : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mask_tap8             : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl5_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012528ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Ctrl6 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t reload_init_cnt       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t reload_init_cnt       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl6_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012530ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t update                : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t update                : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status0_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012550ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status10_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status10 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status10_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status10_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap2_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap2_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status10_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status10_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status10_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status10_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS10_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status11_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status11 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status11_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status11_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap2_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap2_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status11_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status11_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status11_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status11_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS11_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status12_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status12 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status12_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status12_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap3_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap3_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status12_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status12_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status12_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status12_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS12_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status13_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status13 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status13_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status13_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap3_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap3_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status13_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status13_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status13_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status13_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS13_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status14_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status14 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status14_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status14_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap4_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap4_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status14_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status14_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status14_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status14_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS14_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status15_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status15 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status15_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status15_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap4_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap4_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status15_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status15_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status15_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status15_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS15_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status16_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status16 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status16_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status16_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap5_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap5_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status16_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status16_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status16_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status16_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS16_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status17_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status17 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status17_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status17_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap5_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap5_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status17_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status17_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status17_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status17_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS17_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status18_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status18 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status18_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status18_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap6_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap6_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status18_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status18_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status18_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012600ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status18_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS18_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status19_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status19 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status19_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status19_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap6_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap6_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status19_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status19_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status19_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012608ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status19_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS19_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t update_dir            : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t update_dir            : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status1_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012558ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status20_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status20 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status20_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status20_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap7_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap7_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status20_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status20_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status20_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012610ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status20_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS20_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status21_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status21 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status21_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status21_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap7_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap7_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status21_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status21_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status21_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012618ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status21_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS21_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status22_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status22 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status22_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status22_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap8_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status22_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status22_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status22_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012620ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status22_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS22_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status23_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status23 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status23_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status23_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap8_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap8_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status23_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status23_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status23_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012628ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status23_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS23_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status2_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status2 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tapm2_counter_7_0     : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tapm2_counter_7_0     : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status2_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status3_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status3 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tapm2_counter_9_8     : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tapm2_counter_9_8     : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status3_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012588ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status3_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status4_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status4 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tapm1_counter_7_0     : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tapm1_counter_7_0     : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status4_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012590ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status5_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status5 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tapm1_counter_9_8     : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tapm1_counter_9_8     : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status5_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012598ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status6_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status6 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dlev_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlev_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status6_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status6_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status7_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status7 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t dlev_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlev_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status7_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status7_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status8_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status8 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap1_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_counter_7_0      : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status8_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status8_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status8_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status8_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_status9_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Status9 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_status9_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_status9_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tap1_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_counter_9_8      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_status9_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_status9_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_status9_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80125b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_status9_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_STATUS9_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_tap_status0_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Tap Status0 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t update                : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t update                : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status0_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012540ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_dfe_rxclk_sslms_tap_status1_rsvd
 *
 * INTERNAL: GSERC Ln Dfe Rxclk Sslms Tap Status1 Register
 */
union bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t update_dir            : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t update_dir            : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status1_rsvd bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012548ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(a,b) bdk_gsercx_lnx_dfe_rxclk_sslms_tap_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(a,b) "GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DFE_RXCLK_SSLMS_TAP_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_att_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Att Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_att_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_att_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t txdrv_sel_att_x2      : 5;  /**< [  7:  3](R/W/H) Reserved. */
        uint32_t txdrv_sel_att_x1      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_sel_att_x1      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t txdrv_sel_att_x2      : 5;  /**< [  7:  3](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_att_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_att_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_att_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_att_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_ATT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_c1_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe C1 Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_c1_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_c1_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t txdrv_sel_c1_x2       : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t txdrv_sel_c1_x1       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t txdrv_sel_c1_p5       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_sel_c1_p5       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t txdrv_sel_c1_x1       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t txdrv_sel_c1_x2       : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_c1_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_c1_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_c1_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_c1_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_C1_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_caln_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Caln Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txdrv_caln_x1_fixed   : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txdrv_caln_x1         : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_caln_x1         : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txdrv_caln_x1_fixed   : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_caln_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Caln Ctrl1 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t txdrv_caln_xp5_fixed  : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txdrv_caln_x2         : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_caln_x2         : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txdrv_caln_xp5_fixed  : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl1_rsvd bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_caln_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALN_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_calp_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Calp Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txdrv_calp_x1_fixed   : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txdrv_calp_x1         : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_calp_x1         : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2            : 1;
        uint32_t txdrv_calp_x1_fixed   : 2;  /**< [  4:  3](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_calp_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Calp Ctrl1 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t txdrv_calp_xp5_fixed  : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txdrv_calp_x2         : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_calp_x2         : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4            : 1;
        uint32_t txdrv_calp_xp5_fixed  : 2;  /**< [  6:  5](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl1_rsvd bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011cb0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_calp_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CALP_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_cm1_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Cm1 Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_cm1_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_cm1_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txdrv_sel_cxcm1_x2    : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t txdrv_sel_cm1_x2      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t txdrv_sel_cm1_x1      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t txdrv_sel_cm1_p5      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_sel_cm1_p5      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t txdrv_sel_cm1_x1      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t txdrv_sel_cm1_x2      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t txdrv_sel_cxcm1_x2    : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_cm1_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_cm1_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_cm1_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_cm1_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CM1_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl0
 *
 * GSERC Ln Drv Refclk Afe Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t txdrv_lp_idle         : 1;  /**< [  0:  0](R/W/H) When HIGH, TX driver goes into a low power IDLE model.
                                                                 In this mode, the output termination is not guaranteed to be 50 Ohm closer to 200 Ohm */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_lp_idle         : 1;  /**< [  0:  0](R/W/H) When HIGH, TX driver goes into a low power IDLE model.
                                                                 In this mode, the output termination is not guaranteed to be 50 Ohm closer to 200 Ohm */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_ctrl0 bdk_gsercx_lnx_drv_refclk_afe_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) bdk_gsercx_lnx_drv_refclk_afe_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Ctrl1 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t txdrv_spare           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_spare           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_ctrl1_rsvd bdk_gsercx_lnx_drv_refclk_afe_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Ctrl2 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txdrv_clk4_delay      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t txdrv_clkdly_low      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t txdrv_toggle_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_toggle_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t txdrv_clkdly_low      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t txdrv_clk4_delay      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_ctrl2_rsvd bdk_gsercx_lnx_drv_refclk_afe_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl3
 *
 * GSERC Ln Drv Refclk Afe Ctrl3 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t txdrv_co_pol          : 3;  /**< [  2:  0](R/W/H) TXEQ coefficient polarity control 0 = no inversion, 1= inverted as follows:

                                                                 000 : no inversion
                                                                 001 : CM1 is inverted
                                                                 010 : C0 is inverted
                                                                 100 : C1 is inverted */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_co_pol          : 3;  /**< [  2:  0](R/W/H) TXEQ coefficient polarity control 0 = no inversion, 1= inverted as follows:

                                                                 000 : no inversion
                                                                 001 : CM1 is inverted
                                                                 010 : C0 is inverted
                                                                 100 : C1 is inverted */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_ctrl3 bdk_gsercx_lnx_drv_refclk_afe_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) bdk_gsercx_lnx_drv_refclk_afe_ctrl3_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL3"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Ctrl4 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t txdrv_clk_delay_7_0   : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_clk_delay_7_0   : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_ctrl4_rsvd bdk_gsercx_lnx_drv_refclk_afe_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Ctrl5 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t txdrv_clk_delay_9_8   : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txdrv_clk_delay_9_8   : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_ctrl5_rsvd bdk_gsercx_lnx_drv_refclk_afe_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Pd Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pd_txdrv              : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_txdrv              : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_pd_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_afe_rst_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Drv Refclk Afe Rst Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_afe_rst_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_afe_rst_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rst_txdrv_div2_n      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_txdrv_div2_n      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_afe_rst_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_afe_rst_ctrl0_rsvd bdk_gsercx_lnx_drv_refclk_afe_rst_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(a,b) bdk_gsercx_lnx_drv_refclk_afe_rst_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(a,b) "GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_AFE_RST_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl0
 *
 * GSERC Ln Drv Refclk Txeq Ctrl0 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient request
                                                                 Set to 1 to have PHY firmware map the current register coefficient settings to the AFE TXDRV */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient request
                                                                 Set to 1 to have PHY firmware map the current register coefficient settings to the AFE TXDRV */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_ctrl0 bdk_gsercx_lnx_drv_refclk_txeq_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) bdk_gsercx_lnx_drv_refclk_txeq_ctrl0_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl1
 *
 * GSERC Ln Drv Refclk Txeq Ctrl1 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient control.
                                                                 0 = min equalization setting
                                                                 31 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient control.
                                                                 0 = min equalization setting
                                                                 31 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_ctrl1 bdk_gsercx_lnx_drv_refclk_txeq_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) bdk_gsercx_lnx_drv_refclk_txeq_ctrl1_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl3
 *
 * GSERC Ln Drv Refclk Txeq Ctrl3 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ pre-cursor tap CM1 cofficient control.

                                                                 0 = min equalization setting
                                                                 15 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ pre-cursor tap CM1 cofficient control.

                                                                 0 = min equalization setting
                                                                 15 = max equalization setting

                                                                 Note that need to initiate a TXEQ request to firmware to have TXEQ register
                                                                 values transferred to AFE. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_ctrl3 bdk_gsercx_lnx_drv_refclk_txeq_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) bdk_gsercx_lnx_drv_refclk_txeq_ctrl3_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl4
 *
 * GSERC Ln Drv Refclk Txeq Ctrl4 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t swing_1lsb_mode       : 1;  /**< [  1:  1](R/W/H) TXDRV swing 1-LSB mode enable. */
        uint32_t txeq_1lsb_mode        : 1;  /**< [  0:  0](R/W/H) TXEQ 1-LSB mode enable. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_1lsb_mode        : 1;  /**< [  0:  0](R/W/H) TXEQ 1-LSB mode enable. */
        uint32_t swing_1lsb_mode       : 1;  /**< [  1:  1](R/W/H) TXDRV swing 1-LSB mode enable. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_ctrl4 bdk_gsercx_lnx_drv_refclk_txeq_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) bdk_gsercx_lnx_drv_refclk_txeq_ctrl4_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_ctrl5
 *
 * GSERC Ln Drv Refclk Txeq Ctrl5 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_ctrl5
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t drv_swing             : 3;  /**< [  2:  0](R/W/H) TXDRV swing control.
                                                                 0 = min swing
                                                                 7 = 100% swing */
#else /* Word 0 - Little Endian */
        uint32_t drv_swing             : 3;  /**< [  2:  0](R/W/H) TXDRV swing control.
                                                                 0 = min swing
                                                                 7 = 100% swing */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_ctrl5_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_ctrl5 bdk_gsercx_lnx_drv_refclk_txeq_ctrl5_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) bdk_gsercx_lnx_drv_refclk_txeq_ctrl5_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status0
 *
 * GSERC Ln Drv Refclk Txeq Status0 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ack                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient acknowledge
                                                                 This register is set to 1 by PHY firmware once AFE updates are complete. Cleared when req = 0 */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](R/W/H) TXEQ coefficient acknowledge
                                                                 This register is set to 1 by PHY firmware once AFE updates are complete. Cleared when req = 0 */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_status0_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_status0 bdk_gsercx_lnx_drv_refclk_txeq_status0_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) bdk_gsercx_lnx_drv_refclk_txeq_status0_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status1
 *
 * GSERC Ln Drv Refclk Txeq Status1 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient status. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_c1               : 5;  /**< [  4:  0](R/W/H) TXEQ post-cursor tap C1 coefficient status. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_status1_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_status1 bdk_gsercx_lnx_drv_refclk_txeq_status1_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) bdk_gsercx_lnx_drv_refclk_txeq_status1_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status2
 *
 * GSERC Ln Drv Refclk Txeq Status2 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ post-cursor tap CM1 coefficient status. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_cm1              : 4;  /**< [  3:  0](R/W/H) TXEQ post-cursor tap CM1 coefficient status. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_status2_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_status2 bdk_gsercx_lnx_drv_refclk_txeq_status2_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d48ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) bdk_gsercx_lnx_drv_refclk_txeq_status2_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_drv_refclk_txeq_status3
 *
 * GSERC Ln Drv Refclk Txeq Status3 Register
 */
union bdk_gsercx_lnx_drv_refclk_txeq_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_drv_refclk_txeq_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t txeq_c0               : 3;  /**< [  2:  0](R/W/H) TXEQ main-cursor tap C0 coefficient status. */
#else /* Word 0 - Little Endian */
        uint32_t txeq_c0               : 3;  /**< [  2:  0](R/W/H) TXEQ main-cursor tap C0 coefficient status. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_drv_refclk_txeq_status3_s cn; */
};
typedef union bdk_gsercx_lnx_drv_refclk_txeq_status3 bdk_gsercx_lnx_drv_refclk_txeq_status3_t;

static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011d50ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) bdk_gsercx_lnx_drv_refclk_txeq_status3_t
#define bustype_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) "GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3"
#define device_bar_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_DRV_REFCLK_TXEQ_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_alert_pattern0_rsvd
 *
 * INTERNAL: GSERC Ln Eee Alert Pattern0 Register
 */
union bdk_gsercx_lnx_eee_alert_pattern0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_alert_pattern0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bits_7_0              : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_7_0              : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_alert_pattern0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_alert_pattern0_rsvd bdk_gsercx_lnx_eee_alert_pattern0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(a,b) bdk_gsercx_lnx_eee_alert_pattern0_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(a,b) "GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_ALERT_PATTERN0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_alert_pattern1_rsvd
 *
 * INTERNAL: GSERC Ln Eee Alert Pattern1 Register
 */
union bdk_gsercx_lnx_eee_alert_pattern1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_alert_pattern1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bits_15_8             : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_15_8             : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_alert_pattern1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_alert_pattern1_rsvd bdk_gsercx_lnx_eee_alert_pattern1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(a,b) bdk_gsercx_lnx_eee_alert_pattern1_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(a,b) "GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_ALERT_PATTERN1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Eee Ctrl Register
 */
union bdk_gsercx_lnx_eee_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t tx_alert_coeff        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tx_alert_coeff        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_ctrl_rsvd bdk_gsercx_lnx_eee_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_CTRL_RSVD(a,b) bdk_gsercx_lnx_eee_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_CTRL_RSVD(a,b) "GSERCX_LNX_EEE_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_ovr_rsvd
 *
 * INTERNAL: GSERC Ln Eee Ovr Register
 */
union bdk_gsercx_lnx_eee_ovr_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_ovr_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t ctrl_rx_eee_mode_val  : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t ctrl_rx_eee_mode_en   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_tx_eee_mode_val  : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ctrl_tx_eee_mode_en   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_tx_eee_mode_en   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ctrl_tx_eee_mode_val  : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ctrl_rx_eee_mode_en   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_rx_eee_mode_val  : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_ovr_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_ovr_rsvd bdk_gsercx_lnx_eee_ovr_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_OVR_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_OVR_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_OVR_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_OVR_RSVD(a,b) bdk_gsercx_lnx_eee_ovr_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_OVR_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_OVR_RSVD(a,b) "GSERCX_LNX_EEE_OVR_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_OVR_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_OVR_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_OVR_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_status0_rsvd
 *
 * INTERNAL: GSERC Ln Eee Status0 Register
 */
union bdk_gsercx_lnx_eee_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_rx_eee_mode      : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t ctrl_tx_eee_mode      : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_tx_eee_mode      : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t ctrl_rx_eee_mode      : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_status0_rsvd bdk_gsercx_lnx_eee_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_STATUS0_RSVD(a,b) bdk_gsercx_lnx_eee_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_STATUS0_RSVD(a,b) "GSERCX_LNX_EEE_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_status1_rsvd
 *
 * INTERNAL: GSERC Ln Eee Status1 Register
 */
union bdk_gsercx_lnx_eee_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sticky_eee_tx_quiet   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sticky_eee_tx_quiet   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_status1_rsvd bdk_gsercx_lnx_eee_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_STATUS1_RSVD(a,b) bdk_gsercx_lnx_eee_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_STATUS1_RSVD(a,b) "GSERCX_LNX_EEE_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_eee_status2_rsvd
 *
 * INTERNAL: GSERC Ln Eee Status2 Register
 */
union bdk_gsercx_lnx_eee_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_eee_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t sticky_eee_rx_quiet   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sticky_eee_rx_quiet   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_eee_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_eee_status2_rsvd bdk_gsercx_lnx_eee_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_EEE_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_EEE_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010e18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_EEE_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_EEE_STATUS2_RSVD(a,b) bdk_gsercx_lnx_eee_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_EEE_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_EEE_STATUS2_RSVD(a,b) "GSERCX_LNX_EEE_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_EEE_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_EEE_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_EEE_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cfg0
 *
 * GSERC Ln Feature Adapt Cfg0 Register
 */
union bdk_gsercx_lnx_feature_adapt_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ena_8b10b             : 1;  /**< [  0:  0](R/W/H) Enables modifications for 8b10b encoded signals in RX adaptations. */
#else /* Word 0 - Little Endian */
        uint32_t ena_8b10b             : 1;  /**< [  0:  0](R/W/H) Enables modifications for 8b10b encoded signals in RX adaptations. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cfg0 bdk_gsercx_lnx_feature_adapt_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013478ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) bdk_gsercx_lnx_feature_adapt_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) "GSERCX_LNX_FEATURE_ADAPT_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg0
 *
 * GSERC Ln Feature Adapt Cont Cfg0 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t stagger_taps          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables continuous background adaptation. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Enables continuous background adaptation. */
        uint32_t stagger_taps          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg0 bdk_gsercx_lnx_feature_adapt_cont_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013580ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg1
 *
 * GSERC Ln Feature Adapt Cont Cfg1 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg1
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval_7_0          : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
#else /* Word 0 - Little Endian */
        uint32_t interval_7_0          : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg1_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg1 bdk_gsercx_lnx_feature_adapt_cont_cfg1_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013588ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg1_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg2
 *
 * GSERC Ln Feature Adapt Cont Cfg2 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg2
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval_15_8         : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
#else /* Word 0 - Little Endian */
        uint32_t interval_15_8         : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg2_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg2 bdk_gsercx_lnx_feature_adapt_cont_cfg2_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013590ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg2_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg3
 *
 * GSERC Ln Feature Adapt Cont Cfg3 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg3
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval_23_16        : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
#else /* Word 0 - Little Endian */
        uint32_t interval_23_16        : 8;  /**< [  7:  0](R/W/H) How often in ms to run continuous adaptations 1ms to ~279 mins. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg3_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg3 bdk_gsercx_lnx_feature_adapt_cont_cfg3_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013598ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg3_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg4_rsvd
 *
 * INTERNAL: GSERC Ln Feature Adapt Cont Cfg4 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t hfg_threshold         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t hfg_threshold         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg4_rsvd bdk_gsercx_lnx_feature_adapt_cont_cfg4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80135a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg4_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg5_rsvd
 *
 * INTERNAL: GSERC Ln Feature Adapt Cont Cfg5 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dlev_threshold        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlev_threshold        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg5_rsvd bdk_gsercx_lnx_feature_adapt_cont_cfg5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80135a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg5_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg6_rsvd
 *
 * INTERNAL: GSERC Ln Feature Adapt Cont Cfg6 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap_threshold         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap_threshold         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg6_rsvd bdk_gsercx_lnx_feature_adapt_cont_cfg6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80135b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg6_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_adapt_cont_cfg7_rsvd
 *
 * INTERNAL: GSERC Ln Feature Adapt Cont Cfg7 Register
 */
union bdk_gsercx_lnx_feature_adapt_cont_cfg7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_adapt_cont_cfg7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap_avg_samples       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t tap_avg_samples       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_adapt_cont_cfg7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_adapt_cont_cfg7_rsvd bdk_gsercx_lnx_feature_adapt_cont_cfg7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80135b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(a,b) bdk_gsercx_lnx_feature_adapt_cont_cfg7_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(a,b) "GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_ADAPT_CONT_CFG7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_adapt_smpl_cfg
 *
 * GSERC Ln Feature Cdr Adapt Smpl Cfg Register
 */
union bdk_gsercx_lnx_feature_cdr_adapt_smpl_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_cdr_adapt_smpl_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cdr_smpl_start_val_sel : 1; /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cdr_smpl_cont_en      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t cdr_smpl_eie_en       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cdr_smpl_init_en      : 1;  /**< [  0:  0](R/W/H) Enables CDR sampling point initial adaptation. */
#else /* Word 0 - Little Endian */
        uint32_t cdr_smpl_init_en      : 1;  /**< [  0:  0](R/W/H) Enables CDR sampling point initial adaptation. */
        uint32_t cdr_smpl_eie_en       : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cdr_smpl_cont_en      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t cdr_smpl_start_val_sel : 1; /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_cdr_adapt_smpl_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_cdr_adapt_smpl_cfg bdk_gsercx_lnx_feature_cdr_adapt_smpl_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013550ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) bdk_gsercx_lnx_feature_cdr_adapt_smpl_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) "GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CDR_ADAPT_SMPL_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_cal_cfg0
 *
 * GSERC Ln Feature Cdr Cal Cfg0 Register
 */
union bdk_gsercx_lnx_feature_cdr_cal_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_cdr_cal_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cdr_iq_cal_result_sel : 2;  /**< [  6:  5](R/W/H) Selects which CDR I/Q Mismatch Calibration result to use:
                                                                 0x0 = Method 1
                                                                 0x1 = Method 2
                                                                 0x2 = Method 3
                                                                 0x3 = Reserved */
        uint32_t cdr_iq_cal3_en        : 1;  /**< [  4:  4](R/W/H) Enables CDR I/Q Mismatch Calibration Method 3. */
        uint32_t cdr_iq_cal2_en        : 1;  /**< [  3:  3](R/W/H) Enables CDR I/Q Mismatch Calibration Method 2. */
        uint32_t cdr_iq_cal1_en        : 1;  /**< [  2:  2](R/W/H) Enables CDR I/Q Mismatch Calibration Method 1. */
        uint32_t vco_freq_dosc_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vco_freq_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t vco_freq_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t vco_freq_dosc_en      : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t cdr_iq_cal1_en        : 1;  /**< [  2:  2](R/W/H) Enables CDR I/Q Mismatch Calibration Method 1. */
        uint32_t cdr_iq_cal2_en        : 1;  /**< [  3:  3](R/W/H) Enables CDR I/Q Mismatch Calibration Method 2. */
        uint32_t cdr_iq_cal3_en        : 1;  /**< [  4:  4](R/W/H) Enables CDR I/Q Mismatch Calibration Method 3. */
        uint32_t cdr_iq_cal_result_sel : 2;  /**< [  6:  5](R/W/H) Selects which CDR I/Q Mismatch Calibration result to use:
                                                                 0x0 = Method 1
                                                                 0x1 = Method 2
                                                                 0x2 = Method 3
                                                                 0x3 = Reserved */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_cdr_cal_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_cdr_cal_cfg0 bdk_gsercx_lnx_feature_cdr_cal_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013430ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CDR_CAL_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) bdk_gsercx_lnx_feature_cdr_cal_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) "GSERCX_LNX_FEATURE_CDR_CAL_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CDR_CAL_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_lock_check_cfg0
 *
 * GSERC Ln Feature Cdr Lock Check Cfg0 Register
 */
union bdk_gsercx_lnx_feature_cdr_lock_check_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_cdr_lock_check_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check after CDR lock is detected. */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check after CDR lock is detected. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_cdr_lock_check_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_cdr_lock_check_cfg0 bdk_gsercx_lnx_feature_cdr_lock_check_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013458ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) bdk_gsercx_lnx_feature_cdr_lock_check_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) "GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CDR_LOCK_CHECK_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_lockd_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Cdr Lockd Cfg0 Register
 */
union bdk_gsercx_lnx_feature_cdr_lockd_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_cdr_lockd_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t timeout_us            : 7;  /**< [  7:  1](R/W/H) Reserved. */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t timeout_us            : 7;  /**< [  7:  1](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_cdr_lockd_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_cdr_lockd_cfg0_rsvd bdk_gsercx_lnx_feature_cdr_lockd_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013448ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_cdr_lockd_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_cdr_lockd_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Feature Cdr Lockd Cfg1 Register
 */
union bdk_gsercx_lnx_feature_cdr_lockd_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_cdr_lockd_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_time_us          : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_time_us          : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_cdr_lockd_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_cdr_lockd_cfg1_rsvd bdk_gsercx_lnx_feature_cdr_lockd_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013450ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(a,b) bdk_gsercx_lnx_feature_cdr_lockd_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(a,b) "GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CDR_LOCKD_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_apg_cfg
 *
 * GSERC Ln Feature Ctle Adapt Apg Cfg Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_apg_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_apg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ APG adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ APG adaptation enable. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_apg_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_apg_cfg bdk_gsercx_lnx_feature_ctle_adapt_apg_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013498ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) bdk_gsercx_lnx_feature_ctle_adapt_apg_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_APG_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_cfg_rsvd
 *
 * INTERNAL: GSERC Ln Feature Ctle Adapt Cfg Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_cfg_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_cfg_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t repeat_count_eie1     : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t repeat_count_eie0     : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t repeat_count_init1    : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t repeat_count_init0    : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t repeat_count_init0    : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t repeat_count_init1    : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t repeat_count_eie0     : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t repeat_count_eie1     : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_cfg_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_cfg_rsvd bdk_gsercx_lnx_feature_ctle_adapt_cfg_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013480ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(a,b) bdk_gsercx_lnx_feature_ctle_adapt_cfg_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_CFG_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_eie0_cfg_rsvd
 *
 * INTERNAL: GSERC Ln Feature Ctle Adapt Eie0 Cfg Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_eie0_cfg_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_eie0_cfg_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t mbs_start_val_sel     : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t hfg_start_val_sel     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t gn_apg_start_val_sel  : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eq_lfg_start_val_sel  : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ple_att_start_val_sel : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_start_val_sel : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t eq_lfg_start_val_sel  : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t gn_apg_start_val_sel  : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t hfg_start_val_sel     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t mbs_start_val_sel     : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_eie0_cfg_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_eie0_cfg_rsvd bdk_gsercx_lnx_feature_ctle_adapt_eie0_cfg_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(a,b) bdk_gsercx_lnx_feature_ctle_adapt_eie0_cfg_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_EIE0_CFG_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_hfg_cfg0
 *
 * GSERC Ln Feature Ctle Adapt Hfg Cfg0 Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cont_en               : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable edge-based algorithm. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable edge-based algorithm. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cont_en               : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg0 bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_hfg_cfg1
 *
 * GSERC Ln Feature Ctle Adapt Hfg Cfg1 Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg1
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable data-based algorithm. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ HFG adaptation enable data-based algorithm. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg1 bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg1_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_hfg_cfg2
 *
 * GSERC Ln Feature Ctle Adapt Hfg Cfg2 Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg2
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) LEQ HFG adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
#else /* Word 0 - Little Endian */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) LEQ HFG adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg2 bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) bdk_gsercx_lnx_feature_ctle_adapt_hfg_cfg2_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_HFG_CFG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_lfg_cfg
 *
 * GSERC Ln Feature Ctle Adapt Lfg Cfg Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_lfg_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_lfg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ LFG equalization adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) LEQ LFG equalization adaptation enable. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_lfg_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_lfg_cfg bdk_gsercx_lnx_feature_ctle_adapt_lfg_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013490ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) bdk_gsercx_lnx_feature_ctle_adapt_lfg_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_LFG_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_mbs_cfg0
 *
 * GSERC Ln Feature Ctle Adapt Mbs Cfg0 Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable edge-based. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable edge-based. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg0 bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_mbs_cfg1
 *
 * GSERC Ln Feature Ctle Adapt Mbs Cfg1 Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg1
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable data-based. */
#else /* Word 0 - Little Endian */
        uint32_t init0_en              : 1;  /**< [  0:  0](R/W/H) Mid-Band Shaping MBS adaptation enable data-based. */
        uint32_t init1_en              : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eie0_en               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eie1_en               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg1 bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg1_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_mbs_cfg2
 *
 * GSERC Ln Feature Ctle Adapt Mbs Cfg2 Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg2
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) Mid-Band Shaping MBS adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
#else /* Word 0 - Little Endian */
        uint32_t init0_result_sel      : 2;  /**< [  1:  0](R/W/H) Mid-Band Shaping MBS adaptation algorithm selection
                                                                 0x0 = Maximize eye width edge based adaptation
                                                                 0x1 = Maximize eye height data based adaptation
                                                                 0x2 = Average of Edge & Data result
                                                                 0x3 = Reserved */
        uint32_t init1_result_sel      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t eie0_result_sel       : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eie1_result_sel       : 2;  /**< [  7:  6](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg2 bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80134c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) bdk_gsercx_lnx_feature_ctle_adapt_mbs_cfg2_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_MBS_CFG2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_ctle_adapt_ple_cfg
 *
 * GSERC Ln Feature Ctle Adapt Ple Cfg Register
 */
union bdk_gsercx_lnx_feature_ctle_adapt_ple_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_ctle_adapt_ple_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t eie_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t init_en               : 1;  /**< [  0:  0](R/W/H) Enables PLE_ATT adaptation for initial adaptation. */
#else /* Word 0 - Little Endian */
        uint32_t init_en               : 1;  /**< [  0:  0](R/W/H) Enables PLE_ATT adaptation for initial adaptation. */
        uint32_t eie_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_ctle_adapt_ple_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_ctle_adapt_ple_cfg bdk_gsercx_lnx_feature_ctle_adapt_ple_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013488ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) bdk_gsercx_lnx_feature_ctle_adapt_ple_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) "GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_CTLE_ADAPT_PLE_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_cfg
 *
 * GSERC Ln Feature Dfe Adapt Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t method_sel            : 1;  /**< [  0:  0](R/W/H) DFE tap adaptation algorithm selection:
                                                                 0x0 = SS-LMS
                                                                 0x1 = Pattern Based Zero Forcing */
#else /* Word 0 - Little Endian */
        uint32_t method_sel            : 1;  /**< [  0:  0](R/W/H) DFE tap adaptation algorithm selection:
                                                                 0x0 = SS-LMS
                                                                 0x1 = Pattern Based Zero Forcing */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_cfg bdk_gsercx_lnx_feature_dfe_adapt_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013508ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap1_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap1 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap1_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap1_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap1_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap1_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap1_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap1_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap1 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap1 adaptation enable. */
        uint32_t tap1_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap1_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap1_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap1_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap1_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap1_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013510ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap1_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP1_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap2_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap2 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap2_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap2_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap2_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap2_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap2_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap2_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap2 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap2_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap2 adaptation enable. */
        uint32_t tap2_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap2_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap2_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap2_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap2_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap2_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013518ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap2_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP2_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap3_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap3 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap3_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap3_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap3_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap3_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap3_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap3_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap3 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap3_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap3 adaptation enable. */
        uint32_t tap3_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap3_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap3_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap3_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap3_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap3_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013520ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap3_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP3_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap4_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap4 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap4_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap4_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap4_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap4_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap4_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap4_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap4 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap4_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap4 adaptation enable. */
        uint32_t tap4_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap4_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap4_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap4_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap4_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap4_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013528ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap4_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP4_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap5_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap5 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap5_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap5_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap5_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap5_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap5_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap5_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap5 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap5_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap5 adaptation enable. */
        uint32_t tap5_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap5_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap5_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap5_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap5_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap5_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013530ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap5_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP5_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap6_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap6 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap6_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap6_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap6_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap6_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap6_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap6_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap6 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap6_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap6 adaptation enable. */
        uint32_t tap6_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap6_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap6_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap6_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap6_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap6_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013538ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap6_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP6_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap7_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap7 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap7_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap7_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap7_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap7_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap7_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap7_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap7 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap7_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap7 adaptation enable. */
        uint32_t tap7_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap7_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap7_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap7_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap7_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap7_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013540ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap7_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP7_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_adapt_tap8_cfg
 *
 * GSERC Ln Feature Dfe Adapt Tap8 Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_adapt_tap8_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_adapt_tap8_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tap8_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tap8_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap8_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap8_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap8 adaptation enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap8_init_en          : 1;  /**< [  0:  0](R/W/H) DFE tap8 adaptation enable. */
        uint32_t tap8_eie_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tap8_cont_en          : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tap8_start_val_sel    : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_adapt_tap8_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_adapt_tap8_cfg bdk_gsercx_lnx_feature_dfe_adapt_tap8_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013548ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) bdk_gsercx_lnx_feature_dfe_adapt_tap8_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_ADAPT_TAP8_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_cfg
 *
 * GSERC Ln Feature Dfe Cfg Register
 */
union bdk_gsercx_lnx_feature_dfe_cfg
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tap8_en               : 1;  /**< [  7:  7](R/W/H) DFE Tap 8 enable. */
        uint32_t tap7_en               : 1;  /**< [  6:  6](R/W/H) DFE Tap 7 enable. */
        uint32_t tap6_en               : 1;  /**< [  5:  5](R/W/H) DFE Tap 6 enable. */
        uint32_t tap5_en               : 1;  /**< [  4:  4](R/W/H) DFE Tap 5 enable. */
        uint32_t tap4_en               : 1;  /**< [  3:  3](R/W/H) DFE Tap 4 enable. */
        uint32_t tap3_en               : 1;  /**< [  2:  2](R/W/H) DFE Tap 3 enable. */
        uint32_t tap2_en               : 1;  /**< [  1:  1](R/W/H) DFE Tap 2 enable. */
        uint32_t tap1_en               : 1;  /**< [  0:  0](R/W/H) DFE Tap 1 enable. */
#else /* Word 0 - Little Endian */
        uint32_t tap1_en               : 1;  /**< [  0:  0](R/W/H) DFE Tap 1 enable. */
        uint32_t tap2_en               : 1;  /**< [  1:  1](R/W/H) DFE Tap 2 enable. */
        uint32_t tap3_en               : 1;  /**< [  2:  2](R/W/H) DFE Tap 3 enable. */
        uint32_t tap4_en               : 1;  /**< [  3:  3](R/W/H) DFE Tap 4 enable. */
        uint32_t tap5_en               : 1;  /**< [  4:  4](R/W/H) DFE Tap 5 enable. */
        uint32_t tap6_en               : 1;  /**< [  5:  5](R/W/H) DFE Tap 6 enable. */
        uint32_t tap7_en               : 1;  /**< [  6:  6](R/W/H) DFE Tap 7 enable. */
        uint32_t tap8_en               : 1;  /**< [  7:  7](R/W/H) DFE Tap 8 enable. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_cfg_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_cfg bdk_gsercx_lnx_feature_dfe_cfg_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_CFG(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_CFG(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013500ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_CFG", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_CFG(a,b) bdk_gsercx_lnx_feature_dfe_cfg_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_CFG(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_CFG(a,b) "GSERCX_LNX_FEATURE_DFE_CFG"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_CFG(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_CFG(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_CFG(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_offset_cal_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Dfe Offset Cal Cfg0 Register
 */
union bdk_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t vscan_en              : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t summeven_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t summodd_en            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t summodd_en            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t summeven_en           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t vscan_en              : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd bdk_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013418ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_dfe_offset_cal_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_dfe_offset_cal_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Feature Dfe Offset Cal Cfg1 Register
 */
union bdk_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eyeslicer_en          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t edgeslicerodd_en      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t edgeslicereven_en     : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t dataslicerodd0_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t dataslicerodd1_en     : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t dataslicereven0_en    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t dataslicereven1_en    : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dataslicereven1_en    : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t dataslicereven0_en    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t dataslicerodd1_en     : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t dataslicerodd0_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t edgeslicereven_en     : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t edgeslicerodd_en      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t eyeslicer_en          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd bdk_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013428ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) bdk_gsercx_lnx_feature_dfe_offset_cal_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) "GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_DFE_OFFSET_CAL_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_cfg_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Cfg Register
 */
union bdk_gsercx_lnx_feature_eye_cfg_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_cfg_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t leave_on              : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leave_on              : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_cfg_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_cfg_rsvd bdk_gsercx_lnx_feature_eye_cfg_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013640ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_CFG_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(a,b) bdk_gsercx_lnx_feature_eye_cfg_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_CFG_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_CFG_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg0 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sig_det_threshold     : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sig_det_threshold     : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg0_rsvd bdk_gsercx_lnx_feature_eye_los_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013600ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg1 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t los_det_threshold     : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t los_det_threshold     : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg1_rsvd bdk_gsercx_lnx_feature_eye_los_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013608ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg2_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg2 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sample_len_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sample_len_7_0        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg2_rsvd bdk_gsercx_lnx_feature_eye_los_cfg2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013610ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg2_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg3_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg3 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t sample_len_11_8       : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sample_len_11_8       : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg3_rsvd bdk_gsercx_lnx_feature_eye_los_cfg3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013618ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg3_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg4_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg4 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_lfg                : 5;  /**< [  7:  3](R/W/H) Reserved. */
        uint32_t ple_att               : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att               : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t eq_lfg                : 5;  /**< [  7:  3](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg4_rsvd bdk_gsercx_lnx_feature_eye_los_cfg4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013620ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg4_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg5_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg5 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t hfg_sql               : 5;  /**< [  6:  2](R/W/H) Reserved. */
        uint32_t gn_apg                : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg                : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t hfg_sql               : 5;  /**< [  6:  2](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg5_rsvd bdk_gsercx_lnx_feature_eye_los_cfg5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013628ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg5_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_eye_los_cfg6_rsvd
 *
 * INTERNAL: GSERC Ln Feature Eye Los Cfg6 Register
 */
union bdk_gsercx_lnx_feature_eye_los_cfg6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_eye_los_cfg6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mbg                   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t mbf                   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mbf                   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t mbg                   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_eye_los_cfg6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_eye_los_cfg6_rsvd bdk_gsercx_lnx_feature_eye_los_cfg6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013630ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(a,b) bdk_gsercx_lnx_feature_eye_los_cfg6_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(a,b) "GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_EYE_LOS_CFG6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_lane_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Lane Cfg0 Register
 */
union bdk_gsercx_lnx_feature_lane_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_lane_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t bit_stuff_strip_dis   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bit_stuff_strip_dis   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_lane_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_lane_cfg0_rsvd bdk_gsercx_lnx_feature_lane_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013658ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_LANE_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_lane_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_LANE_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_LANE_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_leq_offset_cal_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Leq Offset Cal Cfg0 Register
 */
union bdk_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t gn_en                 : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t eq4_en                : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t eq3_en                : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eq2_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq1_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq1_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t eq2_en                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq3_en                : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t eq4_en                : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t gn_en                 : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd bdk_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_leq_offset_cal_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_LEQ_OFFSET_CAL_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_periodic_check_cfg0
 *
 * GSERC Ln Feature Periodic Check Cfg0 Register
 */
union bdk_gsercx_lnx_feature_periodic_check_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_periodic_check_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during periodic restart check while in LOCKED state. */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during periodic restart check while in LOCKED state. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_periodic_check_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_periodic_check_cfg0 bdk_gsercx_lnx_feature_periodic_check_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013468ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) bdk_gsercx_lnx_feature_periodic_check_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) "GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_periodic_check_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Feature Periodic Check Cfg1 Register
 */
union bdk_gsercx_lnx_feature_periodic_check_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_periodic_check_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t interval              : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t interval              : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_periodic_check_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_periodic_check_cfg1_rsvd bdk_gsercx_lnx_feature_periodic_check_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013470ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(a,b) bdk_gsercx_lnx_feature_periodic_check_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(a,b) "GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_PERIODIC_CHECK_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_pre_locked_check_cfg0
 *
 * GSERC Ln Feature Pre Locked Check Cfg0 Register
 */
union bdk_gsercx_lnx_feature_pre_locked_check_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_pre_locked_check_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check before entering LOCKED state. */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t freq_measure_en       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t los_en                : 1;  /**< [  1:  1](R/W/H) Enables Eye Monitor LOS detection during restart check before entering LOCKED state. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_pre_locked_check_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_pre_locked_check_cfg0 bdk_gsercx_lnx_feature_pre_locked_check_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013460ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) bdk_gsercx_lnx_feature_pre_locked_check_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) "GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_PRE_LOCKED_CHECK_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_rext_cal_result_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Rext Cal Result Cfg0 Register
 */
union bdk_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxdfe_cmlr_en         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdfe_cmli_en         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxleq_biasi_trim_en   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rxterm_val_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxterm_val_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxleq_biasi_trim_en   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rxdfe_cmli_en         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rxdfe_cmlr_en         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd bdk_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_rext_cal_result_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_REXT_CAL_RESULT_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_rxterm_cfg0
 *
 * GSERC Ln Feature Rxterm Cfg0 Register
 */
union bdk_gsercx_lnx_feature_rxterm_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_rxterm_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ac_coupled            : 1;  /**< [  0:  0](R/W/H) Configures AC/DC coupling of the lane
                                                                 0 = DC coupled internal RX termination common-mode voltage floating
                                                                 1 = AC coupled internal RX termination common-mode voltage shorted to vssa */
#else /* Word 0 - Little Endian */
        uint32_t ac_coupled            : 1;  /**< [  0:  0](R/W/H) Configures AC/DC coupling of the lane
                                                                 0 = DC coupled internal RX termination common-mode voltage floating
                                                                 1 = AC coupled internal RX termination common-mode voltage shorted to vssa */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_rxterm_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_rxterm_cfg0 bdk_gsercx_lnx_feature_rxterm_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_RXTERM_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) bdk_gsercx_lnx_feature_rxterm_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) "GSERCX_LNX_FEATURE_RXTERM_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_RXTERM_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_sig_det_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Sig Det Cfg0 Register
 */
union bdk_gsercx_lnx_feature_sig_det_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_sig_det_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t sig_det_mode          : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t sig_det_mode          : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_sig_det_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_sig_det_cfg0_rsvd bdk_gsercx_lnx_feature_sig_det_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013440ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_sig_det_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SIG_DET_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg0 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg0_rsvd bdk_gsercx_lnx_feature_spare_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013680ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg1 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg1_rsvd bdk_gsercx_lnx_feature_spare_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013688ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg2_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg2 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg2_rsvd bdk_gsercx_lnx_feature_spare_cfg2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013690ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg2_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg3_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg3 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg3_rsvd bdk_gsercx_lnx_feature_spare_cfg3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013698ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg3_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg4_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg4 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg4_rsvd bdk_gsercx_lnx_feature_spare_cfg4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80136a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg4_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg5_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg5 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg5_rsvd bdk_gsercx_lnx_feature_spare_cfg5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80136a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg5_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg6_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg6 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg6_rsvd bdk_gsercx_lnx_feature_spare_cfg6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80136b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg6_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_spare_cfg7_rsvd
 *
 * INTERNAL: GSERC Ln Feature Spare Cfg7 Register
 */
union bdk_gsercx_lnx_feature_spare_cfg7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_spare_cfg7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_spare_cfg7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_spare_cfg7_rsvd bdk_gsercx_lnx_feature_spare_cfg7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80136b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(a,b) bdk_gsercx_lnx_feature_spare_cfg7_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(a,b) "GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_SPARE_CFG7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_test_cfg0
 *
 * GSERC Ln Feature Test Cfg0 Register
 */
union bdk_gsercx_lnx_feature_test_cfg0
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_test_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t lt_txdrv_dis          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t tx_coeff_sweep_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t cdr_decimation_dis    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t rx_ctrl_dis           : 1;  /**< [  1:  1](R/W/H) Disables the firmware rx_ctrl MSM. */
        uint32_t lane_msm_dis          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t lane_msm_dis          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rx_ctrl_dis           : 1;  /**< [  1:  1](R/W/H) Disables the firmware rx_ctrl MSM. */
        uint32_t cdr_decimation_dis    : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tx_coeff_sweep_en     : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t lt_txdrv_dis          : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_test_cfg0_s cn; */
};
typedef union bdk_gsercx_lnx_feature_test_cfg0 bdk_gsercx_lnx_feature_test_cfg0_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_TEST_CFG0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_TEST_CFG0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013648ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_TEST_CFG0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) bdk_gsercx_lnx_feature_test_cfg0_t
#define bustype_BDK_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) "GSERCX_LNX_FEATURE_TEST_CFG0"
#define device_bar_BDK_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_TEST_CFG0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_feature_tx_cal_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Feature Tx Cal Cfg0 Register
 */
union bdk_gsercx_lnx_feature_tx_cal_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_feature_tx_cal_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txdp_clock_phase_en   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t tx_dcd2_en            : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t tx_dcd1_en            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t tx_dcd1_en            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t tx_dcd2_en            : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txdp_clock_phase_en   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_feature_tx_cal_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_feature_tx_cal_cfg0_rsvd bdk_gsercx_lnx_feature_tx_cal_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013438ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) bdk_gsercx_lnx_feature_tx_cal_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) "GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_FEATURE_TX_CAL_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_avg_up_cnt_status0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Avg Up Cnt Status0 Register
 */
union bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status0_rsvd bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012890ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a,b) "GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_avg_up_cnt_status1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Avg Up Cnt Status1 Register
 */
union bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t bit_8                 : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bit_8                 : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status1_rsvd bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012898ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_avg_up_cnt_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a,b) "GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_AVG_UP_CNT_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_cmd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Cmd Ctrl0 Register
 */
union bdk_gsercx_lnx_gcfsm2_cmd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_cmd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_cmd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_cmd_ctrl0_rsvd bdk_gsercx_lnx_gcfsm2_cmd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012800ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_cmd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(a,b) "GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_cmd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Cmd Ctrl1 Register
 */
union bdk_gsercx_lnx_gcfsm2_cmd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_cmd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cmd                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cmd                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_cmd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_cmd_ctrl1_rsvd bdk_gsercx_lnx_gcfsm2_cmd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012808ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_cmd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(a,b) "GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_cmd_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Cmd Ctrl2 Register
 */
union bdk_gsercx_lnx_gcfsm2_cmd_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_cmd_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t addr                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_cmd_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_cmd_ctrl2_rsvd bdk_gsercx_lnx_gcfsm2_cmd_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012810ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_cmd_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(a,b) "GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_CMD_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_cmd_status_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Cmd Status Register
 */
union bdk_gsercx_lnx_gcfsm2_cmd_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_cmd_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t code                  : 4;  /**< [  4:  1](RO/H) Reserved. */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t code                  : 4;  /**< [  4:  1](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_cmd_status_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_cmd_status_rsvd bdk_gsercx_lnx_gcfsm2_cmd_status_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012818ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_cmd_status_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(a,b) "GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_CMD_STATUS_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl0 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t width                 : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t type_val              : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t type_val              : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t width                 : 4;  /**< [  5:  2](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl0_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012900ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl1 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t start_7_0             : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t start_7_0             : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl1_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012908ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl2 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t start_11_8            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t start_11_8            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl2_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012910ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl3 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t min_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t min_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl3_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012918ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl4 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t min_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t min_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl4_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012920ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl5 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t max_7_0               : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl5_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012928ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_data_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Data Ctrl6 Register
 */
union bdk_gsercx_lnx_gcfsm2_data_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_data_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t max_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t max_11_8              : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_data_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_data_ctrl6_rsvd bdk_gsercx_lnx_gcfsm2_data_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012930ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_data_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(a,b) "GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_DATA_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_feedback_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Feedback Ctrl0 Register
 */
union bdk_gsercx_lnx_gcfsm2_feedback_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_feedback_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t len_wait_afe_up       : 4;  /**< [  4:  1](R/W/H) Reserved. */
        uint32_t invert_afe_up         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t invert_afe_up         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t len_wait_afe_up       : 4;  /**< [  4:  1](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_feedback_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_feedback_ctrl0_rsvd bdk_gsercx_lnx_gcfsm2_feedback_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_feedback_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(a,b) "GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_feedback_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Feedback Ctrl1 Register
 */
union bdk_gsercx_lnx_gcfsm2_feedback_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_feedback_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_avg_afe_up        : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_avg_afe_up        : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_feedback_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_feedback_ctrl1_rsvd bdk_gsercx_lnx_gcfsm2_feedback_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_feedback_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(a,b) "GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_FEEDBACK_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_param_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Param Ctrl0 Register
 */
union bdk_gsercx_lnx_gcfsm2_param_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_param_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t step_size             : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t step_size             : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_param_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_param_ctrl0_rsvd bdk_gsercx_lnx_gcfsm2_param_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012980ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_param_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(a,b) "GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_param_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Param Ctrl1 Register
 */
union bdk_gsercx_lnx_gcfsm2_param_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_param_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t coarse_bounce_num     : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t bounce_num            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bounce_num            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t coarse_bounce_num     : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_param_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_param_ctrl1_rsvd bdk_gsercx_lnx_gcfsm2_param_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012988ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_param_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(a,b) "GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_param_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Param Ctrl2 Register
 */
union bdk_gsercx_lnx_gcfsm2_param_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_param_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t settle_on_lowest_avg_en : 1;/**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t settle_on_lowest_avg_en : 1;/**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_param_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_param_ctrl2_rsvd bdk_gsercx_lnx_gcfsm2_param_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012990ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_param_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(a,b) "GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_PARAM_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_read_shadow_data_status0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Read Shadow Data Status0 Register
 */
union bdk_gsercx_lnx_gcfsm2_read_shadow_data_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_read_shadow_data_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_7_0              : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_read_shadow_data_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_read_shadow_data_status0_rsvd bdk_gsercx_lnx_gcfsm2_read_shadow_data_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012880ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_read_shadow_data_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a,b) "GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_read_shadow_data_status1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Read Shadow Data Status1 Register
 */
union bdk_gsercx_lnx_gcfsm2_read_shadow_data_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_read_shadow_data_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t bits_11_8             : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bits_11_8             : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_read_shadow_data_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_read_shadow_data_status1_rsvd bdk_gsercx_lnx_gcfsm2_read_shadow_data_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012888ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_read_shadow_data_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a,b) "GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_READ_SHADOW_DATA_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl0 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t len_delay_afe_en      : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_delay_afe_en      : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl0_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl1 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_1st_latch_settle_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_1st_latch_settle_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl1_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl2 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_1st_latch_settle_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_1st_latch_settle_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl2_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl3 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_latch_settle  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_latch_settle  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl3_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl4 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_cmp_7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_cmp_7_0       : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl4_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl5 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_afe_cmp_15_8      : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_afe_cmp_15_8      : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl5_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl6 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_coarse_bounce_afe_cmp_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_coarse_bounce_afe_cmp_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl6_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl7_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl7 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t len_coarse_bounce_afe_cmp_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t len_coarse_bounce_afe_cmp_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl7_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_gcfsm2_wait_ctrl8_rsvd
 *
 * INTERNAL: GSERC Ln Gcfsm2 Wait Ctrl8 Register
 */
union bdk_gsercx_lnx_gcfsm2_wait_ctrl8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_gcfsm2_wait_ctrl8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t wait_mode             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t wait_mode             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_gcfsm2_wait_ctrl8_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_gcfsm2_wait_ctrl8_rsvd bdk_gsercx_lnx_gcfsm2_wait_ctrl8_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8012a40ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(a,b) bdk_gsercx_lnx_gcfsm2_wait_ctrl8_rsvd_t
#define bustype_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(a,b) "GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD"
#define device_bar_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_GCFSM2_WAIT_CTRL8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_adapt_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Adapt Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_adapt_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_adapt_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t hw_lfg                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t hw_gn_apg             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t hw_gn_apg             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t hw_lfg                : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_adapt_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_adapt_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_adapt_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011700ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_adapt_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_ADAPT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_bias_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Bias Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_bias_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_bias_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxleq_biasi_trim      : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_biasi_trim      : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_bias_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_bias_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_bias_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011018ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_bias_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_BIAS_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_eq_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Eq Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxleq_eq_sql_dir      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_eq_sql_dir      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011038ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_eq_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Eq Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rxleq_eq_loadres      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_eq_loadres      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl1_rsvd bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011040ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_eq_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Eq Ctrl2 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rxleq_eq_biasres      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_eq_biasres      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl2_rsvd bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011048ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_eq_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_EQ_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_gn_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Gn Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rxleq_gn_loadres      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_gn_loadres      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011050ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_gn_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Gn Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxleq_gn_biasi        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_gn_biasi        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl1_rsvd bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011058ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_gn_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_GN_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_i_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe I Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_i_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_i_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxleq_icontrol        : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_icontrol        : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_i_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_i_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_i_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011078ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_i_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_I_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_misc_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Misc Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_misc_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_misc_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxleq_spare           : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_spare           : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_misc_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_misc_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_misc_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011060ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_misc_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_MISC_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_negc_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Negc Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_negc_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_negc_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxleq_negc_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_negc_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_negc_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_negc_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_negc_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011070ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_negc_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_NEGC_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_pd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Pd Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_pd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_pd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t pd_rxleq_biasgen      : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t pd_rxleq              : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_rxleq              : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t pd_rxleq_biasgen      : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_pd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_pd_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_pd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_pd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_afe_ple_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Afe Ple Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_afe_ple_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_afe_ple_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxleq_ple_prech       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxleq_ple_blw_zero    : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t rxleq_ple_mute        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxleq_ple_mute        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxleq_ple_blw_zero    : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t rxleq_ple_prech       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_afe_ple_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_afe_ple_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_afe_ple_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011028ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_afe_ple_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_AFE_PLE_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl0
 *
 * GSERC Ln Leq Refclk Eq Hfg Sql Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_hfg_sql_start      : 5;  /**< [  4:  0](R/W/H) LEQ High-Frequency Gain HFG Start Value.
                                                                 If HFG adaptation is not enabled then this register can be used to manually adjust HFG value. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_start      : 5;  /**< [  4:  0](R/W/H) LEQ High-Frequency Gain HFG Start Value.
                                                                 If HFG adaptation is not enabled then this register can be used to manually adjust HFG value. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0 bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011200ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Hfg Sql Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_hfg_sql_value_max  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_value_max  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl1_rsvd bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011208ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Hfg Sql Ctrl2 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_hfg_sql_value_min  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_value_min  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl2_rsvd bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011210ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Hfg Sql Ctrl3 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_hfg_sql_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t eq_hfg_sql_wrwait_time : 4; /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_wrwait_time : 4; /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t eq_hfg_sql_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl3_rsvd bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011218ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Hfg Sql Ctrl4 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_hfg_sql_step_size  : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_error_sign : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_step_by1   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_step_by1   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_error_sign : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_step_size  : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl4_rsvd bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011220ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Hfg Sql Ctrl5 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eq_hfg_sql_lastwr_floor : 1;/**< [  6:  6](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_lastwr_avg : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_bounce_limit : 4;/**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_bounce_limit : 4;/**< [  3:  0](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_lastwr_avg : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eq_hfg_sql_lastwr_floor : 1;/**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl5_rsvd bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_hfg_sql_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Hfg Sql Ctrl6 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_hfg_sql_lastwr_adjust : 5;/**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_hfg_sql_lastwr_adjust : 5;/**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl6_rsvd bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_hfg_sql_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_HFG_SQL_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl0
 *
 * GSERC Ln Leq Refclk Eq Lfg Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_start          : 5;  /**< [  4:  0](R/W/H) LEQ Low-Frequency Gain LFG Start Value.
                                                                 If LFG adaptation is not enabled then this register can be used to manually adjust LFG value. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_start          : 5;  /**< [  4:  0](R/W/H) LEQ Low-Frequency Gain LFG Start Value.
                                                                 If LFG adaptation is not enabled then this register can be used to manually adjust LFG value. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl0 bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011400ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl1
 *
 * GSERC Ln Leq Refclk Eq Lfg Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_value_max      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Maximum Value, inclusive. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_value_max      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Maximum Value, inclusive. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl1 bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011408ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl2
 *
 * GSERC Ln Leq Refclk Eq Lfg Ctrl2 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_value_min      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Minimum Value, inclusive. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_value_min      : 5;  /**< [  4:  0](R/W/H) LEQ LFG Minimum Value, inclusive. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl2 bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011410ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl2_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Lfg Ctrl3 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_lfg_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t eq_lfg_wrwait_time    : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_wrwait_time    : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t eq_lfg_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl3_rsvd bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011418ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Lfg Ctrl4 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_step_size      : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t eq_lfg_error_sign     : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq_lfg_step_by1       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_step_by1       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t eq_lfg_error_sign     : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t eq_lfg_step_size      : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl4_rsvd bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011420ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Lfg Ctrl5 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eq_lfg_lastwr_floor   : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t eq_lfg_lastwr_avg     : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eq_lfg_bounce_limit   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_bounce_limit   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t eq_lfg_lastwr_avg     : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t eq_lfg_lastwr_floor   : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl5_rsvd bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011428ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Lfg Ctrl6 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_lfg_lastwr_adjust  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_lastwr_adjust  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl6_rsvd bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011430ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl7_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Lfg Ctrl7 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t apg                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t apg                   : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl7_rsvd bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011438ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_lfg_ctrl8_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Lfg Ctrl8 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_lfg_num_samples    : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_num_samples    : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl8_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl8_rsvd bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl8_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011440ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_lfg_ctrl8_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_LFG_CTRL8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_mb_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Mb Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t eq_mb_step_by1        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t eq_mb_wrwait_time     : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_mb_wrwait_time     : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t eq_mb_step_by1        : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_mb_ctrl1
 *
 * GSERC Ln Leq Refclk Eq Mb Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_mbg_start          : 4;  /**< [  7:  4](R/W/H) LEQ Mid-Band Gain MBG Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBG value. */
        uint32_t eq_mbf_start          : 4;  /**< [  3:  0](R/W/H) EQ MBF Start Value
                                                                 LEQ Mid-Band Frequency MBF Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBF value. */
#else /* Word 0 - Little Endian */
        uint32_t eq_mbf_start          : 4;  /**< [  3:  0](R/W/H) EQ MBF Start Value
                                                                 LEQ Mid-Band Frequency MBF Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBF value. */
        uint32_t eq_mbg_start          : 4;  /**< [  7:  4](R/W/H) LEQ Mid-Band Gain MBG Start Value.
                                                                 If mid-band shaping adaptation is not enabled then this register can be used to
                                                                 manually adjust MBG value. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl1 bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) bdk_gsercx_lnx_leq_refclk_eq_mb_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_MB_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_eq_sql_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Eq Sql Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_eq_sql_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_eq_sql_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t eq_sql_map_option     : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_sql_map_option     : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_eq_sql_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_eq_sql_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_eq_sql_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011280ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_eq_sql_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_EQ_SQL_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl0
 *
 * GSERC Ln Leq Refclk Gn Apg Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t gn_apg_start          : 3;  /**< [  2:  0](R/W/H) LEQ All-Pass Gain APG Start Value.
                                                                 If APG adaptation is not enabled then this register can be used to manually adjust APG value. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_start          : 3;  /**< [  2:  0](R/W/H) LEQ All-Pass Gain APG Start Value.
                                                                 If APG adaptation is not enabled then this register can be used to manually adjust APG value. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl0 bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011380ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Gn Apg Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t gn_apg_value_min      : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t gn_apg_value_max      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_value_max      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t gn_apg_value_min      : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl1_rsvd bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011388ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Gn Apg Ctrl2 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t gn_apg_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t gn_apg_wrwait_time    : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_wrwait_time    : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t gn_apg_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl2_rsvd bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011390ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Gn Apg Ctrl3 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t gn_apg_step_size      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t gn_apg_error_sign     : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t gn_apg_step_by1       : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_step_by1       : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t gn_apg_error_sign     : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t gn_apg_step_size      : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl3_rsvd bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011398ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Gn Apg Ctrl4 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t gn_apg_lastwr_floor   : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t gn_apg_lastwr_avg     : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t gn_apg_bounce_limit   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_bounce_limit   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t gn_apg_lastwr_avg     : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t gn_apg_lastwr_floor   : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl4_rsvd bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80113a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Gn Apg Ctrl5 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t gn_apg_lastwr_adjust  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_lastwr_adjust  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl5_rsvd bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80113a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_gn_apg_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Gn Apg Ctrl6 Register
 */
union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t gn_apg_num_samples    : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_num_samples    : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl6_rsvd bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80113b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_gn_apg_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_GN_APG_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_cmd0
 *
 * GSERC Ln Leq Refclk Leq Fsm Cmd0 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd0
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_cmd_target    : 4;  /**< [  7:  4](R/W/H) FSM Command Target
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t leq_fsm_cmd_opcode    : 4;  /**< [  3:  0](R/W/H) FSM Command Opcode and Operand
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_opcode    : 4;  /**< [  3:  0](R/W/H) FSM Command Opcode and Operand
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t leq_fsm_cmd_target    : 4;  /**< [  7:  4](R/W/H) FSM Command Target
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd0_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd0 bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd0_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011108ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd0_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_cmd1
 *
 * GSERC Ln Leq Refclk Leq Fsm Cmd1 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd1
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_cmd_scratchpad : 8; /**< [  7:  0](R/W/H) FSM Scratchpad Write Value
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_scratchpad : 8; /**< [  7:  0](R/W/H) FSM Scratchpad Write Value
                                                                 This field has to be set before asserting leq_fsm_cmd_req. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd1_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd1 bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd1_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd1_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_cmd2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Cmd2 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t leq_fsm_cmd_misc_option : 1;/**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_misc_option : 1;/**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd2_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011118ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_cmd2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CMD2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_ctrl0
 *
 * GSERC Ln Leq Refclk Leq Fsm Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t leq_fsm_state_reset   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_1            : 1;
        uint32_t leq_fsm_cmd_req       : 1;  /**< [  0:  0](R/W/H) FSM command request
                                                                 Write '1' to this field to set a new FSM command.
                                                                 Write '0' to this field when leq_fsm_cmd_ack is asserted. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_cmd_req       : 1;  /**< [  0:  0](R/W/H) FSM command request
                                                                 Write '1' to this field to set a new FSM command.
                                                                 Write '0' to this field when leq_fsm_cmd_ack is asserted. */
        uint32_t reserved_1            : 1;
        uint32_t leq_fsm_state_reset   : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl0 bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011100ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_timeout_limit_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_timeout_limit_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl1_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011148ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Ctrl2 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_timeout_limit_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_timeout_limit_15_8 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl2_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status0
 *
 * GSERC Ln Leq Refclk Leq Fsm Status0 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_min_clamp     : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint32_t leq_fsm_max_clamp     : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint32_t leq_fsm_status_error2 : 3;  /**< [  5:  3](RO/H) Reserved. */
        uint32_t leq_fsm_status_error1 : 3;  /**< [  2:  0](RO/H) FSM Error Status.
                                                                 0 indicates that there is no error. If an error exists then the following decoding is used:.

                                                                 0 = No error
                                                                 1 = Write request timeout
                                                                 2 = No measurement block
                                                                 3 = Measurement timeout
                                                                 4 = undefined
                                                                 5 = Start value is larger max or smaller than min
                                                                 others = undefined */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_status_error1 : 3;  /**< [  2:  0](RO/H) FSM Error Status.
                                                                 0 indicates that there is no error. If an error exists then the following decoding is used:.

                                                                 0 = No error
                                                                 1 = Write request timeout
                                                                 2 = No measurement block
                                                                 3 = Measurement timeout
                                                                 4 = undefined
                                                                 5 = Start value is larger max or smaller than min
                                                                 others = undefined */
        uint32_t leq_fsm_status_error2 : 3;  /**< [  5:  3](RO/H) Reserved. */
        uint32_t leq_fsm_max_clamp     : 1;  /**< [  6:  6](RO/H) Reserved. */
        uint32_t leq_fsm_min_clamp     : 1;  /**< [  7:  7](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status0_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status0 bdk_gsercx_lnx_leq_refclk_leq_fsm_status0_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status0_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Status1 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_last_result   : 4;  /**< [  7:  4](RO/H) Reserved. */
        uint32_t leq_fsm_state         : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_state         : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t leq_fsm_last_result   : 4;  /**< [  7:  4](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status1_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_status1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011128ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Status2 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_last_step     : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_last_step     : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status2_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_status2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011130ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status3
 *
 * GSERC Ln Leq Refclk Leq Fsm Status3 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_last_value    : 8;  /**< [  7:  0](RO/H) Last Write Value written in Write or Write-and-Measure command; or Read Value of a Read Command. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_last_value    : 8;  /**< [  7:  0](RO/H) Last Write Value written in Write or Write-and-Measure command; or Read Value of a Read Command. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status3_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status3 bdk_gsercx_lnx_leq_refclk_leq_fsm_status3_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011138ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status3_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status4_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Status4 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_last_target   : 4;  /**< [  7:  4](RO/H) Reserved. */
        uint32_t leq_fsm_last_opcode   : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_last_opcode   : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t leq_fsm_last_target   : 4;  /**< [  7:  4](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status4_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_status4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011140ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status4_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status5
 *
 * GSERC Ln Leq Refclk Leq Fsm Status5 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status5
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t leq_fsm_cmd_ack       : 1;  /**< [  1:  1](RO/H) FSM command acknowledgement
                                                                 This bit is set to 1 by HW when a command is completed.  It will stay at 1 until
                                                                 leq_fsm_cmd_req is set to 0.

                                                                 All leq_fsm_status* registers are valid only when this bit is asserted. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t leq_fsm_cmd_ack       : 1;  /**< [  1:  1](RO/H) FSM command acknowledgement
                                                                 This bit is set to 1 by HW when a command is completed.  It will stay at 1 until
                                                                 leq_fsm_cmd_req is set to 0.

                                                                 All leq_fsm_status* registers are valid only when this bit is asserted. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status5_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status5 bdk_gsercx_lnx_leq_refclk_leq_fsm_status5_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011158ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status5_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_fsm_status6_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Fsm Status6 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_fsm_status6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_fsm_2lst_value    : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_fsm_2lst_value    : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_fsm_status6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_fsm_status6_rsvd bdk_gsercx_lnx_leq_refclk_leq_fsm_status6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011160ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_fsm_status6_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_FSM_STATUS6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_outintf_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Outintf Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_outintf_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_outintf_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t leq_outintf_rdy_wait  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t leq_outintf_rdy_wait  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_outintf_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_outintf_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_leq_outintf_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011170ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_outintf_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_OUTINTF_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_refclk_spare0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Refclk Spare0 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_refclk_spare0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_refclk_spare0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_refclk_spare0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_refclk_spare0_rsvd bdk_gsercx_lnx_leq_refclk_leq_refclk_spare0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80115c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_refclk_spare0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_leq_refclk_spare1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Leq Refclk Spare1 Register
 */
union bdk_gsercx_lnx_leq_refclk_leq_refclk_spare1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_leq_refclk_spare1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_leq_refclk_spare1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_leq_refclk_spare1_rsvd bdk_gsercx_lnx_leq_refclk_leq_refclk_spare1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80115c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_leq_refclk_spare1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_LEQ_REFCLK_SPARE1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl0 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ple_att_start         : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_start         : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl0_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011480ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl1 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ple_att_value_max     : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_value_max     : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl1_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011488ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl2 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ple_att_value_min     : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_value_min     : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl2_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011490ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl3 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ple_att_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t ple_att_wrwait_time   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_wrwait_time   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_6          : 3;
        uint32_t ple_att_measure_timeout_disable : 1;/**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl3_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011498ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl4_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl4 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t ple_att_step_size     : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t ple_att_error_sign    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ple_att_step_by1      : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_step_by1      : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ple_att_error_sign    : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ple_att_step_size     : 3;  /**< [  4:  2](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl4_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl5_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl5 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t ple_att_lastwr_floor  : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t ple_att_lastwr_avg    : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ple_att_bounce_limit  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_bounce_limit  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t ple_att_lastwr_avg    : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ple_att_lastwr_floor  : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl5_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl5_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl6_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl6 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ple_att_lastwr_adjust : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_lastwr_adjust : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl6_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl6_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl6_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl6_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL6_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl7_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl7 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl7_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl7_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t lfg                   : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t lfg                   : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl7_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl7_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl7_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114b8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl7_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL7_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl8_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl8 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t mbf                   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t mbg                   : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mbg                   : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t mbf                   : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl8_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl8_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl8_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl8_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL8_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ple_att_ctrl9_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ple Att Ctrl9 Register
 */
union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl9_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl9_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t apg                   : 3;  /**< [  7:  5](R/W/H) Reserved. */
        uint32_t hfg_sql               : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t hfg_sql               : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t apg                   : 3;  /**< [  7:  5](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ple_att_ctrl9_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ple_att_ctrl9_rsvd bdk_gsercx_lnx_leq_refclk_ple_att_ctrl9_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80114c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ple_att_ctrl9_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_PLE_ATT_CTRL9_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ref_threshold0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ref Threshold0 Register
 */
union bdk_gsercx_lnx_leq_refclk_ref_threshold0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ref_threshold0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t gn_apg_ref            : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_ref            : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ref_threshold0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ref_threshold0_rsvd bdk_gsercx_lnx_leq_refclk_ref_threshold0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011530ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ref_threshold0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ref_threshold1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ref Threshold1 Register
 */
union bdk_gsercx_lnx_leq_refclk_ref_threshold1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ref_threshold1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_lfg_ref            : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_ref            : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ref_threshold1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ref_threshold1_rsvd bdk_gsercx_lnx_leq_refclk_ref_threshold1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011538ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ref_threshold1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_refclk_ref_threshold2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Refclk Ref Threshold2 Register
 */
union bdk_gsercx_lnx_leq_refclk_ref_threshold2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_refclk_ref_threshold2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ple_att_ref           : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_ref           : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_refclk_ref_threshold2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_refclk_ref_threshold2_rsvd bdk_gsercx_lnx_leq_refclk_ref_threshold2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011540ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(a,b) bdk_gsercx_lnx_leq_refclk_ref_threshold2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(a,b) "GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_REFCLK_REF_THRESHOLD2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eboost_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eboost Cfg0 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eboost_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eboost_train_pattern_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eboost_train_pattern_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eboost_cfg0_rsvd bdk_gsercx_lnx_leq_rxclk_eboost_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011800ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eboost_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eboost_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eboost Cfg1 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eboost_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eboost_train_pattern_14_8 : 7;/**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eboost_train_pattern_14_8 : 7;/**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eboost_cfg1_rsvd bdk_gsercx_lnx_leq_rxclk_eboost_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011808ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eboost_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eboost_cfg2_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eboost Cfg2 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eboost_cfg2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eboost_dont_care_7_0  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eboost_dont_care_7_0  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eboost_cfg2_rsvd bdk_gsercx_lnx_leq_rxclk_eboost_cfg2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011810ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eboost_cfg2_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eboost_cfg3_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eboost Cfg3 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eboost_cfg3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t eboost_dont_care_14_8 : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eboost_dont_care_14_8 : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eboost_cfg3_rsvd bdk_gsercx_lnx_leq_rxclk_eboost_cfg3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011818ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eboost_cfg3_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eboost_cfg4_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eboost Cfg4 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eboost_cfg4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eboost_edge_skew      : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eboost_edge_skew      : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eboost_cfg4_rsvd bdk_gsercx_lnx_leq_rxclk_eboost_cfg4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011820ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eboost_cfg4_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eboost_cfg5_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eboost Cfg5 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eboost_cfg5_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg5_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eboost_num_samples    : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eboost_num_samples    : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eboost_cfg5_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eboost_cfg5_rsvd bdk_gsercx_lnx_leq_rxclk_eboost_cfg5_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011828ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eboost_cfg5_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EBOOST_CFG5_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eq_lfg_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eq Lfg Cfg0 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t eq_lfg_sample_leng_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_sample_leng_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg0_rsvd bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011840ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_eq_lfg_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Eq Lfg Cfg1 Register
 */
union bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t eq_lfg_sample_leng_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t eq_lfg_sample_leng_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg1_rsvd bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011848ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_eq_lfg_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_EQ_LFG_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_gn_apg_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Gn Apg Cfg0 Register
 */
union bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t gn_apg_sample_leng_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_sample_leng_7_0 : 8; /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg0_rsvd bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011860ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_gn_apg_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Gn Apg Cfg1 Register
 */
union bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t gn_apg_sample_leng_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t gn_apg_sample_leng_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg1_rsvd bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011868ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_gn_apg_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_GN_APG_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_leq_rxclk_spare0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Leq Rxclk Spare0 Register
 */
union bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare0_rsvd bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011900ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_leq_rxclk_spare1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Leq Rxclk Spare1 Register
 */
union bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare1_rsvd bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011908ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_leq_rxclk_spare1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_LEQ_RXCLK_SPARE1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_ple_att_cfg0_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Ple Att Cfg0 Register
 */
union bdk_gsercx_lnx_leq_rxclk_ple_att_cfg0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_ple_att_cfg0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ple_att_sample_leng_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_sample_leng_7_0 : 8;/**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_ple_att_cfg0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_ple_att_cfg0_rsvd bdk_gsercx_lnx_leq_rxclk_ple_att_cfg0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011880ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_ple_att_cfg0_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_leq_rxclk_ple_att_cfg1_rsvd
 *
 * INTERNAL: GSERC Ln Leq Rxclk Ple Att Cfg1 Register
 */
union bdk_gsercx_lnx_leq_rxclk_ple_att_cfg1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_leq_rxclk_ple_att_cfg1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ple_att_sample_leng_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ple_att_sample_leng_11_8 : 4;/**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_leq_rxclk_ple_att_cfg1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_leq_rxclk_ple_att_cfg1_rsvd bdk_gsercx_lnx_leq_rxclk_ple_att_cfg1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8011888ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(a,b) bdk_gsercx_lnx_leq_rxclk_ple_att_cfg1_rsvd_t
#define bustype_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(a,b) "GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD"
#define device_bar_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LEQ_RXCLK_PLE_ATT_CFG1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_coefficient_update_status
 *
 * GSERC Ln Lt Rx Coefficient Update Status Register
 */
union bdk_gsercx_lnx_lt_rx_coefficient_update_status
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_coefficient_update_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t preset                : 1;  /**< [  7:  7](RO/H) Received coefficient update preset field. */
        uint32_t initialize            : 1;  /**< [  6:  6](RO/H) Received coefficient update initialize field. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received coefficient update request field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received coefficient update request field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received coefficient update field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received coefficient update field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received coefficient update request field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received coefficient update request field for pre-cursor tap. */
        uint32_t initialize            : 1;  /**< [  6:  6](RO/H) Received coefficient update initialize field. */
        uint32_t preset                : 1;  /**< [  7:  7](RO/H) Received coefficient update preset field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_coefficient_update_status_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_coefficient_update_status bdk_gsercx_lnx_lt_rx_coefficient_update_status_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) bdk_gsercx_lnx_lt_rx_coefficient_update_status_t
#define bustype_BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) "GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS"
#define device_bar_BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_COEFFICIENT_UPDATE_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl0
 *
 * GSERC Ln Lt Rx Ctrl0 Register
 */
union bdk_gsercx_lnx_lt_rx_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t training              : 1;  /**< [  1:  1](R/W/H) This is the 802.3 defined training variable.  It should be set according to
                                                                 corresponding LTSM output. */
        uint32_t clear                 : 1;  /**< [  0:  0](R/W/H) Synchronous reset for LT Rx block. */
#else /* Word 0 - Little Endian */
        uint32_t clear                 : 1;  /**< [  0:  0](R/W/H) Synchronous reset for LT Rx block. */
        uint32_t training              : 1;  /**< [  1:  1](R/W/H) This is the 802.3 defined training variable.  It should be set according to
                                                                 corresponding LTSM output. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_ctrl0 bdk_gsercx_lnx_lt_rx_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_CTRL0(a,b) bdk_gsercx_lnx_lt_rx_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LT_RX_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_CTRL0(a,b) "GSERCX_LNX_LT_RX_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LT_RX_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status0
 *
 * GSERC Ln Lt Rx Ctrl Channel Status0 Register
 */
union bdk_gsercx_lnx_lt_rx_ctrl_channel_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t coefficient_update_7_0 : 8; /**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t coefficient_update_7_0 : 8; /**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_ctrl_channel_status0 bdk_gsercx_lnx_lt_rx_ctrl_channel_status0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) bdk_gsercx_lnx_lt_rx_ctrl_channel_status0_t
#define bustype_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0"
#define device_bar_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status1
 *
 * GSERC Ln Lt Rx Ctrl Channel Status1 Register
 */
union bdk_gsercx_lnx_lt_rx_ctrl_channel_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t coefficient_update_15_8 : 8;/**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t coefficient_update_15_8 : 8;/**< [  7:  0](RO/H) Received coefficient update field of last LT frame. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_ctrl_channel_status1 bdk_gsercx_lnx_lt_rx_ctrl_channel_status1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) bdk_gsercx_lnx_lt_rx_ctrl_channel_status1_t
#define bustype_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1"
#define device_bar_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status2
 *
 * GSERC Ln Lt Rx Ctrl Channel Status2 Register
 */
union bdk_gsercx_lnx_lt_rx_ctrl_channel_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t status_report_7_0     : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t status_report_7_0     : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status2_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_ctrl_channel_status2 bdk_gsercx_lnx_lt_rx_ctrl_channel_status2_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f90ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) bdk_gsercx_lnx_lt_rx_ctrl_channel_status2_t
#define bustype_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2"
#define device_bar_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_ctrl_channel_status3
 *
 * GSERC Ln Lt Rx Ctrl Channel Status3 Register
 */
union bdk_gsercx_lnx_lt_rx_ctrl_channel_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t status_report_15_8    : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
#else /* Word 0 - Little Endian */
        uint32_t status_report_15_8    : 8;  /**< [  7:  0](RO/H) Received status report field. Invalid when LT is not running. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_ctrl_channel_status3_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_ctrl_channel_status3 bdk_gsercx_lnx_lt_rx_ctrl_channel_status3_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) bdk_gsercx_lnx_lt_rx_ctrl_channel_status3_t
#define bustype_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) "GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3"
#define device_bar_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_CTRL_CHANNEL_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_fc_status0
 *
 * GSERC Ln Lt Rx Fc Status0 Register
 */
union bdk_gsercx_lnx_lt_rx_fc_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_fc_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tf                    : 1;  /**< [  3:  3](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t feccap                : 1;  /**< [  2:  2](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t sn                    : 1;  /**< [  1:  1](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t fecreq                : 1;  /**< [  0:  0](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
#else /* Word 0 - Little Endian */
        uint32_t fecreq                : 1;  /**< [  0:  0](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t sn                    : 1;  /**< [  1:  1](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t feccap                : 1;  /**< [  2:  2](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t tf                    : 1;  /**< [  3:  3](R/W/H) Received Fibre Channel specific LT frame fields. Contents are valid only after LT has completed. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_fc_status0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_fc_status0 bdk_gsercx_lnx_lt_rx_fc_status0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FC_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FC_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013fa8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FC_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) bdk_gsercx_lnx_lt_rx_fc_status0_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) "GSERCX_LNX_LT_RX_FC_STATUS0"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FC_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_ctrl
 *
 * GSERC Ln Lt Rx Frame Ctrl Register
 */
union bdk_gsercx_lnx_lt_rx_frame_ctrl
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_frame_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t clear_count           : 1;  /**< [  0:  0](R/W/H) Clears both the absolute and erroneous frame counters. */
#else /* Word 0 - Little Endian */
        uint32_t clear_count           : 1;  /**< [  0:  0](R/W/H) Clears both the absolute and erroneous frame counters. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_frame_ctrl_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_frame_ctrl bdk_gsercx_lnx_lt_rx_frame_ctrl_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FRAME_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) bdk_gsercx_lnx_lt_rx_frame_ctrl_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) "GSERCX_LNX_LT_RX_FRAME_CTRL"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FRAME_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status0
 *
 * GSERC Ln Lt Rx Frame Status0 Register
 */
union bdk_gsercx_lnx_lt_rx_frame_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_frame_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t frame_lock            : 1;  /**< [  0:  0](RO/H) Indicates that the receiver has locked to incoming LT frames. */
#else /* Word 0 - Little Endian */
        uint32_t frame_lock            : 1;  /**< [  0:  0](RO/H) Indicates that the receiver has locked to incoming LT frames. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_frame_status0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_frame_status0 bdk_gsercx_lnx_lt_rx_frame_status0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) bdk_gsercx_lnx_lt_rx_frame_status0_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS0"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status1
 *
 * GSERC Ln Lt Rx Frame Status1 Register
 */
union bdk_gsercx_lnx_lt_rx_frame_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_frame_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t total_frame_count_7_0 : 8;  /**< [  7:  0](RO/H) Total number of received frames since frame lock. */
#else /* Word 0 - Little Endian */
        uint32_t total_frame_count_7_0 : 8;  /**< [  7:  0](RO/H) Total number of received frames since frame lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_frame_status1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_frame_status1 bdk_gsercx_lnx_lt_rx_frame_status1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ea0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) bdk_gsercx_lnx_lt_rx_frame_status1_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS1"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status2
 *
 * GSERC Ln Lt Rx Frame Status2 Register
 */
union bdk_gsercx_lnx_lt_rx_frame_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_frame_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t total_frame_count_15_8 : 8; /**< [  7:  0](RO/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t total_frame_count_15_8 : 8; /**< [  7:  0](RO/H) Same as above. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_frame_status2_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_frame_status2 bdk_gsercx_lnx_lt_rx_frame_status2_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ea8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) bdk_gsercx_lnx_lt_rx_frame_status2_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS2"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status3
 *
 * GSERC Ln Lt Rx Frame Status3 Register
 */
union bdk_gsercx_lnx_lt_rx_frame_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_frame_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bad_frame_count_7_0   : 8;  /**< [  7:  0](RO/H) Total number of received frames  with a PRBS, DME, or framing error since frame lock. */
#else /* Word 0 - Little Endian */
        uint32_t bad_frame_count_7_0   : 8;  /**< [  7:  0](RO/H) Total number of received frames  with a PRBS, DME, or framing error since frame lock. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_frame_status3_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_frame_status3 bdk_gsercx_lnx_lt_rx_frame_status3_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013eb0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) bdk_gsercx_lnx_lt_rx_frame_status3_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS3"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_frame_status4
 *
 * GSERC Ln Lt Rx Frame Status4 Register
 */
union bdk_gsercx_lnx_lt_rx_frame_status4
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_frame_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bad_frame_count_15_8  : 8;  /**< [  7:  0](RO/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t bad_frame_count_15_8  : 8;  /**< [  7:  0](RO/H) Same as above. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_frame_status4_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_frame_status4 bdk_gsercx_lnx_lt_rx_frame_status4_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013eb8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_FRAME_STATUS4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) bdk_gsercx_lnx_lt_rx_frame_status4_t
#define bustype_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) "GSERCX_LNX_LT_RX_FRAME_STATUS4"
#define device_bar_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_FRAME_STATUS4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_ctrl0
 *
 * GSERC Ln Lt Rx Prbs Ctrl0 Register
 */
union bdk_gsercx_lnx_lt_rx_prbs_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_prbs_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS patterns.
                                                                 0 = CL72 1 + x^9 + x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
#else /* Word 0 - Little Endian */
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS patterns.
                                                                 0 = CL72 1 + x^9 + x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_prbs_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_prbs_ctrl0 bdk_gsercx_lnx_lt_rx_prbs_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_PRBS_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) bdk_gsercx_lnx_lt_rx_prbs_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) "GSERCX_LNX_LT_RX_PRBS_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_ctrl1
 *
 * GSERC Ln Lt Rx Prbs Ctrl1 Register
 */
union bdk_gsercx_lnx_lt_rx_prbs_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_prbs_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t lock_threshold        : 8;  /**< [  7:  0](R/W/H) Maximum number  of PRBS bit errors allowed in single LT frame for PRBS lock to be achieved. */
#else /* Word 0 - Little Endian */
        uint32_t lock_threshold        : 8;  /**< [  7:  0](R/W/H) Maximum number  of PRBS bit errors allowed in single LT frame for PRBS lock to be achieved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_prbs_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_prbs_ctrl1 bdk_gsercx_lnx_lt_rx_prbs_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_PRBS_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) bdk_gsercx_lnx_lt_rx_prbs_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) "GSERCX_LNX_LT_RX_PRBS_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_PRBS_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_status0
 *
 * GSERC Ln Lt Rx Prbs Status0 Register
 */
union bdk_gsercx_lnx_lt_rx_prbs_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_prbs_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t lock                  : 1;  /**< [  1:  1](RO/H) Indicates that a valid PRBS pattern has been detected in receiver LT frame. */
        uint32_t update                : 1;  /**< [  0:  0](RO/H) Assertion indicates that PRBS status information has been updated. */
#else /* Word 0 - Little Endian */
        uint32_t update                : 1;  /**< [  0:  0](RO/H) Assertion indicates that PRBS status information has been updated. */
        uint32_t lock                  : 1;  /**< [  1:  1](RO/H) Indicates that a valid PRBS pattern has been detected in receiver LT frame. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_prbs_status0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_prbs_status0 bdk_gsercx_lnx_lt_rx_prbs_status0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_PRBS_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) bdk_gsercx_lnx_lt_rx_prbs_status0_t
#define bustype_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) "GSERCX_LNX_LT_RX_PRBS_STATUS0"
#define device_bar_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_status1
 *
 * GSERC Ln Lt Rx Prbs Status1 Register
 */
union bdk_gsercx_lnx_lt_rx_prbs_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_prbs_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t error_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of bit errors in PRBS pattern since last lock assertion event. */
#else /* Word 0 - Little Endian */
        uint32_t error_count_7_0       : 8;  /**< [  7:  0](RO/H) Number of bit errors in PRBS pattern since last lock assertion event. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_prbs_status1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_prbs_status1 bdk_gsercx_lnx_lt_rx_prbs_status1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_PRBS_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) bdk_gsercx_lnx_lt_rx_prbs_status1_t
#define bustype_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) "GSERCX_LNX_LT_RX_PRBS_STATUS1"
#define device_bar_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_prbs_status2
 *
 * GSERC Ln Lt Rx Prbs Status2 Register
 */
union bdk_gsercx_lnx_lt_rx_prbs_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_prbs_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t error_count_11_8      : 4;  /**< [  3:  0](RO/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t error_count_11_8      : 4;  /**< [  3:  0](RO/H) Same as above. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_prbs_status2_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_prbs_status2 bdk_gsercx_lnx_lt_rx_prbs_status2_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013e38ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_PRBS_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) bdk_gsercx_lnx_lt_rx_prbs_status2_t
#define bustype_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) "GSERCX_LNX_LT_RX_PRBS_STATUS2"
#define device_bar_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_PRBS_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_rx_report_status
 *
 * GSERC Ln Lt Rx Report Status Register
 */
union bdk_gsercx_lnx_lt_rx_report_status
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_rx_report_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t dme_error             : 1;  /**< [  7:  7](RO/H) Indicates differential manchester decoding error.  Not sticky. */
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](RO/H) Received status report field to indicate local receiver is ready. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received status report field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received status report field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](RO/H) Received status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
        uint32_t c_0                   : 2;  /**< [  3:  2](RO/H) Received status report field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](RO/H) Received status report field for pre-cursor tap. */
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](RO/H) Received status report field to indicate local receiver is ready. */
        uint32_t dme_error             : 1;  /**< [  7:  7](RO/H) Indicates differential manchester decoding error.  Not sticky. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_rx_report_status_s cn; */
};
typedef union bdk_gsercx_lnx_lt_rx_report_status bdk_gsercx_lnx_lt_rx_report_status_t;

static inline uint64_t BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013f10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_RX_REPORT_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) bdk_gsercx_lnx_lt_rx_report_status_t
#define bustype_BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) "GSERCX_LNX_LT_RX_REPORT_STATUS"
#define device_bar_BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_RX_REPORT_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_coefficient_update_ctrl0
 *
 * GSERC Ln Lt Tx Coefficient Update Ctrl0 Register
 */
union bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t preset                : 1;  /**< [  7:  7](R/W/H) Coefficient update preset field. */
        uint32_t initialize            : 1;  /**< [  6:  6](R/W/H) Coefficient update initialize field. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Coefficient update request field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Coefficient update request field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Coefficient update request field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Coefficient update request field for post-cursor tap.
                                                                 2'b00 = hold
                                                                 2'b01 = increment
                                                                 2'b10 = decrement
                                                                 2'b11 = reserved */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Coefficient update request field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Coefficient update request field for pre-cursor tap. */
        uint32_t initialize            : 1;  /**< [  6:  6](R/W/H) Coefficient update initialize field. */
        uint32_t preset                : 1;  /**< [  7:  7](R/W/H) Coefficient update preset field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl0 bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) "GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_coefficient_update_ctrl1
 *
 * GSERC Ln Lt Tx Coefficient Update Ctrl1 Register
 */
union bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field_11_6            : 6;  /**< [  7:  2](R/W/H) Controls bits 11:6 of the coefficient update control channel field. */
        uint32_t field_15_14           : 2;  /**< [  1:  0](R/W/H) Controls bits 15:14 of the coefficient update control channel field. */
#else /* Word 0 - Little Endian */
        uint32_t field_15_14           : 2;  /**< [  1:  0](R/W/H) Controls bits 15:14 of the coefficient update control channel field. */
        uint32_t field_11_6            : 6;  /**< [  7:  2](R/W/H) Controls bits 11:6 of the coefficient update control channel field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl1 bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) bdk_gsercx_lnx_lt_tx_coefficient_update_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) "GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_COEFFICIENT_UPDATE_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl0
 *
 * GSERC Ln Lt Tx Fsm Ctrl0 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t clear                 : 1;  /**< [  3:  3](R/W/H) Synchronous reset for LT Tx block. */
        uint32_t signal_detect         : 1;  /**< [  2:  2](R/W/H) Output corresponding to link training signal detect variable.  Should be set
                                                                 when link training has completed successfully. */
        uint32_t mr_training_enable    : 1;  /**< [  1:  1](R/W/H) Indicates to LTSM that link training procedure should be run; otherwise
                                                                 procedures skip directly to signal_det assertion.  This is an 802.3 defined
                                                                 variable. */
        uint32_t mr_restart_training   : 1;  /**< [  0:  0](R/W/H) Starts link training procedure when asserted.  This is an 802.3 defined variable. */
#else /* Word 0 - Little Endian */
        uint32_t mr_restart_training   : 1;  /**< [  0:  0](R/W/H) Starts link training procedure when asserted.  This is an 802.3 defined variable. */
        uint32_t mr_training_enable    : 1;  /**< [  1:  1](R/W/H) Indicates to LTSM that link training procedure should be run; otherwise
                                                                 procedures skip directly to signal_det assertion.  This is an 802.3 defined
                                                                 variable. */
        uint32_t signal_detect         : 1;  /**< [  2:  2](R/W/H) Output corresponding to link training signal detect variable.  Should be set
                                                                 when link training has completed successfully. */
        uint32_t clear                 : 1;  /**< [  3:  3](R/W/H) Synchronous reset for LT Tx block. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl0 bdk_gsercx_lnx_lt_tx_fsm_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c00ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl1
 *
 * GSERC Ln Lt Tx Fsm Ctrl1 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_wait_time_7_0     : 8;  /**< [  7:  0](R/W/H) Maximum time allowed for LT procedure.  If this is exceeded then the
                                                                 training_fail status will assert.  This is an 802.defined variable.  Value is
                                                                 encoded as:
                                                                 39338 * DESIRED_DELAY * 2 ^logdata_width / data_width

                                                                 Should be set to 500ms for 802.3 compliant timeout. */
#else /* Word 0 - Little Endian */
        uint32_t max_wait_time_7_0     : 8;  /**< [  7:  0](R/W/H) Maximum time allowed for LT procedure.  If this is exceeded then the
                                                                 training_fail status will assert.  This is an 802.defined variable.  Value is
                                                                 encoded as:
                                                                 39338 * DESIRED_DELAY * 2 ^logdata_width / data_width

                                                                 Should be set to 500ms for 802.3 compliant timeout. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl1 bdk_gsercx_lnx_lt_tx_fsm_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c08ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl2
 *
 * GSERC Ln Lt Tx Fsm Ctrl2 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t max_wait_time_15_8    : 8;  /**< [  7:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t max_wait_time_15_8    : 8;  /**< [  7:  0](R/W/H) Same as above. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl2 bdk_gsercx_lnx_lt_tx_fsm_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl2_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL2"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl3
 *
 * GSERC Ln Lt Tx Fsm Ctrl3 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wait_time_7_0         : 8;  /**< [  7:  0](R/W/H) Number of additional frames to send after both receivers have been trained and
                                                                 are ready.  This is an 802.3 defined variable.

                                                                 Should be set between 100 and 300 for 802.3 compliance. */
#else /* Word 0 - Little Endian */
        uint32_t wait_time_7_0         : 8;  /**< [  7:  0](R/W/H) Number of additional frames to send after both receivers have been trained and
                                                                 are ready.  This is an 802.3 defined variable.

                                                                 Should be set between 100 and 300 for 802.3 compliance. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl3 bdk_gsercx_lnx_lt_tx_fsm_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl3_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL3"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl4
 *
 * GSERC Ln Lt Tx Fsm Ctrl4 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t wait_time_9_8         : 2;  /**< [  1:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t wait_time_9_8         : 2;  /**< [  1:  0](R/W/H) Same as above. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl4 bdk_gsercx_lnx_lt_tx_fsm_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c28ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl4_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL4"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl5
 *
 * GSERC Ln Lt Tx Fsm Ctrl5 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl5
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t remote_rx_ready       : 1;  /**< [  2:  2](R/W/H) Input to LTSM indicating that the remote receiver is trained and ready.  This
                                                                 value should be taken from the corresponding LT Rx registers.  This is an 802.3
                                                                 defined variable. */
        uint32_t rx_trained            : 1;  /**< [  1:  1](R/W/H) Input to LTSM indicating that the local receiver has completed training.  This
                                                                 is an 802.3 defined variable. */
        uint32_t frame_lock            : 1;  /**< [  0:  0](R/W/H) Input to LTSM that receiver has acquired frame lock.  This value should be taken
                                                                 from the corresponding LT Rx register.  This  an 802.3 defined variable. */
#else /* Word 0 - Little Endian */
        uint32_t frame_lock            : 1;  /**< [  0:  0](R/W/H) Input to LTSM that receiver has acquired frame lock.  This value should be taken
                                                                 from the corresponding LT Rx register.  This  an 802.3 defined variable. */
        uint32_t rx_trained            : 1;  /**< [  1:  1](R/W/H) Input to LTSM indicating that the local receiver has completed training.  This
                                                                 is an 802.3 defined variable. */
        uint32_t remote_rx_ready       : 1;  /**< [  2:  2](R/W/H) Input to LTSM indicating that the remote receiver is trained and ready.  This
                                                                 value should be taken from the corresponding LT Rx registers.  This is an 802.3
                                                                 defined variable. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl5_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl5 bdk_gsercx_lnx_lt_tx_fsm_ctrl5_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c30ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL5", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl5_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL5"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL5(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_ctrl6
 *
 * GSERC Ln Lt Tx Fsm Ctrl6 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_ctrl6
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t max_wait_time_17_16   : 2;  /**< [  1:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t max_wait_time_17_16   : 2;  /**< [  1:  0](R/W/H) Same as above. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_ctrl6_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_ctrl6 bdk_gsercx_lnx_lt_tx_fsm_ctrl6_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_CTRL6", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) bdk_gsercx_lnx_lt_tx_fsm_ctrl6_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) "GSERCX_LNX_LT_TX_FSM_CTRL6"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_CTRL6(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_state_status0
 *
 * GSERC Ln Lt Tx Fsm State Status0 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_state_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_state_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t prev1                 : 3;  /**< [  6:  4](RO/H) One state previous. */
        uint32_t reserved_3            : 1;
        uint32_t current               : 3;  /**< [  2:  0](RO/H) Current state of LTSM.
                                                                 0x0 = INITIALIZE
                                                                 0x1 = SEND_TRAINING
                                                                 0x2 = TRAIN_REMOTE
                                                                 0x3 = TRAIN_LOCAL
                                                                 0x4 = S7
                                                                 0x5 = TRAINING_FAILURE
                                                                 0x6 = LINK_READY
                                                                 0x7 = SEND_DATA */
#else /* Word 0 - Little Endian */
        uint32_t current               : 3;  /**< [  2:  0](RO/H) Current state of LTSM.
                                                                 0x0 = INITIALIZE
                                                                 0x1 = SEND_TRAINING
                                                                 0x2 = TRAIN_REMOTE
                                                                 0x3 = TRAIN_LOCAL
                                                                 0x4 = S7
                                                                 0x5 = TRAINING_FAILURE
                                                                 0x6 = LINK_READY
                                                                 0x7 = SEND_DATA */
        uint32_t reserved_3            : 1;
        uint32_t prev1                 : 3;  /**< [  6:  4](RO/H) One state previous. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_state_status0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_state_status0 bdk_gsercx_lnx_lt_tx_fsm_state_status0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_STATE_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) bdk_gsercx_lnx_lt_tx_fsm_state_status0_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) "GSERCX_LNX_LT_TX_FSM_STATE_STATUS0"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_state_status1
 *
 * GSERC Ln Lt Tx Fsm State Status1 Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_state_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_state_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t prev3                 : 3;  /**< [  6:  4](RO/H) Three states previous. */
        uint32_t reserved_3            : 1;
        uint32_t prev2                 : 3;  /**< [  2:  0](RO/H) Two states previous. */
#else /* Word 0 - Little Endian */
        uint32_t prev2                 : 3;  /**< [  2:  0](RO/H) Two states previous. */
        uint32_t reserved_3            : 1;
        uint32_t prev3                 : 3;  /**< [  6:  4](RO/H) Three states previous. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_state_status1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_state_status1 bdk_gsercx_lnx_lt_tx_fsm_state_status1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d88ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_STATE_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) bdk_gsercx_lnx_lt_tx_fsm_state_status1_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) "GSERCX_LNX_LT_TX_FSM_STATE_STATUS1"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_STATE_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_fsm_status
 *
 * GSERC Ln Lt Tx Fsm Status Register
 */
union bdk_gsercx_lnx_lt_tx_fsm_status
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_fsm_status_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t fsm_local_rx_ready    : 1;  /**< [  4:  4](RO/H) Output from LSM corresponding to 802.3 defined local_rx_ready variable. After
                                                                 this is asserted the corresponding frame status report field should be set. */
        uint32_t reserved_3            : 1;
        uint32_t signal_detect         : 1;  /**< [  2:  2](RO/H) Output from LTSM indicating that link training is complete and successful.  This
                                                                 is an 802.3 defined variable.  This value is only visible internally, and is not
                                                                 the signal_det value driven to PHY top-level. */
        uint32_t training              : 1;  /**< [  1:  1](RO/H) Output from LTSM indicating that link training is in progress.  This is an 802.3 defined variable. */
        uint32_t training_fail         : 1;  /**< [  0:  0](RO/H) Output from LTSM indicating that link training has failed.  This is an 802.3 defined variable. */
#else /* Word 0 - Little Endian */
        uint32_t training_fail         : 1;  /**< [  0:  0](RO/H) Output from LTSM indicating that link training has failed.  This is an 802.3 defined variable. */
        uint32_t training              : 1;  /**< [  1:  1](RO/H) Output from LTSM indicating that link training is in progress.  This is an 802.3 defined variable. */
        uint32_t signal_detect         : 1;  /**< [  2:  2](RO/H) Output from LTSM indicating that link training is complete and successful.  This
                                                                 is an 802.3 defined variable.  This value is only visible internally, and is not
                                                                 the signal_det value driven to PHY top-level. */
        uint32_t reserved_3            : 1;
        uint32_t fsm_local_rx_ready    : 1;  /**< [  4:  4](RO/H) Output from LSM corresponding to 802.3 defined local_rx_ready variable. After
                                                                 this is asserted the corresponding frame status report field should be set. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_fsm_status_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_fsm_status bdk_gsercx_lnx_lt_tx_fsm_status_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_STATUS(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_FSM_STATUS(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c80ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_FSM_STATUS", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) bdk_gsercx_lnx_lt_tx_fsm_status_t
#define bustype_BDK_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) "GSERCX_LNX_LT_TX_FSM_STATUS"
#define device_bar_BDK_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_FSM_STATUS(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_prbs_ctrl0
 *
 * GSERC Ln Lt Tx Prbs Ctrl0 Register
 */
union bdk_gsercx_lnx_lt_tx_prbs_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_prbs_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS pattern.
                                                                 0 = CL72 1 + x^9 +x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
#else /* Word 0 - Little Endian */
        uint32_t polynomial            : 3;  /**< [  2:  0](R/W/H) Selects between CL72 and CL93 PRBS pattern.
                                                                 0 = CL72 1 + x^9 +x^11
                                                                 1 = CL93 1 + x^5 + x^6 + x^10 + x^11
                                                                 2 = CL93 1 + x^5 + x^6 + x^9 + x^11
                                                                 3 = CL93 1 + x^4 + x^6 + x^8 + x^11
                                                                 4 = CL93 1 + x^4 + x^6 + x^7 + x^11 */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_prbs_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_prbs_ctrl0 bdk_gsercx_lnx_lt_tx_prbs_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013c98ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_PRBS_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) bdk_gsercx_lnx_lt_tx_prbs_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) "GSERCX_LNX_LT_TX_PRBS_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_prbs_ctrl1
 *
 * GSERC Ln Lt Tx Prbs Ctrl1 Register
 */
union bdk_gsercx_lnx_lt_tx_prbs_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_prbs_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Initial PRBS LFSR seed.

                                                                 This needs to be set according to the requirements in 802.3 CL72 or CL93
                                                                 depending on the type of link training and lane bonding being performed. */
#else /* Word 0 - Little Endian */
        uint32_t seed_7_0              : 8;  /**< [  7:  0](R/W/H) Initial PRBS LFSR seed.

                                                                 This needs to be set according to the requirements in 802.3 CL72 or CL93
                                                                 depending on the type of link training and lane bonding being performed. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_prbs_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_prbs_ctrl1 bdk_gsercx_lnx_lt_tx_prbs_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ca0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_PRBS_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) bdk_gsercx_lnx_lt_tx_prbs_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) "GSERCX_LNX_LT_TX_PRBS_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_prbs_ctrl2
 *
 * GSERC Ln Lt Tx Prbs Ctrl2 Register
 */
union bdk_gsercx_lnx_lt_tx_prbs_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_prbs_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t seed_10_8             : 3;  /**< [  2:  0](R/W/H) Same as above. */
#else /* Word 0 - Little Endian */
        uint32_t seed_10_8             : 3;  /**< [  2:  0](R/W/H) Same as above. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_prbs_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_prbs_ctrl2 bdk_gsercx_lnx_lt_tx_prbs_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013ca8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_PRBS_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) bdk_gsercx_lnx_lt_tx_prbs_ctrl2_t
#define bustype_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) "GSERCX_LNX_LT_TX_PRBS_CTRL2"
#define device_bar_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_PRBS_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_status_report_ctrl0
 *
 * GSERC Ln Lt Tx Status Report Ctrl0 Register
 */
union bdk_gsercx_lnx_lt_tx_status_report_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_status_report_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](R/W/H) Status report field to indicate local receiver is ready.  Should be set based on
                                                                 LTSM output of corresponding variable. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Status report field for pre-cursor tap. */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Status report field for cursor tap. */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
#else /* Word 0 - Little Endian */
        uint32_t c_p1                  : 2;  /**< [  1:  0](R/W/H) Status report field for post-cursor tap.
                                                                 2'b00 = not updated
                                                                 2'b01 = minimum
                                                                 2'b10 = updated
                                                                 2'b11 = maximum */
        uint32_t c_0                   : 2;  /**< [  3:  2](R/W/H) Status report field for cursor tap. */
        uint32_t c_m1                  : 2;  /**< [  5:  4](R/W/H) Status report field for pre-cursor tap. */
        uint32_t local_rx_ready        : 1;  /**< [  6:  6](R/W/H) Status report field to indicate local receiver is ready.  Should be set based on
                                                                 LTSM output of corresponding variable. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_status_report_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_status_report_ctrl0 bdk_gsercx_lnx_lt_tx_status_report_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d10ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) bdk_gsercx_lnx_lt_tx_status_report_ctrl0_t
#define bustype_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) "GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0"
#define device_bar_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_status_report_ctrl1
 *
 * GSERC Ln Lt Tx Status Report Ctrl1 Register
 */
union bdk_gsercx_lnx_lt_tx_status_report_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_status_report_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field_13_6            : 8;  /**< [  7:  0](R/W/H) Controls bits 13:6 of the status report control channel field. */
#else /* Word 0 - Little Endian */
        uint32_t field_13_6            : 8;  /**< [  7:  0](R/W/H) Controls bits 13:6 of the status report control channel field. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_status_report_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_status_report_ctrl1 bdk_gsercx_lnx_lt_tx_status_report_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d18ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) bdk_gsercx_lnx_lt_tx_status_report_ctrl1_t
#define bustype_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) "GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1"
#define device_bar_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_lt_tx_status_report_ctrl2
 *
 * GSERC Ln Lt Tx Status Report Ctrl2 Register
 */
union bdk_gsercx_lnx_lt_tx_status_report_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_lt_tx_status_report_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field_14              : 1;  /**< [  0:  0](R/W/H) Controls bits 14 of the status report control channel field. */
#else /* Word 0 - Little Endian */
        uint32_t field_14              : 1;  /**< [  0:  0](R/W/H) Controls bits 14 of the status report control channel field. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_lt_tx_status_report_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_lt_tx_status_report_ctrl2 bdk_gsercx_lnx_lt_tx_status_report_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8013d20ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) bdk_gsercx_lnx_lt_tx_status_report_ctrl2_t
#define bustype_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) "GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2"
#define device_bar_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_LT_TX_STATUS_REPORT_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_bias_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Bias Ctrl0 Register
 */
union bdk_gsercx_lnx_top_afe_bias_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_bias_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bias_spare            : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t bias_spare            : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_bias_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_bias_ctrl0_rsvd bdk_gsercx_lnx_top_afe_bias_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010038ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_afe_bias_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_BIAS_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_bias_pd_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Bias Pd Ctrl Register
 */
union bdk_gsercx_lnx_top_afe_bias_pd_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_bias_pd_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pd_bias_icv           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_bias_icc           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_bias_icc           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t pd_bias_icv           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_bias_pd_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_bias_pd_ctrl_rsvd bdk_gsercx_lnx_top_afe_bias_pd_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010018ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_afe_bias_pd_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_BIAS_PD_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_loopback_ctrl
 *
 * GSERC Ln Top Afe Loopback Ctrl Register
 */
union bdk_gsercx_lnx_top_afe_loopback_ctrl
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_loopback_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t loopback_nea_en       : 1;  /**< [  3:  3](R/W/H) Enable for Near-End Analog NEA loopback mode. */
        uint32_t loopback_fea_en       : 1;  /**< [  2:  2](R/W/H) Enable for Far-End Analog FEA loopback mode. */
        uint32_t loopback_txclk_en     : 1;  /**< [  1:  1](R/W/H) Enable for TX clock loopback mode. */
        uint32_t loopback_rxclk_en     : 1;  /**< [  0:  0](R/W/H) Enable for RX clock loopback mode. */
#else /* Word 0 - Little Endian */
        uint32_t loopback_rxclk_en     : 1;  /**< [  0:  0](R/W/H) Enable for RX clock loopback mode. */
        uint32_t loopback_txclk_en     : 1;  /**< [  1:  1](R/W/H) Enable for TX clock loopback mode. */
        uint32_t loopback_fea_en       : 1;  /**< [  2:  2](R/W/H) Enable for Far-End Analog FEA loopback mode. */
        uint32_t loopback_nea_en       : 1;  /**< [  3:  3](R/W/H) Enable for Near-End Analog NEA loopback mode. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_loopback_ctrl_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_loopback_ctrl bdk_gsercx_lnx_top_afe_loopback_ctrl_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010000ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) bdk_gsercx_lnx_top_afe_loopback_ctrl_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) "GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_LOOPBACK_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rx_pd_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Rx Pd Ctrl Register
 */
union bdk_gsercx_lnx_top_afe_rx_pd_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rx_pd_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_rxclkdiv           : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_rxdp               : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_0            : 1;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0            : 1;
        uint32_t pd_rxdp               : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t pd_rxclkdiv           : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rx_pd_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rx_pd_ctrl_rsvd bdk_gsercx_lnx_top_afe_rx_pd_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010008ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_afe_rx_pd_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RX_PD_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rx_rst_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Rx Rst Ctrl Register
 */
union bdk_gsercx_lnx_top_afe_rx_rst_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rx_rst_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rst_rxclkdiv_n        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rst_rxdp_n            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rst_rxdp_n            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rst_rxclkdiv_n        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rx_rst_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rx_rst_ctrl_rsvd bdk_gsercx_lnx_top_afe_rx_rst_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010020ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_afe_rx_rst_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RX_RST_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxclkdiv_ctrl0
 *
 * GSERC Ln Top Afe Rxclkdiv Ctrl0 Register
 */
union bdk_gsercx_lnx_top_afe_rxclkdiv_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rxclkdiv_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t rxclkdiv_sel          : 4;  /**< [  3:  0](R/W/H) RX clock divider division control. This divider affects the output clock RX*X*_CLK_DIV_O clk_rxdiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5 for 20-bit parallel interface via gearbox
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10 for 40-bit parallel interface via gearbox
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 0xF = DIV 5 also enable CLK2 to come in instead of CLK4 to create equivalent of CLK10 */
#else /* Word 0 - Little Endian */
        uint32_t rxclkdiv_sel          : 4;  /**< [  3:  0](R/W/H) RX clock divider division control. This divider affects the output clock RX*X*_CLK_DIV_O clk_rxdiv.
                                                                 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x2 = DIV4
                                                                 0x3 = DIV5 for 20-bit parallel interface via gearbox
                                                                 0x4 = DIV8
                                                                 0x5 = DIV10 for 40-bit parallel interface via gearbox
                                                                 0x6 = DIV16
                                                                 0x7 = DIV 16.5
                                                                 0x8 = DIV 20
                                                                 0x9 = DIV 32
                                                                 0xA = DIV 33
                                                                 0xB = DIV 40
                                                                 0xC = DIV 66
                                                                 0xD = DIV 80
                                                                 0xE = DIV 90
                                                                 0xF = DIV 5 also enable CLK2 to come in instead of CLK4 to create equivalent of CLK10 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rxclkdiv_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rxclkdiv_ctrl0 bdk_gsercx_lnx_top_afe_rxclkdiv_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100b0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) bdk_gsercx_lnx_top_afe_rxclkdiv_ctrl0_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) "GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RXCLKDIV_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxdp_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Rxdp Ctrl0 Register
 */
union bdk_gsercx_lnx_top_afe_rxdp_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rxdp_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rxdp_spare            : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t rxdp_clkdly           : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxdp_clkdly           : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t rxdp_spare            : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rxdp_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rxdp_ctrl0_rsvd bdk_gsercx_lnx_top_afe_rxdp_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010090ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_afe_rxdp_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxdp_ctrl1
 *
 * GSERC Ln Top Afe Rxdp Ctrl1 Register
 */
union bdk_gsercx_lnx_top_afe_rxdp_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rxdp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE RXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
#else /* Word 0 - Little Endian */
        uint32_t rxdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE RXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rxdp_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rxdp_ctrl1 bdk_gsercx_lnx_top_afe_rxdp_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010098ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RXDP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) bdk_gsercx_lnx_top_afe_rxdp_ctrl1_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) "GSERCX_LNX_TOP_AFE_RXDP_CTRL1"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RXDP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxterm_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Rxterm Ctrl0 Register
 */
union bdk_gsercx_lnx_top_afe_rxterm_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rxterm_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rxterm_vcm_gnd        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t rxterm_hiz            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxterm_hiz            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t rxterm_vcm_gnd        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rxterm_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rxterm_ctrl0_rsvd bdk_gsercx_lnx_top_afe_rxterm_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_afe_rxterm_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_rxterm_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Rxterm Ctrl1 Register
 */
union bdk_gsercx_lnx_top_afe_rxterm_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_rxterm_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t rxterm_val            : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rxterm_val            : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_rxterm_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_rxterm_ctrl1_rsvd bdk_gsercx_lnx_top_afe_rxterm_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(a,b) bdk_gsercx_lnx_top_afe_rxterm_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(a,b) "GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_RXTERM_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_tx_pd_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Tx Pd Ctrl Register
 */
union bdk_gsercx_lnx_top_afe_tx_pd_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_tx_pd_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pd_txdp               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t pd_txcp               : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t pd_txcp               : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t pd_txdp               : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_tx_pd_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_tx_pd_ctrl_rsvd bdk_gsercx_lnx_top_afe_tx_pd_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010010ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_afe_tx_pd_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TX_PD_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_tx_rst_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Tx Rst Ctrl Register
 */
union bdk_gsercx_lnx_top_afe_tx_rst_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_tx_rst_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rst_txdp_n            : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_0_1          : 2;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_1          : 2;
        uint32_t rst_txdp_n            : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_tx_rst_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_tx_rst_ctrl_rsvd bdk_gsercx_lnx_top_afe_tx_rst_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010028ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_afe_tx_rst_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TX_RST_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_ctrl2
 *
 * GSERC Ln Top Afe Txcp Ctrl2 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txcp_tx3clk_en        : 1;  /**< [  3:  3](R/W/H) Select rate3 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 or rate2 clock from PLL1 or PLL2
                                                                 1 = rate3 clock from PLL3 DIV 4.125
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_tx2clk_en        : 1;  /**< [  2:  2](R/W/H) Select either rate1 or rate2 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 clock from PLL1, aka LCPLL
                                                                 1 = rate2 clock from PLL2, aka RPLL
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) Enable for TXCP divide-by-2 for rate1 clock from CMU macro.
                                                                 0 = DIV1 mode
                                                                 1 = DIV2 mode
                                                                 2 = DIV4 mode 16G MP PHY only
                                                                 3 = reserved
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_clkdiv           : 2;  /**< [  1:  0](R/W/H) Enable for TXCP divide-by-2 for rate1 clock from CMU macro.
                                                                 0 = DIV1 mode
                                                                 1 = DIV2 mode
                                                                 2 = DIV4 mode 16G MP PHY only
                                                                 3 = reserved
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_tx2clk_en        : 1;  /**< [  2:  2](R/W/H) Select either rate1 or rate2 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 clock from PLL1, aka LCPLL
                                                                 1 = rate2 clock from PLL2, aka RPLL
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t txcp_tx3clk_en        : 1;  /**< [  3:  3](R/W/H) Select rate3 input clocks to TXCP from CMU macro.
                                                                 0 = rate1 or rate2 clock from PLL1 or PLL2
                                                                 1 = rate3 clock from PLL3 DIV 4.125
                                                                 This register is configured by firmware at PHY initialization based on data rate
                                                                 and PHY mode determined by top-level interface pins. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_ctrl2 bdk_gsercx_lnx_top_afe_txcp_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010068ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) bdk_gsercx_lnx_top_afe_txcp_ctrl2_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) "GSERCX_LNX_TOP_AFE_TXCP_CTRL2"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Txcp Ctrl3 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txcp_spare            : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_spare            : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_ctrl3_rsvd bdk_gsercx_lnx_top_afe_txcp_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010070ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(a,b) bdk_gsercx_lnx_top_afe_txcp_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_ctrl4
 *
 * GSERC Ln Top Afe Txcp Ctrl4 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_ctrl4
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_ctrl4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t txcp_loopback_swing   : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t txcp_tx2clk_tst       : 1;  /**< [  1:  1](R/W/H) Enable for TXCP test clock mode after internal AC coupling.
                                                                 This mode allows the test clock from the CMU macro to be muxed into the main
                                                                 transmit data path after the internal AC coupling within the TXCP. The injection
                                                                 of the test clock after the AC coupling is preferred for lower frequency test
                                                                 clocks approx \< 500MHz. */
        uint32_t txcp_toggle_en        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_toggle_en        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t txcp_tx2clk_tst       : 1;  /**< [  1:  1](R/W/H) Enable for TXCP test clock mode after internal AC coupling.
                                                                 This mode allows the test clock from the CMU macro to be muxed into the main
                                                                 transmit data path after the internal AC coupling within the TXCP. The injection
                                                                 of the test clock after the AC coupling is preferred for lower frequency test
                                                                 clocks approx \< 500MHz. */
        uint32_t txcp_loopback_swing   : 2;  /**< [  3:  2](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_ctrl4_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_ctrl4 bdk_gsercx_lnx_top_afe_txcp_ctrl4_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010078ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_CTRL4", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) bdk_gsercx_lnx_top_afe_txcp_ctrl4_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) "GSERCX_LNX_TOP_AFE_TXCP_CTRL4"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_CTRL4(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_dcd_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Txcp Dcd Ctrl0 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txcp_dcd_up_p         : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_dcd_up_p         : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl0_rsvd bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010048ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_dcd_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Txcp Dcd Ctrl1 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txcp_dcd_up_n         : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_dcd_up_n         : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl1_rsvd bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010050ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(a,b) bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_dcd_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Txcp Dcd Ctrl2 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txcp_dcd_dn_p         : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_dcd_dn_p         : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl2_rsvd bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010058ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(a,b) bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txcp_dcd_ctrl3_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Txcp Dcd Ctrl3 Register
 */
union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t txcp_dcd_dn_n         : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txcp_dcd_dn_n         : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl3_rsvd bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010060ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(a,b) bdk_gsercx_lnx_top_afe_txcp_dcd_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXCP_DCD_CTRL3_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txdp_ctrl0
 *
 * GSERC Ln Top Afe Txdp Ctrl0 Register
 */
union bdk_gsercx_lnx_top_afe_txdp_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txdp_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t txdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE TXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
#else /* Word 0 - Little Endian */
        uint32_t txdp_data_width       : 2;  /**< [  1:  0](R/W/H) AFE TXDP data width
                                                                 00 = 16 Bit
                                                                 01 = 20 Bit
                                                                 10 = 32 Bit
                                                                 11 = not used */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txdp_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txdp_ctrl0 bdk_gsercx_lnx_top_afe_txdp_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010080ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXDP_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) bdk_gsercx_lnx_top_afe_txdp_ctrl0_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) "GSERCX_LNX_TOP_AFE_TXDP_CTRL0"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_afe_txdp_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Top Afe Txdp Ctrl1 Register
 */
union bdk_gsercx_lnx_top_afe_txdp_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_afe_txdp_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t txdp_spare            : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_0_3          : 4;
#else /* Word 0 - Little Endian */
        uint32_t reserved_0_3          : 4;
        uint32_t txdp_spare            : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_afe_txdp_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_afe_txdp_ctrl1_rsvd bdk_gsercx_lnx_top_afe_txdp_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010088ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(a,b) bdk_gsercx_lnx_top_afe_txdp_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(a,b) "GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_AFE_TXDP_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_bit_stuff_strip_ctrl
 *
 * GSERC Ln Top Bit Stuff Strip Ctrl Register
 */
union bdk_gsercx_lnx_top_bit_stuff_strip_ctrl
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_bit_stuff_strip_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t bit_strip_even        : 1;  /**< [  2:  2](R/W/H) Selects which bits to strip when bit stripping is enabled in the DPL RX data path:
                                                                 0x0 = Odd bits stripped from RX data
                                                                 0x1 = Even bits stripped from RX data */
        uint32_t bit_strip_en          : 1;  /**< [  1:  1](R/W/H) Enables bit stripping in the DPL RX data path:
                                                                 0x0 = Bit stripping disabled
                                                                 0x1 = Bit stripping enabled */
        uint32_t bit_stuff_en          : 1;  /**< [  0:  0](R/W/H) Enables bit stuffing in the DPL TX data path:
                                                                 0x0 = Bit stuffing disabled
                                                                 0x1 = Bit stuffing enabled */
#else /* Word 0 - Little Endian */
        uint32_t bit_stuff_en          : 1;  /**< [  0:  0](R/W/H) Enables bit stuffing in the DPL TX data path:
                                                                 0x0 = Bit stuffing disabled
                                                                 0x1 = Bit stuffing enabled */
        uint32_t bit_strip_en          : 1;  /**< [  1:  1](R/W/H) Enables bit stripping in the DPL RX data path:
                                                                 0x0 = Bit stripping disabled
                                                                 0x1 = Bit stripping enabled */
        uint32_t bit_strip_even        : 1;  /**< [  2:  2](R/W/H) Selects which bits to strip when bit stripping is enabled in the DPL RX data path:
                                                                 0x0 = Odd bits stripped from RX data
                                                                 0x1 = Even bits stripped from RX data */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_bit_stuff_strip_ctrl_s cn; */
};
typedef union bdk_gsercx_lnx_top_bit_stuff_strip_ctrl bdk_gsercx_lnx_top_bit_stuff_strip_ctrl_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) bdk_gsercx_lnx_top_bit_stuff_strip_ctrl_t
#define bustype_BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) "GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL"
#define device_bar_BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_BIT_STUFF_STRIP_CTRL(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_cdr_dlpf_ovr_rsvd
 *
 * INTERNAL: GSERC Ln Top Cdr Dlpf Ovr Register
 */
union bdk_gsercx_lnx_top_cdr_dlpf_ovr_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_cdr_dlpf_ovr_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t dlpf_frozen           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t dlpf_ovr_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_ovr_en           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t dlpf_frozen           : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_cdr_dlpf_ovr_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_cdr_dlpf_ovr_rsvd bdk_gsercx_lnx_top_cdr_dlpf_ovr_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010180ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(a,b) bdk_gsercx_lnx_top_cdr_dlpf_ovr_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(a,b) "GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_CDR_DLPF_OVR_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_cdr_dlpf_status_rsvd
 *
 * INTERNAL: GSERC Ln Top Cdr Dlpf Status Register
 */
union bdk_gsercx_lnx_top_cdr_dlpf_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_cdr_dlpf_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t dlpf_frozen           : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t dlpf_frozen           : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_cdr_dlpf_status_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_cdr_dlpf_status_rsvd bdk_gsercx_lnx_top_cdr_dlpf_status_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010188ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(a,b) bdk_gsercx_lnx_top_cdr_dlpf_status_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(a,b) "GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_CDR_DLPF_STATUS_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_delay_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Delay Ctrl0 Register
 */
union bdk_gsercx_lnx_top_delay_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_delay_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rx_edge_delay         : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t rx_data_edelay        : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rx_data_edelay        : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t rx_edge_delay         : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_delay_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_delay_ctrl0_rsvd bdk_gsercx_lnx_top_delay_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101a0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_DELAY_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_delay_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_DELAY_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_DELAY_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_delay_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Top Delay Ctrl1 Register
 */
union bdk_gsercx_lnx_top_delay_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_delay_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rx_eye_delay          : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t rx_data_idelay        : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rx_data_idelay        : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t rx_eye_delay          : 3;  /**< [  5:  3](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_delay_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_delay_ctrl1_rsvd bdk_gsercx_lnx_top_delay_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101a8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_DELAY_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(a,b) bdk_gsercx_lnx_top_delay_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(a,b) "GSERCX_LNX_TOP_DELAY_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_DELAY_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_dpl_rxdp_ctrl1
 *
 * GSERC Ln Top Dpl Rxdp Ctrl1 Register
 */
union bdk_gsercx_lnx_top_dpl_rxdp_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_dpl_rxdp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rx_fifo_en            : 1;  /**< [  1:  1](R/W/H) Enable for the RX gearbox FIFO. */
        uint32_t rx_dmux_sel           : 1;  /**< [  0:  0](R/W/H) A mux select for RX data path
                                                                 0 = AFE rx data
                                                                 1 = TX data for LB_NED */
#else /* Word 0 - Little Endian */
        uint32_t rx_dmux_sel           : 1;  /**< [  0:  0](R/W/H) A mux select for RX data path
                                                                 0 = AFE rx data
                                                                 1 = TX data for LB_NED */
        uint32_t rx_fifo_en            : 1;  /**< [  1:  1](R/W/H) Enable for the RX gearbox FIFO. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_dpl_rxdp_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_top_dpl_rxdp_ctrl1 bdk_gsercx_lnx_top_dpl_rxdp_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010120ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_DPL_RXDP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) bdk_gsercx_lnx_top_dpl_rxdp_ctrl1_t
#define bustype_BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) "GSERCX_LNX_TOP_DPL_RXDP_CTRL1"
#define device_bar_BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_DPL_RXDP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_dpl_txdp_ctrl1
 *
 * GSERC Ln Top Dpl Txdp Ctrl1 Register
 */
union bdk_gsercx_lnx_top_dpl_txdp_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_dpl_txdp_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t lb_fed_tx_en          : 1;  /**< [  7:  7](R/W/H) Enable for tx_en to dmux_txa for LB_FEB path.  Tx_en for the path will be set
                                                                 when both this field is set to 1 and rxvalid is 1. */
        uint32_t tx_fifo_en            : 1;  /**< [  6:  6](R/W/H) Enable for the TX gearbox FIFO. */
        uint32_t txpolarity            : 1;  /**< [  5:  5](R/W/H) TX data polarity control
                                                                 0 = No polarity inversion
                                                                 1 = Polarity inverted */
        uint32_t tx_dmux2_sel          : 1;  /**< [  4:  4](R/W/H) Select control for DPL TX data path mux tx_dumx2
                                                                 0 : TX data from customer logics
                                                                 1 = BIST generator */
        uint32_t dmux_txa_sel_ovr_val  : 3;  /**< [  3:  1](R/W/H) Select value for TX data path mux in DPL.  The corresponding mux select override
                                                                 enable must also be set.
                                                                 0 : TX data from customer logics
                                                                 1 = RX data for Far-End-Digital FED loopback
                                                                 2 = AN/802.3
                                                                 3-7: reserved
                                                                 Note: 2/3 encodiing are invalid when AN/LT is not present */
        uint32_t dmux_txa_sel_ovr_en   : 1;  /**< [  0:  0](R/W/H) Enables register control of TX data path mux in DPL. */
#else /* Word 0 - Little Endian */
        uint32_t dmux_txa_sel_ovr_en   : 1;  /**< [  0:  0](R/W/H) Enables register control of TX data path mux in DPL. */
        uint32_t dmux_txa_sel_ovr_val  : 3;  /**< [  3:  1](R/W/H) Select value for TX data path mux in DPL.  The corresponding mux select override
                                                                 enable must also be set.
                                                                 0 : TX data from customer logics
                                                                 1 = RX data for Far-End-Digital FED loopback
                                                                 2 = AN/802.3
                                                                 3-7: reserved
                                                                 Note: 2/3 encodiing are invalid when AN/LT is not present */
        uint32_t tx_dmux2_sel          : 1;  /**< [  4:  4](R/W/H) Select control for DPL TX data path mux tx_dumx2
                                                                 0 : TX data from customer logics
                                                                 1 = BIST generator */
        uint32_t txpolarity            : 1;  /**< [  5:  5](R/W/H) TX data polarity control
                                                                 0 = No polarity inversion
                                                                 1 = Polarity inverted */
        uint32_t tx_fifo_en            : 1;  /**< [  6:  6](R/W/H) Enable for the TX gearbox FIFO. */
        uint32_t lb_fed_tx_en          : 1;  /**< [  7:  7](R/W/H) Enable for tx_en to dmux_txa for LB_FEB path.  Tx_en for the path will be set
                                                                 when both this field is set to 1 and rxvalid is 1. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_dpl_txdp_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_top_dpl_txdp_ctrl1 bdk_gsercx_lnx_top_dpl_txdp_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010110ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_DPL_TXDP_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) bdk_gsercx_lnx_top_dpl_txdp_ctrl1_t
#define bustype_BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) "GSERCX_LNX_TOP_DPL_TXDP_CTRL1"
#define device_bar_BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_DPL_TXDP_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_err_ctrl1
 *
 * GSERC Ln Top Err Ctrl1 Register
 */
union bdk_gsercx_lnx_top_err_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_err_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code lower 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code lower 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_err_ctrl1_s cn; */
};
typedef union bdk_gsercx_lnx_top_err_ctrl1 bdk_gsercx_lnx_top_err_ctrl1_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_ERR_CTRL1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_ERR_CTRL1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010280ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_ERR_CTRL1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_ERR_CTRL1(a,b) bdk_gsercx_lnx_top_err_ctrl1_t
#define bustype_BDK_GSERCX_LNX_TOP_ERR_CTRL1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_ERR_CTRL1(a,b) "GSERCX_LNX_TOP_ERR_CTRL1"
#define device_bar_BDK_GSERCX_LNX_TOP_ERR_CTRL1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_ERR_CTRL1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_ERR_CTRL1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_err_ctrl2
 *
 * GSERC Ln Top Err Ctrl2 Register
 */
union bdk_gsercx_lnx_top_err_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_err_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code higher 8-bits of 16-bit error code. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) Lane top-level firmware error code higher 8-bits of 16-bit error code. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_err_ctrl2_s cn; */
};
typedef union bdk_gsercx_lnx_top_err_ctrl2 bdk_gsercx_lnx_top_err_ctrl2_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_ERR_CTRL2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_ERR_CTRL2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010288ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_ERR_CTRL2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_ERR_CTRL2(a,b) bdk_gsercx_lnx_top_err_ctrl2_t
#define bustype_BDK_GSERCX_LNX_TOP_ERR_CTRL2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_ERR_CTRL2(a,b) "GSERCX_LNX_TOP_ERR_CTRL2"
#define device_bar_BDK_GSERCX_LNX_TOP_ERR_CTRL2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_ERR_CTRL2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_ERR_CTRL2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_err_ctrl3
 *
 * GSERC Ln Top Err Ctrl3 Register
 */
union bdk_gsercx_lnx_top_err_ctrl3
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_err_ctrl3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t critical_err_rx       : 1;  /**< [  1:  1](R/W/H) Lane RX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane RX. ln()_rx_rdy_o is
                                                                 gated when this is set to 1 */
        uint32_t critical_err_tx       : 1;  /**< [  0:  0](R/W/H) Lane TX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane TX. ln()_tx_rdy_o is
                                                                 gated when this is set to 1 */
#else /* Word 0 - Little Endian */
        uint32_t critical_err_tx       : 1;  /**< [  0:  0](R/W/H) Lane TX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane TX. ln()_tx_rdy_o is
                                                                 gated when this is set to 1 */
        uint32_t critical_err_rx       : 1;  /**< [  1:  1](R/W/H) Lane RX critical error status.
                                                                 1 indicates that a critical error has occurred in Lane RX. ln()_rx_rdy_o is
                                                                 gated when this is set to 1 */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_err_ctrl3_s cn; */
};
typedef union bdk_gsercx_lnx_top_err_ctrl3 bdk_gsercx_lnx_top_err_ctrl3_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_ERR_CTRL3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_ERR_CTRL3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010290ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_ERR_CTRL3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_ERR_CTRL3(a,b) bdk_gsercx_lnx_top_err_ctrl3_t
#define bustype_BDK_GSERCX_LNX_TOP_ERR_CTRL3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_ERR_CTRL3(a,b) "GSERCX_LNX_TOP_ERR_CTRL3"
#define device_bar_BDK_GSERCX_LNX_TOP_ERR_CTRL3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_ERR_CTRL3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_ERR_CTRL3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr0
 *
 * GSERC Ln Top Ln Ctrl Ovr0 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_ovr0
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_ovr0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t tx_en                 : 1;  /**< [  4:  4](R/W/H) Override value for TX*X*_CTRL_TX_EN_I ln()_tx_en_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t eye_rxpolarity        : 1;  /**< [  3:  3](R/W/H) Eye_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t edge_rxpolarity       : 1;  /**< [  2:  2](R/W/H) Edge_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t data_rxpolarity       : 1;  /**< [  1:  1](R/W/H) Override value for RX*X*_CTRL_RXPOLARITY_I ln()_rxpolarity_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t data_rxpolarity       : 1;  /**< [  1:  1](R/W/H) Override value for RX*X*_CTRL_RXPOLARITY_I ln()_rxpolarity_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t edge_rxpolarity       : 1;  /**< [  2:  2](R/W/H) Edge_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t eye_rxpolarity        : 1;  /**< [  3:  3](R/W/H) Eye_rxpolarity  inversion control bit.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_en                 : 1;  /**< [  4:  4](R/W/H) Override value for TX*X*_CTRL_TX_EN_I ln()_tx_en_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_ovr0_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_ovr0 bdk_gsercx_lnx_top_ln_ctrl_ovr0_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) bdk_gsercx_lnx_top_ln_ctrl_ovr0_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR0"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr1
 *
 * GSERC Ln Top Ln Ctrl Ovr1 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_ovr1
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_ovr1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rate_chng             : 1;  /**< [  5:  5](R/W/H) Override value for LN*X*_RATE_CHNG_I ln()_rate_chng_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for LN*X*_IDDQ_I ln()_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for LN*X*_RST_N_I ln()_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for LN*X*_PD_I[1:0] ln()_pd_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_pd_i[1:0] and ln()_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_pd_i[1:0] and ln()_rst_n_i.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t pd                    : 2;  /**< [  2:  1](R/W/H) Override value for LN*X*_PD_I[1:0] ln()_pd_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rst_n                 : 1;  /**< [  3:  3](R/W/H) Override value for LN*X*_RST_N_I ln()_rst_n_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t iddq                  : 1;  /**< [  4:  4](R/W/H) Override value for LN*X*_IDDQ_I ln()_iddq_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rate_chng             : 1;  /**< [  5:  5](R/W/H) Override value for LN*X*_RATE_CHNG_I ln()_rate_chng_i.  It takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_ovr1_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_ovr1 bdk_gsercx_lnx_top_ln_ctrl_ovr1_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) bdk_gsercx_lnx_top_ln_ctrl_ovr1_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR1"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr10_rsvd
 *
 * INTERNAL: GSERC Ln Top Ln Ctrl Ovr10 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_ovr10_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_ovr10_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t aneg_cfg_ovr_val      : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t aneg_cfg_ovr_val      : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_ovr10_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_ovr10_rsvd bdk_gsercx_lnx_top_ln_ctrl_ovr10_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010228ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(a,b) bdk_gsercx_lnx_top_ln_ctrl_ovr10_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR10_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr2
 *
 * GSERC Ln Top Ln Ctrl Ovr2 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_ovr2
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_ovr2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rx_data_rate          : 3;  /**< [  7:  5](R/W/H) RX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when rx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used.
                                                                 This register should not be used when programming separate TX and RX data rates
                                                                 per lane. Instead the direct TXCP and RXCDR registers should be used to setup
                                                                 the TX and RX data rates respectively. */
        uint32_t rx_ovr_en             : 1;  /**< [  4:  4](R/W/H) RX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_rate          : 3;  /**< [  3:  1](R/W/H) TX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when tx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it can be used to support separate TX and RX data rates per
                                                                 lane. */
        uint32_t tx_ovr_en             : 1;  /**< [  0:  0](R/W/H) TX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t tx_ovr_en             : 1;  /**< [  0:  0](R/W/H) TX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_rate          : 3;  /**< [  3:  1](R/W/H) TX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when tx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it can be used to support separate TX and RX data rates per
                                                                 lane. */
        uint32_t rx_ovr_en             : 1;  /**< [  4:  4](R/W/H) RX override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rx_data_rate          : 3;  /**< [  7:  5](R/W/H) RX override value for LN*X*_CTRL_DATA_RATE_I ln()_ctrl_data_rate_i.  It takes
                                                                 effect when rx_ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used.
                                                                 This register should not be used when programming separate TX and RX data rates
                                                                 per lane. Instead the direct TXCP and RXCDR registers should be used to setup
                                                                 the TX and RX data rates respectively. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_ovr2_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_ovr2 bdk_gsercx_lnx_top_ln_ctrl_ovr2_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) bdk_gsercx_lnx_top_ln_ctrl_ovr2_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR2"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_ovr3
 *
 * GSERC Ln Top Ln Ctrl Ovr3 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_ovr3
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_ovr3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rx_data_width         : 3;  /**< [  6:  4](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i   for RX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_width         : 3;  /**< [  3:  1](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i  for TX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Override enable for ln()_ctrl_*_i signals in this register.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t tx_data_width         : 3;  /**< [  3:  1](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i  for TX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t rx_data_width         : 3;  /**< [  6:  4](R/W/H) Override value for LN*X*_CTRL_DATA_WIDTH_I[2:0] ln()_data_width_i   for RX.  It
                                                                 takes effect when ovr_en is 1.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_ovr3_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_ovr3 bdk_gsercx_lnx_top_ln_ctrl_ovr3_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_OVR3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) bdk_gsercx_lnx_top_ln_ctrl_ovr3_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) "GSERCX_LNX_TOP_LN_CTRL_OVR3"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_OVR3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status0
 *
 * GSERC Ln Top Ln Ctrl Status0 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t rate_chng             : 1;  /**< [  6:  6](RO/H) Effective value of ln()_rst_n. */
        uint32_t iddq                  : 1;  /**< [  5:  5](RO/H) Effective value of ln()_rst_n. */
        uint32_t rst_n                 : 1;  /**< [  4:  4](RO/H) Effective value of ln()_rst_n. */
        uint32_t pd                    : 2;  /**< [  3:  2](RO/H) Effective value of ln()_pd. */
        uint32_t tx_en                 : 1;  /**< [  1:  1](RO/H) Effective value of ln()_tx_en for TX. */
        uint32_t data_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of ln()_rxpolarity for RX. */
#else /* Word 0 - Little Endian */
        uint32_t data_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of ln()_rxpolarity for RX. */
        uint32_t tx_en                 : 1;  /**< [  1:  1](RO/H) Effective value of ln()_tx_en for TX. */
        uint32_t pd                    : 2;  /**< [  3:  2](RO/H) Effective value of ln()_pd. */
        uint32_t rst_n                 : 1;  /**< [  4:  4](RO/H) Effective value of ln()_rst_n. */
        uint32_t iddq                  : 1;  /**< [  5:  5](RO/H) Effective value of ln()_rst_n. */
        uint32_t rate_chng             : 1;  /**< [  6:  6](RO/H) Effective value of ln()_rst_n. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_status0_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_status0 bdk_gsercx_lnx_top_ln_ctrl_status0_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010230ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) bdk_gsercx_lnx_top_ln_ctrl_status0_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS0"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status1
 *
 * GSERC Ln Top Ln Ctrl Status1 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_status1
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t tx_data_width         : 3;  /**< [  5:  3](RO/H) Width of TX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t tx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of TX ln()_ctrl_data_rate. */
#else /* Word 0 - Little Endian */
        uint32_t tx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of TX ln()_ctrl_data_rate. */
        uint32_t tx_data_width         : 3;  /**< [  5:  3](RO/H) Width of TX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_status1_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_status1 bdk_gsercx_lnx_top_ln_ctrl_status1_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010238ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS1", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) bdk_gsercx_lnx_top_ln_ctrl_status1_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS1"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS1(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status2
 *
 * GSERC Ln Top Ln Ctrl Status2 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_status2
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rx_data_width         : 3;  /**< [  5:  3](RO/H) Width of RX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t rx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of RX ln()_ctrl_data_rate. */
#else /* Word 0 - Little Endian */
        uint32_t rx_data_rate          : 3;  /**< [  2:  0](RO/H) Effective value of RX ln()_ctrl_data_rate. */
        uint32_t rx_data_width         : 3;  /**< [  5:  3](RO/H) Width of RX data path
                                                                 1 = 10-bit
                                                                 2 = 16-bit
                                                                 3 = 20-bit
                                                                 4 = 32-bit
                                                                 5 = 40-bit */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_status2_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_status2 bdk_gsercx_lnx_top_ln_ctrl_status2_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010240ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS2", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) bdk_gsercx_lnx_top_ln_ctrl_status2_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS2"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS2(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status3
 *
 * GSERC Ln Top Ln Ctrl Status3 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_status3
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t eye_rxpolarity        : 1;  /**< [  1:  1](RO/H) Effective value of eye_rxpolarity for RX. */
        uint32_t edge_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of edge_rxpolarity for RX. */
#else /* Word 0 - Little Endian */
        uint32_t edge_rxpolarity       : 1;  /**< [  0:  0](RO/H) Effective value of edge_rxpolarity for RX. */
        uint32_t eye_rxpolarity        : 1;  /**< [  1:  1](RO/H) Effective value of eye_rxpolarity for RX. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_status3_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_status3 bdk_gsercx_lnx_top_ln_ctrl_status3_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010248ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS3", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) bdk_gsercx_lnx_top_ln_ctrl_status3_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS3"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS3(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_ctrl_status4_rsvd
 *
 * INTERNAL: GSERC Ln Top Ln Ctrl Status4 Register
 */
union bdk_gsercx_lnx_top_ln_ctrl_status4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_ctrl_status4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t aneg_cfg              : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t aneg_cfg              : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_ctrl_status4_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_ctrl_status4_rsvd bdk_gsercx_lnx_top_ln_ctrl_status4_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010250ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(a,b) bdk_gsercx_lnx_top_ln_ctrl_status4_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(a,b) "GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_CTRL_STATUS4_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_stat_ctrl0
 *
 * GSERC Ln Top Ln Stat Ctrl0 Register
 */
union bdk_gsercx_lnx_top_ln_stat_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_stat_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t rxvalid               : 1;  /**< [  0:  0](R/W/H) Rxvalid status output. */
#else /* Word 0 - Little Endian */
        uint32_t rxvalid               : 1;  /**< [  0:  0](R/W/H) Rxvalid status output. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_stat_ctrl0_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_stat_ctrl0 bdk_gsercx_lnx_top_ln_stat_ctrl0_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101c0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_STAT_CTRL0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) bdk_gsercx_lnx_top_ln_stat_ctrl0_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) "GSERCX_LNX_TOP_LN_STAT_CTRL0"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_stat_ctrl_ovr_rsvd
 *
 * INTERNAL: GSERC Ln Top Ln Stat Ctrl Ovr Register
 */
union bdk_gsercx_lnx_top_ln_stat_ctrl_ovr_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_stat_ctrl_ovr_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t state_chng_rdy        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ovr_en                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t state_chng_rdy        : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_stat_ctrl_ovr_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_stat_ctrl_ovr_rsvd bdk_gsercx_lnx_top_ln_stat_ctrl_ovr_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101c8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(a,b) bdk_gsercx_lnx_top_ln_stat_ctrl_ovr_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(a,b) "GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_STAT_CTRL_OVR_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_ln_stat_status0
 *
 * GSERC Ln Top Ln Stat Status0 Register
 */
union bdk_gsercx_lnx_top_ln_stat_status0
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_ln_stat_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of ln()_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
#else /* Word 0 - Little Endian */
        uint32_t state_chng_rdy        : 1;  /**< [  0:  0](RO/H) Value of ln()_state_chng_rdy_o.
                                                                 This register for standalone testing of PHY eg. macro test mode.  In the normal
                                                                 operating mode, it should not be used. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_ln_stat_status0_s cn; */
};
typedef union bdk_gsercx_lnx_top_ln_stat_status0 bdk_gsercx_lnx_top_ln_stat_status0_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80101d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LN_STAT_STATUS0", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) bdk_gsercx_lnx_top_ln_stat_status0_t
#define bustype_BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) "GSERCX_LNX_TOP_LN_STAT_STATUS0"
#define device_bar_BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LN_STAT_STATUS0(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_los_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Los Ctrl0 Register
 */
union bdk_gsercx_lnx_top_los_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_los_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t los                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t los                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_los_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_los_ctrl0_rsvd bdk_gsercx_lnx_top_los_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010380ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_LOS_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_los_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_LOS_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_LOS_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_phy_if_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Phy If Ctrl Register
 */
union bdk_gsercx_lnx_top_phy_if_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_phy_if_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ln_rx_rdy             : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ln_tx_rdy             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ln_tx_rdy             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ln_rx_rdy             : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_phy_if_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_phy_if_ctrl_rsvd bdk_gsercx_lnx_top_phy_if_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010150ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_phy_if_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_PHY_IF_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_pwr_state_ack_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Pwr State Ack Ctrl0 Register
 */
union bdk_gsercx_lnx_top_pwr_state_ack_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_pwr_state_ack_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ack                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ack                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_pwr_state_ack_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_pwr_state_ack_ctrl0_rsvd bdk_gsercx_lnx_top_pwr_state_ack_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010138ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_pwr_state_ack_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_PWR_STATE_ACK_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_pwr_state_ctrl_rsvd
 *
 * INTERNAL: GSERC Ln Top Pwr State Ctrl Register
 */
union bdk_gsercx_lnx_top_pwr_state_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_pwr_state_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t delay_len             : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t delay_len             : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_pwr_state_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_pwr_state_ctrl_rsvd bdk_gsercx_lnx_top_pwr_state_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010148ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(a,b) bdk_gsercx_lnx_top_pwr_state_ctrl_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(a,b) "GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_PWR_STATE_CTRL_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_pwr_state_req_status0_rsvd
 *
 * INTERNAL: GSERC Ln Top Pwr State Req Status0 Register
 */
union bdk_gsercx_lnx_top_pwr_state_req_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_pwr_state_req_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pwr_state             : 3;  /**< [  3:  1](RO/H) Reserved. */
        uint32_t req                   : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t req                   : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t pwr_state             : 3;  /**< [  3:  1](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_pwr_state_req_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_pwr_state_req_status0_rsvd bdk_gsercx_lnx_top_pwr_state_req_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a8010128ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(a,b) bdk_gsercx_lnx_top_pwr_state_req_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(a,b) "GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_PWR_STATE_REQ_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_rx_gearbox_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Rx Gearbox Ctrl0 Register
 */
union bdk_gsercx_lnx_top_rx_gearbox_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_rx_gearbox_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t select                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t latency               : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t mode                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t latency               : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t select                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_rx_gearbox_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_rx_gearbox_ctrl0_rsvd bdk_gsercx_lnx_top_rx_gearbox_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100d8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_rx_gearbox_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_rx_gearbox_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Top Rx Gearbox Ctrl1 Register
 */
union bdk_gsercx_lnx_top_rx_gearbox_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_rx_gearbox_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t low_uncertainty_mode  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t low_uncertainty_mode  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_rx_gearbox_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_rx_gearbox_ctrl1_rsvd bdk_gsercx_lnx_top_rx_gearbox_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(a,b) bdk_gsercx_lnx_top_rx_gearbox_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(a,b) "GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_rx_gearbox_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Top Rx Gearbox Ctrl2 Register
 */
union bdk_gsercx_lnx_top_rx_gearbox_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_rx_gearbox_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rd_delay              : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rd_delay              : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_rx_gearbox_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_rx_gearbox_ctrl2_rsvd bdk_gsercx_lnx_top_rx_gearbox_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100f8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(a,b) bdk_gsercx_lnx_top_rx_gearbox_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(a,b) "GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_RX_GEARBOX_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_tx_gearbox_ctrl0_rsvd
 *
 * INTERNAL: GSERC Ln Top Tx Gearbox Ctrl0 Register
 */
union bdk_gsercx_lnx_top_tx_gearbox_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_tx_gearbox_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t select                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t latency               : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t mode                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t latency               : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t select                : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_tx_gearbox_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_tx_gearbox_ctrl0_rsvd bdk_gsercx_lnx_top_tx_gearbox_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100d0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(a,b) bdk_gsercx_lnx_top_tx_gearbox_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(a,b) "GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_tx_gearbox_ctrl1_rsvd
 *
 * INTERNAL: GSERC Ln Top Tx Gearbox Ctrl1 Register
 */
union bdk_gsercx_lnx_top_tx_gearbox_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_tx_gearbox_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t low_uncertainty_mode  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t low_uncertainty_mode  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_tx_gearbox_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_tx_gearbox_ctrl1_rsvd bdk_gsercx_lnx_top_tx_gearbox_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100e0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(a,b) bdk_gsercx_lnx_top_tx_gearbox_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(a,b) "GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL1_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_tx_gearbox_ctrl2_rsvd
 *
 * INTERNAL: GSERC Ln Top Tx Gearbox Ctrl2 Register
 */
union bdk_gsercx_lnx_top_tx_gearbox_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_tx_gearbox_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t rd_delay              : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t rd_delay              : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_tx_gearbox_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_tx_gearbox_ctrl2_rsvd bdk_gsercx_lnx_top_tx_gearbox_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80100e8ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(a,b) bdk_gsercx_lnx_top_tx_gearbox_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(a,b) "GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_TX_GEARBOX_CTRL2_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_ln#_top_txjtag_status0_rsvd
 *
 * INTERNAL: GSERC Ln Top Txjtag Status0 Register
 */
union bdk_gsercx_lnx_top_txjtag_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_lnx_top_txjtag_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t txjtag_en             : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t txjtag_en             : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_lnx_top_txjtag_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_lnx_top_txjtag_status0_rsvd bdk_gsercx_lnx_top_txjtag_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80102f0ll + 0x1000000ll * ((a) & 0x7) + 0x4000ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(a,b) bdk_gsercx_lnx_top_txjtag_status0_rsvd_t
#define bustype_BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(a,b) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(a,b) "GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(a,b) (a)
#define arguments_BDK_GSERCX_LNX_TOP_TXJTAG_STATUS0_RSVD(a,b) (a),(b),-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Icc Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000000ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Icc Offset O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000008ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Icc Offset O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000010ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icc_offset_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICC_OFFSET_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Icv Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000018ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Icv Offset O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000020ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Icv Offset O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000028ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_icv_offset_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_ICV_OFFSET_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Rext Trim O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000030ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Rext Trim O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000038ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Bias Rext Trim O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000040ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_bias_rext_trim_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_BIAS_REXT_TRIM_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000048ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000050ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000058ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Mute O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000060ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Mute O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000068ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Mute O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000070ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_mute_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_MUTE_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000078ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000080ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000088ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Sel O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000090ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Sel O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000098ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Sel O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_sel_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SEL_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Spare O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Spare O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Calcomp Spare O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_calcomp_spare_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CALCOMP_SPARE_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Dosc O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Dosc O Ovr Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_ovr_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_OVR_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Dosc O Read Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_dosc_o_read_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_DOSC_O_READ_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Ndiv O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Ndiv O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Ndiv O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_ndiv_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_NDIV_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Psel O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Psel O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80000f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Psel O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000100ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_psel_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_PSEL_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Vcofr O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000108ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Vcofr O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000110ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll2 Vcofr O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000118ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll2_vcofr_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL2_VCOFR_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Buf Swing O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000120ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Buf Swing O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000128ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Buf Swing O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000130ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_buf_swing_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_BUF_SWING_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Calref O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000138ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Calref O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000140ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Calref O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000148ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_calref_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_CALREF_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Dosc O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000150ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Dosc O Ovr Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000158ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_ovr_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_OVR_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Dosc O Read Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000160ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_dosc_o_read_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_DOSC_O_READ_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Ndiv O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000168ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Ndiv O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000170ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Ndiv O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000178ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_ndiv_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_NDIV_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Psel O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000180ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Psel O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000188ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Psel O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000190ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_psel_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_PSEL_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Vco Swing O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000198ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Vco Swing O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmpll Vco Swing O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmpll_vco_swing_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMPLL_VCO_SWING_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmu Acal En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmu Acal En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmu Acal En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_acal_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ACAL_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmu Atest En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmu Atest En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Cmu Atest En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_cmu_atest_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_CMU_ATEST_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Soc Atest En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Soc Atest En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Cm0 Soc Atest En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_cm0_soc_atest_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_CM0_SOC_ATEST_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Lane Acal En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80001f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Lane Acal En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000200ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Lane Acal En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000208ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_acal_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Lane Atest En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000210ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Lane Atest En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000218ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Lane Atest En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000220ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_lane_atest_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Dlpf O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000228ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Dlpf O Ovr Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000238ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Dlpf O Ovr Val 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000230ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_ovr_val_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Dlpf O Read Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000248ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Dlpf O Read Val 8 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000240ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_dlpf_o_read_val_8_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clki Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000250ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clki Lsb O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000258ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clki Lsb O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000260ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clki Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000268ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clki Msb O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000270ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clki Msb O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000278ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clkq Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000280ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clkq Lsb O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000288ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clkq Lsb O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000290ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clkq Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000298ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clkq Msb O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Clkq Msb O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Lsb Fine O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Lsb Fine O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Lsb Fine O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Lsb O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Lsb O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Msb O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Hscan Eye Msb O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80002f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000300ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000308ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal Go O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000310ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal Go O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000318ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal Go O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000320ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_go_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal Load O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000328ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal Load O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000330ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcocal Load O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000338ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcocal_load_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcofr O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000340ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcofr O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000348ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxcdr Vcofr O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000350ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxcdr_vcofr_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicereven0 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000358ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicereven0 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000360ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicereven0 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000368ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicereven1 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000370ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicereven1 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000378ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicereven1 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000380ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicerodd0 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000388ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicerodd0 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000390ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicerodd0 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000398ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicerodd1 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicerodd1 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Dataslicerodd1 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Edgeslicereven Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Edgeslicereven Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Edgeslicereven Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Edgeslicerodd Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Edgeslicerodd Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Edgeslicerodd Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Even Tap1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Even Tap1 O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Even Tap1 O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80003f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_even_tap1_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Tap1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000400ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Tap1 O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000408ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Tap1 O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000410ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_tap1_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Vscan Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000418ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Vscan Lsb O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000420ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Vscan Lsb O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000428ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Vscan Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000430ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Vscan Msb O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000438ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eye Vscan Msb O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000440ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eyeslicer Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000448ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eyeslicer Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000450ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Eyeslicer Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000458ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Odd Tap1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000460ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Odd Tap1 O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000468ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Odd Tap1 O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000470ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_odd_tap1_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Sumeven Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000478ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Sumeven Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000480ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Sumeven Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000488ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Sumodd Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000490ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Sumodd Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000498ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Sumodd Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap2 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap2 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap2 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap2_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap3 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap3 O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap3 O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap3_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap4 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap4 O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap4 O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap4_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap5 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap5 O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80004f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap5 O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000500ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap5_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap6 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000508ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap6 O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000510ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap6 O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000518ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap6_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap7 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000520ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap7 O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000528ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap7 O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000530ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap7_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap8 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000538ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap8 O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000540ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Tap8 O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000548ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_tap8_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Vscan Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000550ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Vscan Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000558ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxdfe Vscan Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000560ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxdfe_vscan_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxjtag Hysteresis O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000568ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxjtag Hysteresis O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000570ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxjtag Hysteresis O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000578ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxjtag_hysteresis_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Hfg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000580ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Hfg O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000588ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Hfg O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000590ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_hfg_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Lfg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000598ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Lfg O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Lfg O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_lfg_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbf O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbf O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbf O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbf_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbg O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Mbg O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_mbg_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Sql O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Sql O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Eq Sql O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_eq_sql_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Gn Apg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80005f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Gn Apg O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000600ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Gn Apg O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000608ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_gn_apg_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000610ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E1 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000618ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E1 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000620ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e1_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E2 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000628ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E2 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000630ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E2 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000638ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e2_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E3 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000640ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E3 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000648ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E3 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000650ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e3_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E4 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000658ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E4 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000660ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset E4 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000668ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_e4_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset G1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000670ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset G1 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000678ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Offset G1 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000680ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_offset_g1_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Ple Att O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000688ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Ple Att O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000690ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Rxleq Ple Att O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000698ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_rxleq_ple_att_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Ovr Val 15 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_15_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_15_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Ovr Val 23 16 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_23_16_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_23_16_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Ovr Val 31 24 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_31_24_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_31_24_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Ovr Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_ovr_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_OVR_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Read Val 15 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_15_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_15_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Read Val 23 16 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_23_16_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_23_16_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Read Val 31 24 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_31_24_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_31_24_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdata O Read Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80006f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdata_o_read_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDATA_O_READ_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdp Clkdly O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000700ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdp Clkdly O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000708ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln0 Txdp Clkdly O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000710ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln0_txdp_clkdly_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN0_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Lane Acal En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000718ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Lane Acal En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000720ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Lane Acal En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000728ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_acal_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ACAL_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Lane Atest En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000730ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Lane Atest En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000738ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Lane Atest En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000740ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_lane_atest_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_LANE_ATEST_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Dlpf O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000748ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Dlpf O Ovr Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000758ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Dlpf O Ovr Val 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000750ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_ovr_val_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_OVR_VAL_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Dlpf O Read Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000768ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Dlpf O Read Val 8 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000760ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_dlpf_o_read_val_8_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_DLPF_O_READ_VAL_8_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clki Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000770ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clki Lsb O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000778ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clki Lsb O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000780ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_lsb_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_LSB_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clki Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000788ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clki Msb O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000790ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clki Msb O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000798ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clki_msb_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKI_MSB_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clkq Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clkq Lsb O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clkq Lsb O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_lsb_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_LSB_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clkq Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clkq Msb O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Clkq Msb O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_clkq_msb_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_CLKQ_MSB_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Lsb Fine O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Lsb Fine O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Lsb Fine O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_fine_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_FINE_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Lsb O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Lsb O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80007f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_lsb_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_LSB_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000800ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Msb O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000808ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Hscan Eye Msb O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000810ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_hscan_eye_msb_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_HSCAN_EYE_MSB_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000818ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000820ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000828ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal Go O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000830ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal Go O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000838ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal Go O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000840ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_go_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_GO_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal Load O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000848ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal Load O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000850ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcocal Load O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000858ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcocal_load_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOCAL_LOAD_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcofr O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000860ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcofr O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000868ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxcdr Vcofr O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000870ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxcdr_vcofr_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXCDR_VCOFR_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicereven0 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000878ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicereven0 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000880ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicereven0 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000888ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven0_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicereven1 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000890ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicereven1 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000898ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicereven1 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicereven1_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICEREVEN1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicerodd0 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicerodd0 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicerodd0 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd0_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD0_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicerodd1 Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicerodd1 Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Dataslicerodd1 Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_dataslicerodd1_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_DATASLICERODD1_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Edgeslicereven Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Edgeslicereven Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Edgeslicereven Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicereven_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICEREVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Edgeslicerodd Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Edgeslicerodd Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80008f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Edgeslicerodd Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000900ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_edgeslicerodd_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EDGESLICERODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Even Tap1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000908ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Even Tap1 O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000910ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Even Tap1 O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000918ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_even_tap1_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EVEN_TAP1_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Tap1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000920ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Tap1 O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000928ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Tap1 O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000930ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_tap1_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_TAP1_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Vscan Lsb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000938ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Vscan Lsb O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000940ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Vscan Lsb O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000948ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_lsb_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_LSB_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Vscan Msb O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000950ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Vscan Msb O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000958ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eye Vscan Msb O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000960ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eye_vscan_msb_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYE_VSCAN_MSB_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eyeslicer Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000968ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eyeslicer Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000970ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Eyeslicer Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000978ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_eyeslicer_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_EYESLICER_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Odd Tap1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000980ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Odd Tap1 O Ovr Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000988ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_ovr_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_OVR_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Odd Tap1 O Read Val 6 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](RO/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000990ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_odd_tap1_o_read_val_6_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_ODD_TAP1_O_READ_VAL_6_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Sumeven Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000998ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Sumeven Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Sumeven Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumeven_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMEVEN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Sumodd Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Sumodd Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Sumodd Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_sumodd_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_SUMODD_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap2 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap2 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap2 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap2_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP2_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap3 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap3 O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap3 O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap3_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP3_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap4 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80009f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap4 O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap4 O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap4_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP4_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap5 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a10ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap5 O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a18ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap5 O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a20ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap5_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP5_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap6 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap6 O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a30ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap6 O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a38ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap6_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP6_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap7 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a40ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap7 O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a48ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap7 O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a50ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap7_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP7_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap8 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a58ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap8 O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a60ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Tap8 O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a68ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_tap8_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_TAP8_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Vscan Offset O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a70ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Vscan Offset O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a78ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxdfe Vscan Offset O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxdfe_vscan_offset_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXDFE_VSCAN_OFFSET_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxjtag Hysteresis O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a88ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxjtag Hysteresis O Ovr Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a90ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_ovr_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_OVR_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxjtag Hysteresis O Read Val 1 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 2;  /**< [  1:  0](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000a98ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxjtag_hysteresis_o_read_val_1_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXJTAG_HYSTERESIS_O_READ_VAL_1_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Hfg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000aa0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Hfg O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000aa8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Hfg O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ab0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_hfg_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_HFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Lfg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ab8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Lfg O Ovr Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ac0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_ovr_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_OVR_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Lfg O Read Val 4 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ac8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_lfg_o_read_val_4_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_LFG_O_READ_VAL_4_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbf O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ad0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbf O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ad8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbf O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ae0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbf_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBF_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ae8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbg O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000af0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Mbg O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000af8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_mbg_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_MBG_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Sql O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Sql O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Eq Sql O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b10ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_eq_sql_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_EQ_SQL_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Gn Apg O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b18ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Gn Apg O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b20ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Gn Apg O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_gn_apg_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_GN_APG_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b30ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E1 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b38ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E1 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b40ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e1_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E1_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E2 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b48ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E2 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b50ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E2 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b58ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e2_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E2_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E3 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b60ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E3 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b68ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E3 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b70ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e3_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E3_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E4 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b78ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E4 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset E4 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b88ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_e4_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_E4_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset G1 O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b90ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset G1 O Ovr Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000b98ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_ovr_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_OVR_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Offset G1 O Read Val 5 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ba0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_offset_g1_o_read_val_5_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_OFFSET_G1_O_READ_VAL_5_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Ple Att O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000ba8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Ple Att O Ovr Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bb0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_ovr_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_OVR_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Rxleq Ple Att O Read Val 2 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bb8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_rxleq_ple_att_o_read_val_2_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_RXLEQ_PLE_ATT_O_READ_VAL_2_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata En O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bc0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata En O Ovr Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bc8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_ovr_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_OVR_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata En O Read Val 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bd0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_en_o_read_val_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_EN_O_READ_VAL_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bd8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Ovr Val 15 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bf0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_15_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_15_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Ovr Val 23 16 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000be8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_23_16_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_23_16_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Ovr Val 31 24 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000be0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_31_24_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_31_24_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Ovr Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000bf8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_ovr_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_OVR_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Read Val 15 8 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c10ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_15_8_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_15_8_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Read Val 23 16 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_23_16_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_23_16_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Read Val 31 24 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_31_24_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_31_24_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdata O Read Val 7 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c18ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdata_o_read_val_7_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDATA_O_READ_VAL_7_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdp Clkdly O Ovr En Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c20ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_en_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_EN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdp Clkdly O Ovr Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_ovr_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_OVR_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd
 *
 * INTERNAL: GSERC Phy0 Afe Ovr Afe Ln1 Txdp Clkdly O Read Val 3 0 Register
 */
union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8000c30ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) bdk_gsercx_phy0_afe_ovr_afe_ln1_txdp_clkdly_o_read_val_3_0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) "GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_AFE_OVR_AFE_LN1_TXDP_CLKDLY_O_READ_VAL_3_0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd
 *
 * GSERC Phy0 Mb Cmd Register
 */
union bdk_gsercx_phy0_mb_cmd
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command to the PHY firmware.
                                                                 It is expected that only the APB master writes to the command register.
                                                                 Upon a write to this register, CMD_FLAG is set automatically. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command to the PHY firmware.
                                                                 It is expected that only the APB master writes to the command register.
                                                                 Upon a write to this register, CMD_FLAG is set automatically. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd bdk_gsercx_phy0_mb_cmd_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003800ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD(a) bdk_gsercx_phy0_mb_cmd_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD(a) "GSERCX_PHY0_MB_CMD"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data0
 *
 * GSERC Phy0 Mb Cmd Data0 Register
 */
union bdk_gsercx_phy0_mb_cmd_data0
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data0_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data0 bdk_gsercx_phy0_mb_cmd_data0_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003818ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA0(a) bdk_gsercx_phy0_mb_cmd_data0_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA0(a) "GSERCX_PHY0_MB_CMD_DATA0"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA0(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data1
 *
 * GSERC Phy0 Mb Cmd Data1 Register
 */
union bdk_gsercx_phy0_mb_cmd_data1
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 1. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 1. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data1_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data1 bdk_gsercx_phy0_mb_cmd_data1_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003820ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA1(a) bdk_gsercx_phy0_mb_cmd_data1_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA1(a) "GSERCX_PHY0_MB_CMD_DATA1"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA1(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data2
 *
 * GSERC Phy0 Mb Cmd Data2 Register
 */
union bdk_gsercx_phy0_mb_cmd_data2
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 2. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 2. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data2_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data2 bdk_gsercx_phy0_mb_cmd_data2_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003828ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA2(a) bdk_gsercx_phy0_mb_cmd_data2_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA2(a) "GSERCX_PHY0_MB_CMD_DATA2"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA2(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data3
 *
 * GSERC Phy0 Mb Cmd Data3 Register
 */
union bdk_gsercx_phy0_mb_cmd_data3
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 3. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 3. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data3_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data3 bdk_gsercx_phy0_mb_cmd_data3_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003830ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA3(a) bdk_gsercx_phy0_mb_cmd_data3_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA3(a) "GSERCX_PHY0_MB_CMD_DATA3"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA3(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data4
 *
 * GSERC Phy0 Mb Cmd Data4 Register
 */
union bdk_gsercx_phy0_mb_cmd_data4
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 4. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data4_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data4 bdk_gsercx_phy0_mb_cmd_data4_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003838ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA4(a) bdk_gsercx_phy0_mb_cmd_data4_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA4(a) "GSERCX_PHY0_MB_CMD_DATA4"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA4(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA4(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data5
 *
 * GSERC Phy0 Mb Cmd Data5 Register
 */
union bdk_gsercx_phy0_mb_cmd_data5
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 5. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 5. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data5_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data5 bdk_gsercx_phy0_mb_cmd_data5_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003840ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA5(a) bdk_gsercx_phy0_mb_cmd_data5_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA5(a) "GSERCX_PHY0_MB_CMD_DATA5"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA5(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA5(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data6
 *
 * GSERC Phy0 Mb Cmd Data6 Register
 */
union bdk_gsercx_phy0_mb_cmd_data6
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 6. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 6. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data6_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data6 bdk_gsercx_phy0_mb_cmd_data6_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003848ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA6(a) bdk_gsercx_phy0_mb_cmd_data6_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA6(a) "GSERCX_PHY0_MB_CMD_DATA6"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA6(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA6(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_data7
 *
 * GSERC Phy0 Mb Cmd Data7 Register
 */
union bdk_gsercx_phy0_mb_cmd_data7
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_data7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 7. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Command auxiliary data or argument 7. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_data7_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_data7 bdk_gsercx_phy0_mb_cmd_data7_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_DATA7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003850ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_DATA7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_DATA7(a) bdk_gsercx_phy0_mb_cmd_data7_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_DATA7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_DATA7(a) "GSERCX_PHY0_MB_CMD_DATA7"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_DATA7(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_DATA7(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_DATA7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_cmd_flag
 *
 * GSERC Phy0 Mb Cmd Flag Register
 */
union bdk_gsercx_phy0_mb_cmd_flag
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_cmd_flag_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new command to the PHY firmware.
                                                                 It is set automatically when CMD is written.
                                                                 It is expected to be cleared by the PHY firmware by writing 1 to it. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new command to the PHY firmware.
                                                                 It is set automatically when CMD is written.
                                                                 It is expected to be cleared by the PHY firmware by writing 1 to it. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_cmd_flag_s cn; */
};
typedef union bdk_gsercx_phy0_mb_cmd_flag bdk_gsercx_phy0_mb_cmd_flag_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_FLAG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_CMD_FLAG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003810ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_CMD_FLAG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_CMD_FLAG(a) bdk_gsercx_phy0_mb_cmd_flag_t
#define bustype_BDK_GSERCX_PHY0_MB_CMD_FLAG(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_CMD_FLAG(a) "GSERCX_PHY0_MB_CMD_FLAG"
#define device_bar_BDK_GSERCX_PHY0_MB_CMD_FLAG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_CMD_FLAG(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_CMD_FLAG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp
 *
 * GSERC Phy0 Mb Rsp Register
 */
union bdk_gsercx_phy0_mb_rsp
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response from the PHY firmware.
                                                                 It is expected that only the firmware writes to the Response register.
                                                                 Upon a write to this register, RSP_FLAG is set automatically. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response from the PHY firmware.
                                                                 It is expected that only the firmware writes to the Response register.
                                                                 Upon a write to this register, RSP_FLAG is set automatically. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp bdk_gsercx_phy0_mb_rsp_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003880ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP(a) bdk_gsercx_phy0_mb_rsp_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP(a) "GSERCX_PHY0_MB_RSP"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data0
 *
 * GSERC Phy0 Mb Rsp Data0 Register
 */
union bdk_gsercx_phy0_mb_rsp_data0
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data0_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data0 bdk_gsercx_phy0_mb_rsp_data0_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003898ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA0(a) bdk_gsercx_phy0_mb_rsp_data0_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA0(a) "GSERCX_PHY0_MB_RSP_DATA0"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA0(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data1
 *
 * GSERC Phy0 Mb Rsp Data1 Register
 */
union bdk_gsercx_phy0_mb_rsp_data1
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 1. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 1. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data1_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data1 bdk_gsercx_phy0_mb_rsp_data1_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA1(a) bdk_gsercx_phy0_mb_rsp_data1_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA1(a) "GSERCX_PHY0_MB_RSP_DATA1"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA1(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data10
 *
 * GSERC Phy0 Mb Rsp Data10 Register
 */
union bdk_gsercx_phy0_mb_rsp_data10
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 10. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 10. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data10_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data10 bdk_gsercx_phy0_mb_rsp_data10_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA10(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA10(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038e8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA10", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA10(a) bdk_gsercx_phy0_mb_rsp_data10_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA10(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA10(a) "GSERCX_PHY0_MB_RSP_DATA10"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA10(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA10(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA10(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data11
 *
 * GSERC Phy0 Mb Rsp Data11 Register
 */
union bdk_gsercx_phy0_mb_rsp_data11
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 11. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 11. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data11_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data11 bdk_gsercx_phy0_mb_rsp_data11_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA11(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA11(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA11", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA11(a) bdk_gsercx_phy0_mb_rsp_data11_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA11(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA11(a) "GSERCX_PHY0_MB_RSP_DATA11"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA11(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA11(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA11(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data12
 *
 * GSERC Phy0 Mb Rsp Data12 Register
 */
union bdk_gsercx_phy0_mb_rsp_data12
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 12. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 12. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data12_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data12 bdk_gsercx_phy0_mb_rsp_data12_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA12(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA12(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038f8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA12", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA12(a) bdk_gsercx_phy0_mb_rsp_data12_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA12(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA12(a) "GSERCX_PHY0_MB_RSP_DATA12"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA12(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA12(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA12(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data13
 *
 * GSERC Phy0 Mb Rsp Data13 Register
 */
union bdk_gsercx_phy0_mb_rsp_data13
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 13. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 13. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data13_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data13 bdk_gsercx_phy0_mb_rsp_data13_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA13(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA13(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003900ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA13", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA13(a) bdk_gsercx_phy0_mb_rsp_data13_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA13(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA13(a) "GSERCX_PHY0_MB_RSP_DATA13"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA13(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA13(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA13(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data14
 *
 * GSERC Phy0 Mb Rsp Data14 Register
 */
union bdk_gsercx_phy0_mb_rsp_data14
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 14. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 14. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data14_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data14 bdk_gsercx_phy0_mb_rsp_data14_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA14(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA14(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003908ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA14", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA14(a) bdk_gsercx_phy0_mb_rsp_data14_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA14(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA14(a) "GSERCX_PHY0_MB_RSP_DATA14"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA14(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA14(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA14(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data15
 *
 * GSERC Phy0 Mb Rsp Data15 Register
 */
union bdk_gsercx_phy0_mb_rsp_data15
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 15. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 15. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data15_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data15 bdk_gsercx_phy0_mb_rsp_data15_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA15(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA15(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003910ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA15", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA15(a) bdk_gsercx_phy0_mb_rsp_data15_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA15(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA15(a) "GSERCX_PHY0_MB_RSP_DATA15"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA15(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA15(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA15(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data2
 *
 * GSERC Phy0 Mb Rsp Data2 Register
 */
union bdk_gsercx_phy0_mb_rsp_data2
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 2. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 2. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data2_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data2 bdk_gsercx_phy0_mb_rsp_data2_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA2(a) bdk_gsercx_phy0_mb_rsp_data2_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA2(a) "GSERCX_PHY0_MB_RSP_DATA2"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA2(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data3
 *
 * GSERC Phy0 Mb Rsp Data3 Register
 */
union bdk_gsercx_phy0_mb_rsp_data3
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 3. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 3. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data3_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data3 bdk_gsercx_phy0_mb_rsp_data3_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA3(a) bdk_gsercx_phy0_mb_rsp_data3_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA3(a) "GSERCX_PHY0_MB_RSP_DATA3"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA3(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data4
 *
 * GSERC Phy0 Mb Rsp Data4 Register
 */
union bdk_gsercx_phy0_mb_rsp_data4
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 4. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 4. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data4_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data4 bdk_gsercx_phy0_mb_rsp_data4_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA4(a) bdk_gsercx_phy0_mb_rsp_data4_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA4(a) "GSERCX_PHY0_MB_RSP_DATA4"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA4(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA4(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data5
 *
 * GSERC Phy0 Mb Rsp Data5 Register
 */
union bdk_gsercx_phy0_mb_rsp_data5
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 5. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 5. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data5_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data5 bdk_gsercx_phy0_mb_rsp_data5_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA5(a) bdk_gsercx_phy0_mb_rsp_data5_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA5(a) "GSERCX_PHY0_MB_RSP_DATA5"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA5(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA5(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data6
 *
 * GSERC Phy0 Mb Rsp Data6 Register
 */
union bdk_gsercx_phy0_mb_rsp_data6
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 6. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 6. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data6_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data6 bdk_gsercx_phy0_mb_rsp_data6_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA6(a) bdk_gsercx_phy0_mb_rsp_data6_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA6(a) "GSERCX_PHY0_MB_RSP_DATA6"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA6(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA6(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data7
 *
 * GSERC Phy0 Mb Rsp Data7 Register
 */
union bdk_gsercx_phy0_mb_rsp_data7
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 7. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 7. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data7_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data7 bdk_gsercx_phy0_mb_rsp_data7_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA7(a) bdk_gsercx_phy0_mb_rsp_data7_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA7(a) "GSERCX_PHY0_MB_RSP_DATA7"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA7(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA7(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data8
 *
 * GSERC Phy0 Mb Rsp Data8 Register
 */
union bdk_gsercx_phy0_mb_rsp_data8
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 8. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 8. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data8_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data8 bdk_gsercx_phy0_mb_rsp_data8_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA8(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038d8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA8(a) bdk_gsercx_phy0_mb_rsp_data8_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA8(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA8(a) "GSERCX_PHY0_MB_RSP_DATA8"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA8(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA8(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_data9
 *
 * GSERC Phy0 Mb Rsp Data9 Register
 */
union bdk_gsercx_phy0_mb_rsp_data9
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_data9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 9. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Response auxiliary data or argument 9. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_data9_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_data9 bdk_gsercx_phy0_mb_rsp_data9_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA9(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_DATA9(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80038e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_DATA9", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_DATA9(a) bdk_gsercx_phy0_mb_rsp_data9_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_DATA9(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_DATA9(a) "GSERCX_PHY0_MB_RSP_DATA9"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_DATA9(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_DATA9(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_DATA9(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_mb_rsp_flag
 *
 * GSERC Phy0 Mb Rsp Flag Register
 */
union bdk_gsercx_phy0_mb_rsp_flag
{
    uint32_t u;
    struct bdk_gsercx_phy0_mb_rsp_flag_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new Response to the PHY firmware.
                                                                 It is set automatically when RSP is written.
                                                                 It is expected to be cleared by the APB Master by writing 1 to it. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W1C/H) Indicates the presence of a new Response to the PHY firmware.
                                                                 It is set automatically when RSP is written.
                                                                 It is expected to be cleared by the APB Master by writing 1 to it. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_mb_rsp_flag_s cn; */
};
typedef union bdk_gsercx_phy0_mb_rsp_flag bdk_gsercx_phy0_mb_rsp_flag_t;

static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_FLAG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_MB_RSP_FLAG(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8003890ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_MB_RSP_FLAG", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_MB_RSP_FLAG(a) bdk_gsercx_phy0_mb_rsp_flag_t
#define bustype_BDK_GSERCX_PHY0_MB_RSP_FLAG(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_MB_RSP_FLAG(a) "GSERCX_PHY0_MB_RSP_FLAG"
#define device_bar_BDK_GSERCX_PHY0_MB_RSP_FLAG(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_MB_RSP_FLAG(a) (a)
#define arguments_BDK_GSERCX_PHY0_MB_RSP_FLAG(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_atest_ctrl0
 *
 * GSERC Phy0 Top Afe Atest Ctrl0 Register
 */
union bdk_gsercx_phy0_top_afe_atest_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_atest_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t atest_en              : 4;  /**< [  3:  0](R/W/H) Analog test bus enable.
                                                                 0 = off
                                                                 1 = CMU macro atest enabled
                                                                 3 = lane 0 atest enabled
                                                                 4 = lane 1 atest enabled
                                                                 5 = lane 2 atest enabled
                                                                 6 = lane 3 atest enabled
                                                                 7 = lane 4 atest enabled
                                                                 8 = lane 5 atest enabled
                                                                 9 = lane 6 atest enabled
                                                                 10 = lane 7 atest enabled
                                                                 15 = soc_atest enabled
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t atest_en              : 4;  /**< [  3:  0](R/W/H) Analog test bus enable.
                                                                 0 = off
                                                                 1 = CMU macro atest enabled
                                                                 3 = lane 0 atest enabled
                                                                 4 = lane 1 atest enabled
                                                                 5 = lane 2 atest enabled
                                                                 6 = lane 3 atest enabled
                                                                 7 = lane 4 atest enabled
                                                                 8 = lane 5 atest enabled
                                                                 9 = lane 6 atest enabled
                                                                 10 = lane 7 atest enabled
                                                                 15 = soc_atest enabled
                                                                 others = reserved */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_atest_ctrl0_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_atest_ctrl0 bdk_gsercx_phy0_top_afe_atest_ctrl0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80051c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_ATEST_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) bdk_gsercx_phy0_top_afe_atest_ctrl0_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) "GSERCX_PHY0_TOP_AFE_ATEST_CTRL0"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_atest_ctrl1
 *
 * GSERC Phy0 Top Afe Atest Ctrl1 Register
 */
union bdk_gsercx_phy0_top_afe_atest_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_atest_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t atest_sel             : 6;  /**< [  5:  0](R/W/H) Analog test bus selection.
                                                                 Once a lane or CMU is selected, then the desired analog voltage or current
                                                                 signals that is sent to the ATEST1/2 C4s is determined by this register. A
                                                                 different mapping is used for both CMU and lane macros. This mapping is provided
                                                                 in separate documentation. */
#else /* Word 0 - Little Endian */
        uint32_t atest_sel             : 6;  /**< [  5:  0](R/W/H) Analog test bus selection.
                                                                 Once a lane or CMU is selected, then the desired analog voltage or current
                                                                 signals that is sent to the ATEST1/2 C4s is determined by this register. A
                                                                 different mapping is used for both CMU and lane macros. This mapping is provided
                                                                 in separate documentation. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_atest_ctrl1_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_atest_ctrl1 bdk_gsercx_phy0_top_afe_atest_ctrl1_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80051c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_ATEST_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) bdk_gsercx_phy0_top_afe_atest_ctrl1_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) "GSERCX_PHY0_TOP_AFE_ATEST_CTRL1"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_ATEST_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_calcomp_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Afe Calcomp Ctrl0 Register
 */
union bdk_gsercx_phy0_top_afe_calcomp_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_calcomp_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t acal_en               : 4;  /**< [  3:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t acal_en               : 4;  /**< [  3:  0](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_calcomp_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_calcomp_ctrl0_rsvd bdk_gsercx_phy0_top_afe_calcomp_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005180ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(a) bdk_gsercx_phy0_top_afe_calcomp_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_calcomp_ctrl1_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Afe Calcomp Ctrl1 Register
 */
union bdk_gsercx_phy0_top_afe_calcomp_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_calcomp_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t acal_sel              : 5;  /**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t acal_sel              : 5;  /**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_calcomp_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_calcomp_ctrl1_rsvd bdk_gsercx_phy0_top_afe_calcomp_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005188ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(a) bdk_gsercx_phy0_top_afe_calcomp_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(a) "GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_calcomp_ctrl2_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Afe Calcomp Ctrl2 Register
 */
union bdk_gsercx_phy0_top_afe_calcomp_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_calcomp_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t calcomp_spare         : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t calcomp_sel           : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t calcomp_mute          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t calcomp_en            : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t calcomp_en            : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t calcomp_mute          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t calcomp_sel           : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3            : 1;
        uint32_t calcomp_spare         : 4;  /**< [  7:  4](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_calcomp_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_calcomp_ctrl2_rsvd bdk_gsercx_phy0_top_afe_calcomp_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005190ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(a) bdk_gsercx_phy0_top_afe_calcomp_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(a) "GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_calcomp_status0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Afe Calcomp Status0 Register
 */
union bdk_gsercx_phy0_top_afe_calcomp_status0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_calcomp_status0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t calcomp_out           : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t calcomp_out           : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_calcomp_status0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_calcomp_status0_rsvd bdk_gsercx_phy0_top_afe_calcomp_status0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005198ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(a) bdk_gsercx_phy0_top_afe_calcomp_status0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(a) "GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_CALCOMP_STATUS0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_afe_refclk_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Afe Refclk Ctrl0 Register
 */
union bdk_gsercx_phy0_top_afe_refclk_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_afe_refclk_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t refclk_pad_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t refclk_pad_en         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_afe_refclk_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_afe_refclk_ctrl0_rsvd bdk_gsercx_phy0_top_afe_refclk_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005140ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(a) bdk_gsercx_phy0_top_afe_refclk_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_AFE_REFCLK_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Afe Cm0 Clk Pll2ref Register
 */
union bdk_gsercx_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_pll2ref_clk_en   : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_pll2ref_clk_en   : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd bdk_gsercx_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005798ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(a) bdk_gsercx_phy0_top_clock_afe_cm0_clk_pll2ref_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_PLL2REF_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_cm0_clk_ref_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Afe Cm0 Clk Ref Register
 */
union bdk_gsercx_phy0_top_clock_afe_cm0_clk_ref_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_afe_cm0_clk_ref_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_ref_clk_en       : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_ref_clk_en       : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_afe_cm0_clk_ref_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_afe_cm0_clk_ref_rsvd bdk_gsercx_phy0_top_clock_afe_cm0_clk_ref_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005780ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(a) bdk_gsercx_phy0_top_clock_afe_cm0_clk_ref_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_CM0_CLK_REF_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_ln0_clk_rx
 *
 * GSERC Phy0 Top Clock Afe Ln0 Clk Rx Register
 */
union bdk_gsercx_phy0_top_clock_afe_ln0_clk_rx
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_afe_ln0_clk_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln0_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln0_clk_rxdata AFE rx word clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln0_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln0_clk_rxdata AFE rx word clock */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_afe_ln0_clk_rx_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_afe_ln0_clk_rx bdk_gsercx_phy0_top_clock_afe_ln0_clk_rx_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005890ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) bdk_gsercx_phy0_top_clock_afe_ln0_clk_rx_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) "GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RX(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Afe Ln0 Clk Rxdiv Register
 */
union bdk_gsercx_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rxdiv_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rxdiv_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd bdk_gsercx_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005898ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(a) bdk_gsercx_phy0_top_clock_afe_ln0_clk_rxdiv_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN0_CLK_RXDIV_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_ln1_clk_rx
 *
 * GSERC Phy0 Top Clock Afe Ln1 Clk Rx Register
 */
union bdk_gsercx_phy0_top_clock_afe_ln1_clk_rx
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_afe_ln1_clk_rx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln1_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln1_clk_rxdata AFE rx word clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Clock source select for the lane afe_ln1_clk_rx
                                                                 0x0 = select the default clock life clock
                                                                 0x1 = afe_ln1_clk_rxdata AFE rx word clock */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rx_clk_en        : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_afe_ln1_clk_rx_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_afe_ln1_clk_rx bdk_gsercx_phy0_top_clock_afe_ln1_clk_rx_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005910ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) bdk_gsercx_phy0_top_clock_afe_ln1_clk_rx_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) "GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RX(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Afe Ln1 Clk Rxdiv Register
 */
union bdk_gsercx_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rxdiv_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rxdiv_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd bdk_gsercx_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005918ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(a) bdk_gsercx_phy0_top_clock_afe_ln1_clk_rxdiv_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_AFE_LN1_CLK_RXDIV_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_cg_ctrl_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Cg Ctrl Register
 */
union bdk_gsercx_phy0_top_clock_cm0_cg_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_cg_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t gcfsm                 : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t clk_cmpll2_vco        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_cmpll_vco         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t refclk                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t refclk                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t clk_cmpll_vco         : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t clk_cmpll2_vco        : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t gcfsm                 : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_cg_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_cg_ctrl_rsvd bdk_gsercx_phy0_top_clock_cm0_cg_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005860ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_cg_ctrl_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CG_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Cmpll2 Vco Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_cmpll2_vco_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL2_VCO_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_cmpll_vco_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Cmpll Vco Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_cmpll_vco_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_cmpll_vco_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_cmpll_vco_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_cmpll_vco_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_cmpll_vco_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_cmpll_vco_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_CMPLL_VCO_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_gcfsm_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Gcfsm Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_gcfsm_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_gcfsm_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_div_sel          : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_gcfsm_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_gcfsm_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_gcfsm_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_gcfsm_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_GCFSM_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Pll2 Fracn Fbk Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ctrl_div_sel          : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_sel          : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ctrl_frcdiv_mode_en   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_frcdiv_mode_en   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_sel          : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ctrl_div_sel          : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057d0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_pll2_fracn_fbk_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_FRACN_FBK_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Pll2 Ssc Gen Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_div_sel          : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_pll2_ssc_gen_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2_SSC_GEN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_pll2ref_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Pll2ref Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_pll2ref_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_pll2ref_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_pll2ref_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_pll2ref_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_pll2ref_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_pll2ref_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL2REF_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Pll Fracn Fbk Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ctrl_div_sel          : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_sel          : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ctrl_frcdiv_mode_en   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_frcdiv_mode_en   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_sel          : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t ctrl_div_sel          : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80057c8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_pll_fracn_fbk_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_FRACN_FBK_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Pll Ssc Gen Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_div_sel          : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005790ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_pll_ssc_gen_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_PLL_SSC_GEN_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_rate1_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Rate1 Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_rate1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_rate1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rate1_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rate1_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_rate1_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_rate1_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_rate1_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005828ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_rate1_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_rate1div_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Rate1div Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_rate1div_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_rate1div_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rate1div_clk_en  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rate1div_clk_en  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_rate1div_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_rate1div_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_rate1div_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005830ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_rate1div_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE1DIV_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_rate2_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Rate2 Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_rate2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_rate2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rate2_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rate2_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_rate2_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_rate2_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_rate2_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005838ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_rate2_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_rate2div_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Rate2div Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_rate2div_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_rate2div_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rate2div_clk_en  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rate2div_clk_en  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_rate2div_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_rate2div_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_rate2div_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005840ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_rate2div_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE2DIV_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_rate3_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Rate3 Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_rate3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_rate3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rate3_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rate3_clk_en     : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_rate3_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_rate3_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_rate3_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005848ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_rate3_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_rate3div_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Rate3div Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_rate3div_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_rate3div_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t stat_rate3div_clk_en  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t stat_default_clk_en   : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t stat_rate3div_clk_en  : 1;  /**< [  2:  2](RO/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_rate3div_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_rate3div_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_rate3div_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005850ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_rate3div_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_RATE3DIV_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_clk_ref_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Clk Ref Register
 */
union bdk_gsercx_phy0_top_clock_cm0_clk_ref_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_clk_ref_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_div_sel          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_clk_ref_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_clk_ref_rsvd bdk_gsercx_phy0_top_clock_cm0_clk_ref_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005788ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_clk_ref_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_CLK_REF_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_tbus_ctrl1_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Tbus Ctrl1 Register
 */
union bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clk_rate2             : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t clk_rate1             : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t clk_cmpll2_vco        : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t clk_cmpll_vco         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t clk_gcfsm             : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t refclk                : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_ref               : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t afe_clk_ref           : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t afe_clk_ref           : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t clk_ref               : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t refclk                : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_gcfsm             : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t clk_cmpll_vco         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t clk_cmpll2_vco        : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t clk_rate1             : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t clk_rate2             : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl1_rsvd bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005868ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_tbus_ctrl2_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Tbus Ctrl2 Register
 */
union bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clk_pll2_fracn_fbk    : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t clk_pll_fracn_fbk     : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t clk_pll2_ssc_gen      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t clk_pll_ssc_gen       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t clk_pll2ref           : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t afe_clk_pll2ref       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_rate2div          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t clk_rate1div          : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t clk_rate1div          : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t clk_rate2div          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t afe_clk_pll2ref       : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_pll2ref           : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t clk_pll_ssc_gen       : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t clk_pll2_ssc_gen      : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t clk_pll_fracn_fbk     : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t clk_pll2_fracn_fbk    : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl2_rsvd bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005870ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_cm0_tbus_ctrl3_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Cm0 Tbus Ctrl3 Register
 */
union bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t clk_rate3div          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t clk_rate3             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t clk_rate3             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t clk_rate3div          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl3_rsvd bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005878ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(a) bdk_gsercx_phy0_top_clock_cm0_tbus_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_CM0_TBUS_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_cg_ctrl
 *
 * GSERC Phy0 Top Clock Ln0 Cg Ctrl Register
 */
union bdk_gsercx_phy0_top_clock_ln0_cg_ctrl
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_cg_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln0 clk_rx. */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
#else /* Word 0 - Little Endian */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln0 clk_rx. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_cg_ctrl_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_cg_ctrl bdk_gsercx_phy0_top_clock_ln0_cg_ctrl_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) bdk_gsercx_phy0_top_clock_ln0_cg_ctrl_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CG_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_rxb
 *
 * GSERC Phy0 Top Clock Ln0 Clk Rxb Register
 */
union bdk_gsercx_phy0_top_clock_ln0_clk_rxb
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_clk_rxb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_rxb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_rxb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_clk_rxb_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_clk_rxb bdk_gsercx_phy0_top_clock_ln0_clk_rxb_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) bdk_gsercx_phy0_top_clock_ln0_clk_rxb_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_rxf
 *
 * GSERC Phy0 Top Clock Ln0 Clk Rxf Register
 */
union bdk_gsercx_phy0_top_clock_ln0_clk_rxf
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_clk_rxf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 0 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 0 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_clk_rxf_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_clk_rxf bdk_gsercx_phy0_top_clock_ln0_clk_rxf_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) bdk_gsercx_phy0_top_clock_ln0_clk_rxf_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_RXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_txb
 *
 * GSERC Phy0 Top Clock Ln0 Clk Txb Register
 */
union bdk_gsercx_phy0_top_clock_ln0_clk_txb
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_clk_txb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Clock source select override value for ln0_clk_txb
                                                                 0x0 = rx clock
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Clock source select override value for ln0_clk_txb
                                                                 0x0 = rx clock
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_clk_txb_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_clk_txb bdk_gsercx_phy0_top_clock_ln0_clk_txb_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005880ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) bdk_gsercx_phy0_top_clock_ln0_clk_txb_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_clk_txf
 *
 * GSERC Phy0 Top Clock Ln0 Clk Txf Register
 */
union bdk_gsercx_phy0_top_clock_ln0_clk_txf
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_clk_txf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txf. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln0_clk_txf. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_clk_txf_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_clk_txf bdk_gsercx_phy0_top_clock_ln0_clk_txf_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005888ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) bdk_gsercx_phy0_top_clock_ln0_clk_txf_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CLK_TXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Ln0 Cm0 Clk Ctrl0 Register
 */
union bdk_gsercx_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd bdk_gsercx_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058e0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(a) bdk_gsercx_phy0_top_clock_ln0_cm0_clk_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Ln0 Cm0 Clk Gs Mode Ctrl0 Register
 */
union bdk_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd bdk_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058f0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) bdk_gsercx_phy0_top_clock_ln0_cm0_clk_gs_mode_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_tbus_ctrl_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Ln0 Tbus Ctrl Register
 */
union bdk_gsercx_phy0_top_clock_ln0_tbus_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_tbus_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t clk_rx                : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t clk_rxf               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t afe_clk_rxdiv         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t afe_clk_rx            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t clk_tx                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t clk_tx                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t afe_clk_rx            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t afe_clk_rxdiv         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_rxf               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t clk_rx                : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_tbus_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_tbus_ctrl_rsvd bdk_gsercx_phy0_top_clock_ln0_tbus_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(a) bdk_gsercx_phy0_top_clock_ln0_tbus_ctrl_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TBUS_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln0_tx_rate
 *
 * GSERC Phy0 Top Clock Ln0 Tx Rate Register
 */
union bdk_gsercx_phy0_top_clock_ln0_tx_rate
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln0_tx_rate_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln0_tx_rate_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln0_tx_rate bdk_gsercx_phy0_top_clock_ln0_tx_rate_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80058c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) bdk_gsercx_phy0_top_clock_ln0_tx_rate_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) "GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN0_TX_RATE(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_cg_ctrl
 *
 * GSERC Phy0 Top Clock Ln1 Cg Ctrl Register
 */
union bdk_gsercx_phy0_top_clock_ln1_cg_ctrl
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_cg_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln1 clk_rx. */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
#else /* Word 0 - Little Endian */
        uint32_t bist_tx               : 1;  /**< [  0:  0](R/W/H) Clock gate enable for TXF bist clock branch. */
        uint32_t clk_rx                : 1;  /**< [  1:  1](R/W/H) Clock gate enable for ln1 clk_rx. */
        uint32_t bist_rx               : 1;  /**< [  2:  2](R/W/H) Clock gate enable for RXF bist clock branch. */
        uint32_t leq                   : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t dfe                   : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t gcfsm                 : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t clk_rx_cg_disable     : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_cg_ctrl_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_cg_ctrl bdk_gsercx_phy0_top_clock_ln1_cg_ctrl_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005930ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) bdk_gsercx_phy0_top_clock_ln1_cg_ctrl_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CG_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_rxb
 *
 * GSERC Phy0 Top Clock Ln1 Clk Rxb Register
 */
union bdk_gsercx_phy0_top_clock_ln1_clk_rxb
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_clk_rxb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_rxb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_rxb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_clk_rxb_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_clk_rxb bdk_gsercx_phy0_top_clock_ln1_clk_rxb_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005920ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) bdk_gsercx_phy0_top_clock_ln1_clk_rxb_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_rxf
 *
 * GSERC Phy0 Top Clock Ln1 Clk Rxf Register
 */
union bdk_gsercx_phy0_top_clock_ln1_clk_rxf
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_clk_rxf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 1 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_sel          : 2;  /**< [  1:  0](R/W/H) Clock source select for lane 1 RXF clock.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = unused
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_clk_rxf_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_clk_rxf bdk_gsercx_phy0_top_clock_ln1_clk_rxf_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005928ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) bdk_gsercx_phy0_top_clock_ln1_clk_rxf_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_RXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_txb
 *
 * GSERC Phy0 Top Clock Ln1 Clk Txb Register
 */
union bdk_gsercx_phy0_top_clock_ln1_clk_txb
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_clk_txb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txb. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln0_clk_rxb.
                                                                 0x0 = ln()_txclk_i
                                                                 0x1 = rxdiv clock
                                                                 0x2 = cmu clock
                                                                 0x3 = rxclock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txb. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_clk_txb_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_clk_txb bdk_gsercx_phy0_top_clock_ln1_clk_txb_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005900ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) bdk_gsercx_phy0_top_clock_ln1_clk_txb_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_clk_txf
 *
 * GSERC Phy0 Top Clock Ln1 Clk Txf Register
 */
union bdk_gsercx_phy0_top_clock_ln1_clk_txf
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_clk_txf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txf. */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 2;  /**< [  1:  0](R/W/H) Override value for ln1_clk_txf.
                                                                 0x0 = rx clock
                                                                 0x1 = reserved
                                                                 0x2 = cmu clock
                                                                 0x3 = ln0_txclk_i PHY input clock */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  2:  2](R/W/H) Override enable for ln1_clk_txf. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_clk_txf_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_clk_txf bdk_gsercx_phy0_top_clock_ln1_clk_txf_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005908ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) bdk_gsercx_phy0_top_clock_ln1_clk_txf_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CLK_TXF(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Ln1 Cm0 Clk Ctrl0 Register
 */
union bdk_gsercx_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd bdk_gsercx_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005960ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(a) bdk_gsercx_phy0_top_clock_ln1_cm0_clk_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Ln1 Cm0 Clk Gs Mode Ctrl0 Register
 */
union bdk_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ctrl_src_ovr_val      : 3;  /**< [  2:  0](R/W/H) Reserved. */
        uint32_t ctrl_src_ovr_en       : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t ctrl_div_ovr_val      : 2;  /**< [  5:  4](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ctrl_div_ovr_en       : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd bdk_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005970ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) bdk_gsercx_phy0_top_clock_ln1_cm0_clk_gs_mode_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_CM0_CLK_GS_MODE_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_tbus_ctrl_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Ln1 Tbus Ctrl Register
 */
union bdk_gsercx_phy0_top_clock_ln1_tbus_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_tbus_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t clk_rx                : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t clk_rxf               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t afe_clk_rxdiv         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t afe_clk_rx            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t clk_tx                : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t clk_tx                : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t afe_clk_rx            : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t afe_clk_rxdiv         : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t clk_rxf               : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t clk_rx                : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_tbus_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_tbus_ctrl_rsvd bdk_gsercx_phy0_top_clock_ln1_tbus_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005938ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(a) bdk_gsercx_phy0_top_clock_ln1_tbus_ctrl_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TBUS_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_ln1_tx_rate
 *
 * GSERC Phy0 Top Clock Ln1 Tx Rate Register
 */
union bdk_gsercx_phy0_top_clock_ln1_tx_rate
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_ln1_tx_rate_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
#else /* Word 0 - Little Endian */
        uint32_t rate_sel              : 2;  /**< [  1:  0](R/W/H) Clock selection in Gearbox mode
                                                                 0x0 = PLL1
                                                                 0x1 = PLL2
                                                                 0x2 = PLL3
                                                                 others = reserved */
        uint32_t div_sel               : 2;  /**< [  3:  2](R/W/H) 0x0 = DIV1
                                                                 0x1 = DIV2
                                                                 0x3 = DIV4
                                                                 others = reserved */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_ln1_tx_rate_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_ln1_tx_rate bdk_gsercx_phy0_top_clock_ln1_tx_rate_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005940ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) bdk_gsercx_phy0_top_clock_ln1_tx_rate_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) "GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_LN1_TX_RATE(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_clock_phy_ctrl_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Clock Phy Ctrl Register
 */
union bdk_gsercx_phy0_top_clock_phy_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_clock_phy_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t cg_ovr_en             : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t cg_ovr_en             : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_clock_phy_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_clock_phy_ctrl_rsvd bdk_gsercx_phy0_top_clock_phy_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005858ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(a) bdk_gsercx_phy0_top_clock_phy_ctrl_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(a) "GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_CLOCK_PHY_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_during_cal
 *
 * GSERC Phy0 Top Dosc Temp During Cal Register
 */
union bdk_gsercx_phy0_top_dosc_temp_during_cal
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_during_cal_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t temp_value            : 8;  /**< [  7:  0](R/W/H) Temperature value supplied by user. Value needs to be set to temperature + 40
                                                                 e.g. if temperature is -40Celsius then value = -40 + 40 = 0; if temperature is
                                                                 120Celsius then value = 120 + 40 = 160. */
#else /* Word 0 - Little Endian */
        uint32_t temp_value            : 8;  /**< [  7:  0](R/W/H) Temperature value supplied by user. Value needs to be set to temperature + 40
                                                                 e.g. if temperature is -40Celsius then value = -40 + 40 = 0; if temperature is
                                                                 120Celsius then value = 120 + 40 = 160. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_during_cal_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_during_cal bdk_gsercx_phy0_top_dosc_temp_during_cal_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ec8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) bdk_gsercx_phy0_top_dosc_temp_during_cal_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) "GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_DURING_CAL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin0_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin0 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 6 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 6 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ed8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin0_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN0_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin1_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin1 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 4 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 4 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ee0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin1_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN1_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin2_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin2 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX

                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 2 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX

                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 2 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ee8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin2_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN2_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin3_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin3 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value:0 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value:0 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ef0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin3_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN3_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin4_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin4 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 1 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 1 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ef8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin4_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN4_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin5_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin5 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                  Default value: 3 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                  Default value: 3 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin5_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN5_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin6_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin6 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX 0: DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 5 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX 0: DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 5 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin6_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN6_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_bin7_adj
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Bin7 Adj Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 7 */
#else /* Word 0 - Little Endian */
        uint32_t dosc_level_sel        : 4;  /**< [  3:  0](R/W/H) Enums for selecting a value between DOSC_TEMP_MIN and DOSC_TEMP_MAX
                                                                 0 = DOSC_CURRENT_PLUS_ONE
                                                                 1 = DOSC_CURRENT_MINUS_ONE
                                                                 2 = DOSC_MAX_ONE_FOURTH_DOWN
                                                                 3 = DOSC_MIN_ONE_FOURTH_UP
                                                                 4 = DOSC_MAX_ONE_EIGHTH_DOWN
                                                                 5 = DOSC_MIN_ONE_EIGHTH_UP
                                                                 6 = DOSC_MAX_MINUS_ONE
                                                                 7 = DOSC_MIN_PLUS_ONE
                                                                 Default value: 7 */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj bdk_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f10ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_bin7_adj_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_BIN7_ADJ(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_dosc_temp_range_ext_num_bins
 *
 * GSERC Phy0 Top Dosc Temp Range Ext Num Bins Register
 */
union bdk_gsercx_phy0_top_dosc_temp_range_ext_num_bins
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_dosc_temp_range_ext_num_bins_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t temp_bins             : 2;  /**< [  1:  0](R/W/H) Enum for temperature bins supported: 0: 8 bins -40C to -20C; -20C to 0C; 0C to
                                                                 20C; 20C to 40C; 40C to 60C; 60C to 80C; 80C to 100C; 100C and beyond Default
                                                                 value: 0
                                                                 1 = 4 bins -40C to 10C; 11C to 60C; 61C to 110C; 111C to 165C */
#else /* Word 0 - Little Endian */
        uint32_t temp_bins             : 2;  /**< [  1:  0](R/W/H) Enum for temperature bins supported: 0: 8 bins -40C to -20C; -20C to 0C; 0C to
                                                                 20C; 20C to 40C; 40C to 60C; 60C to 80C; 80C to 100C; 100C and beyond Default
                                                                 value: 0
                                                                 1 = 4 bins -40C to 10C; 11C to 60C; 61C to 110C; 111C to 165C */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_dosc_temp_range_ext_num_bins_s cn; */
};
typedef union bdk_gsercx_phy0_top_dosc_temp_range_ext_num_bins bdk_gsercx_phy0_top_dosc_temp_range_ext_num_bins_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ed0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) bdk_gsercx_phy0_top_dosc_temp_range_ext_num_bins_t
#define bustype_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) "GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS"
#define device_bar_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_DOSC_TEMP_RANGE_EXT_NUM_BINS(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_ctrl0
 *
 * GSERC Phy0 Top Err Ctrl0 Register
 */
union bdk_gsercx_phy0_top_err_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_err_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t err_o                 : 1;  /**< [  0:  0](R/W/H) PHY error status.
                                                                 PHY firmware sets sets this to 1 to assert PHY top-level err_o signal. */
#else /* Word 0 - Little Endian */
        uint32_t err_o                 : 1;  /**< [  0:  0](R/W/H) PHY error status.
                                                                 PHY firmware sets sets this to 1 to assert PHY top-level err_o signal. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_err_ctrl0_s cn; */
};
typedef union bdk_gsercx_phy0_top_err_ctrl0 bdk_gsercx_phy0_top_err_ctrl0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_ERR_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_ERR_CTRL0(a) bdk_gsercx_phy0_top_err_ctrl0_t
#define bustype_BDK_GSERCX_PHY0_TOP_ERR_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_ERR_CTRL0(a) "GSERCX_PHY0_TOP_ERR_CTRL0"
#define device_bar_BDK_GSERCX_PHY0_TOP_ERR_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_ERR_CTRL0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_ERR_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_ctrl1
 *
 * GSERC Phy0 Top Err Ctrl1 Register
 */
union bdk_gsercx_phy0_top_err_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_err_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) PHY error status lower 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_7_0          : 8;  /**< [  7:  0](R/W/H) PHY error status lower 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_err_ctrl1_s cn; */
};
typedef union bdk_gsercx_phy0_top_err_ctrl1 bdk_gsercx_phy0_top_err_ctrl1_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_ERR_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_ERR_CTRL1(a) bdk_gsercx_phy0_top_err_ctrl1_t
#define bustype_BDK_GSERCX_PHY0_TOP_ERR_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_ERR_CTRL1(a) "GSERCX_PHY0_TOP_ERR_CTRL1"
#define device_bar_BDK_GSERCX_PHY0_TOP_ERR_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_ERR_CTRL1(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_ERR_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_ctrl2
 *
 * GSERC Phy0 Top Err Ctrl2 Register
 */
union bdk_gsercx_phy0_top_err_ctrl2
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_err_ctrl2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) PHY error status higher 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
#else /* Word 0 - Little Endian */
        uint32_t err_code_15_8         : 8;  /**< [  7:  0](R/W/H) PHY error status higher 8-bits of 16-bit top-level error code. 0 indicates that there is no error. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_err_ctrl2_s cn; */
};
typedef union bdk_gsercx_phy0_top_err_ctrl2 bdk_gsercx_phy0_top_err_ctrl2_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_CTRL2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_CTRL2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d10ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_ERR_CTRL2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_ERR_CTRL2(a) bdk_gsercx_phy0_top_err_ctrl2_t
#define bustype_BDK_GSERCX_PHY0_TOP_ERR_CTRL2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_ERR_CTRL2(a) "GSERCX_PHY0_TOP_ERR_CTRL2"
#define device_bar_BDK_GSERCX_PHY0_TOP_ERR_CTRL2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_ERR_CTRL2(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_ERR_CTRL2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_err_status0
 *
 * GSERC Phy0 Top Err Status0 Register
 */
union bdk_gsercx_phy0_top_err_status0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_err_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t regbus_err            : 1;  /**< [  0:  0](R/W1C/H) Regbug error status.  Write 1 to clear. */
#else /* Word 0 - Little Endian */
        uint32_t regbus_err            : 1;  /**< [  0:  0](R/W1C/H) Regbug error status.  Write 1 to clear. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_err_status0_s cn; */
};
typedef union bdk_gsercx_phy0_top_err_status0 bdk_gsercx_phy0_top_err_status0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_STATUS0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_ERR_STATUS0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_ERR_STATUS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_ERR_STATUS0(a) bdk_gsercx_phy0_top_err_status0_t
#define bustype_BDK_GSERCX_PHY0_TOP_ERR_STATUS0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_ERR_STATUS0(a) "GSERCX_PHY0_TOP_ERR_STATUS0"
#define device_bar_BDK_GSERCX_PHY0_TOP_ERR_STATUS0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_ERR_STATUS0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_ERR_STATUS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_int0_status_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Int0 Status Register
 */
union bdk_gsercx_phy0_top_int0_status_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_int0_status_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t jtag_bs_mode          : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t regbus_err            : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t regbus_err            : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t jtag_bs_mode          : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_int0_status_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_int0_status_rsvd bdk_gsercx_phy0_top_int0_status_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005c88ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_INT0_STATUS_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(a) bdk_gsercx_phy0_top_int0_status_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(a) "GSERCX_PHY0_TOP_INT0_STATUS_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_INT0_STATUS_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_ln0_tx_gb
 *
 * GSERC Phy0 Top Ln0 Tx Gb Register
 */
union bdk_gsercx_phy0_top_ln0_tx_gb
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_ln0_tx_gb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
#else /* Word 0 - Little Endian */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_ln0_tx_gb_s cn; */
};
typedef union bdk_gsercx_phy0_top_ln0_tx_gb bdk_gsercx_phy0_top_ln0_tx_gb_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_LN0_TX_GB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_LN0_TX_GB(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f28ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_LN0_TX_GB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_LN0_TX_GB(a) bdk_gsercx_phy0_top_ln0_tx_gb_t
#define bustype_BDK_GSERCX_PHY0_TOP_LN0_TX_GB(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_LN0_TX_GB(a) "GSERCX_PHY0_TOP_LN0_TX_GB"
#define device_bar_BDK_GSERCX_PHY0_TOP_LN0_TX_GB(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_LN0_TX_GB(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_LN0_TX_GB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_ln1_tx_gb
 *
 * GSERC Phy0 Top Ln1 Tx Gb Register
 */
union bdk_gsercx_phy0_top_ln1_tx_gb
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_ln1_tx_gb_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
#else /* Word 0 - Little Endian */
        uint32_t ml_mode               : 1;  /**< [  0:  0](R/W/H) Multi-lane mode enable; 0=independent operation; 1=multi-lane latency matching mode; default is 0. */
        uint32_t ml_mode_master_ln     : 1;  /**< [  1:  1](R/W/H) Selects the master lane for each lane, valid only when ln()_tx_gb_ml_mode == 1;
                                                                 default is 2'b00=lane0, ... 2'b11=lane3. */
        uint32_t reserved_2            : 1;
        uint32_t ml_mode_master_en     : 1;  /**< [  3:  3](R/W/H) TX Gearbox FIFO enable; valid only when ln()_tx_gb_ml_mode = 1; default is 0. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_ln1_tx_gb_s cn; */
};
typedef union bdk_gsercx_phy0_top_ln1_tx_gb bdk_gsercx_phy0_top_ln1_tx_gb_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_LN1_TX_GB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_LN1_TX_GB(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005f30ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_LN1_TX_GB", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_LN1_TX_GB(a) bdk_gsercx_phy0_top_ln1_tx_gb_t
#define bustype_BDK_GSERCX_PHY0_TOP_LN1_TX_GB(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_LN1_TX_GB(a) "GSERCX_PHY0_TOP_LN1_TX_GB"
#define device_bar_BDK_GSERCX_PHY0_TOP_LN1_TX_GB(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_LN1_TX_GB(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_LN1_TX_GB(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_los_int_en_ctrl_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Los Int En Ctrl Register
 */
union bdk_gsercx_phy0_top_los_int_en_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_los_int_en_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ln1                   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t ln0                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t ln0                   : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t ln1                   : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_los_int_en_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_los_int_en_ctrl_rsvd bdk_gsercx_phy0_top_los_int_en_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005c80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(a) bdk_gsercx_phy0_top_los_int_en_ctrl_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(a) "GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_LOS_INT_EN_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_cfg0
 *
 * GSERC Phy0 Top Phy Cfg0 Register
 */
union bdk_gsercx_phy0_top_phy_cfg0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_cfg0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cpu_clk_freq          : 8;  /**< [  7:  0](R/W/H) CPU clock frequency in units of 10 MHz. */
#else /* Word 0 - Little Endian */
        uint32_t cpu_clk_freq          : 8;  /**< [  7:  0](R/W/H) CPU clock frequency in units of 10 MHz. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_cfg0_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_cfg0 bdk_gsercx_phy0_top_phy_cfg0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CFG0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CFG0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005100ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CFG0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CFG0(a) bdk_gsercx_phy0_top_phy_cfg0_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CFG0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CFG0(a) "GSERCX_PHY0_TOP_PHY_CFG0"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CFG0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CFG0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CFG0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Ctrl0 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ovr_en                : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_5_6          : 2;
        uint32_t phy_ctrl_refclk_ovr_val : 5;/**< [  4:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_refclk_ovr_val : 5;/**< [  4:  0](R/W/H) Reserved. */
        uint32_t reserved_5_6          : 2;
        uint32_t ovr_en                : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl0_rsvd bdk_gsercx_phy0_top_phy_ctrl0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005080ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(a) bdk_gsercx_phy0_top_phy_ctrl0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(a) "GSERCX_PHY0_TOP_PHY_CTRL0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl1_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Ctrl1 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ovr_en                : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t phy_ctrl_rate1_ovr_val : 6; /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_rate1_ovr_val : 6; /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ovr_en                : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl1_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl1_rsvd bdk_gsercx_phy0_top_phy_ctrl1_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005088ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(a) bdk_gsercx_phy0_top_phy_ctrl1_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(a) "GSERCX_PHY0_TOP_PHY_CTRL1_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl2_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Ctrl2 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ovr_en                : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t phy_ctrl_rate2_ovr_val : 6; /**< [  5:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_rate2_ovr_val : 6; /**< [  5:  0](R/W/H) Reserved. */
        uint32_t reserved_6            : 1;
        uint32_t ovr_en                : 1;  /**< [  7:  7](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl2_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl2_rsvd bdk_gsercx_phy0_top_phy_ctrl2_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005090ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(a) bdk_gsercx_phy0_top_phy_ctrl2_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(a) "GSERCX_PHY0_TOP_PHY_CTRL2_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl3_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Ctrl3 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t phy_rext_ready        : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_ready        : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl3_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl3_rsvd bdk_gsercx_phy0_top_phy_ctrl3_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005098ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(a) bdk_gsercx_phy0_top_phy_ctrl3_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(a) "GSERCX_PHY0_TOP_PHY_CTRL3_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl4_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Ctrl4 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_rext_trim         : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_trim         : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl4_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl4_rsvd bdk_gsercx_phy0_top_phy_ctrl4_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(a) bdk_gsercx_phy0_top_phy_ctrl4_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(a) "GSERCX_PHY0_TOP_PHY_CTRL4_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl5
 *
 * GSERC Phy0 Top Phy Ctrl5 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl5
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_rext_ovr_en       : 1;  /**< [  7:  7](R/W/H) Override enable for HSS_PHY_REXT_*_I HSS_PHY_REXT_MASTER_I, HSS_PHY_REXT_READY_I
                                                                 and HSS_PHY_REXT_TRIM_I . */
        uint32_t reserved_2_6          : 5;
        uint32_t phy_rext_ready_ovr_val : 1; /**< [  1:  1](R/W/H) Override value for HSS_PHY_REXT_READY_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_rext_master_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_REXT_MASTER_I in case hardwired tie off is incorrectly done. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_master_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_REXT_MASTER_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_rext_ready_ovr_val : 1; /**< [  1:  1](R/W/H) Override value for HSS_PHY_REXT_READY_I in case hardwired tie off is incorrectly done. */
        uint32_t reserved_2_6          : 5;
        uint32_t phy_rext_ovr_en       : 1;  /**< [  7:  7](R/W/H) Override enable for HSS_PHY_REXT_*_I HSS_PHY_REXT_MASTER_I, HSS_PHY_REXT_READY_I
                                                                 and HSS_PHY_REXT_TRIM_I . */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl5_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl5 bdk_gsercx_phy0_top_phy_ctrl5_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL5(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050b0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL5", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL5(a) bdk_gsercx_phy0_top_phy_ctrl5_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL5(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL5(a) "GSERCX_PHY0_TOP_PHY_CTRL5"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL5(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL5(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL5(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl6
 *
 * GSERC Phy0 Top Phy Ctrl6 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl6
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_rext_trim_ovr_val : 8;  /**< [  7:  0](R/W/H) Override value for HSS_PHY_REXT_TRIM_I in case hardwired tie off is incorrectly done. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_trim_ovr_val : 8;  /**< [  7:  0](R/W/H) Override value for HSS_PHY_REXT_TRIM_I in case hardwired tie off is incorrectly done. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl6_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl6 bdk_gsercx_phy0_top_phy_ctrl6_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL6(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050b8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL6", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL6(a) bdk_gsercx_phy0_top_phy_ctrl6_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL6(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL6(a) "GSERCX_PHY0_TOP_PHY_CTRL6"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL6(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL6(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL6(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_ctrl7
 *
 * GSERC Phy0 Top Phy Ctrl7 Register
 */
union bdk_gsercx_phy0_top_phy_ctrl7
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_ctrl7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_ctrl_vddha_sel_ovr_en : 1;/**< [  7:  7](R/W/H) Override enable for HSS_PHY_CTRL_VDDHA_SEL_I. */
        uint32_t phy_ctrl_vdda_sel_ovr_en : 1;/**< [  6:  6](R/W/H) Override enable for HSS_PHY_CTRL_VDDA_SEL_I. */
        uint32_t reserved_2_5          : 4;
        uint32_t phy_ctrl_vddha_sel_ovr_val : 1;/**< [  1:  1](R/W/H) Override value for HSS_PHY_CTRL_VDDHA_SEL_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_ctrl_vdda_sel_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_CTRL_VDDA_SEL_I in case hardwired tie off is incorrectly done. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_vdda_sel_ovr_val : 1;/**< [  0:  0](R/W/H) Override value for HSS_PHY_CTRL_VDDA_SEL_I in case hardwired tie off is incorrectly done. */
        uint32_t phy_ctrl_vddha_sel_ovr_val : 1;/**< [  1:  1](R/W/H) Override value for HSS_PHY_CTRL_VDDHA_SEL_I in case hardwired tie off is incorrectly done. */
        uint32_t reserved_2_5          : 4;
        uint32_t phy_ctrl_vdda_sel_ovr_en : 1;/**< [  6:  6](R/W/H) Override enable for HSS_PHY_CTRL_VDDA_SEL_I. */
        uint32_t phy_ctrl_vddha_sel_ovr_en : 1;/**< [  7:  7](R/W/H) Override enable for HSS_PHY_CTRL_VDDHA_SEL_I. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_ctrl7_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_ctrl7 bdk_gsercx_phy0_top_phy_ctrl7_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_CTRL7(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80050c0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_CTRL7", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_CTRL7(a) bdk_gsercx_phy0_top_phy_ctrl7_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_CTRL7(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_CTRL7(a) "GSERCX_PHY0_TOP_PHY_CTRL7"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_CTRL7(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_CTRL7(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_CTRL7(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_device_info0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Device Info0 Register
 */
union bdk_gsercx_phy0_top_phy_device_info0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_device_info0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t num_lanes             : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t num_lanes             : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_device_info0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_device_info0_rsvd bdk_gsercx_phy0_top_phy_device_info0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005ec0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(a) bdk_gsercx_phy0_top_phy_device_info0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(a) "GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_DEVICE_INFO0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_stat0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Stat0 Register
 */
union bdk_gsercx_phy0_top_phy_stat0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_stat0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t phy_ctrl_refclk       : 5;  /**< [  4:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_refclk       : 5;  /**< [  4:  0](RO/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_stat0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_stat0_rsvd bdk_gsercx_phy0_top_phy_stat0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005000ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_STAT0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(a) bdk_gsercx_phy0_top_phy_stat0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(a) "GSERCX_PHY0_TOP_PHY_STAT0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_STAT0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_stat1_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Stat1 Register
 */
union bdk_gsercx_phy0_top_phy_stat1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_stat1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t phy_ctrl_rate1        : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_rate1        : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_stat1_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_stat1_rsvd bdk_gsercx_phy0_top_phy_stat1_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005008ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_STAT1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(a) bdk_gsercx_phy0_top_phy_stat1_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(a) "GSERCX_PHY0_TOP_PHY_STAT1_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_STAT1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_stat2_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Stat2 Register
 */
union bdk_gsercx_phy0_top_phy_stat2_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_stat2_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t phy_ctrl_rate2        : 6;  /**< [  5:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_ctrl_rate2        : 6;  /**< [  5:  0](RO/H) Reserved. */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_stat2_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_stat2_rsvd bdk_gsercx_phy0_top_phy_stat2_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005010ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_STAT2_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(a) bdk_gsercx_phy0_top_phy_stat2_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(a) "GSERCX_PHY0_TOP_PHY_STAT2_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_STAT2_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_stat3_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Stat3 Register
 */
union bdk_gsercx_phy0_top_phy_stat3_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_stat3_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t phy_rext_ready        : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t phy_rext_master       : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_master       : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t phy_rext_ready        : 1;  /**< [  1:  1](RO/H) Reserved. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_stat3_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_stat3_rsvd bdk_gsercx_phy0_top_phy_stat3_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005018ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_STAT3_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(a) bdk_gsercx_phy0_top_phy_stat3_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(a) "GSERCX_PHY0_TOP_PHY_STAT3_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_STAT3_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_stat4_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Stat4 Register
 */
union bdk_gsercx_phy0_top_phy_stat4_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_stat4_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t phy_rext_trim         : 8;  /**< [  7:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t phy_rext_trim         : 8;  /**< [  7:  0](RO/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_stat4_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_stat4_rsvd bdk_gsercx_phy0_top_phy_stat4_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005020ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_STAT4_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(a) bdk_gsercx_phy0_top_phy_stat4_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(a) "GSERCX_PHY0_TOP_PHY_STAT4_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_STAT4_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_phy_stat6_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Phy Stat6 Register
 */
union bdk_gsercx_phy0_top_phy_stat6_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_phy_stat6_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t refclk_pad_ena        : 1;  /**< [  0:  0](RO/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t refclk_pad_ena        : 1;  /**< [  0:  0](RO/H) Reserved. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_phy_stat6_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_phy_stat6_rsvd bdk_gsercx_phy0_top_phy_stat6_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005030ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_PHY_STAT6_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(a) bdk_gsercx_phy0_top_phy_stat6_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(a) "GSERCX_PHY0_TOP_PHY_STAT6_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_PHY_STAT6_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_arb_ctrl_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Regbus Arb Ctrl Register
 */
union bdk_gsercx_phy0_top_regbus_arb_ctrl_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_arb_ctrl_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t park_master           : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t park_en               : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t park_en               : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t park_master           : 2;  /**< [  2:  1](R/W/H) Reserved. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_arb_ctrl_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_arb_ctrl_rsvd bdk_gsercx_phy0_top_regbus_arb_ctrl_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005cc8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(a) bdk_gsercx_phy0_top_regbus_arb_ctrl_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(a) "GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ARB_CTRL_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_ctrl
 *
 * GSERC Phy0 Top Regbus Err Info Ctrl Register
 */
union bdk_gsercx_phy0_top_regbus_err_info_ctrl
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_err_info_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t clr                   : 1;  /**< [  0:  0](R/W/H) Regbus error information clear.
                                                                 Write 1 to clear the debug info presented in REGBUS_ERR_INFO_STATUS* registers. */
#else /* Word 0 - Little Endian */
        uint32_t clr                   : 1;  /**< [  0:  0](R/W/H) Regbus error information clear.
                                                                 Write 1 to clear the debug info presented in REGBUS_ERR_INFO_STATUS* registers. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_err_info_ctrl_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_err_info_ctrl bdk_gsercx_phy0_top_regbus_err_info_ctrl_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d38ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) bdk_gsercx_phy0_top_regbus_err_info_ctrl_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status0
 *
 * GSERC Phy0 Top Regbus Err Info Status0 Register
 */
union bdk_gsercx_phy0_top_regbus_err_info_status0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_err_info_status0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t transfer_rw           : 1;  /**< [  2:  2](RO/H) Regbus error information errored register transfer type:
                                                                 0 = read transfer
                                                                 1 = write transfer */
        uint32_t err_type              : 2;  /**< [  1:  0](RO/H) Regbus error information type of error:
                                                                 1 = err ack
                                                                 2 = timeout */
#else /* Word 0 - Little Endian */
        uint32_t err_type              : 2;  /**< [  1:  0](RO/H) Regbus error information type of error:
                                                                 1 = err ack
                                                                 2 = timeout */
        uint32_t transfer_rw           : 1;  /**< [  2:  2](RO/H) Regbus error information errored register transfer type:
                                                                 0 = read transfer
                                                                 1 = write transfer */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_err_info_status0_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_err_info_status0 bdk_gsercx_phy0_top_regbus_err_info_status0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d40ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) bdk_gsercx_phy0_top_regbus_err_info_status0_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status1
 *
 * GSERC Phy0 Top Regbus Err Info Status1 Register
 */
union bdk_gsercx_phy0_top_regbus_err_info_status1
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_err_info_status1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_addr_lsb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address lower bits. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_addr_lsb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address lower bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_err_info_status1_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_err_info_status1 bdk_gsercx_phy0_top_regbus_err_info_status1_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d48ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) bdk_gsercx_phy0_top_regbus_err_info_status1_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status2
 *
 * GSERC Phy0 Top Regbus Err Info Status2 Register
 */
union bdk_gsercx_phy0_top_regbus_err_info_status2
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_err_info_status2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_addr_msb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address upper bits. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_addr_msb     : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer address upper bits. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_err_info_status2_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_err_info_status2 bdk_gsercx_phy0_top_regbus_err_info_status2_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d50ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) bdk_gsercx_phy0_top_regbus_err_info_status2_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS2(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status3
 *
 * GSERC Phy0 Top Regbus Err Info Status3 Register
 */
union bdk_gsercx_phy0_top_regbus_err_info_status3
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_err_info_status3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_wd           : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer write data. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_wd           : 8;  /**< [  7:  0](RO/H) Regbus error information errored register transfer write data. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_err_info_status3_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_err_info_status3 bdk_gsercx_phy0_top_regbus_err_info_status3_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d58ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) bdk_gsercx_phy0_top_regbus_err_info_status3_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS3(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_err_info_status4
 *
 * GSERC Phy0 Top Regbus Err Info Status4 Register
 */
union bdk_gsercx_phy0_top_regbus_err_info_status4
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_err_info_status4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t transfer_wr_bit_en    : 8;  /**< [  7:  0](RO/H) Regbus error information register transfer write data bit enable. */
#else /* Word 0 - Little Endian */
        uint32_t transfer_wr_bit_en    : 8;  /**< [  7:  0](RO/H) Regbus error information register transfer write data bit enable. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_err_info_status4_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_err_info_status4 bdk_gsercx_phy0_top_regbus_err_info_status4_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d60ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) bdk_gsercx_phy0_top_regbus_err_info_status4_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) "GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_ERR_INFO_STATUS4(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_regbus_timer_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Regbus Timer Register
 */
union bdk_gsercx_phy0_top_regbus_timer_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_regbus_timer_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t load_val              : 8;  /**< [  7:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t load_val              : 8;  /**< [  7:  0](R/W/H) Reserved. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_regbus_timer_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_regbus_timer_rsvd bdk_gsercx_phy0_top_regbus_timer_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005cc0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(a) bdk_gsercx_phy0_top_regbus_timer_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(a) "GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_REGBUS_TIMER_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_reset_ctrl_cm0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Reset Ctrl Cm0 Register
 */
union bdk_gsercx_phy0_top_reset_ctrl_cm0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_reset_ctrl_cm0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_3_5          : 3;
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reserved_3_5          : 3;
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_reset_ctrl_cm0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_reset_ctrl_cm0_rsvd bdk_gsercx_phy0_top_reset_ctrl_cm0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005280ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(a) bdk_gsercx_phy0_top_reset_ctrl_cm0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(a) "GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_RESET_CTRL_CM0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_reset_ctrl_ln0_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Reset Ctrl Ln0 Register
 */
union bdk_gsercx_phy0_top_reset_ctrl_ln0_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_reset_ctrl_ln0_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_reset_ctrl_ln0_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_reset_ctrl_ln0_rsvd bdk_gsercx_phy0_top_reset_ctrl_ln0_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80052a0ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) bdk_gsercx_phy0_top_reset_ctrl_ln0_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) "GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN0_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_reset_ctrl_ln1_rsvd
 *
 * INTERNAL: GSERC Phy0 Top Reset Ctrl Ln1 Register
 */
union bdk_gsercx_phy0_top_reset_ctrl_ln1_rsvd
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_reset_ctrl_ln1_rsvd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
#else /* Word 0 - Little Endian */
        uint32_t core_sw_reset         : 1;  /**< [  0:  0](R/W/H) Reserved. */
        uint32_t reg_sw_reset          : 1;  /**< [  1:  1](R/W/H) Reserved. */
        uint32_t subcore_sw_reset      : 1;  /**< [  2:  2](R/W/H) Reserved. */
        uint32_t txdp_sw_reset         : 1;  /**< [  3:  3](R/W/H) Reserved. */
        uint32_t rxdp_sw_reset         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t los_sw_reset          : 1;  /**< [  5:  5](R/W/H) Reserved. */
        uint32_t cal_sw_reset          : 1;  /**< [  6:  6](R/W/H) Reserved. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_reset_ctrl_ln1_rsvd_s cn; */
};
typedef union bdk_gsercx_phy0_top_reset_ctrl_ln1_rsvd bdk_gsercx_phy0_top_reset_ctrl_ln1_rsvd_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a80052a8ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) bdk_gsercx_phy0_top_reset_ctrl_ln1_rsvd_t
#define bustype_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) "GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD"
#define device_bar_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_RESET_CTRL_LN1_RSVD(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_sim_ctrl
 *
 * GSERC Phy0 Top Sim Ctrl Register
 */
union bdk_gsercx_phy0_top_sim_ctrl
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_sim_ctrl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t sv_real_model         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t fast_sim              : 3;  /**< [  3:  1](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set to enable simulation time optimizations in the firmware. Do not set on actual silicon.
                                                                 0 = No fast sim optimizations enabled
                                                                 1 = fast_sim optimizations enabled
                                                                 others = reserved */
        uint32_t sim_1b_model          : 1;  /**< [  0:  0](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set if running a 1b simulation.  Firmware may check this field to discover its
                                                                 runtime context.  Do not set on actual silicon. */
#else /* Word 0 - Little Endian */
        uint32_t sim_1b_model          : 1;  /**< [  0:  0](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set if running a 1b simulation.  Firmware may check this field to discover its
                                                                 runtime context.  Do not set on actual silicon. */
        uint32_t fast_sim              : 3;  /**< [  3:  1](R/W/H) For simulation use only.  Do not touch this register when working with physical PHY.
                                                                 Set to enable simulation time optimizations in the firmware. Do not set on actual silicon.
                                                                 0 = No fast sim optimizations enabled
                                                                 1 = fast_sim optimizations enabled
                                                                 others = reserved */
        uint32_t sv_real_model         : 1;  /**< [  4:  4](R/W/H) Reserved. */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_sim_ctrl_s cn; */
};
typedef union bdk_gsercx_phy0_top_sim_ctrl bdk_gsercx_phy0_top_sim_ctrl_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_SIM_CTRL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_SIM_CTRL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005e80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_SIM_CTRL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_SIM_CTRL(a) bdk_gsercx_phy0_top_sim_ctrl_t
#define bustype_BDK_GSERCX_PHY0_TOP_SIM_CTRL(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_SIM_CTRL(a) "GSERCX_PHY0_TOP_SIM_CTRL"
#define device_bar_BDK_GSERCX_PHY0_TOP_SIM_CTRL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_SIM_CTRL(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_SIM_CTRL(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_addr_15_8
 *
 * GSERC Phy0 Top Tbus Addr 15 8 Register
 */
union bdk_gsercx_phy0_top_tbus_addr_15_8
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_tbus_addr_15_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS upper 8-bits of the 16-bit address. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS upper 8-bits of the 16-bit address. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_tbus_addr_15_8_s cn; */
};
typedef union bdk_gsercx_phy0_top_tbus_addr_15_8 bdk_gsercx_phy0_top_tbus_addr_15_8_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d88ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_TBUS_ADDR_15_8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) bdk_gsercx_phy0_top_tbus_addr_15_8_t
#define bustype_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) "GSERCX_PHY0_TOP_TBUS_ADDR_15_8"
#define device_bar_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_15_8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_addr_7_0
 *
 * GSERC Phy0 Top Tbus Addr 7 0 Register
 */
union bdk_gsercx_phy0_top_tbus_addr_7_0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_tbus_addr_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS lower 8-bits of the 16-bit address. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS lower 8-bits of the 16-bit address. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_tbus_addr_7_0_s cn; */
};
typedef union bdk_gsercx_phy0_top_tbus_addr_7_0 bdk_gsercx_phy0_top_tbus_addr_7_0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d80ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_TBUS_ADDR_7_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) bdk_gsercx_phy0_top_tbus_addr_7_0_t
#define bustype_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) "GSERCX_PHY0_TOP_TBUS_ADDR_7_0"
#define device_bar_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_TBUS_ADDR_7_0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_ctrl0
 *
 * GSERC Phy0 Top Tbus Ctrl0 Register
 */
union bdk_gsercx_phy0_top_tbus_ctrl0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_tbus_ctrl0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t clock_gate0           : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
#else /* Word 0 - Little Endian */
        uint32_t clock_gate0           : 8;  /**< [  7:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_tbus_ctrl0_s cn; */
};
typedef union bdk_gsercx_phy0_top_tbus_ctrl0 bdk_gsercx_phy0_top_tbus_ctrl0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d90ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_TBUS_CTRL0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(a) bdk_gsercx_phy0_top_tbus_ctrl0_t
#define bustype_BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(a) "GSERCX_PHY0_TOP_TBUS_CTRL0"
#define device_bar_BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_TBUS_CTRL0(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_ctrl1
 *
 * GSERC Phy0 Top Tbus Ctrl1 Register
 */
union bdk_gsercx_phy0_top_tbus_ctrl1
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_tbus_ctrl1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t clock_gate1           : 4;  /**< [  3:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
#else /* Word 0 - Little Endian */
        uint32_t clock_gate1           : 4;  /**< [  3:  0](R/W/H) Digital test bus TBUS clock gating enable for clocks going to TBUS. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_tbus_ctrl1_s cn; */
};
typedef union bdk_gsercx_phy0_top_tbus_ctrl1 bdk_gsercx_phy0_top_tbus_ctrl1_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005d98ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_TBUS_CTRL1", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(a) bdk_gsercx_phy0_top_tbus_ctrl1_t
#define bustype_BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(a) "GSERCX_PHY0_TOP_TBUS_CTRL1"
#define device_bar_BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_TBUS_CTRL1(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_data_11_8
 *
 * GSERC Phy0 Top Tbus Data 11 8 Register
 */
union bdk_gsercx_phy0_top_tbus_data_11_8
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_tbus_data_11_8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Digital test bus TBUS output bits [11:8]. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](RO/H) Digital test bus TBUS output bits [11:8]. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_tbus_data_11_8_s cn; */
};
typedef union bdk_gsercx_phy0_top_tbus_data_11_8 bdk_gsercx_phy0_top_tbus_data_11_8_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005e08ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_TBUS_DATA_11_8", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) bdk_gsercx_phy0_top_tbus_data_11_8_t
#define bustype_BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) "GSERCX_PHY0_TOP_TBUS_DATA_11_8"
#define device_bar_BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_TBUS_DATA_11_8(a) (a),-1,-1,-1

/**
 * Register (RSL32b) gserc#_phy0_top_tbus_data_7_0
 *
 * GSERC Phy0 Top Tbus Data 7 0 Register
 */
union bdk_gsercx_phy0_top_tbus_data_7_0
{
    uint32_t u;
    struct bdk_gsercx_phy0_top_tbus_data_7_0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Digital test bus TBUS output bits [7:0]. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](RO/H) Digital test bus TBUS output bits [7:0]. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_phy0_top_tbus_data_7_0_s cn; */
};
typedef union bdk_gsercx_phy0_top_tbus_data_7_0 bdk_gsercx_phy0_top_tbus_data_7_0_t;

static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8005e00ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_PHY0_TOP_TBUS_DATA_7_0", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) bdk_gsercx_phy0_top_tbus_data_7_0_t
#define bustype_BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) BDK_CSR_TYPE_RSL32b
#define basename_BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) "GSERCX_PHY0_TOP_TBUS_DATA_7_0"
#define device_bar_BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) (a)
#define arguments_BDK_GSERCX_PHY0_TOP_TBUS_DATA_7_0(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_pmem#
 *
 * GSERC Program Memory (96kB) Registers
 */
union bdk_gsercx_pmemx
{
    uint64_t u;
    struct bdk_gsercx_pmemx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) Firmware memory for GSERC microcontroller. */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) Firmware memory for GSERC microcontroller. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_pmemx_s cn; */
};
typedef union bdk_gsercx_pmemx bdk_gsercx_pmemx_t;

static inline uint64_t BDK_GSERCX_PMEMX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_PMEMX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=12287)))
        return 0x87e0a80a0000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x3fff);
    __bdk_csr_fatal("GSERCX_PMEMX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_PMEMX(a,b) bdk_gsercx_pmemx_t
#define bustype_BDK_GSERCX_PMEMX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_PMEMX(a,b) "GSERCX_PMEMX"
#define device_bar_BDK_GSERCX_PMEMX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_PMEMX(a,b) (a)
#define arguments_BDK_GSERCX_PMEMX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_refclk_ctr
 *
 * GSERC Reference Clock Cycle Counter Register
 * A free-running counter of PLL reference clock cycles to enable rough
 * confirmation of reference clock frequency via software. Read the counter; wait some
 * time, e.g., 100ms; read the counter; calculate frequency based on the difference in
 * values during the known wait time.
 *
 * Internal:
 * Lowest address of Marvell wrapper CSRs that are reset by domain reset (when
 * enabled).
 */
union bdk_gsercx_refclk_ctr
{
    uint64_t u;
    struct bdk_gsercx_refclk_ctr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running count of PLL reference clock cycles. */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 64; /**< [ 63:  0](R/W/H) Running count of PLL reference clock cycles. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_refclk_ctr_s cn; */
};
typedef union bdk_gsercx_refclk_ctr bdk_gsercx_refclk_ctr_t;

static inline uint64_t BDK_GSERCX_REFCLK_CTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_REFCLK_CTR(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8081000ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_REFCLK_CTR", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_REFCLK_CTR(a) bdk_gsercx_refclk_ctr_t
#define bustype_BDK_GSERCX_REFCLK_CTR(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_REFCLK_CTR(a) "GSERCX_REFCLK_CTR"
#define device_bar_BDK_GSERCX_REFCLK_CTR(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_REFCLK_CTR(a) (a)
#define arguments_BDK_GSERCX_REFCLK_CTR(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_rx_term_ctl
 *
 * Receiver Termination Under perst (by lane) Control Register
 */
union bdk_gsercx_rx_term_ctl
{
    uint64_t u;
    struct bdk_gsercx_rx_term_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t term_ctl              : 64; /**< [ 63:  0](R/W) Placeholder until RTL is written. */
#else /* Word 0 - Little Endian */
        uint64_t term_ctl              : 64; /**< [ 63:  0](R/W) Placeholder until RTL is written. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_rx_term_ctl_s cn; */
};
typedef union bdk_gsercx_rx_term_ctl bdk_gsercx_rx_term_ctl_t;

static inline uint64_t BDK_GSERCX_RX_TERM_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_RX_TERM_CTL(unsigned long a)
{
    if (bdk_is_model(OCTEONTX_LOKI) && (a<=4))
        return 0x87e0a8080070ll + 0x1000000ll * ((a) & 0x7);
    __bdk_csr_fatal("GSERCX_RX_TERM_CTL", 1, a, 0, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_RX_TERM_CTL(a) bdk_gsercx_rx_term_ctl_t
#define bustype_BDK_GSERCX_RX_TERM_CTL(a) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_RX_TERM_CTL(a) "GSERCX_RX_TERM_CTL"
#define device_bar_BDK_GSERCX_RX_TERM_CTL(a) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_RX_TERM_CTL(a) (a)
#define arguments_BDK_GSERCX_RX_TERM_CTL(a) (a),-1,-1,-1

/**
 * Register (RSL) gserc#_scratch#
 *
 * GSERC Scratch Registers
 * Internal:
 * Lowest address of Marvell wrapper CSRs. Also lowest address of Marvell wrapper CSRs
 * that are reset by cold reset only, i.e, never reset by domain reset.
 */
union bdk_gsercx_scratchx
{
    uint64_t u;
    struct bdk_gsercx_scratchx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact.
                                                                 Internal:
                                                                 Reset by cold reset (only). */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact.
                                                                 Internal:
                                                                 Reset by cold reset (only). */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_scratchx_s cn; */
};
typedef union bdk_gsercx_scratchx bdk_gsercx_scratchx_t;

static inline uint64_t BDK_GSERCX_SCRATCHX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_SCRATCHX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=7)))
        return 0x87e0a8080000ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("GSERCX_SCRATCHX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_SCRATCHX(a,b) bdk_gsercx_scratchx_t
#define bustype_BDK_GSERCX_SCRATCHX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_SCRATCHX(a,b) "GSERCX_SCRATCHX"
#define device_bar_BDK_GSERCX_SCRATCHX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_SCRATCHX(a,b) (a)
#define arguments_BDK_GSERCX_SCRATCHX(a,b) (a),(b),-1,-1

/**
 * Register (RSL) gserc#_scratch_dom_rst#
 *
 * GSERC Scratch Registers
 */
union bdk_gsercx_scratch_dom_rstx
{
    uint64_t u;
    struct bdk_gsercx_scratch_dom_rstx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact.
                                                                 Internal:
                                                                 Reset by cold reset and (if enabled by GSERC()_DOMAIN_RST_EN) domain reset. */
#else /* Word 0 - Little Endian */
        uint64_t scratch               : 64; /**< [ 63:  0](R/W) Scratch registers for software use, no hardware impact.
                                                                 Internal:
                                                                 Reset by cold reset and (if enabled by GSERC()_DOMAIN_RST_EN) domain reset. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_gsercx_scratch_dom_rstx_s cn; */
};
typedef union bdk_gsercx_scratch_dom_rstx bdk_gsercx_scratch_dom_rstx_t;

static inline uint64_t BDK_GSERCX_SCRATCH_DOM_RSTX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_GSERCX_SCRATCH_DOM_RSTX(unsigned long a, unsigned long b)
{
    if (bdk_is_model(OCTEONTX_LOKI) && ((a<=4) && (b<=1)))
        return 0x87e0a80810d0ll + 0x1000000ll * ((a) & 0x7) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("GSERCX_SCRATCH_DOM_RSTX", 2, a, b, 0, 0, 0, 0);
}

#define typedef_BDK_GSERCX_SCRATCH_DOM_RSTX(a,b) bdk_gsercx_scratch_dom_rstx_t
#define bustype_BDK_GSERCX_SCRATCH_DOM_RSTX(a,b) BDK_CSR_TYPE_RSL
#define basename_BDK_GSERCX_SCRATCH_DOM_RSTX(a,b) "GSERCX_SCRATCH_DOM_RSTX"
#define device_bar_BDK_GSERCX_SCRATCH_DOM_RSTX(a,b) 0x0 /* PF_BAR0 */
#define busnum_BDK_GSERCX_SCRATCH_DOM_RSTX(a,b) (a)
#define arguments_BDK_GSERCX_SCRATCH_DOM_RSTX(a,b) (a),(b),-1,-1

#endif /* __BDK_CSRS_GSERC_H__ */
