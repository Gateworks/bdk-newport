#ifndef __BDK_CSRS_TNS_SST_H__
#define __BDK_CSRS_TNS_SST_H__
/* This file is auto-generated. Do not edit */

/***********************license start***************
 * Copyright (c) 2003-2017  Cavium Inc. (support@cavium.com). All rights
 * reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.

 *   * Neither the name of Cavium Inc. nor the names of
 *     its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written
 *     permission.

 * This Software, including technical data, may be subject to U.S. export  control
 * laws, including the U.S. Export Administration Act and its  associated
 * regulations, and may be subject to export or import  regulations in other
 * countries.

 * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
 * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
 * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
 * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
 * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
 * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
 ***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * Cavium TNS_SST.
 *
 * This file is auto generated. Do not edit.
 *
 */

/**
 * Enumeration tns_sst_bar_e
 *
 * TNS Base Address Register Enumeration
 * Enumerates the base address registers.
 */
#define BDK_TNS_SST_BAR_E_TNS_SST_PF_BAR2 (0x842040000000ll)
#define BDK_TNS_SST_BAR_E_TNS_SST_PF_BAR2_SIZE 0x40000000ull

/**
 * Register (NCB) tns_sde_cfg_spare
 *
 * TNS SDE Configuration Spare Register
 * Scratch register for SDE
 */
union bdk_tns_sde_cfg_spare
{
    uint64_t u;
    struct bdk_tns_sde_cfg_spare_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t field                 : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t field                 : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cfg_spare_s cn; */
};
typedef union bdk_tns_sde_cfg_spare bdk_tns_sde_cfg_spare_t;

#define BDK_TNS_SDE_CFG_SPARE BDK_TNS_SDE_CFG_SPARE_FUNC()
static inline uint64_t BDK_TNS_SDE_CFG_SPARE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CFG_SPARE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060740000ll;
    __bdk_csr_fatal("TNS_SDE_CFG_SPARE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CFG_SPARE bdk_tns_sde_cfg_spare_t
#define bustype_BDK_TNS_SDE_CFG_SPARE BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_CFG_SPARE "TNS_SDE_CFG_SPARE"
#define device_bar_BDK_TNS_SDE_CFG_SPARE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CFG_SPARE 0
#define arguments_BDK_TNS_SDE_CFG_SPARE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_bk_ecc_ctl#
 *
 * TNS SDE CNT Bank Bank ECC Control Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_bk_ecc_ctlx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cor_dis               : 1;  /**< [  6:  6](R/W) -- */
        uint32_t flip_sb_ecc           : 3;  /**< [  5:  3](R/W) -- */
        uint32_t flip_db_ecc           : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t flip_db_ecc           : 3;  /**< [  2:  0](R/W) -- */
        uint32_t flip_sb_ecc           : 3;  /**< [  5:  3](R/W) -- */
        uint32_t cor_dis               : 1;  /**< [  6:  6](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_bk_ecc_ctlx bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x8420606100c0ll + 0x20000ll * ((a) & 0x3) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_BK_ECC_CTLX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(a,b) bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(a,b) "TNS_SDE_CNT_BKX_BK_ECC_CTLX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_ctr_ovfl_sta#
 *
 * TNS SDE CNT Bank Counter Overflow Status Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_ctr_ovfl_stax
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t fifo_usage            : 5;  /**< [ 23: 19](R/W/H) -- */
        uint32_t ctr_id                : 16; /**< [ 18:  3](R/W/H) -- */
        uint32_t ovfl_bmp              : 3;  /**< [  2:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ovfl_bmp              : 3;  /**< [  2:  0](R/W/H) -- */
        uint32_t ctr_id                : 16; /**< [ 18:  3](R/W/H) -- */
        uint32_t fifo_usage            : 5;  /**< [ 23: 19](R/W/H) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_ctr_ovfl_stax bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610030ll + 0x20000ll * ((a) & 0x3) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_CTR_OVFL_STAX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(a,b) bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_t
#define bustype_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(a,b) "TNS_SDE_CNT_BKX_CTR_OVFL_STAX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_ecc_int_en_hi#
 *
 * TNS SDE CNT Bank ECC Interrrupt Enable High Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_ecc_int_en_hix
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_ecc_int_en_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t sb_err                : 3;  /**< [  5:  3](R/W) -- */
        uint32_t db_err                : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 3;  /**< [  2:  0](R/W) -- */
        uint32_t sb_err                : 3;  /**< [  5:  3](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_ecc_int_en_hix_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_ecc_int_en_hix bdk_tns_sde_cnt_bkx_ecc_int_en_hix_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610084ll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_ECC_INT_EN_HIX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(a,b) bdk_tns_sde_cnt_bkx_ecc_int_en_hix_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(a,b) "TNS_SDE_CNT_BKX_ECC_INT_EN_HIX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_ecc_int_en_lo#
 *
 * TNS SDE CNT Bank ECC Interrrupt Enable Low Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_ecc_int_en_lox
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_ecc_int_en_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t sb_err                : 3;  /**< [  5:  3](R/W) -- */
        uint32_t db_err                : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 3;  /**< [  2:  0](R/W) -- */
        uint32_t sb_err                : 3;  /**< [  5:  3](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_ecc_int_en_lox_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_ecc_int_en_lox bdk_tns_sde_cnt_bkx_ecc_int_en_lox_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610088ll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_ECC_INT_EN_LOX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(a,b) bdk_tns_sde_cnt_bkx_ecc_int_en_lox_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(a,b) "TNS_SDE_CNT_BKX_ECC_INT_EN_LOX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_ecc_int_frc#
 *
 * TNS SDE CNT Bank ECC Interrrupt Force Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_ecc_int_frcx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_ecc_int_frcx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t sb_err                : 3;  /**< [  5:  3](WO) -- */
        uint32_t db_err                : 3;  /**< [  2:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 3;  /**< [  2:  0](WO) -- */
        uint32_t sb_err                : 3;  /**< [  5:  3](WO) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_ecc_int_frcx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_ecc_int_frcx bdk_tns_sde_cnt_bkx_ecc_int_frcx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x84206061008cll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_ECC_INT_FRCX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(a,b) bdk_tns_sde_cnt_bkx_ecc_int_frcx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(a,b) "TNS_SDE_CNT_BKX_ECC_INT_FRCX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_ecc_int_w1c#
 *
 * TNS SDE CNT Bank ECC Interrrupt W1C Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_ecc_int_w1cx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_ecc_int_w1cx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t sb_err                : 3;  /**< [  5:  3](R/W1C/H) -- */
        uint32_t db_err                : 3;  /**< [  2:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 3;  /**< [  2:  0](R/W1C/H) -- */
        uint32_t sb_err                : 3;  /**< [  5:  3](R/W1C/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_ecc_int_w1cx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_ecc_int_w1cx bdk_tns_sde_cnt_bkx_ecc_int_w1cx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610080ll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_ECC_INT_W1CX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(a,b) bdk_tns_sde_cnt_bkx_ecc_int_w1cx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(a,b) "TNS_SDE_CNT_BKX_ECC_INT_W1CX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_fif_int_en_hi#
 *
 * TNS SDE CNT Bank FIFO Interrrupt Enable High Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_fif_int_en_hix
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_fif_int_en_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fifo_full             : 1;  /**< [  1:  1](R/W) -- */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](R/W) -- */
        uint32_t fifo_full             : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_fif_int_en_hix_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_fif_int_en_hix bdk_tns_sde_cnt_bkx_fif_int_en_hix_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610044ll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_FIF_INT_EN_HIX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(a,b) bdk_tns_sde_cnt_bkx_fif_int_en_hix_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(a,b) "TNS_SDE_CNT_BKX_FIF_INT_EN_HIX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_fif_int_en_lo#
 *
 * TNS SDE CNT Bank FIFO Interrrupt Enable Low Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_fif_int_en_lox
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_fif_int_en_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fifo_full             : 1;  /**< [  1:  1](R/W) -- */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](R/W) -- */
        uint32_t fifo_full             : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_fif_int_en_lox_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_fif_int_en_lox bdk_tns_sde_cnt_bkx_fif_int_en_lox_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610048ll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_FIF_INT_EN_LOX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(a,b) bdk_tns_sde_cnt_bkx_fif_int_en_lox_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(a,b) "TNS_SDE_CNT_BKX_FIF_INT_EN_LOX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_fif_int_frc#
 *
 * TNS SDE CNT Bank FIFO Interrrupt Force Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_fif_int_frcx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_fif_int_frcx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fifo_full             : 1;  /**< [  1:  1](WO) -- */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](WO) -- */
        uint32_t fifo_full             : 1;  /**< [  1:  1](WO) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_fif_int_frcx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_fif_int_frcx bdk_tns_sde_cnt_bkx_fif_int_frcx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x84206061004cll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_FIF_INT_FRCX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(a,b) bdk_tns_sde_cnt_bkx_fif_int_frcx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(a,b) "TNS_SDE_CNT_BKX_FIF_INT_FRCX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_fif_int_w1c#
 *
 * TNS SDE CNT Bank FIFO Interrrupt W1C Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_fif_int_w1cx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_fif_int_w1cx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t fifo_full             : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_non_empty        : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint32_t fifo_full             : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_fif_int_w1cx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_fif_int_w1cx bdk_tns_sde_cnt_bkx_fif_int_w1cx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610040ll + 0x20000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_FIF_INT_W1CX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(a,b) bdk_tns_sde_cnt_bkx_fif_int_w1cx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(a,b) "TNS_SDE_CNT_BKX_FIF_INT_W1CX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_lock
 *
 * TNS SDE CNT Bank Lock Registers
 * Lock Register
 */
union bdk_tns_sde_cnt_bkx_lock
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_lock_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_lock bdk_tns_sde_cnt_bkx_lock_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x8420606100d0ll + 0x20000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_LOCK(a) bdk_tns_sde_cnt_bkx_lock_t
#define bustype_BDK_TNS_SDE_CNT_BKX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_LOCK(a) "TNS_SDE_CNT_BKX_LOCK"
#define device_bar_BDK_TNS_SDE_CNT_BKX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_mem#d#_w#
 *
 * TNS SDE CNT Bank Memory Registers
 * --
 * Bits[31:16] in _W[8] are unused.
 * When writing, the MSBs (word 8) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_cnt_bkx_memxdx_wx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_memxdx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_memxdx_wx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_memxdx_wx bdk_tns_sde_cnt_bkx_memxdx_wx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3) && (c<=255) && (d<=8)))
        return 0x842060600000ll + 0x20000ll * ((a) & 0x3) + 0x4000ll * ((b) & 0x3) + 0x40ll * ((c) & 0xff) + 4ll * ((d) & 0xf);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_MEMXDX_WX", 4, a, b, c, d);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(a,b,c,d) bdk_tns_sde_cnt_bkx_memxdx_wx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(a,b,c,d) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(a,b,c,d) "TNS_SDE_CNT_BKX_MEMXDX_WX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(a,b,c,d) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(a,b,c,d) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) tns_sde_cnt_bk#_mode#
 *
 * TNS SDE CNT Bank Mode Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_modex
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_modex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t wrap_around           : 1;  /**< [  7:  7](R/W) -- */
        uint32_t clear_on_read         : 1;  /**< [  6:  6](R/W) -- */
        uint32_t tile_rst              : 1;  /**< [  5:  5](R/W) -- */
        uint32_t mode                  : 4;  /**< [  4:  1](R/W) -- */
        uint32_t ooo                   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ooo                   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t mode                  : 4;  /**< [  4:  1](R/W) -- */
        uint32_t tile_rst              : 1;  /**< [  5:  5](R/W) -- */
        uint32_t clear_on_read         : 1;  /**< [  6:  6](R/W) -- */
        uint32_t wrap_around           : 1;  /**< [  7:  7](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_modex_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_modex bdk_tns_sde_cnt_bkx_modex_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODEX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODEX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610000ll + 0x20000ll * ((a) & 0x3) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_MODEX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_MODEX(a,b) bdk_tns_sde_cnt_bkx_modex_t
#define bustype_BDK_TNS_SDE_CNT_BKX_MODEX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_MODEX(a,b) "TNS_SDE_CNT_BKX_MODEX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_MODEX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_MODEX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_MODEX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_cnt_bk#_mode_pol#
 *
 * TNS SDE CNT Bank Mode POL Registers
 * --
 */
union bdk_tns_sde_cnt_bkx_mode_polx
{
    uint64_t u;
    struct bdk_tns_sde_cnt_bkx_mode_polx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_46_63        : 18;
        uint64_t refr_en               : 1;  /**< [ 45: 45](R/W) -- */
        uint64_t unit_time             : 32; /**< [ 44: 13](R/W) -- */
        uint64_t refr_time_gran_expo   : 4;  /**< [ 12:  9](R/W) -- */
        uint64_t updt_weight           : 8;  /**< [  8:  1](R/W) -- */
        uint64_t billing_ctr_en        : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t billing_ctr_en        : 1;  /**< [  0:  0](R/W) -- */
        uint64_t updt_weight           : 8;  /**< [  8:  1](R/W) -- */
        uint64_t refr_time_gran_expo   : 4;  /**< [ 12:  9](R/W) -- */
        uint64_t unit_time             : 32; /**< [ 44: 13](R/W) -- */
        uint64_t refr_en               : 1;  /**< [ 45: 45](R/W) -- */
        uint64_t reserved_46_63        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_mode_polx_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_mode_polx bdk_tns_sde_cnt_bkx_mode_polx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODE_POLX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODE_POLX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=3)))
        return 0x842060610010ll + 0x20000ll * ((a) & 0x3) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_MODE_POLX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_MODE_POLX(a,b) bdk_tns_sde_cnt_bkx_mode_polx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_MODE_POLX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_CNT_BKX_MODE_POLX(a,b) "TNS_SDE_CNT_BKX_MODE_POLX"
#define device_bar_BDK_TNS_SDE_CNT_BKX_MODE_POLX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_MODE_POLX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_MODE_POLX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_bk#_spad
 *
 * TNS SDE CNT Bank ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_cnt_bkx_spad
{
    uint32_t u;
    struct bdk_tns_sde_cnt_bkx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_bkx_spad_s cn; */
};
typedef union bdk_tns_sde_cnt_bkx_spad bdk_tns_sde_cnt_bkx_spad_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x8420606100d4ll + 0x20000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_CNT_BKX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_BKX_SPAD(a) bdk_tns_sde_cnt_bkx_spad_t
#define bustype_BDK_TNS_SDE_CNT_BKX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_BKX_SPAD(a) "TNS_SDE_CNT_BKX_SPAD"
#define device_bar_BDK_TNS_SDE_CNT_BKX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_BKX_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_CNT_BKX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_cnt_cinf_bckt#
 *
 * TNS SDE CNT Client Interface Bucket Registers
 * --
 */
union bdk_tns_sde_cnt_cinf_bcktx
{
    uint64_t u;
    struct bdk_tns_sde_cnt_cinf_bcktx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t en                    : 1;  /**< [ 54: 54](R/W) -- */
        uint64_t a_a                   : 16; /**< [ 53: 38](R/W) -- */
        uint64_t b_b                   : 16; /**< [ 37: 22](R/W) -- */
        uint64_t n                     : 16; /**< [ 21:  6](R/W) -- */
        uint64_t gran_expo             : 4;  /**< [  5:  2](R/W) -- */
        uint64_t add_addr              : 1;  /**< [  1:  1](R/W) -- */
        uint64_t bkt_use_addr          : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t bkt_use_addr          : 1;  /**< [  0:  0](R/W) -- */
        uint64_t add_addr              : 1;  /**< [  1:  1](R/W) -- */
        uint64_t gran_expo             : 4;  /**< [  5:  2](R/W) -- */
        uint64_t n                     : 16; /**< [ 21:  6](R/W) -- */
        uint64_t b_b                   : 16; /**< [ 37: 22](R/W) -- */
        uint64_t a_a                   : 16; /**< [ 53: 38](R/W) -- */
        uint64_t en                    : 1;  /**< [ 54: 54](R/W) -- */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_cinf_bcktx_s cn; */
};
typedef union bdk_tns_sde_cnt_cinf_bcktx bdk_tns_sde_cnt_cinf_bcktx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CINF_BCKTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_BCKTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842060681020ll + 8ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SDE_CNT_CINF_BCKTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CINF_BCKTX(a) bdk_tns_sde_cnt_cinf_bcktx_t
#define bustype_BDK_TNS_SDE_CNT_CINF_BCKTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_CNT_CINF_BCKTX(a) "TNS_SDE_CNT_CINF_BCKTX"
#define device_bar_BDK_TNS_SDE_CNT_CINF_BCKTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CINF_BCKTX(a) (a)
#define arguments_BDK_TNS_SDE_CNT_CINF_BCKTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_cinf_int_ro
 *
 * TNS SDE CNT Client Interface Interrrupt Read Only Register
 * --
 */
union bdk_tns_sde_cnt_cinf_int_ro
{
    uint32_t u;
    struct bdk_tns_sde_cnt_cinf_int_ro_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ctr_ovfl              : 16; /**< [ 31: 16](RO/H) -- */
        uint32_t mem_err               : 16; /**< [ 15:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mem_err               : 16; /**< [ 15:  0](RO/H) -- */
        uint32_t ctr_ovfl              : 16; /**< [ 31: 16](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_cinf_int_ro_s cn; */
};
typedef union bdk_tns_sde_cnt_cinf_int_ro bdk_tns_sde_cnt_cinf_int_ro_t;

#define BDK_TNS_SDE_CNT_CINF_INT_RO BDK_TNS_SDE_CNT_CINF_INT_RO_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CINF_INT_RO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_INT_RO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060681060ll;
    __bdk_csr_fatal("TNS_SDE_CNT_CINF_INT_RO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CINF_INT_RO bdk_tns_sde_cnt_cinf_int_ro_t
#define bustype_BDK_TNS_SDE_CNT_CINF_INT_RO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CINF_INT_RO "TNS_SDE_CNT_CINF_INT_RO"
#define device_bar_BDK_TNS_SDE_CNT_CINF_INT_RO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CINF_INT_RO 0
#define arguments_BDK_TNS_SDE_CNT_CINF_INT_RO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_cinf_intf_tbl#
 *
 * TNS SDE CNT Client Interface Interface Table Registers
 * --
 */
union bdk_tns_sde_cnt_cinf_intf_tblx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_cinf_intf_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t mode                  : 4;  /**< [ 26: 23](R/W) -- */
        uint32_t bank_start            : 6;  /**< [ 22: 17](R/W) -- */
        uint32_t bank_end              : 6;  /**< [ 16: 11](R/W) -- */
        uint32_t entry_sel_sz          : 6;  /**< [ 10:  5](R/W) -- */
        uint32_t dual_bank             : 1;  /**< [  4:  4](R/W) -- */
        uint32_t count_offset          : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t count_offset          : 4;  /**< [  3:  0](R/W) -- */
        uint32_t dual_bank             : 1;  /**< [  4:  4](R/W) -- */
        uint32_t entry_sel_sz          : 6;  /**< [ 10:  5](R/W) -- */
        uint32_t bank_end              : 6;  /**< [ 16: 11](R/W) -- */
        uint32_t bank_start            : 6;  /**< [ 22: 17](R/W) -- */
        uint32_t mode                  : 4;  /**< [ 26: 23](R/W) -- */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_cinf_intf_tblx_s cn; */
};
typedef union bdk_tns_sde_cnt_cinf_intf_tblx bdk_tns_sde_cnt_cinf_intf_tblx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CINF_INTF_TBLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_INTF_TBLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842060681000ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SDE_CNT_CINF_INTF_TBLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(a) bdk_tns_sde_cnt_cinf_intf_tblx_t
#define bustype_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(a) "TNS_SDE_CNT_CINF_INTF_TBLX"
#define device_bar_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(a) (a)
#define arguments_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_cinf_lock
 *
 * TNS SDE CNT Client Interface Lock Register
 * Lock Register
 */
union bdk_tns_sde_cnt_cinf_lock
{
    uint32_t u;
    struct bdk_tns_sde_cnt_cinf_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_cinf_lock_s cn; */
};
typedef union bdk_tns_sde_cnt_cinf_lock bdk_tns_sde_cnt_cinf_lock_t;

#define BDK_TNS_SDE_CNT_CINF_LOCK BDK_TNS_SDE_CNT_CINF_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CINF_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060681064ll;
    __bdk_csr_fatal("TNS_SDE_CNT_CINF_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CINF_LOCK bdk_tns_sde_cnt_cinf_lock_t
#define bustype_BDK_TNS_SDE_CNT_CINF_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CINF_LOCK "TNS_SDE_CNT_CINF_LOCK"
#define device_bar_BDK_TNS_SDE_CNT_CINF_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CINF_LOCK 0
#define arguments_BDK_TNS_SDE_CNT_CINF_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_cinf_spad
 *
 * TNS SDE CNT Client Interface ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_cnt_cinf_spad
{
    uint32_t u;
    struct bdk_tns_sde_cnt_cinf_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_cinf_spad_s cn; */
};
typedef union bdk_tns_sde_cnt_cinf_spad bdk_tns_sde_cnt_cinf_spad_t;

#define BDK_TNS_SDE_CNT_CINF_SPAD BDK_TNS_SDE_CNT_CINF_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CINF_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060681068ll;
    __bdk_csr_fatal("TNS_SDE_CNT_CINF_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CINF_SPAD bdk_tns_sde_cnt_cinf_spad_t
#define bustype_BDK_TNS_SDE_CNT_CINF_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CINF_SPAD "TNS_SDE_CNT_CINF_SPAD"
#define device_bar_BDK_TNS_SDE_CNT_CINF_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CINF_SPAD 0
#define arguments_BDK_TNS_SDE_CNT_CINF_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_crsl_cnt_dbg_sel
 *
 * TNS SDE CNT Client Result CNT Debug Selector Register
 * --
 */
union bdk_tns_sde_cnt_crsl_cnt_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_cnt_crsl_cnt_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_crsl_cnt_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_cnt_crsl_cnt_dbg_sel bdk_tns_sde_cnt_crsl_cnt_dbg_sel_t;

#define BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060680800ll;
    __bdk_csr_fatal("TNS_SDE_CNT_CRSL_CNT_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL bdk_tns_sde_cnt_crsl_cnt_dbg_sel_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL "TNS_SDE_CNT_CRSL_CNT_DBG_SEL"
#define device_bar_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL 0
#define arguments_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_crsl_lock
 *
 * TNS SDE CNT Client Result Lock Register
 * Lock Register
 */
union bdk_tns_sde_cnt_crsl_lock
{
    uint32_t u;
    struct bdk_tns_sde_cnt_crsl_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_crsl_lock_s cn; */
};
typedef union bdk_tns_sde_cnt_crsl_lock bdk_tns_sde_cnt_crsl_lock_t;

#define BDK_TNS_SDE_CNT_CRSL_LOCK BDK_TNS_SDE_CNT_CRSL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206068080cll;
    __bdk_csr_fatal("TNS_SDE_CNT_CRSL_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CRSL_LOCK bdk_tns_sde_cnt_crsl_lock_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CRSL_LOCK "TNS_SDE_CNT_CRSL_LOCK"
#define device_bar_BDK_TNS_SDE_CNT_CRSL_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CRSL_LOCK 0
#define arguments_BDK_TNS_SDE_CNT_CRSL_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_crsl_pol_ecc_ctl#
 *
 * TNS SDE CNT Client Result POL ECC Control Registers
 * --
 */
union bdk_tns_sde_cnt_crsl_pol_ecc_ctlx
{
    uint32_t u;
    struct bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cor_dis               : 1;  /**< [  2:  2](R/W) -- */
        uint32_t flip_db_ecc           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t flip_sb_ecc           : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t flip_sb_ecc           : 1;  /**< [  0:  0](R/W) -- */
        uint32_t flip_db_ecc           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t cor_dis               : 1;  /**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_s cn; */
};
typedef union bdk_tns_sde_cnt_crsl_pol_ecc_ctlx bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060680804ll + 4ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_CNT_CRSL_POL_ECC_CTLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(a) bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(a) "TNS_SDE_CNT_CRSL_POL_ECC_CTLX"
#define device_bar_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(a) (a)
#define arguments_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_cnt_crsl_pol_prm#d#
 *
 * TNS SDE CNT Client Result POL Parameter Registers
 * This memory is only applicable to request interface 0, 4, 8, ... 44
 */
union bdk_tns_sde_cnt_crsl_pol_prmxdx
{
    uint64_t u;
    struct bdk_tns_sde_cnt_crsl_pol_prmxdx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_57_63        : 7;
        uint64_t data                  : 57; /**< [ 56:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 57; /**< [ 56:  0](R/W) -- */
        uint64_t reserved_57_63        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_crsl_pol_prmxdx_s cn; */
};
typedef union bdk_tns_sde_cnt_crsl_pol_prmxdx bdk_tns_sde_cnt_crsl_pol_prmxdx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=101)))
        return 0x842060680000ll + 0x330ll * ((a) & 0x1) + 8ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_CNT_CRSL_POL_PRMXDX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(a,b) bdk_tns_sde_cnt_crsl_pol_prmxdx_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(a,b) "TNS_SDE_CNT_CRSL_POL_PRMXDX"
#define device_bar_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(a,b) (a)
#define arguments_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_cnt_crsl_spad
 *
 * TNS SDE CNT Client Result ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_cnt_crsl_spad
{
    uint32_t u;
    struct bdk_tns_sde_cnt_crsl_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_cnt_crsl_spad_s cn; */
};
typedef union bdk_tns_sde_cnt_crsl_spad bdk_tns_sde_cnt_crsl_spad_t;

#define BDK_TNS_SDE_CNT_CRSL_SPAD BDK_TNS_SDE_CNT_CRSL_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060680810ll;
    __bdk_csr_fatal("TNS_SDE_CNT_CRSL_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_CNT_CRSL_SPAD bdk_tns_sde_cnt_crsl_spad_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_CNT_CRSL_SPAD "TNS_SDE_CNT_CRSL_SPAD"
#define device_bar_BDK_TNS_SDE_CNT_CRSL_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_CNT_CRSL_SPAD 0
#define arguments_BDK_TNS_SDE_CNT_CRSL_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_dbg_sel
 *
 * TNS SDE HDBF Debug Selector Register
 * --
 */
union bdk_tns_sde_hdbf_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_hdbf_dbg_sel bdk_tns_sde_hdbf_dbg_sel_t;

#define BDK_TNS_SDE_HDBF_DBG_SEL BDK_TNS_SDE_HDBF_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780800ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_DBG_SEL bdk_tns_sde_hdbf_dbg_sel_t
#define bustype_BDK_TNS_SDE_HDBF_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_DBG_SEL "TNS_SDE_HDBF_DBG_SEL"
#define device_bar_BDK_TNS_SDE_HDBF_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_DBG_SEL 0
#define arguments_BDK_TNS_SDE_HDBF_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_ecc_ctl
 *
 * TNS SDE HDBF ECC Control Register
 * --
 */
union bdk_tns_sde_hdbf_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t fl_cor_dis            : 1;  /**< [ 16: 16](R/W) -- */
        uint32_t main_cor_dis          : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t ctx_cor_dis           : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t fl_flip_db_ecc        : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t fl_flip_sb_ecc        : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t main_flip_db_ecc      : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t main_flip_sb_ecc      : 4;  /**< [  7:  4](R/W) -- */
        uint32_t ctx_flip_db_ecc       : 2;  /**< [  3:  2](R/W) -- */
        uint32_t ctx_flip_sb_ecc       : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ctx_flip_sb_ecc       : 2;  /**< [  1:  0](R/W) -- */
        uint32_t ctx_flip_db_ecc       : 2;  /**< [  3:  2](R/W) -- */
        uint32_t main_flip_sb_ecc      : 4;  /**< [  7:  4](R/W) -- */
        uint32_t main_flip_db_ecc      : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t fl_flip_sb_ecc        : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t fl_flip_db_ecc        : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t ctx_cor_dis           : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t main_cor_dis          : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t fl_cor_dis            : 1;  /**< [ 16: 16](R/W) -- */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_ecc_ctl_s cn; */
};
typedef union bdk_tns_sde_hdbf_ecc_ctl bdk_tns_sde_hdbf_ecc_ctl_t;

#define BDK_TNS_SDE_HDBF_ECC_CTL BDK_TNS_SDE_HDBF_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780808ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_ECC_CTL bdk_tns_sde_hdbf_ecc_ctl_t
#define bustype_BDK_TNS_SDE_HDBF_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_ECC_CTL "TNS_SDE_HDBF_ECC_CTL"
#define device_bar_BDK_TNS_SDE_HDBF_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_ECC_CTL 0
#define arguments_BDK_TNS_SDE_HDBF_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_fl_mon
 *
 * TNS SDE HDBF Fail Monitor Register
 * These registers control monitoring of the free list for lost
 * pages.  Free list monitoring has two controls, a sample target
 * and a window size.
 * Monitoring of the list is accomplished by picking a particular
 * page number, and then setting the monitoring window size.  The
 * window size is in multipels of 256 page returns.  For good sampling
 * the monitoring period should be at least 4x the expected
 * lifetime of a page.
 * At the end of each monitoring period the four status registers
 * in fl_mon_status are updated with the number of times the
 * requested block was seen being returned to the free list FIFO.
 */
union bdk_tns_sde_hdbf_fl_mon
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_fl_mon_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t target                : 9;  /**< [ 16:  8](R/W) Target page to monitor. */
        uint32_t window                : 8;  /**< [  7:  0](R/W) Monitoring window size, in units of 256 page returns. */
#else /* Word 0 - Little Endian */
        uint32_t window                : 8;  /**< [  7:  0](R/W) Monitoring window size, in units of 256 page returns. */
        uint32_t target                : 9;  /**< [ 16:  8](R/W) Target page to monitor. */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_fl_mon_s cn; */
};
typedef union bdk_tns_sde_hdbf_fl_mon bdk_tns_sde_hdbf_fl_mon_t;

#define BDK_TNS_SDE_HDBF_FL_MON BDK_TNS_SDE_HDBF_FL_MON_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780884ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_FL_MON", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_FL_MON bdk_tns_sde_hdbf_fl_mon_t
#define bustype_BDK_TNS_SDE_HDBF_FL_MON BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_FL_MON "TNS_SDE_HDBF_FL_MON"
#define device_bar_BDK_TNS_SDE_HDBF_FL_MON 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_FL_MON 0
#define arguments_BDK_TNS_SDE_HDBF_FL_MON -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_fl_mon_sta
 *
 * TNS SDE HDBF Fail Monitor Status Register
 * --
 */
union bdk_tns_sde_hdbf_fl_mon_sta
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_fl_mon_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t returns0              : 8;  /**< [  7:  0](RO/H) Number of page returns for free list 0. */
#else /* Word 0 - Little Endian */
        uint32_t returns0              : 8;  /**< [  7:  0](RO/H) Number of page returns for free list 0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_fl_mon_sta_s cn; */
};
typedef union bdk_tns_sde_hdbf_fl_mon_sta bdk_tns_sde_hdbf_fl_mon_sta_t;

#define BDK_TNS_SDE_HDBF_FL_MON_STA BDK_TNS_SDE_HDBF_FL_MON_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_STA_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780888ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_FL_MON_STA", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_FL_MON_STA bdk_tns_sde_hdbf_fl_mon_sta_t
#define bustype_BDK_TNS_SDE_HDBF_FL_MON_STA BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_FL_MON_STA "TNS_SDE_HDBF_FL_MON_STA"
#define device_bar_BDK_TNS_SDE_HDBF_FL_MON_STA 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_FL_MON_STA 0
#define arguments_BDK_TNS_SDE_HDBF_FL_MON_STA -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_flst_ctl
 *
 * TNS SDE HDBF Freelist Control Register
 * --
 */
union bdk_tns_sde_hdbf_flst_ctl
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_flst_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) Enqueue enable for freelist FIFOs. */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) Dequeue enable for freelist FIFOs. */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) Dequeue enable for freelist FIFOs. */
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) Enqueue enable for freelist FIFOs. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_flst_ctl_s cn; */
};
typedef union bdk_tns_sde_hdbf_flst_ctl bdk_tns_sde_hdbf_flst_ctl_t;

#define BDK_TNS_SDE_HDBF_FLST_CTL BDK_TNS_SDE_HDBF_FLST_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078088cll;
    __bdk_csr_fatal("TNS_SDE_HDBF_FLST_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_FLST_CTL bdk_tns_sde_hdbf_flst_ctl_t
#define bustype_BDK_TNS_SDE_HDBF_FLST_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_FLST_CTL "TNS_SDE_HDBF_FLST_CTL"
#define device_bar_BDK_TNS_SDE_HDBF_FLST_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_FLST_CTL 0
#define arguments_BDK_TNS_SDE_HDBF_FLST_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_flst_dbg
 *
 * TNS SDE HDBF Freelist Debug Register
 * Free List debug access. TNS_SDE_HDBF_GEN[CHANNEL_ENABLE]
 * (XP_HDBF_CFG_GENERAL[CHANNEL_ENABLE])
 * must be set to 1 before any read/write access is attempted to this
 * register.
 */
union bdk_tns_sde_hdbf_flst_dbg
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_flst_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t field                 : 18; /**< [ 17:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 18; /**< [ 17:  0](R/W/H) -- */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_flst_dbg_s cn; */
};
typedef union bdk_tns_sde_hdbf_flst_dbg bdk_tns_sde_hdbf_flst_dbg_t;

#define BDK_TNS_SDE_HDBF_FLST_DBG BDK_TNS_SDE_HDBF_FLST_DBG_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_DBG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780890ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_FLST_DBG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_FLST_DBG bdk_tns_sde_hdbf_flst_dbg_t
#define bustype_BDK_TNS_SDE_HDBF_FLST_DBG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_FLST_DBG "TNS_SDE_HDBF_FLST_DBG"
#define device_bar_BDK_TNS_SDE_HDBF_FLST_DBG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_FLST_DBG 0
#define arguments_BDK_TNS_SDE_HDBF_FLST_DBG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_free_ct
 *
 * TNS SDE HDBF Free Count Register
 * These fields show the current free list counts for each of the
 * four free list FIFOs.  In operation these FIFOs will show a
 * value of 253 when empty due to prefetching of free pages.
 */
union bdk_tns_sde_hdbf_free_ct
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_free_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t free_bank0            : 8;  /**< [  7:  0](RO/H) Length of the free list FIFO for bank 0. */
#else /* Word 0 - Little Endian */
        uint32_t free_bank0            : 8;  /**< [  7:  0](RO/H) Length of the free list FIFO for bank 0. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_free_ct_s cn; */
};
typedef union bdk_tns_sde_hdbf_free_ct bdk_tns_sde_hdbf_free_ct_t;

#define BDK_TNS_SDE_HDBF_FREE_CT BDK_TNS_SDE_HDBF_FREE_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FREE_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FREE_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780880ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_FREE_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_FREE_CT bdk_tns_sde_hdbf_free_ct_t
#define bustype_BDK_TNS_SDE_HDBF_FREE_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_FREE_CT "TNS_SDE_HDBF_FREE_CT"
#define device_bar_BDK_TNS_SDE_HDBF_FREE_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_FREE_CT 0
#define arguments_BDK_TNS_SDE_HDBF_FREE_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_gen
 *
 * TNS SDE HDBF General Register
 * General configuration for header buffer
 */
union bdk_tns_sde_hdbf_gen
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_gen_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t channel_enable        : 1;  /**< [  2:  2](R/W) When set to 0, the channel is disabled.  The free list is cleared and any
                                                                 returned
                                                                 pages will be ignored.
                                                                 When set to 1, the free list will be re-initialized based on the number
                                                                 of pages
                                                                 specified in the channel_page_size field.
                                                                 The parser and MRE must be disabled prior to free list initialization
                                                                 so that they
                                                                 are not holding slot requests when the free list is cleared. */
        uint32_t channel_page_size     : 1;  /**< [  1:  1](R/W) This sets the page size for each channel.  0 means a page size of 4 lines
                                                                 (256B),
                                                                 1 sets page size to 2 lines (128B).  For correct operation this should
                                                                 only be
                                                                 set when channel_enable is 0 or concurrently with setting
                                                                 channel_enable to 0. */
        uint32_t channel_ct_mode       : 1;  /**< [  0:  0](R/W) This sets the request count for each channel.  When set to 0, each channel
                                                                 counts
                                                                 the number of requests on each request line from Parser and MRE and
                                                                 attempts to
                                                                 provide them with that many pages.
                                                                 When set to 1, each channel has a page budget for both Parser and MRE.
                                                                 HDBF monitors
                                                                 writes to determine when a page has been consumed and allocates a new
                                                                 page. */
#else /* Word 0 - Little Endian */
        uint32_t channel_ct_mode       : 1;  /**< [  0:  0](R/W) This sets the request count for each channel.  When set to 0, each channel
                                                                 counts
                                                                 the number of requests on each request line from Parser and MRE and
                                                                 attempts to
                                                                 provide them with that many pages.
                                                                 When set to 1, each channel has a page budget for both Parser and MRE.
                                                                 HDBF monitors
                                                                 writes to determine when a page has been consumed and allocates a new
                                                                 page. */
        uint32_t channel_page_size     : 1;  /**< [  1:  1](R/W) This sets the page size for each channel.  0 means a page size of 4 lines
                                                                 (256B),
                                                                 1 sets page size to 2 lines (128B).  For correct operation this should
                                                                 only be
                                                                 set when channel_enable is 0 or concurrently with setting
                                                                 channel_enable to 0. */
        uint32_t channel_enable        : 1;  /**< [  2:  2](R/W) When set to 0, the channel is disabled.  The free list is cleared and any
                                                                 returned
                                                                 pages will be ignored.
                                                                 When set to 1, the free list will be re-initialized based on the number
                                                                 of pages
                                                                 specified in the channel_page_size field.
                                                                 The parser and MRE must be disabled prior to free list initialization
                                                                 so that they
                                                                 are not holding slot requests when the free list is cleared. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_gen_s cn; */
};
typedef union bdk_tns_sde_hdbf_gen bdk_tns_sde_hdbf_gen_t;

#define BDK_TNS_SDE_HDBF_GEN BDK_TNS_SDE_HDBF_GEN_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_GEN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_GEN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780804ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_GEN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_GEN bdk_tns_sde_hdbf_gen_t
#define bustype_BDK_TNS_SDE_HDBF_GEN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_GEN "TNS_SDE_HDBF_GEN"
#define device_bar_BDK_TNS_SDE_HDBF_GEN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_GEN 0
#define arguments_BDK_TNS_SDE_HDBF_GEN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_int_en_hi
 *
 * TNS SDE HDBF Interrrupt Enable High Register
 * --
 */
union bdk_tns_sde_hdbf_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](R/W) Single bit errors from free list memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](R/W) Single bit errors from main header memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](R/W) Single bit errors from context memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](R/W) Double bit errors from free list memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](R/W) Double bit errors from main header memory. */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](R/W) Double bit errors from context memory. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](R/W) Overflow indication from free list FIFO */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else /* Word 0 - Little Endian */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](R/W) Overflow indication from free list FIFO */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](R/W) Double bit errors from context memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](R/W) Double bit errors from main header memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](R/W) Double bit errors from free list memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](R/W) Single bit errors from context memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](R/W) Single bit errors from main header memory. */
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](R/W) Single bit errors from free list memory. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_hdbf_int_en_hi bdk_tns_sde_hdbf_int_en_hi_t;

#define BDK_TNS_SDE_HDBF_INT_EN_HI BDK_TNS_SDE_HDBF_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780874ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_INT_EN_HI bdk_tns_sde_hdbf_int_en_hi_t
#define bustype_BDK_TNS_SDE_HDBF_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_INT_EN_HI "TNS_SDE_HDBF_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_HDBF_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_HDBF_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_int_en_lo
 *
 * TNS SDE HDBF Interrrupt Enable Low Register
 * --
 */
union bdk_tns_sde_hdbf_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](R/W) Single bit errors from free list memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](R/W) Single bit errors from main header memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](R/W) Single bit errors from context memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](R/W) Double bit errors from free list memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](R/W) Double bit errors from main header memory. */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](R/W) Double bit errors from context memory. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](R/W) Overflow indication from free list FIFO */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else /* Word 0 - Little Endian */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](R/W) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](R/W) Overflow indication from free list FIFO */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](R/W) Double bit errors from context memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](R/W) Double bit errors from main header memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](R/W) Double bit errors from free list memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](R/W) Single bit errors from context memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](R/W) Single bit errors from main header memory. */
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](R/W) Single bit errors from free list memory. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_hdbf_int_en_lo bdk_tns_sde_hdbf_int_en_lo_t;

#define BDK_TNS_SDE_HDBF_INT_EN_LO BDK_TNS_SDE_HDBF_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780878ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_INT_EN_LO bdk_tns_sde_hdbf_int_en_lo_t
#define bustype_BDK_TNS_SDE_HDBF_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_INT_EN_LO "TNS_SDE_HDBF_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_HDBF_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_HDBF_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_int_frc
 *
 * TNS SDE HDBF Interrrupt Force Register
 * --
 */
union bdk_tns_sde_hdbf_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](WO) Single bit errors from free list memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](WO) Single bit errors from main header memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](WO) Single bit errors from context memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](WO) Double bit errors from free list memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](WO) Double bit errors from main header memory. */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](WO) Double bit errors from context memory. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](WO) Overflow indication from free list FIFO */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](WO) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](WO) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else /* Word 0 - Little Endian */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](WO) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](WO) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](WO) Overflow indication from free list FIFO */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](WO) Double bit errors from context memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](WO) Double bit errors from main header memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](WO) Double bit errors from free list memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](WO) Single bit errors from context memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](WO) Single bit errors from main header memory. */
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](WO) Single bit errors from free list memory. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_int_frc_s cn; */
};
typedef union bdk_tns_sde_hdbf_int_frc bdk_tns_sde_hdbf_int_frc_t;

#define BDK_TNS_SDE_HDBF_INT_FRC BDK_TNS_SDE_HDBF_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078087cll;
    __bdk_csr_fatal("TNS_SDE_HDBF_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_INT_FRC bdk_tns_sde_hdbf_int_frc_t
#define bustype_BDK_TNS_SDE_HDBF_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_INT_FRC "TNS_SDE_HDBF_INT_FRC"
#define device_bar_BDK_TNS_SDE_HDBF_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_INT_FRC 0
#define arguments_BDK_TNS_SDE_HDBF_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_int_w1c
 *
 * TNS SDE HDBF Interrrupt W1C Register
 * --
 */
union bdk_tns_sde_hdbf_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](R/W1C/H) Single bit errors from free list memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](R/W1C/H) Single bit errors from main header memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](R/W1C/H) Single bit errors from context memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](R/W1C/H) Double bit errors from free list memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](R/W1C/H) Double bit errors from main header memory. */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](R/W1C/H) Double bit errors from context memory. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](R/W1C/H) Overflow indication from free list FIFO */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](R/W1C/H) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](R/W1C/H) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else /* Word 0 - Little Endian */
        uint32_t read_out_of_range     : 1;  /**< [  0:  0](R/W1C/H) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
        uint32_t write_out_of_range    : 1;  /**< [  1:  1](R/W1C/H) In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
        uint32_t free_list_ovfl        : 1;  /**< [  2:  2](R/W1C/H) Overflow indication from free list FIFO */
        uint32_t ctx_db_err            : 1;  /**< [  3:  3](R/W1C/H) Double bit errors from context memory. */
        uint32_t main_db_err           : 1;  /**< [  4:  4](R/W1C/H) Double bit errors from main header memory. */
        uint32_t fl_db_err             : 1;  /**< [  5:  5](R/W1C/H) Double bit errors from free list memory. */
        uint32_t ctx_sb_err            : 1;  /**< [  6:  6](R/W1C/H) Single bit errors from context memory. */
        uint32_t main_sb_err           : 1;  /**< [  7:  7](R/W1C/H) Single bit errors from main header memory. */
        uint32_t fl_sb_err             : 1;  /**< [  8:  8](R/W1C/H) Single bit errors from free list memory. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_int_w1c_s cn; */
};
typedef union bdk_tns_sde_hdbf_int_w1c bdk_tns_sde_hdbf_int_w1c_t;

#define BDK_TNS_SDE_HDBF_INT_W1C BDK_TNS_SDE_HDBF_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780870ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_INT_W1C bdk_tns_sde_hdbf_int_w1c_t
#define bustype_BDK_TNS_SDE_HDBF_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_INT_W1C "TNS_SDE_HDBF_INT_W1C"
#define device_bar_BDK_TNS_SDE_HDBF_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_INT_W1C 0
#define arguments_BDK_TNS_SDE_HDBF_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_lock
 *
 * TNS SDE HDBF Lock Register
 * Lock Register
 */
union bdk_tns_sde_hdbf_lock
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_lock_s cn; */
};
typedef union bdk_tns_sde_hdbf_lock bdk_tns_sde_hdbf_lock_t;

#define BDK_TNS_SDE_HDBF_LOCK BDK_TNS_SDE_HDBF_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078089cll;
    __bdk_csr_fatal("TNS_SDE_HDBF_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_LOCK bdk_tns_sde_hdbf_lock_t
#define bustype_BDK_TNS_SDE_HDBF_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_LOCK "TNS_SDE_HDBF_LOCK"
#define device_bar_BDK_TNS_SDE_HDBF_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_LOCK 0
#define arguments_BDK_TNS_SDE_HDBF_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_memctx_adr
 *
 * TNS SDE HDBF Contex Memory Address Register
 * Shared address value for indirect access to context memory bank.
 * Context memory is 512 words deep.
 */
union bdk_tns_sde_hdbf_memctx_adr
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_memctx_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_memctx_adr_s cn; */
};
typedef union bdk_tns_sde_hdbf_memctx_adr bdk_tns_sde_hdbf_memctx_adr_t;

#define BDK_TNS_SDE_HDBF_MEMCTX_ADR BDK_TNS_SDE_HDBF_MEMCTX_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780854ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_MEMCTX_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_MEMCTX_ADR bdk_tns_sde_hdbf_memctx_adr_t
#define bustype_BDK_TNS_SDE_HDBF_MEMCTX_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_MEMCTX_ADR "TNS_SDE_HDBF_MEMCTX_ADR"
#define device_bar_BDK_TNS_SDE_HDBF_MEMCTX_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_MEMCTX_ADR 0
#define arguments_BDK_TNS_SDE_HDBF_MEMCTX_ADR -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_hdbf_memctx_w#
 *
 * TNS SDE HDBF Contex Memory Registers
 * Indirect access for header context bank
 * Bits 63..36 of registers ending in _W2 are unused.
 */
union bdk_tns_sde_hdbf_memctx_wx
{
    uint64_t u;
    struct bdk_tns_sde_hdbf_memctx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t field                 : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t field                 : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_memctx_wx_s cn; */
};
typedef union bdk_tns_sde_hdbf_memctx_wx bdk_tns_sde_hdbf_memctx_wx_t;

static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2))
        return 0x842060780858ll + 8ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_HDBF_MEMCTX_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_MEMCTX_WX(a) bdk_tns_sde_hdbf_memctx_wx_t
#define bustype_BDK_TNS_SDE_HDBF_MEMCTX_WX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_HDBF_MEMCTX_WX(a) "TNS_SDE_HDBF_MEMCTX_WX"
#define device_bar_BDK_TNS_SDE_HDBF_MEMCTX_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_MEMCTX_WX(a) (a)
#define arguments_BDK_TNS_SDE_HDBF_MEMCTX_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_memmain_adr
 *
 * TNS SDE HDBF Main Memory Address Register
 * Shared address value for indirect access to main memory bank.  Main
 * memory is 1024 words deep.
 */
union bdk_tns_sde_hdbf_memmain_adr
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_memmain_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_memmain_adr_s cn; */
};
typedef union bdk_tns_sde_hdbf_memmain_adr bdk_tns_sde_hdbf_memmain_adr_t;

#define BDK_TNS_SDE_HDBF_MEMMAIN_ADR BDK_TNS_SDE_HDBF_MEMMAIN_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780810ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_MEMMAIN_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_MEMMAIN_ADR bdk_tns_sde_hdbf_memmain_adr_t
#define bustype_BDK_TNS_SDE_HDBF_MEMMAIN_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_MEMMAIN_ADR "TNS_SDE_HDBF_MEMMAIN_ADR"
#define device_bar_BDK_TNS_SDE_HDBF_MEMMAIN_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_MEMMAIN_ADR 0
#define arguments_BDK_TNS_SDE_HDBF_MEMMAIN_ADR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_memmain_w#
 *
 * TNS SDE HDBF Main Memory Registers
 * Indirect access for header main memory bank
 */
union bdk_tns_sde_hdbf_memmain_wx
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_memmain_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t field                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_memmain_wx_s cn; */
};
typedef union bdk_tns_sde_hdbf_memmain_wx bdk_tns_sde_hdbf_memmain_wx_t;

static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842060780814ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_SDE_HDBF_MEMMAIN_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_MEMMAIN_WX(a) bdk_tns_sde_hdbf_memmain_wx_t
#define bustype_BDK_TNS_SDE_HDBF_MEMMAIN_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_MEMMAIN_WX(a) "TNS_SDE_HDBF_MEMMAIN_WX"
#define device_bar_BDK_TNS_SDE_HDBF_MEMMAIN_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_MEMMAIN_WX(a) (a)
#define arguments_BDK_TNS_SDE_HDBF_MEMMAIN_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_mre_budget
 *
 * TNS SDE HDBF MRE budget Register
 * Page budget for each channel.  When channel_count_mode is 1, this sets the page
 * budget
 * for the channel.  When channel_count_mode is 0, this is the saturation
 * value for
 * the request counter.
 */
union bdk_tns_sde_hdbf_mre_budget
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_mre_budget_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ch0_budget            : 8;  /**< [  7:  0](R/W) MRE channel 0 budget */
#else /* Word 0 - Little Endian */
        uint32_t ch0_budget            : 8;  /**< [  7:  0](R/W) MRE channel 0 budget */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_mre_budget_s cn; */
};
typedef union bdk_tns_sde_hdbf_mre_budget bdk_tns_sde_hdbf_mre_budget_t;

#define BDK_TNS_SDE_HDBF_MRE_BUDGET BDK_TNS_SDE_HDBF_MRE_BUDGET_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_MRE_BUDGET_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MRE_BUDGET_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780898ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_MRE_BUDGET", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_MRE_BUDGET bdk_tns_sde_hdbf_mre_budget_t
#define bustype_BDK_TNS_SDE_HDBF_MRE_BUDGET BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_MRE_BUDGET "TNS_SDE_HDBF_MRE_BUDGET"
#define device_bar_BDK_TNS_SDE_HDBF_MRE_BUDGET 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_MRE_BUDGET 0
#define arguments_BDK_TNS_SDE_HDBF_MRE_BUDGET -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_parser_budget
 *
 * TNS SDE HDBF Parser budget Register
 * Page budget for each channel.  When channel_count_mode is 1, this sets the page
 * budget
 * for the channel.  When channel_count_mode is 0, this is the saturation
 * value for
 * the request counter.
 */
union bdk_tns_sde_hdbf_parser_budget
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_parser_budget_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ch0_budget            : 8;  /**< [  7:  0](R/W) Parser channel 0 budget */
#else /* Word 0 - Little Endian */
        uint32_t ch0_budget            : 8;  /**< [  7:  0](R/W) Parser channel 0 budget */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_parser_budget_s cn; */
};
typedef union bdk_tns_sde_hdbf_parser_budget bdk_tns_sde_hdbf_parser_budget_t;

#define BDK_TNS_SDE_HDBF_PARSER_BUDGET BDK_TNS_SDE_HDBF_PARSER_BUDGET_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_PARSER_BUDGET_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_PARSER_BUDGET_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780894ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_PARSER_BUDGET", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_PARSER_BUDGET bdk_tns_sde_hdbf_parser_budget_t
#define bustype_BDK_TNS_SDE_HDBF_PARSER_BUDGET BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_PARSER_BUDGET "TNS_SDE_HDBF_PARSER_BUDGET"
#define device_bar_BDK_TNS_SDE_HDBF_PARSER_BUDGET 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_PARSER_BUDGET 0
#define arguments_BDK_TNS_SDE_HDBF_PARSER_BUDGET -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_req_cts
 *
 * TNS SDE HDBF Request Status Counter Register
 * Status counters for each requestor
 */
union bdk_tns_sde_hdbf_req_cts
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_req_cts_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t mre_req0              : 8;  /**< [ 15:  8](RO/H) Requests outstanding from MRE for channel 3 */
        uint32_t par_req0              : 8;  /**< [  7:  0](RO/H) Requests outstanding from Parser for channel 3 */
#else /* Word 0 - Little Endian */
        uint32_t par_req0              : 8;  /**< [  7:  0](RO/H) Requests outstanding from Parser for channel 3 */
        uint32_t mre_req0              : 8;  /**< [ 15:  8](RO/H) Requests outstanding from MRE for channel 3 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_req_cts_s cn; */
};
typedef union bdk_tns_sde_hdbf_req_cts bdk_tns_sde_hdbf_req_cts_t;

#define BDK_TNS_SDE_HDBF_REQ_CTS BDK_TNS_SDE_HDBF_REQ_CTS_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_REQ_CTS_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_REQ_CTS_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078080cll;
    __bdk_csr_fatal("TNS_SDE_HDBF_REQ_CTS", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_REQ_CTS bdk_tns_sde_hdbf_req_cts_t
#define bustype_BDK_TNS_SDE_HDBF_REQ_CTS BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_REQ_CTS "TNS_SDE_HDBF_REQ_CTS"
#define device_bar_BDK_TNS_SDE_HDBF_REQ_CTS 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_REQ_CTS 0
#define arguments_BDK_TNS_SDE_HDBF_REQ_CTS -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_hdbf_spad
 *
 * TNS SDE HDBF ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_hdbf_spad
{
    uint32_t u;
    struct bdk_tns_sde_hdbf_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_hdbf_spad_s cn; */
};
typedef union bdk_tns_sde_hdbf_spad bdk_tns_sde_hdbf_spad_t;

#define BDK_TNS_SDE_HDBF_SPAD BDK_TNS_SDE_HDBF_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607808a0ll;
    __bdk_csr_fatal("TNS_SDE_HDBF_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_HDBF_SPAD bdk_tns_sde_hdbf_spad_t
#define bustype_BDK_TNS_SDE_HDBF_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_HDBF_SPAD "TNS_SDE_HDBF_SPAD"
#define device_bar_BDK_TNS_SDE_HDBF_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_HDBF_SPAD 0
#define arguments_BDK_TNS_SDE_HDBF_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_cfg_lm_lde#
 *
 * TNS SDE ISME Configuration LM LDE Registers
 * Config key_length_mode, lookup_bypass option, 4-b hash function sel, 3-b
 * mem_tile offset for each LDE
 */
union bdk_tns_sde_isme_cfg_lm_ldex
{
    uint32_t u;
    struct bdk_tns_sde_isme_cfg_lm_ldex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t key_length_mode       : 1;  /**< [ 27: 27](R/W) -- */
        uint32_t key_mask              : 16; /**< [ 26: 11](R/W) -- */
        uint32_t left_hash_sel         : 4;  /**< [ 10:  7](R/W) -- */
        uint32_t right_hash_sel        : 4;  /**< [  6:  3](R/W) -- */
        uint32_t tile_offset           : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tile_offset           : 3;  /**< [  2:  0](R/W) -- */
        uint32_t right_hash_sel        : 4;  /**< [  6:  3](R/W) -- */
        uint32_t left_hash_sel         : 4;  /**< [ 10:  7](R/W) -- */
        uint32_t key_mask              : 16; /**< [ 26: 11](R/W) -- */
        uint32_t key_length_mode       : 1;  /**< [ 27: 27](R/W) -- */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_cfg_lm_ldex_s cn; */
};
typedef union bdk_tns_sde_isme_cfg_lm_ldex bdk_tns_sde_isme_cfg_lm_ldex_t;

static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_LDEX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_LDEX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x842060080008ll + 4ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_ISME_CFG_LM_LDEX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_CFG_LM_LDEX(a) bdk_tns_sde_isme_cfg_lm_ldex_t
#define bustype_BDK_TNS_SDE_ISME_CFG_LM_LDEX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_CFG_LM_LDEX(a) "TNS_SDE_ISME_CFG_LM_LDEX"
#define device_bar_BDK_TNS_SDE_ISME_CFG_LM_LDEX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_CFG_LM_LDEX(a) (a)
#define arguments_BDK_TNS_SDE_ISME_CFG_LM_LDEX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_cfg_lm_tile
 *
 * TNS SDE ISME Configuration LM Tile Register
 * Config key_length_mode for each memory tile - THIS REGISTER IS NOT USED. ONLY
 * PRESENT FOR SW/ENV COMPATIBILITY
 */
union bdk_tns_sde_isme_cfg_lm_tile
{
    uint32_t u;
    struct bdk_tns_sde_isme_cfg_lm_tile_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t key_length_mode       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t lde_mask              : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t lde_mask              : 4;  /**< [  3:  0](R/W) -- */
        uint32_t key_length_mode       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_cfg_lm_tile_s cn; */
};
typedef union bdk_tns_sde_isme_cfg_lm_tile bdk_tns_sde_isme_cfg_lm_tile_t;

#define BDK_TNS_SDE_ISME_CFG_LM_TILE BDK_TNS_SDE_ISME_CFG_LM_TILE_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_TILE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_TILE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080018ll;
    __bdk_csr_fatal("TNS_SDE_ISME_CFG_LM_TILE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_CFG_LM_TILE bdk_tns_sde_isme_cfg_lm_tile_t
#define bustype_BDK_TNS_SDE_ISME_CFG_LM_TILE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_CFG_LM_TILE "TNS_SDE_ISME_CFG_LM_TILE"
#define device_bar_BDK_TNS_SDE_ISME_CFG_LM_TILE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_CFG_LM_TILE 0
#define arguments_BDK_TNS_SDE_ISME_CFG_LM_TILE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_ecc_ctl_cd
 *
 * TNS SDE ISME ECC Control Disable Correction Register
 * --
 */
union bdk_tns_sde_isme_ecc_ctl_cd
{
    uint32_t u;
    struct bdk_tns_sde_isme_ecc_ctl_cd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t left_mem              : 1;  /**< [  1:  1](R/W) -- */
        uint32_t right_mem             : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t right_mem             : 1;  /**< [  0:  0](R/W) -- */
        uint32_t left_mem              : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_ecc_ctl_cd_s cn; */
};
typedef union bdk_tns_sde_isme_ecc_ctl_cd bdk_tns_sde_isme_ecc_ctl_cd_t;

#define BDK_TNS_SDE_ISME_ECC_CTL_CD BDK_TNS_SDE_ISME_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_CD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080000ll;
    __bdk_csr_fatal("TNS_SDE_ISME_ECC_CTL_CD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_ECC_CTL_CD bdk_tns_sde_isme_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_ISME_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_ECC_CTL_CD "TNS_SDE_ISME_ECC_CTL_CD"
#define device_bar_BDK_TNS_SDE_ISME_ECC_CTL_CD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_ISME_ECC_CTL_CD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_ecc_ctl_flp
 *
 * TNS SDE ISME ECC Control Flip Register
 * --
 */
union bdk_tns_sde_isme_ecc_ctl_flp
{
    uint32_t u;
    struct bdk_tns_sde_isme_ecc_ctl_flp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t left_sb_ecc           : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t left_db_ecc           : 3;  /**< [  8:  6](R/W) -- */
        uint32_t right_sb_ecc          : 3;  /**< [  5:  3](R/W) -- */
        uint32_t right_db_ecc          : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t right_db_ecc          : 3;  /**< [  2:  0](R/W) -- */
        uint32_t right_sb_ecc          : 3;  /**< [  5:  3](R/W) -- */
        uint32_t left_db_ecc           : 3;  /**< [  8:  6](R/W) -- */
        uint32_t left_sb_ecc           : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_ecc_ctl_flp_s cn; */
};
typedef union bdk_tns_sde_isme_ecc_ctl_flp bdk_tns_sde_isme_ecc_ctl_flp_t;

#define BDK_TNS_SDE_ISME_ECC_CTL_FLP BDK_TNS_SDE_ISME_ECC_CTL_FLP_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_FLP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_FLP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080004ll;
    __bdk_csr_fatal("TNS_SDE_ISME_ECC_CTL_FLP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_ECC_CTL_FLP bdk_tns_sde_isme_ecc_ctl_flp_t
#define bustype_BDK_TNS_SDE_ISME_ECC_CTL_FLP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_ECC_CTL_FLP "TNS_SDE_ISME_ECC_CTL_FLP"
#define device_bar_BDK_TNS_SDE_ISME_ECC_CTL_FLP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_ECC_CTL_FLP 0
#define arguments_BDK_TNS_SDE_ISME_ECC_CTL_FLP -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_lmem#_w0
 *
 * TNS SDE ISME LM Tile Left Memory Word 0 Registers
 * 8 left mems
 * Each entry of the left mem contains 2 keys and 2 data items.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_isme_lm_tile_lmemx_w0
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_lmemx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_lmemx_w0_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w0 bdk_tns_sde_isme_lm_tile_lmemx_w0_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060000000ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_LMEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(a) bdk_tns_sde_isme_lm_tile_lmemx_w0_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(a) "TNS_SDE_ISME_LM_TILE_LMEMX_W0"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_lmem#_w1
 *
 * TNS SDE ISME LM Tile Left Memory Word 1 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_lmemx_w1
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_lmemx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_lmemx_w1_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w1 bdk_tns_sde_isme_lm_tile_lmemx_w1_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060000008ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_LMEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(a) bdk_tns_sde_isme_lm_tile_lmemx_w1_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(a) "TNS_SDE_ISME_LM_TILE_LMEMX_W1"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_lmem#_w2
 *
 * TNS SDE ISME LM Tile Left Memory Word 2 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_lmemx_w2
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_lmemx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t datab_and_keyb        : 32; /**< [ 63: 32](R/W) -- */
        uint64_t dataa_and_keya        : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t dataa_and_keya        : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
        uint64_t datab_and_keyb        : 32; /**< [ 63: 32](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_lmemx_w2_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w2 bdk_tns_sde_isme_lm_tile_lmemx_w2_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060000010ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_LMEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(a) bdk_tns_sde_isme_lm_tile_lmemx_w2_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(a) "TNS_SDE_ISME_LM_TILE_LMEMX_W2"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_lmem#_w3
 *
 * TNS SDE ISME LM Tile Left Memory Word 3 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_lmemx_w3
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_lmemx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_lmemx_w3_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w3 bdk_tns_sde_isme_lm_tile_lmemx_w3_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060000018ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_LMEMX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(a) bdk_tns_sde_isme_lm_tile_lmemx_w3_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(a) "TNS_SDE_ISME_LM_TILE_LMEMX_W3"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_lmem#_w4
 *
 * TNS SDE ISME LM Tile Left Memory Word 4 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_lmemx_w4
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_lmemx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_lmemx_w4_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w4 bdk_tns_sde_isme_lm_tile_lmemx_w4_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060000020ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_LMEMX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(a) bdk_tns_sde_isme_lm_tile_lmemx_w4_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(a) "TNS_SDE_ISME_LM_TILE_LMEMX_W4"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_rmem#_w0
 *
 * TNS SDE ISME LM Tile Right Memory Word 0 Registers
 * 8 right mems
 * Each entry of the right mem contains 2 keys and 2 data items.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_isme_lm_tile_rmemx_w0
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_rmemx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_rmemx_w0_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w0 bdk_tns_sde_isme_lm_tile_rmemx_w0_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060040000ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_RMEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(a) bdk_tns_sde_isme_lm_tile_rmemx_w0_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(a) "TNS_SDE_ISME_LM_TILE_RMEMX_W0"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_rmem#_w1
 *
 * TNS SDE ISME LM Tile Right Memory Word 1 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_rmemx_w1
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_rmemx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t dataa_and_keya        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_rmemx_w1_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w1 bdk_tns_sde_isme_lm_tile_rmemx_w1_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060040008ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_RMEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(a) bdk_tns_sde_isme_lm_tile_rmemx_w1_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(a) "TNS_SDE_ISME_LM_TILE_RMEMX_W1"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_rmem#_w2
 *
 * TNS SDE ISME LM Tile Right Memory Word 2 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_rmemx_w2
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_rmemx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t datab_and_keyb        : 32; /**< [ 63: 32](R/W) -- */
        uint64_t dataa_and_keya        : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t dataa_and_keya        : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
        uint64_t datab_and_keyb        : 32; /**< [ 63: 32](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_rmemx_w2_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w2 bdk_tns_sde_isme_lm_tile_rmemx_w2_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060040010ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_RMEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(a) bdk_tns_sde_isme_lm_tile_rmemx_w2_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(a) "TNS_SDE_ISME_LM_TILE_RMEMX_W2"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_rmem#_w3
 *
 * TNS SDE ISME LM Tile Right Memory Word 3 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_rmemx_w3
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_rmemx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_rmemx_w3_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w3 bdk_tns_sde_isme_lm_tile_rmemx_w3_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060040018ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_RMEMX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(a) bdk_tns_sde_isme_lm_tile_rmemx_w3_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(a) "TNS_SDE_ISME_LM_TILE_RMEMX_W3"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_isme_lm_tile_rmem#_w4
 *
 * TNS SDE ISME LM Tile Right Memory Word 4 Registers
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 */
union bdk_tns_sde_isme_lm_tile_rmemx_w4
{
    uint64_t u;
    struct bdk_tns_sde_isme_lm_tile_rmemx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t datab_and_keyb        : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lm_tile_rmemx_w4_s cn; */
};
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w4 bdk_tns_sde_isme_lm_tile_rmemx_w4_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4095))
        return 0x842060040020ll + 0x40ll * ((a) & 0xfff);
    __bdk_csr_fatal("TNS_SDE_ISME_LM_TILE_RMEMX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(a) bdk_tns_sde_isme_lm_tile_rmemx_w4_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(a) "TNS_SDE_ISME_LM_TILE_RMEMX_W4"
#define device_bar_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(a) (a)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_lmkl_lock
 *
 * TNS SDE ISME LMKL Lock Register
 * Lock Register
 */
union bdk_tns_sde_isme_lmkl_lock
{
    uint32_t u;
    struct bdk_tns_sde_isme_lmkl_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_lmkl_lock_s cn; */
};
typedef union bdk_tns_sde_isme_lmkl_lock bdk_tns_sde_isme_lmkl_lock_t;

#define BDK_TNS_SDE_ISME_LMKL_LOCK BDK_TNS_SDE_ISME_LMKL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_LMKL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LMKL_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206008002cll;
    __bdk_csr_fatal("TNS_SDE_ISME_LMKL_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_LMKL_LOCK bdk_tns_sde_isme_lmkl_lock_t
#define bustype_BDK_TNS_SDE_ISME_LMKL_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_LMKL_LOCK "TNS_SDE_ISME_LMKL_LOCK"
#define device_bar_BDK_TNS_SDE_ISME_LMKL_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_LMKL_LOCK 0
#define arguments_BDK_TNS_SDE_ISME_LMKL_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_cfg_dbg_sel
 *
 * TNS SDE ISME Routing Configuration Debug Selector Register
 * Select debug data for isme__dbg_data_out to the top
 */
union bdk_tns_sde_isme_rt_cfg_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_cfg_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) -- */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_cfg_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_isme_rt_cfg_dbg_sel bdk_tns_sde_isme_rt_cfg_dbg_sel_t;

#define BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100044ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_CFG_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL bdk_tns_sde_isme_rt_cfg_dbg_sel_t
#define bustype_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL "TNS_SDE_ISME_RT_CFG_DBG_SEL"
#define device_bar_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL 0
#define arguments_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_cfg_mtrt#
 *
 * TNS SDE ISME Routing Configuration MTRT Registers
 * 1 shared MTRT for all input lanes.
 * The MTRT has 4 entries; each entry has 8 bit engine_id, a 2-bit output
 * link mask
 * representing the two LDEs, plus two lm_sel fields, one for each of the
 * LDEs. This field is used to select the local memory configuration to
 * be used for each of the lookups.
 */
union bdk_tns_sde_isme_rt_cfg_mtrtx
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_cfg_mtrtx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t engine_id             : 8;  /**< [ 13:  6](R/W) -- */
        uint32_t output_link_mask      : 2;  /**< [  5:  4](R/W) -- */
        uint32_t lm_sel0               : 2;  /**< [  3:  2](R/W) -- */
        uint32_t lm_sel1               : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t lm_sel1               : 2;  /**< [  1:  0](R/W) -- */
        uint32_t lm_sel0               : 2;  /**< [  3:  2](R/W) -- */
        uint32_t output_link_mask      : 2;  /**< [  5:  4](R/W) -- */
        uint32_t engine_id             : 8;  /**< [ 13:  6](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_cfg_mtrtx_s cn; */
};
typedef union bdk_tns_sde_isme_rt_cfg_mtrtx bdk_tns_sde_isme_rt_cfg_mtrtx_t;

static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_MTRTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_MTRTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x842060100020ll + 4ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_ISME_RT_CFG_MTRTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(a) bdk_tns_sde_isme_rt_cfg_mtrtx_t
#define bustype_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(a) "TNS_SDE_ISME_RT_CFG_MTRTX"
#define device_bar_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(a) (a)
#define arguments_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_cfg_utrt#
 *
 * TNS SDE ISME Routing Configuration UTRT Registers
 * --
 */
union bdk_tns_sde_isme_rt_cfg_utrtx
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_cfg_utrtx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t engine_id             : 8;  /**< [ 11:  4](R/W) -- */
        uint32_t link_id               : 2;  /**< [  3:  2](R/W) -- */
        uint32_t lm_sel                : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t lm_sel                : 2;  /**< [  1:  0](R/W) -- */
        uint32_t link_id               : 2;  /**< [  3:  2](R/W) -- */
        uint32_t engine_id             : 8;  /**< [ 11:  4](R/W) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_cfg_utrtx_s cn; */
};
typedef union bdk_tns_sde_isme_rt_cfg_utrtx bdk_tns_sde_isme_rt_cfg_utrtx_t;

static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_UTRTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_UTRTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842060100000ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SDE_ISME_RT_CFG_UTRTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(a) bdk_tns_sde_isme_rt_cfg_utrtx_t
#define bustype_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(a) "TNS_SDE_ISME_RT_CFG_UTRTX"
#define device_bar_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(a) (a)
#define arguments_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_dbg_cptr
 *
 * TNS SDE ISME Routing Debug Caputure Register
 * --
 */
union bdk_tns_sde_isme_rt_dbg_cptr
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_dbg_cptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_dbg_cptr_s cn; */
};
typedef union bdk_tns_sde_isme_rt_dbg_cptr bdk_tns_sde_isme_rt_dbg_cptr_t;

#define BDK_TNS_SDE_ISME_RT_DBG_CPTR BDK_TNS_SDE_ISME_RT_DBG_CPTR_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DBG_CPTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DBG_CPTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100048ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_DBG_CPTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_DBG_CPTR bdk_tns_sde_isme_rt_dbg_cptr_t
#define bustype_BDK_TNS_SDE_ISME_RT_DBG_CPTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_DBG_CPTR "TNS_SDE_ISME_RT_DBG_CPTR"
#define device_bar_BDK_TNS_SDE_ISME_RT_DBG_CPTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_DBG_CPTR 0
#define arguments_BDK_TNS_SDE_ISME_RT_DBG_CPTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_dr_int_en_hi
 *
 * TNS SDE ISME Routing DFC RX Interrrupt Enable High Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_rt_dr_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_dr_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](R/W) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](R/W) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](R/W) -- */
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_dr_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_isme_rt_dr_int_en_hi bdk_tns_sde_isme_rt_dr_int_en_hi_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100038ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_DR_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI bdk_tns_sde_isme_rt_dr_int_en_hi_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI "TNS_SDE_ISME_RT_DR_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_dr_int_en_lo
 *
 * TNS SDE ISME Routing DFC RX Interrrupt Enable Low Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_rt_dr_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_dr_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](R/W) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](R/W) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](R/W) -- */
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_dr_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_isme_rt_dr_int_en_lo bdk_tns_sde_isme_rt_dr_int_en_lo_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206010003cll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_DR_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO bdk_tns_sde_isme_rt_dr_int_en_lo_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO "TNS_SDE_ISME_RT_DR_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_dr_int_frc
 *
 * TNS SDE ISME Routing DFC RX Interrrupt Force Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_rt_dr_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_dr_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](WO) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](WO) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](WO) -- */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](WO) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](WO) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](WO) -- */
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](WO) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_dr_int_frc_s cn; */
};
typedef union bdk_tns_sde_isme_rt_dr_int_frc bdk_tns_sde_isme_rt_dr_int_frc_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_FRC BDK_TNS_SDE_ISME_RT_DR_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100040ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_DR_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_FRC bdk_tns_sde_isme_rt_dr_int_frc_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_FRC "TNS_SDE_ISME_RT_DR_INT_FRC"
#define device_bar_BDK_TNS_SDE_ISME_RT_DR_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_FRC 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_dr_int_w1c
 *
 * TNS SDE ISME Routing DFC RX Interrrupt W1C Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_rt_dr_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_dr_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t lde0_isme_dfc_rx_ovfl : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t lde1_isme_dfc_rx_ovfl : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_dr_int_w1c_s cn; */
};
typedef union bdk_tns_sde_isme_rt_dr_int_w1c bdk_tns_sde_isme_rt_dr_int_w1c_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_W1C BDK_TNS_SDE_ISME_RT_DR_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100034ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_DR_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_W1C bdk_tns_sde_isme_rt_dr_int_w1c_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_W1C "TNS_SDE_ISME_RT_DR_INT_W1C"
#define device_bar_BDK_TNS_SDE_ISME_RT_DR_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_W1C 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_fw_mode
 *
 * TNS SDE ISME Routing Forward Mode Register
 * --
 */
union bdk_tns_sde_isme_rt_fw_mode
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_fw_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_fw_mode_s cn; */
};
typedef union bdk_tns_sde_isme_rt_fw_mode bdk_tns_sde_isme_rt_fw_mode_t;

#define BDK_TNS_SDE_ISME_RT_FW_MODE BDK_TNS_SDE_ISME_RT_FW_MODE_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_FW_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_FW_MODE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100030ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_FW_MODE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_FW_MODE bdk_tns_sde_isme_rt_fw_mode_t
#define bustype_BDK_TNS_SDE_ISME_RT_FW_MODE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_FW_MODE "TNS_SDE_ISME_RT_FW_MODE"
#define device_bar_BDK_TNS_SDE_ISME_RT_FW_MODE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_FW_MODE 0
#define arguments_BDK_TNS_SDE_ISME_RT_FW_MODE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_lock
 *
 * TNS SDE ISME Routing Lock Register
 * Lock Register
 */
union bdk_tns_sde_isme_rt_lock
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_lock_s cn; */
};
typedef union bdk_tns_sde_isme_rt_lock bdk_tns_sde_isme_rt_lock_t;

#define BDK_TNS_SDE_ISME_RT_LOCK BDK_TNS_SDE_ISME_RT_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206010004cll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_LOCK bdk_tns_sde_isme_rt_lock_t
#define bustype_BDK_TNS_SDE_ISME_RT_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_LOCK "TNS_SDE_ISME_RT_LOCK"
#define device_bar_BDK_TNS_SDE_ISME_RT_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_LOCK 0
#define arguments_BDK_TNS_SDE_ISME_RT_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_rt_spad
 *
 * TNS SDE ISME Routing ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_isme_rt_spad
{
    uint32_t u;
    struct bdk_tns_sde_isme_rt_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_rt_spad_s cn; */
};
typedef union bdk_tns_sde_isme_rt_spad bdk_tns_sde_isme_rt_spad_t;

#define BDK_TNS_SDE_ISME_RT_SPAD BDK_TNS_SDE_ISME_RT_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060100050ll;
    __bdk_csr_fatal("TNS_SDE_ISME_RT_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_RT_SPAD bdk_tns_sde_isme_rt_spad_t
#define bustype_BDK_TNS_SDE_ISME_RT_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_RT_SPAD "TNS_SDE_ISME_RT_SPAD"
#define device_bar_BDK_TNS_SDE_ISME_RT_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_RT_SPAD 0
#define arguments_BDK_TNS_SDE_ISME_RT_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_spad
 *
 * TNS SDE ISME ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_isme_spad
{
    uint32_t u;
    struct bdk_tns_sde_isme_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_spad_s cn; */
};
typedef union bdk_tns_sde_isme_spad bdk_tns_sde_isme_spad_t;

#define BDK_TNS_SDE_ISME_SPAD BDK_TNS_SDE_ISME_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080030ll;
    __bdk_csr_fatal("TNS_SDE_ISME_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_SPAD bdk_tns_sde_isme_spad_t
#define bustype_BDK_TNS_SDE_ISME_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_SPAD "TNS_SDE_ISME_SPAD"
#define device_bar_BDK_TNS_SDE_ISME_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_SPAD 0
#define arguments_BDK_TNS_SDE_ISME_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_tile_int_en_hi
 *
 * TNS SDE ISME Tile Interrrupt Enable High Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_tile_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_isme_tile_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](R/W) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](R/W) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](R/W) -- */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](R/W) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](R/W) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](R/W) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](R/W) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_tile_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_isme_tile_int_en_hi bdk_tns_sde_isme_tile_int_en_hi_t;

#define BDK_TNS_SDE_ISME_TILE_INT_EN_HI BDK_TNS_SDE_ISME_TILE_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080020ll;
    __bdk_csr_fatal("TNS_SDE_ISME_TILE_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_TILE_INT_EN_HI bdk_tns_sde_isme_tile_int_en_hi_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_TILE_INT_EN_HI "TNS_SDE_ISME_TILE_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_ISME_TILE_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_tile_int_en_lo
 *
 * TNS SDE ISME Tile Interrrupt Enable Low Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_tile_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_isme_tile_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](R/W) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](R/W) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](R/W) -- */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](R/W) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](R/W) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](R/W) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](R/W) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_tile_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_isme_tile_int_en_lo bdk_tns_sde_isme_tile_int_en_lo_t;

#define BDK_TNS_SDE_ISME_TILE_INT_EN_LO BDK_TNS_SDE_ISME_TILE_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080024ll;
    __bdk_csr_fatal("TNS_SDE_ISME_TILE_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_TILE_INT_EN_LO bdk_tns_sde_isme_tile_int_en_lo_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_TILE_INT_EN_LO "TNS_SDE_ISME_TILE_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_ISME_TILE_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_tile_int_frc
 *
 * TNS SDE ISME Tile Interrrupt Force Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_tile_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_isme_tile_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](WO) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](WO) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](WO) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](WO) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](WO) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](WO) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](WO) -- */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](WO) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](WO) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](WO) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](WO) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](WO) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](WO) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](WO) -- */
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](WO) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_tile_int_frc_s cn; */
};
typedef union bdk_tns_sde_isme_tile_int_frc bdk_tns_sde_isme_tile_int_frc_t;

#define BDK_TNS_SDE_ISME_TILE_INT_FRC BDK_TNS_SDE_ISME_TILE_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060080028ll;
    __bdk_csr_fatal("TNS_SDE_ISME_TILE_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_TILE_INT_FRC bdk_tns_sde_isme_tile_int_frc_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_TILE_INT_FRC "TNS_SDE_ISME_TILE_INT_FRC"
#define device_bar_BDK_TNS_SDE_ISME_TILE_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_FRC 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_isme_tile_int_w1c
 *
 * TNS SDE ISME Tile Interrrupt W1C Register
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_isme_tile_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_isme_tile_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](R/W1C/H) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](R/W1C/H) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](R/W1C/H) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](R/W1C/H) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](R/W1C/H) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](R/W1C/H) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](R/W1C/H) -- */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t right_mem_ecc_db_err1 : 3;  /**< [  2:  0](R/W1C/H) -- */
        uint32_t right_mem_ecc_sb_err1 : 3;  /**< [  5:  3](R/W1C/H) -- */
        uint32_t right_mem_ecc_db_err0 : 3;  /**< [  8:  6](R/W1C/H) -- */
        uint32_t right_mem_ecc_sb_err0 : 3;  /**< [ 11:  9](R/W1C/H) -- */
        uint32_t left_mem_ecc_db_err1  : 3;  /**< [ 14: 12](R/W1C/H) -- */
        uint32_t left_mem_ecc_sb_err1  : 3;  /**< [ 17: 15](R/W1C/H) -- */
        uint32_t left_mem_ecc_db_err0  : 3;  /**< [ 20: 18](R/W1C/H) -- */
        uint32_t left_mem_ecc_sb_err0  : 3;  /**< [ 23: 21](R/W1C/H) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_isme_tile_int_w1c_s cn; */
};
typedef union bdk_tns_sde_isme_tile_int_w1c bdk_tns_sde_isme_tile_int_w1c_t;

#define BDK_TNS_SDE_ISME_TILE_INT_W1C BDK_TNS_SDE_ISME_TILE_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206008001cll;
    __bdk_csr_fatal("TNS_SDE_ISME_TILE_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_ISME_TILE_INT_W1C bdk_tns_sde_isme_tile_int_w1c_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_ISME_TILE_INT_W1C "TNS_SDE_ISME_TILE_INT_W1C"
#define device_bar_BDK_TNS_SDE_ISME_TILE_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_W1C 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_acmrh_int_en_hi
 *
 * TNS SDE LDE ACMRH Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_acmrh_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_acmrh_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t merge_timeout         : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t merge_timeout         : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_acmrh_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_acmrh_int_en_hi bdk_tns_sde_ldex_acmrh_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207298ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_ACMRH_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(a) bdk_tns_sde_ldex_acmrh_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(a) "TNS_SDE_LDEX_ACMRH_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_acmrh_int_en_lo
 *
 * TNS SDE LDE ACMRH Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_acmrh_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_acmrh_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t merge_timeout         : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t merge_timeout         : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_acmrh_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_acmrh_int_en_lo bdk_tns_sde_ldex_acmrh_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020729cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_ACMRH_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(a) bdk_tns_sde_ldex_acmrh_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(a) "TNS_SDE_LDEX_ACMRH_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_acmrh_int_frc
 *
 * TNS SDE LDE ACMRH Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_acmrh_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_acmrh_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t merge_timeout         : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t merge_timeout         : 1;  /**< [  0:  0](WO) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_acmrh_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_acmrh_int_frc bdk_tns_sde_ldex_acmrh_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072a0ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_ACMRH_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(a) bdk_tns_sde_ldex_acmrh_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(a) "TNS_SDE_LDEX_ACMRH_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_acmrh_int_w1c
 *
 * TNS SDE LDE ACMRH Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_acmrh_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_acmrh_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t merge_timeout         : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t merge_timeout         : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_acmrh_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_acmrh_int_w1c bdk_tns_sde_ldex_acmrh_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207294ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_ACMRH_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(a) bdk_tns_sde_ldex_acmrh_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(a) "TNS_SDE_LDEX_ACMRH_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_bp_mode
 *
 * TNS SDE LDE Configuration ACM Bypass Mode Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_bp_mode
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_bp_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_bp_mode_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_bp_mode bdk_tns_sde_ldex_cfg_acm_bp_mode_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207224ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_BP_MODE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(a) bdk_tns_sde_ldex_cfg_acm_bp_mode_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(a) "TNS_SDE_LDEX_CFG_ACM_BP_MODE"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fmbm_en
 *
 * TNS SDE LDE Configuration ACM Full Mirror Bit Mask Enable Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fmbm_en
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fmbm_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fmbm_en_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fmbm_en bdk_tns_sde_ldex_cfg_acm_fmbm_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207228ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FMBM_EN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(a) bdk_tns_sde_ldex_cfg_acm_fmbm_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(a) "TNS_SDE_LDEX_CFG_ACM_FMBM_EN"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fmbm_idx
 *
 * TNS SDE LDE Configuration ACM Full Mirror Bit Mask Index Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fmbm_idx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fmbm_idx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t field                 : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fmbm_idx_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fmbm_idx bdk_tns_sde_ldex_cfg_acm_fmbm_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020722cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FMBM_IDX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(a) bdk_tns_sde_ldex_cfg_acm_fmbm_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(a) "TNS_SDE_LDEX_CFG_ACM_FMBM_IDX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fneng
 *
 * TNS SDE LDE Configuration ACM Full Next Engine Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fneng
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fneng_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fneng_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fneng bdk_tns_sde_ldex_cfg_acm_fneng_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207244ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FNENG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(a) bdk_tns_sde_ldex_cfg_acm_fneng_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(a) "TNS_SDE_LDEX_CFG_ACM_FNENG"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fpcmd_cp
 *
 * TNS SDE LDE Configuration ACM Full Packet Command Is COPY2CPU Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fpcmd_cp
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_cp bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207238ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FPCMD_CP", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(a) bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(a) "TNS_SDE_LDEX_CFG_ACM_FPCMD_CP"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fpcmd_dp
 *
 * TNS SDE LDE Configuration ACM Full Packet Command Is Drop Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fpcmd_dp
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_dp bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207230ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FPCMD_DP", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(a) bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(a) "TNS_SDE_LDEX_CFG_ACM_FPCMD_DP"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fpcmd_fw
 *
 * TNS SDE LDE Configuration ACM Full Packet Command Forward Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fpcmd_fw
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_fw bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207234ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FPCMD_FW", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(a) bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(a) "TNS_SDE_LDEX_CFG_ACM_FPCMD_FW"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_fpcmd_tr
 *
 * TNS SDE LDE Configuration ACM Full Packet Command Is TRAP2CPU Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_fpcmd_tr
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_tr bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020723cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FPCMD_TR", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(a) bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(a) "TNS_SDE_LDEX_CFG_ACM_FPCMD_TR"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_frcod
 *
 * TNS SDE LDE Configuration ACM Full Reason Code Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_frcod
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_frcod_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_frcod_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_frcod bdk_tns_sde_ldex_cfg_acm_frcod_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207240ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_FRCOD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(a) bdk_tns_sde_ldex_cfg_acm_frcod_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(a) "TNS_SDE_LDEX_CFG_ACM_FRCOD"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_lane#
 *
 * TNS SDE LDE Configuration ACM Lane Registers
 * ACM lane types: null, counting, policing or sampling
 */
union bdk_tns_sde_ldex_cfg_acm_lanex
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_lanex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t req_type              : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t req_type              : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_lanex_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_lanex bdk_tns_sde_ldex_cfg_acm_lanex_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=3)))
        return 0x842060207214ll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_LANEX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(a,b) bdk_tns_sde_ldex_cfg_acm_lanex_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(a,b) "TNS_SDE_LDEX_CFG_ACM_LANEX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_to_cy
 *
 * TNS SDE LDE Configuration ACM Timeout Cycle Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_to_cy
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_to_cy_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field                 : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_to_cy_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_to_cy bdk_tns_sde_ldex_cfg_acm_to_cy_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020720cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_TO_CY", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(a) bdk_tns_sde_ldex_cfg_acm_to_cy_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(a) "TNS_SDE_LDEX_CFG_ACM_TO_CY"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_acm_to_fw_en
 *
 * TNS SDE LDE Configuration ACM Timeout Forward Enable Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_acm_to_fw_en
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_acm_to_fw_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_acm_to_fw_en_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_acm_to_fw_en bdk_tns_sde_ldex_cfg_acm_to_fw_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207210ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_ACM_TO_FW_EN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(a) bdk_tns_sde_ldex_cfg_acm_to_fw_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(a) "TNS_SDE_LDEX_CFG_ACM_TO_FW_EN"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit0#_w0
 *
 * TNS SDE LDE Configuration 1FIT_0 Word 0 Registers
 * KFIT_0
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_kfit0x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit0x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit0x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit0x_w0 bdk_tns_sde_ldex_cfg_kfit0x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206000ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT0X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(a,b) bdk_tns_sde_ldex_cfg_kfit0x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(a,b) "TNS_SDE_LDEX_CFG_KFIT0X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit0#_w1
 *
 * TNS SDE LDE Configuration 1FIT_0 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT0(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit0x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit0x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit0x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit0x_w1 bdk_tns_sde_ldex_cfg_kfit0x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206008ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT0X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(a,b) bdk_tns_sde_ldex_cfg_kfit0x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(a,b) "TNS_SDE_LDEX_CFG_KFIT0X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit0#_w2
 *
 * TNS SDE LDE Configuration 1FIT_0 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT0(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit0x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit0x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit0x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit0x_w2 bdk_tns_sde_ldex_cfg_kfit0x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206010ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT0X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(a,b) bdk_tns_sde_ldex_cfg_kfit0x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(a,b) "TNS_SDE_LDEX_CFG_KFIT0X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit1#_w0
 *
 * TNS SDE LDE Configuration 1FIT_1 Word 0 Registers
 * KFIT_1
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_kfit1x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit1x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit1x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit1x_w0 bdk_tns_sde_ldex_cfg_kfit1x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206200ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT1X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(a,b) bdk_tns_sde_ldex_cfg_kfit1x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(a,b) "TNS_SDE_LDEX_CFG_KFIT1X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit1#_w1
 *
 * TNS SDE LDE Configuration 1FIT_1 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT1(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit1x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit1x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit1x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit1x_w1 bdk_tns_sde_ldex_cfg_kfit1x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206208ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT1X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(a,b) bdk_tns_sde_ldex_cfg_kfit1x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(a,b) "TNS_SDE_LDEX_CFG_KFIT1X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit1#_w2
 *
 * TNS SDE LDE Configuration 1FIT_1 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT1(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit1x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit1x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit1x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit1x_w2 bdk_tns_sde_ldex_cfg_kfit1x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206210ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT1X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(a,b) bdk_tns_sde_ldex_cfg_kfit1x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(a,b) "TNS_SDE_LDEX_CFG_KFIT1X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit2#_w0
 *
 * TNS SDE LDE Configuration 1FIT_2 Word 0 Registers
 * KFIT_2
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_kfit2x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit2x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit2x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit2x_w0 bdk_tns_sde_ldex_cfg_kfit2x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206400ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT2X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(a,b) bdk_tns_sde_ldex_cfg_kfit2x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(a,b) "TNS_SDE_LDEX_CFG_KFIT2X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit2#_w1
 *
 * TNS SDE LDE Configuration 1FIT_2 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT2(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit2x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit2x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit2x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit2x_w1 bdk_tns_sde_ldex_cfg_kfit2x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206408ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT2X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(a,b) bdk_tns_sde_ldex_cfg_kfit2x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(a,b) "TNS_SDE_LDEX_CFG_KFIT2X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit2#_w2
 *
 * TNS SDE LDE Configuration 1FIT_2 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT2(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit2x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit2x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit2x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit2x_w2 bdk_tns_sde_ldex_cfg_kfit2x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206410ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT2X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(a,b) bdk_tns_sde_ldex_cfg_kfit2x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(a,b) "TNS_SDE_LDEX_CFG_KFIT2X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit3#_w0
 *
 * TNS SDE LDE Configuration 1FIT_3 Word 0 Registers
 * KFIT_3
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_kfit3x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit3x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit3x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit3x_w0 bdk_tns_sde_ldex_cfg_kfit3x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206600ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT3X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(a,b) bdk_tns_sde_ldex_cfg_kfit3x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(a,b) "TNS_SDE_LDEX_CFG_KFIT3X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit3#_w1
 *
 * TNS SDE LDE Configuration 1FIT_3 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT3(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit3x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit3x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit3x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit3x_w1 bdk_tns_sde_ldex_cfg_kfit3x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206608ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT3X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(a,b) bdk_tns_sde_ldex_cfg_kfit3x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(a,b) "TNS_SDE_LDEX_CFG_KFIT3X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit3#_w2
 *
 * TNS SDE LDE Configuration 1FIT_3 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT3(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit3x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit3x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit3x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit3x_w2 bdk_tns_sde_ldex_cfg_kfit3x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206610ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT3X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(a,b) bdk_tns_sde_ldex_cfg_kfit3x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(a,b) "TNS_SDE_LDEX_CFG_KFIT3X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit4#_w0
 *
 * TNS SDE LDE Configuration 1FIT_4 Word 0 Registers
 * KFIT_4
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_kfit4x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit4x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit4x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit4x_w0 bdk_tns_sde_ldex_cfg_kfit4x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206800ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT4X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(a,b) bdk_tns_sde_ldex_cfg_kfit4x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(a,b) "TNS_SDE_LDEX_CFG_KFIT4X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit4#_w1
 *
 * TNS SDE LDE Configuration 1FIT_4 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT4(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit4x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit4x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit4x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit4x_w1 bdk_tns_sde_ldex_cfg_kfit4x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206808ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT4X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(a,b) bdk_tns_sde_ldex_cfg_kfit4x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(a,b) "TNS_SDE_LDEX_CFG_KFIT4X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit4#_w2
 *
 * TNS SDE LDE Configuration 1FIT_4 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT4(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit4x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit4x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit4x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit4x_w2 bdk_tns_sde_ldex_cfg_kfit4x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206810ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT4X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(a,b) bdk_tns_sde_ldex_cfg_kfit4x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(a,b) "TNS_SDE_LDEX_CFG_KFIT4X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit5#_w0
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 0 Registers
 * KFIT_5
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_kfit5x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit5x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst0     : 42; /**< [ 41:  0](R/W) -- */
        uint64_t se_superkey_inst1     : 22; /**< [ 63: 42](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit5x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit5x_w0 bdk_tns_sde_ldex_cfg_kfit5x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206a00ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT5X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(a,b) bdk_tns_sde_ldex_cfg_kfit5x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(a,b) "TNS_SDE_LDEX_CFG_KFIT5X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit5#_w1
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT5(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit5x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit5x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst1     : 20; /**< [ 19:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
        uint64_t se_superkey_inst2     : 42; /**< [ 61: 20](R/W) -- */
        uint64_t se_superkey_inst3     : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit5x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit5x_w1 bdk_tns_sde_ldex_cfg_kfit5x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206a08ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT5X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(a,b) bdk_tns_sde_ldex_cfg_kfit5x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(a,b) "TNS_SDE_LDEX_CFG_KFIT5X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_kfit5#_w2
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT5(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_kfit5x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_kfit5x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t se_superkey_inst3     : 40; /**< [ 39:  0](R/W) Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit5x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit5x_w2 bdk_tns_sde_ldex_cfg_kfit5x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206a10ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT5X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(a,b) bdk_tns_sde_ldex_cfg_kfit5x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(a,b) "TNS_SDE_LDEX_CFG_KFIT5X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_kfit6#
 *
 * TNS SDE LDE Configuration 1FIT_6 Registers
 * KFIT_6
 */
union bdk_tns_sde_ldex_cfg_kfit6x
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_kfit6x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t se_profileid_inst     : 4;  /**< [  8:  5](R/W) -- */
        uint32_t se_cmd_envec_inst     : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_cmd_envec_inst     : 5;  /**< [  4:  0](R/W) -- */
        uint32_t se_profileid_inst     : 4;  /**< [  8:  5](R/W) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfit6x_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfit6x bdk_tns_sde_ldex_cfg_kfit6x_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT6X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT6X(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060206c00ll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFIT6X", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT6X(a,b) bdk_tns_sde_ldex_cfg_kfit6x_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT6X(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT6X(a,b) "TNS_SDE_LDEX_CFG_KFIT6X"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFIT6X(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT6X(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT6X(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_kfits_idx
 *
 * TNS SDE LDE Configuration KFITS Index Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_kfits_idx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_kfits_idx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_kfits_idx_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_kfits_idx bdk_tns_sde_ldex_cfg_kfits_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060206c40ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_KFITS_IDX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(a) bdk_tns_sde_ldex_cfg_kfits_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(a) "TNS_SDE_LDEX_CFG_KFITS_IDX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_lde_adr
 *
 * TNS SDE LDE Configuration LDE Address Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_lde_adr
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_lde_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_lde_adr_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_lde_adr bdk_tns_sde_ldex_cfg_lde_adr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_ADR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_ADR(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207204ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_LDE_ADR", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(a) bdk_tns_sde_ldex_cfg_lde_adr_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(a) "TNS_SDE_LDEX_CFG_LDE_ADR"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_lde_type
 *
 * TNS SDE LDE Configuration LDE Type Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_lde_type
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_lde_type_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_lde_type_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_lde_type bdk_tns_sde_ldex_cfg_lde_type_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207200ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_LDE_TYPE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(a) bdk_tns_sde_ldex_cfg_lde_type_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(a) "TNS_SDE_LDEX_CFG_LDE_TYPE"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ldea_dbg_sel
 *
 * TNS SDE LDE Configuration LDEA Debug Selector Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_ldea_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ldea_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ldea_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ldea_dbg_sel bdk_tns_sde_ldex_cfg_ldea_dbg_sel_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205044ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_LDEA_DBG_SEL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(a) bdk_tns_sde_ldex_cfg_ldea_dbg_sel_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(a) "TNS_SDE_LDEX_CFG_LDEA_DBG_SEL"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ldeb_dbg_sel
 *
 * TNS SDE LDE Configuration LDEB Debug Selector Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_ldeb_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ldeb_dbg_sel bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072c4ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_LDEB_DBG_SEL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(a) bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(a) "TNS_SDE_LDEX_CFG_LDEB_DBG_SEL"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_max_acm_reqs
 *
 * TNS SDE LDE Configuration Maximum ACM Requests Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_max_acm_reqs
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_max_acm_reqs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t field                 : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 5;  /**< [  4:  0](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_max_acm_reqs_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_max_acm_reqs bdk_tns_sde_ldex_cfg_max_acm_reqs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207208ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_MAX_ACM_REQS", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(a) bdk_tns_sde_ldex_cfg_max_acm_reqs_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(a) "TNS_SDE_LDEX_CFG_MAX_ACM_REQS"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_max_se_reqs
 *
 * TNS SDE LDE Configuration Maximum Search Requests Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_max_se_reqs
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_max_se_reqs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t field                 : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 7;  /**< [  6:  0](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_max_se_reqs_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_max_se_reqs bdk_tns_sde_ldex_cfg_max_se_reqs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205004ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_MAX_SE_REQS", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(a) bdk_tns_sde_ldex_cfg_max_se_reqs_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(a) "TNS_SDE_LDEX_CFG_MAX_SE_REQS"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_merge_mode
 *
 * TNS SDE LDE Configuration Merge Mode Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_merge_mode
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_merge_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_merge_mode_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_merge_mode bdk_tns_sde_ldex_cfg_merge_mode_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205000ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_MERGE_MODE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(a) bdk_tns_sde_ldex_cfg_merge_mode_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(a) "TNS_SDE_LDEX_CFG_MERGE_MODE"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit0#_w0
 *
 * TNS SDE LDE Configuration 1FIT_0 Word 0 Registers
 * OFIT_0
 * Bits[63:36] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit0x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit0x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_reasoncode_inst : 3;  /**< [ 63: 61](R/W) -- */
        uint64_t token_filtergrpnumber_inst : 20;/**< [ 60: 41](R/W) -- */
        uint64_t token_txq_sel_inst    : 28; /**< [ 40: 13](R/W) -- */
        uint64_t token_nextengine_inst : 9;  /**< [ 12:  4](R/W) -- */
        uint64_t token_slavelanesel_inst : 4;/**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token_slavelanesel_inst : 4;/**< [  3:  0](R/W) -- */
        uint64_t token_nextengine_inst : 9;  /**< [ 12:  4](R/W) -- */
        uint64_t token_txq_sel_inst    : 28; /**< [ 40: 13](R/W) -- */
        uint64_t token_filtergrpnumber_inst : 20;/**< [ 60: 41](R/W) -- */
        uint64_t token_reasoncode_inst : 3;  /**< [ 63: 61](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit0x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit0x_w0 bdk_tns_sde_ldex_cfg_ofit0x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200800ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT0X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit0x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT0X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit0#_w1
 *
 * TNS SDE LDE Configuration 1FIT_0 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT0(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit0x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit0x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_egressvif_inst  : 10; /**< [ 63: 54](R/W) -- */
        uint64_t token_ecmpsize_inst   : 24; /**< [ 53: 30](R/W) -- */
        uint64_t token_reasoncode_inst : 30; /**< [ 29:  0](R/W) Continuation of MSBs of field TOKEN_REASONCODE_INST from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_reasoncode_inst : 30; /**< [ 29:  0](R/W) Continuation of MSBs of field TOKEN_REASONCODE_INST from previous word. */
        uint64_t token_ecmpsize_inst   : 24; /**< [ 53: 30](R/W) -- */
        uint64_t token_egressvif_inst  : 10; /**< [ 63: 54](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit0x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit0x_w1 bdk_tns_sde_ldex_cfg_ofit0x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200808ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT0X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit0x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT0X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit0#_w2
 *
 * TNS SDE LDE Configuration 1FIT_0 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT0(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit0x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit0x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t token_pktcmd_inst     : 14; /**< [ 35: 22](R/W) -- */
        uint64_t token_egressvif_inst  : 22; /**< [ 21:  0](R/W) Continuation of MSBs of field TOKEN_EGRESSVIF_INST from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_egressvif_inst  : 22; /**< [ 21:  0](R/W) Continuation of MSBs of field TOKEN_EGRESSVIF_INST from previous word. */
        uint64_t token_pktcmd_inst     : 14; /**< [ 35: 22](R/W) -- */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit0x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit0x_w2 bdk_tns_sde_ldex_cfg_ofit0x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200810ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT0X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit0x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT0X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit1#
 *
 * TNS SDE LDE Configuration 1FIT_1 Registers
 * OFIT_1
 */
union bdk_tns_sde_ldex_cfg_ofit1x
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit1x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t token_ingressvif_inst : 32; /**< [ 51: 20](R/W) -- */
        uint64_t token_firstvldlayer_inst : 16;/**< [ 19:  4](R/W) -- */
        uint64_t token_hashselect_inst : 2;  /**< [  3:  2](R/W) -- */
        uint64_t token_tt_inst         : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token_tt_inst         : 2;  /**< [  1:  0](R/W) -- */
        uint64_t token_hashselect_inst : 2;  /**< [  3:  2](R/W) -- */
        uint64_t token_firstvldlayer_inst : 16;/**< [ 19:  4](R/W) -- */
        uint64_t token_ingressvif_inst : 32; /**< [ 51: 20](R/W) -- */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit1x_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit1x bdk_tns_sde_ldex_cfg_ofit1x_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT1X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT1X(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060202000ll + 0x8000ll * ((a) & 0x1) + 8ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT1X", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT1X(a,b) bdk_tns_sde_ldex_cfg_ofit1x_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT1X(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT1X(a,b) "TNS_SDE_LDEX_CFG_OFIT1X"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT1X(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT1X(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT1X(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit2#
 *
 * TNS SDE LDE Configuration 1FIT_2 Registers
 * OFIT_2
 */
union bdk_tns_sde_ldex_cfg_ofit2x
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit2x_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t token_mir_bm_inst     : 18; /**< [ 17:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t token_mir_bm_inst     : 18; /**< [ 17:  0](R/W) -- */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit2x_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit2x bdk_tns_sde_ldex_cfg_ofit2x_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT2X(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT2X(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060202100ll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT2X", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT2X(a,b) bdk_tns_sde_ldex_cfg_ofit2x_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT2X(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT2X(a,b) "TNS_SDE_LDEX_CFG_OFIT2X"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT2X(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT2X(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT2X(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit3#_w0
 *
 * TNS SDE LDE Configuration 1FIT_3 Word 0 Registers
 * OFIT_3
 * Bits[63:39] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit3x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit3x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_pcp_inst        : 12; /**< [ 63: 52](R/W) -- */
        uint64_t token_dei_inst        : 15; /**< [ 51: 37](R/W) -- */
        uint64_t token_dscp_inst       : 20; /**< [ 36: 17](R/W) -- */
        uint64_t token_exp_inst        : 17; /**< [ 16:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token_exp_inst        : 17; /**< [ 16:  0](R/W) -- */
        uint64_t token_dscp_inst       : 20; /**< [ 36: 17](R/W) -- */
        uint64_t token_dei_inst        : 15; /**< [ 51: 37](R/W) -- */
        uint64_t token_pcp_inst        : 12; /**< [ 63: 52](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit3x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit3x_w0 bdk_tns_sde_ldex_cfg_ofit3x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201c00ll + 0x8000ll * ((a) & 0x1) + 0x10ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT3X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit3x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT3X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit3#_w1
 *
 * TNS SDE LDE Configuration 1FIT_3 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT3(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit3x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit3x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_39_63        : 25;
        uint64_t token_dp_inst         : 16; /**< [ 38: 23](R/W) -- */
        uint64_t token_tc_inst         : 18; /**< [ 22:  5](R/W) -- */
        uint64_t token_pcp_inst        : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field TOKEN_PCP_INST from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_pcp_inst        : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field TOKEN_PCP_INST from previous word. */
        uint64_t token_tc_inst         : 18; /**< [ 22:  5](R/W) -- */
        uint64_t token_dp_inst         : 16; /**< [ 38: 23](R/W) -- */
        uint64_t reserved_39_63        : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit3x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit3x_w1 bdk_tns_sde_ldex_cfg_ofit3x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201c08ll + 0x8000ll * ((a) & 0x1) + 0x10ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT3X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit3x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT3X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit4#_w0
 *
 * TNS SDE LDE Configuration 1FIT_4 Word 0 Registers
 * OFIT_4
 * Bits[63:53] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit4x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit4x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_rewrptr3_inst   : 4;  /**< [ 63: 60](R/W) -- */
        uint64_t token_rewrptr2_inst   : 20; /**< [ 59: 40](R/W) -- */
        uint64_t token_rewrptr1_inst   : 20; /**< [ 39: 20](R/W) -- */
        uint64_t token_rewrptr0_inst   : 20; /**< [ 19:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token_rewrptr0_inst   : 20; /**< [ 19:  0](R/W) -- */
        uint64_t token_rewrptr1_inst   : 20; /**< [ 39: 20](R/W) -- */
        uint64_t token_rewrptr2_inst   : 20; /**< [ 59: 40](R/W) -- */
        uint64_t token_rewrptr3_inst   : 4;  /**< [ 63: 60](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit4x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit4x_w0 bdk_tns_sde_ldex_cfg_ofit4x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200c00ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT4X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit4x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT4X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit4#_w1
 *
 * TNS SDE LDE Configuration 1FIT_4 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT4(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit4x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit4x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_rewrptr6_inst   : 8;  /**< [ 63: 56](R/W) -- */
        uint64_t token_rewrptr5_inst   : 20; /**< [ 55: 36](R/W) -- */
        uint64_t token_rewrptr4_inst   : 20; /**< [ 35: 16](R/W) -- */
        uint64_t token_rewrptr3_inst   : 16; /**< [ 15:  0](R/W) Continuation of MSBs of field TOKEN_REWRITEPTR3_INST from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_rewrptr3_inst   : 16; /**< [ 15:  0](R/W) Continuation of MSBs of field TOKEN_REWRITEPTR3_INST from previous word. */
        uint64_t token_rewrptr4_inst   : 20; /**< [ 35: 16](R/W) -- */
        uint64_t token_rewrptr5_inst   : 20; /**< [ 55: 36](R/W) -- */
        uint64_t token_rewrptr6_inst   : 8;  /**< [ 63: 56](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit4x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit4x_w1 bdk_tns_sde_ldex_cfg_ofit4x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200c08ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT4X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit4x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT4X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit4#_w2
 *
 * TNS SDE LDE Configuration 1FIT_4 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT4(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit4x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit4x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_53_63        : 11;
        uint64_t token_rewritept6isins_inst : 2;/**< [ 52: 51](R/W) -- */
        uint64_t token_insertptr22_16_inst : 19;/**< [ 50: 32](R/W) -- */
        uint64_t token_rewrptr7_inst   : 20; /**< [ 31: 12](R/W) -- */
        uint64_t token_rewrptr6_inst   : 12; /**< [ 11:  0](R/W) Continuation of MSBs of field TOKEN_REWRITEPTR6_INST from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_rewrptr6_inst   : 12; /**< [ 11:  0](R/W) Continuation of MSBs of field TOKEN_REWRITEPTR6_INST from previous word. */
        uint64_t token_rewrptr7_inst   : 20; /**< [ 31: 12](R/W) -- */
        uint64_t token_insertptr22_16_inst : 19;/**< [ 50: 32](R/W) -- */
        uint64_t token_rewritept6isins_inst : 2;/**< [ 52: 51](R/W) -- */
        uint64_t reserved_53_63        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit4x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit4x_w2 bdk_tns_sde_ldex_cfg_ofit4x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200c10ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT4X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit4x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT4X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w0
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 0 Registers
 * OFIT_5
 * Bits[31:8] in _W[10] are unused.
 * When writing, the MSBs (word 10) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst0 : 32;/**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst0 : 32;/**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w0 bdk_tns_sde_ldex_cfg_ofit5x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200000ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w1
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst1 : 2; /**< [ 31: 30](R/W) -- */
        uint32_t token_scratchpad_inst0 : 30;/**< [ 29:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST0 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst0 : 30;/**< [ 29:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST0 from previous word. */
        uint32_t token_scratchpad_inst1 : 2; /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w1 bdk_tns_sde_ldex_cfg_ofit5x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200004ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w10
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 10 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w10
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t token_scratchpad_inst7 : 8; /**< [  7:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST7 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst7 : 8; /**< [  7:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST7 from previous word. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w10_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w10 bdk_tns_sde_ldex_cfg_ofit5x_w10_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200028ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W10", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w10_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W10"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w2
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst1 : 32;/**< [ 31:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst1 : 32;/**< [ 31:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST1 from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w2 bdk_tns_sde_ldex_cfg_ofit5x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200008ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w3
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 3 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w3
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst2 : 28;/**< [ 31:  4](R/W) -- */
        uint32_t token_scratchpad_inst1 : 4; /**< [  3:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst1 : 4; /**< [  3:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST1 from previous word. */
        uint32_t token_scratchpad_inst2 : 28;/**< [ 31:  4](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w3_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w3 bdk_tns_sde_ldex_cfg_ofit5x_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x84206020000cll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W3", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w3_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W3"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w4
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 4 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w4
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst3 : 22;/**< [ 31: 10](R/W) -- */
        uint32_t token_scratchpad_inst2 : 10;/**< [  9:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst2 : 10;/**< [  9:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST2 from previous word. */
        uint32_t token_scratchpad_inst3 : 22;/**< [ 31: 10](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w4_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w4 bdk_tns_sde_ldex_cfg_ofit5x_w4_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200010ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W4", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w4_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W4"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w5
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 5 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w5
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst4 : 16;/**< [ 31: 16](R/W) -- */
        uint32_t token_scratchpad_inst3 : 16;/**< [ 15:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst3 : 16;/**< [ 15:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST3 from previous word. */
        uint32_t token_scratchpad_inst4 : 16;/**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w5_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w5 bdk_tns_sde_ldex_cfg_ofit5x_w5_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200014ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W5", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w5_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W5"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w6
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 6 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w6
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst5 : 10;/**< [ 31: 22](R/W) -- */
        uint32_t token_scratchpad_inst4 : 22;/**< [ 21:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST4 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst4 : 22;/**< [ 21:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST4 from previous word. */
        uint32_t token_scratchpad_inst5 : 10;/**< [ 31: 22](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w6_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w6 bdk_tns_sde_ldex_cfg_ofit5x_w6_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200018ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W6", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w6_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W6"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w7
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 7 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w7
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst6 : 4; /**< [ 31: 28](R/W) -- */
        uint32_t token_scratchpad_inst5 : 28;/**< [ 27:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST5 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst5 : 28;/**< [ 27:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST5 from previous word. */
        uint32_t token_scratchpad_inst6 : 4; /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w7_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w7 bdk_tns_sde_ldex_cfg_ofit5x_w7_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x84206020001cll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W7", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w7_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W7"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w8
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 8 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w8
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst6 : 32;/**< [ 31:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST6 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst6 : 32;/**< [ 31:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST6 from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w8_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w8 bdk_tns_sde_ldex_cfg_ofit5x_w8_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200020ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W8", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w8_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W8"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit5#_w9
 *
 * TNS SDE LDE Configuration 1FIT_5 Word 9 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit5x_w9
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit5x_w9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_scratchpad_inst7 : 30;/**< [ 31:  2](R/W) -- */
        uint32_t token_scratchpad_inst6 : 2; /**< [  1:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST6 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_scratchpad_inst6 : 2; /**< [  1:  0](R/W) Continuation of MSBs of field TOKEN_SCRATCHPAD_INST6 from previous word. */
        uint32_t token_scratchpad_inst7 : 30;/**< [ 31:  2](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit5x_w9_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w9 bdk_tns_sde_ldex_cfg_ofit5x_w9_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060200024ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT5X_W9", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(a,b) bdk_tns_sde_ldex_cfg_ofit5x_w9_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(a,b) "TNS_SDE_LDEX_CFG_OFIT5X_W9"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit6#_w0
 *
 * TNS SDE LDE Configuration 1FIT_6 Word 0 Registers
 * OFIT_6
 * Bits[63:48] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit6x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit6x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_layers_inst1    : 20; /**< [ 63: 44](R/W) -- */
        uint64_t token_layers_inst0    : 44; /**< [ 43:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token_layers_inst0    : 44; /**< [ 43:  0](R/W) -- */
        uint64_t token_layers_inst1    : 20; /**< [ 63: 44](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit6x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit6x_w0 bdk_tns_sde_ldex_cfg_ofit6x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201000ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT6X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit6x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT6X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit6#_w1
 *
 * TNS SDE LDE Configuration 1FIT_6 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT6(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit6x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit6x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_layers_inst2    : 40; /**< [ 63: 24](R/W) -- */
        uint64_t token_layers_inst1    : 24; /**< [ 23:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_layers_inst1    : 24; /**< [ 23:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST1 from previous word. */
        uint64_t token_layers_inst2    : 40; /**< [ 63: 24](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit6x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit6x_w1 bdk_tns_sde_ldex_cfg_ofit6x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201008ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT6X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit6x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT6X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit6#_w2
 *
 * TNS SDE LDE Configuration 1FIT_6 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT6(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit6x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit6x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t token_layers_inst3    : 44; /**< [ 47:  4](R/W) -- */
        uint64_t token_layers_inst2    : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST2 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_layers_inst2    : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST2 from previous word. */
        uint64_t token_layers_inst3    : 44; /**< [ 47:  4](R/W) -- */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit6x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit6x_w2 bdk_tns_sde_ldex_cfg_ofit6x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201010ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT6X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit6x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT6X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit7#_w0
 *
 * TNS SDE LDE Configuration 1FIT_7 Word 0 Registers
 * OFIT_7
 * Bits[63:48] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit7x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit7x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_layers_inst1    : 20; /**< [ 63: 44](R/W) -- */
        uint64_t token_layers_inst0    : 44; /**< [ 43:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token_layers_inst0    : 44; /**< [ 43:  0](R/W) -- */
        uint64_t token_layers_inst1    : 20; /**< [ 63: 44](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit7x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit7x_w0 bdk_tns_sde_ldex_cfg_ofit7x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201400ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT7X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit7x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT7X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit7#_w1
 *
 * TNS SDE LDE Configuration 1FIT_7 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT7(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit7x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit7x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token_layers_inst2    : 40; /**< [ 63: 24](R/W) -- */
        uint64_t token_layers_inst1    : 24; /**< [ 23:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_layers_inst1    : 24; /**< [ 23:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST1 from previous word. */
        uint64_t token_layers_inst2    : 40; /**< [ 63: 24](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit7x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit7x_w1 bdk_tns_sde_ldex_cfg_ofit7x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201408ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT7X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit7x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT7X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit7#_w2
 *
 * TNS SDE LDE Configuration 1FIT_7 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT7(0..31)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit7x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit7x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t token_layers_inst3    : 44; /**< [ 47:  4](R/W) -- */
        uint64_t token_layers_inst2    : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST2 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t token_layers_inst2    : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field TOKEN_LAYERS_INST2 from previous word. */
        uint64_t token_layers_inst3    : 44; /**< [ 47:  4](R/W) -- */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit7x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit7x_w2 bdk_tns_sde_ldex_cfg_ofit7x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842060201410ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT7X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit7x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT7X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit8#_w0
 *
 * TNS SDE LDE Configuration 1FIT_8 Word 0 Registers
 * OFIT_8
 * Bits[31:28] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit8x_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit8x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t acm_req_addr_inst0    : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_req_addr_inst0    : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit8x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w0 bdk_tns_sde_ldex_cfg_ofit8x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201e00ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT8X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit8x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT8X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit8#_w1
 *
 * TNS SDE LDE Configuration 1FIT_8 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit8x_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit8x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t acm_req_addr_inst1    : 25; /**< [ 31:  7](R/W) -- */
        uint32_t acm_req_cmd_inst0     : 2;  /**< [  6:  5](R/W) -- */
        uint32_t acm_req_addr_inst0    : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST0 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t acm_req_addr_inst0    : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST0 from previous word. */
        uint32_t acm_req_cmd_inst0     : 2;  /**< [  6:  5](R/W) -- */
        uint32_t acm_req_addr_inst1    : 25; /**< [ 31:  7](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit8x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w1 bdk_tns_sde_ldex_cfg_ofit8x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201e04ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT8X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit8x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT8X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit8#_w2
 *
 * TNS SDE LDE Configuration 1FIT_8 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit8x_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit8x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t acm_req_addr_inst2    : 18; /**< [ 31: 14](R/W) -- */
        uint32_t acm_req_cmd_inst1     : 2;  /**< [ 13: 12](R/W) -- */
        uint32_t acm_req_addr_inst1    : 12; /**< [ 11:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t acm_req_addr_inst1    : 12; /**< [ 11:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST1 from previous word. */
        uint32_t acm_req_cmd_inst1     : 2;  /**< [ 13: 12](R/W) -- */
        uint32_t acm_req_addr_inst2    : 18; /**< [ 31: 14](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit8x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w2 bdk_tns_sde_ldex_cfg_ofit8x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201e08ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT8X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit8x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT8X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit8#_w3
 *
 * TNS SDE LDE Configuration 1FIT_8 Word 3 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit8x_w3
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit8x_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t acm_req_addr_inst3    : 11; /**< [ 31: 21](R/W) -- */
        uint32_t acm_req_cmd_inst2     : 2;  /**< [ 20: 19](R/W) -- */
        uint32_t acm_req_addr_inst2    : 19; /**< [ 18:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t acm_req_addr_inst2    : 19; /**< [ 18:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST2 from previous word. */
        uint32_t acm_req_cmd_inst2     : 2;  /**< [ 20: 19](R/W) -- */
        uint32_t acm_req_addr_inst3    : 11; /**< [ 31: 21](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit8x_w3_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w3 bdk_tns_sde_ldex_cfg_ofit8x_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201e0cll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT8X_W3", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(a,b) bdk_tns_sde_ldex_cfg_ofit8x_w3_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(a,b) "TNS_SDE_LDEX_CFG_OFIT8X_W3"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofit8#_w4
 *
 * TNS SDE LDE Configuration 1FIT_8 Word 4 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit8x_w4
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofit8x_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t acm_req_cmd_inst3     : 2;  /**< [ 27: 26](R/W) -- */
        uint32_t acm_req_addr_inst3    : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t acm_req_addr_inst3    : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ACM_REQ_ADDR_INST3 from previous word. */
        uint32_t acm_req_cmd_inst3     : 2;  /**< [ 27: 26](R/W) -- */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit8x_w4_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w4 bdk_tns_sde_ldex_cfg_ofit8x_w4_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201e10ll + 0x8000ll * ((a) & 0x1) + 0x20ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT8X_W4", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(a,b) bdk_tns_sde_ldex_cfg_ofit8x_w4_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(a,b) "TNS_SDE_LDEX_CFG_OFIT8X_W4"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit9#_w0
 *
 * TNS SDE LDE Configuration 1FIT_9 Word 0 Registers
 * OFIT_9
 * Bits[63:50] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_ofit9x_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit9x_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lm_req_key_inst1      : 26; /**< [ 63: 38](R/W) -- */
        uint64_t lm_req_key_inst0      : 38; /**< [ 37:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t lm_req_key_inst0      : 38; /**< [ 37:  0](R/W) -- */
        uint64_t lm_req_key_inst1      : 26; /**< [ 63: 38](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit9x_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w0 bdk_tns_sde_ldex_cfg_ofit9x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201800ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT9X_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(a,b) bdk_tns_sde_ldex_cfg_ofit9x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(a,b) "TNS_SDE_LDEX_CFG_OFIT9X_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit9#_w1
 *
 * TNS SDE LDE Configuration 1FIT_9 Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit9x_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit9x_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lm_req_key_inst3      : 14; /**< [ 63: 50](R/W) -- */
        uint64_t lm_req_key_inst2      : 38; /**< [ 49: 12](R/W) -- */
        uint64_t lm_req_key_inst1      : 12; /**< [ 11:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lm_req_key_inst1      : 12; /**< [ 11:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST1 from previous word. */
        uint64_t lm_req_key_inst2      : 38; /**< [ 49: 12](R/W) -- */
        uint64_t lm_req_key_inst3      : 14; /**< [ 63: 50](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit9x_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w1 bdk_tns_sde_ldex_cfg_ofit9x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201808ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT9X_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(a,b) bdk_tns_sde_ldex_cfg_ofit9x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(a,b) "TNS_SDE_LDEX_CFG_OFIT9X_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit9#_w2
 *
 * TNS SDE LDE Configuration 1FIT_9 Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit9x_w2
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit9x_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lm_req_key_inst5      : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t lm_req_key_inst4      : 38; /**< [ 61: 24](R/W) -- */
        uint64_t lm_req_key_inst3      : 24; /**< [ 23:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST3 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lm_req_key_inst3      : 24; /**< [ 23:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST3 from previous word. */
        uint64_t lm_req_key_inst4      : 38; /**< [ 61: 24](R/W) -- */
        uint64_t lm_req_key_inst5      : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit9x_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w2 bdk_tns_sde_ldex_cfg_ofit9x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201810ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT9X_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(a,b) bdk_tns_sde_ldex_cfg_ofit9x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(a,b) "TNS_SDE_LDEX_CFG_OFIT9X_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit9#_w3
 *
 * TNS SDE LDE Configuration 1FIT_9 Word 3 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit9x_w3
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit9x_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lm_req_key_inst6      : 28; /**< [ 63: 36](R/W) -- */
        uint64_t lm_req_key_inst5      : 36; /**< [ 35:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST5 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lm_req_key_inst5      : 36; /**< [ 35:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST5 from previous word. */
        uint64_t lm_req_key_inst6      : 28; /**< [ 63: 36](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit9x_w3_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w3 bdk_tns_sde_ldex_cfg_ofit9x_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201818ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT9X_W3", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(a,b) bdk_tns_sde_ldex_cfg_ofit9x_w3_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(a,b) "TNS_SDE_LDEX_CFG_OFIT9X_W3"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_lde#_cfg_ofit9#_w4
 *
 * TNS SDE LDE Configuration 1FIT_9 Word 4 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 */
union bdk_tns_sde_ldex_cfg_ofit9x_w4
{
    uint64_t u;
    struct bdk_tns_sde_ldex_cfg_ofit9x_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_50_63        : 14;
        uint64_t lm_req_cmd_inst       : 2;  /**< [ 49: 48](R/W) -- */
        uint64_t lm_req_key_inst7      : 38; /**< [ 47: 10](R/W) -- */
        uint64_t lm_req_key_inst6      : 10; /**< [  9:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST6 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lm_req_key_inst6      : 10; /**< [  9:  0](R/W) Continuation of MSBs of field LM_REQ_KEY_INST6 from previous word. */
        uint64_t lm_req_key_inst7      : 38; /**< [ 47: 10](R/W) -- */
        uint64_t lm_req_cmd_inst       : 2;  /**< [ 49: 48](R/W) -- */
        uint64_t reserved_50_63        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofit9x_w4_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w4 bdk_tns_sde_ldex_cfg_ofit9x_w4_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=15)))
        return 0x842060201820ll + 0x8000ll * ((a) & 0x1) + 0x40ll * ((b) & 0xf);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFIT9X_W4", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(a,b) bdk_tns_sde_ldex_cfg_ofit9x_w4_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(a,b) "TNS_SDE_LDEX_CFG_OFIT9X_W4"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ofits_idx
 *
 * TNS SDE LDE Configuration OFITS Index Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_ofits_idx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ofits_idx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ofits_idx_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ofits_idx bdk_tns_sde_ldex_cfg_ofits_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060202180ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_OFITS_IDX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(a) bdk_tns_sde_ldex_cfg_ofits_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(a) "TNS_SDE_LDEX_CFG_OFITS_IDX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dmbm_en
 *
 * TNS SDE LDE Configuration POL Drop Mirror Bit Mask Enable Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dmbm_en
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dmbm_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dmbm_en_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dmbm_en bdk_tns_sde_ldex_cfg_pol_dmbm_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207248ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DMBM_EN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(a) bdk_tns_sde_ldex_cfg_pol_dmbm_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(a) "TNS_SDE_LDEX_CFG_POL_DMBM_EN"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dmbm_idx
 *
 * TNS SDE LDE Configuration POL Drop Mirror Bit Mask Index Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dmbm_idx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dmbm_idx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t field                 : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dmbm_idx_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dmbm_idx bdk_tns_sde_ldex_cfg_pol_dmbm_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020724cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DMBM_IDX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(a) bdk_tns_sde_ldex_cfg_pol_dmbm_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(a) "TNS_SDE_LDEX_CFG_POL_DMBM_IDX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dneng
 *
 * TNS SDE LDE Configuration POL Drop Next Engine Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dneng
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dneng_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dneng_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dneng bdk_tns_sde_ldex_cfg_pol_dneng_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DNENG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DNENG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207264ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DNENG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(a) bdk_tns_sde_ldex_cfg_pol_dneng_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(a) "TNS_SDE_LDEX_CFG_POL_DNENG"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dpcmd_cp
 *
 * TNS SDE LDE Configuration POL Drop Packet Command Is COPY2CPU Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dpcmd_cp
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_cp bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207258ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DPCMD_CP", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(a) bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(a) "TNS_SDE_LDEX_CFG_POL_DPCMD_CP"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dpcmd_dp
 *
 * TNS SDE LDE Configuration POL Drop Packet Command Is Drop Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dpcmd_dp
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_dp bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207250ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DPCMD_DP", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(a) bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(a) "TNS_SDE_LDEX_CFG_POL_DPCMD_DP"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dpcmd_fw
 *
 * TNS SDE LDE Configuration POL Drop Packet Command Forward Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dpcmd_fw
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_fw bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207254ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DPCMD_FW", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(a) bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(a) "TNS_SDE_LDEX_CFG_POL_DPCMD_FW"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_dpcmd_tr
 *
 * TNS SDE LDE Configuration POL Drop Packet Command Is TRAP2CPU Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_dpcmd_tr
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_tr bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020725cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DPCMD_TR", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(a) bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(a) "TNS_SDE_LDEX_CFG_POL_DPCMD_TR"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_pol_drcod
 *
 * TNS SDE LDE Configuration POL Drop Reason Code Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_pol_drcod
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_pol_drcod_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_pol_drcod_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_pol_drcod bdk_tns_sde_ldex_cfg_pol_drcod_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207260ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_POL_DRCOD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(a) bdk_tns_sde_ldex_cfg_pol_drcod_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(a) "TNS_SDE_LDEX_CFG_POL_DRCOD"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_prfl_tbl#
 *
 * TNS SDE LDE Configuration Profile Table Registers
 * ProfileID Table
 */
union bdk_tns_sde_ldex_cfg_prfl_tblx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_prfl_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t se_cmd3_rslt_lane_bitmap : 8;/**< [ 31: 24](R/W) -- */
        uint32_t se_cmd2_rslt_lane_bitmap : 8;/**< [ 23: 16](R/W) -- */
        uint32_t se_cmd1_rslt_lane_bitmap : 8;/**< [ 15:  8](R/W) -- */
        uint32_t se_cmd0_rslt_lane_bitmap : 8;/**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_cmd0_rslt_lane_bitmap : 8;/**< [  7:  0](R/W) -- */
        uint32_t se_cmd1_rslt_lane_bitmap : 8;/**< [ 15:  8](R/W) -- */
        uint32_t se_cmd2_rslt_lane_bitmap : 8;/**< [ 23: 16](R/W) -- */
        uint32_t se_cmd3_rslt_lane_bitmap : 8;/**< [ 31: 24](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_prfl_tblx_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_prfl_tblx bdk_tns_sde_ldex_cfg_prfl_tblx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=7)))
        return 0x842060207300ll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_PRFL_TBLX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(a,b) bdk_tns_sde_ldex_cfg_prfl_tblx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(a,b) "TNS_SDE_LDEX_CFG_PRFL_TBLX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_se_to_cy
 *
 * TNS SDE LDE Configuration Search Timeout Cycle Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_se_to_cy
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_se_to_cy_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field                 : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_se_to_cy_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_se_to_cy bdk_tns_sde_ldex_cfg_se_to_cy_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207320ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_SE_TO_CY", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(a) bdk_tns_sde_ldex_cfg_se_to_cy_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(a) "TNS_SDE_LDEX_CFG_SE_TO_CY"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_se_to_fw_en
 *
 * TNS SDE LDE Configuration Search Timeout Forward Enable Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_se_to_fw_en
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_se_to_fw_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_se_to_fw_en_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_se_to_fw_en bdk_tns_sde_ldex_cfg_se_to_fw_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207324ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_SE_TO_FW_EN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(a) bdk_tns_sde_ldex_cfg_se_to_fw_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(a) "TNS_SDE_LDEX_CFG_SE_TO_FW_EN"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_smp_lane#
 *
 * TNS SDE LDE Configuration SMP Lane Registers
 * 4 sampling indexes for 4 rslt lanes
 */
union bdk_tns_sde_ldex_cfg_smp_lanex
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_smp_lanex_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mirrorbitmask_index   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mirrorbitmask_index   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_smp_lanex_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_smp_lanex bdk_tns_sde_ldex_cfg_smp_lanex_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=3)))
        return 0x842060207268ll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_SMP_LANEX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(a,b) bdk_tns_sde_ldex_cfg_smp_lanex_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(a,b) "TNS_SDE_LDEX_CFG_SMP_LANEX"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_tpl_tbl#_w0
 *
 * TNS SDE LDE Configuration TPL Table Word 0 Registers
 * TemplateID Table
 * Bits[31:30] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_ldex_cfg_tpl_tblx_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_tpl_tblx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t metadata              : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t metadata              : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_tpl_tblx_w0 bdk_tns_sde_ldex_cfg_tpl_tblx_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=255)))
        return 0x842060204000ll + 0x8000ll * ((a) & 0x1) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_TPL_TBLX_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(a,b) bdk_tns_sde_ldex_cfg_tpl_tblx_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(a,b) "TNS_SDE_LDEX_CFG_TPL_TBLX_W0"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_tpl_tbl#_w1
 *
 * TNS SDE LDE Configuration TPL Table Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_TPL_TBL(0..255)_W0
 */
union bdk_tns_sde_ldex_cfg_tpl_tblx_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_tpl_tblx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t layer4_offset         : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t layer3_offset         : 7;  /**< [ 27: 21](R/W) -- */
        uint32_t layer2_offset         : 7;  /**< [ 20: 14](R/W) -- */
        uint32_t layer1_offset         : 7;  /**< [ 13:  7](R/W) -- */
        uint32_t layer0_offset         : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t layer0_offset         : 7;  /**< [  6:  0](R/W) -- */
        uint32_t layer1_offset         : 7;  /**< [ 13:  7](R/W) -- */
        uint32_t layer2_offset         : 7;  /**< [ 20: 14](R/W) -- */
        uint32_t layer3_offset         : 7;  /**< [ 27: 21](R/W) -- */
        uint32_t layer4_offset         : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_tpl_tblx_w1 bdk_tns_sde_ldex_cfg_tpl_tblx_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=255)))
        return 0x842060204004ll + 0x8000ll * ((a) & 0x1) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_TPL_TBLX_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(a,b) bdk_tns_sde_ldex_cfg_tpl_tblx_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(a,b) "TNS_SDE_LDEX_CFG_TPL_TBLX_W1"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_tpl_tbl#_w2
 *
 * TNS SDE LDE Configuration TPL Table Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_TPL_TBL(0..255)_W0
 */
union bdk_tns_sde_ldex_cfg_tpl_tblx_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_tpl_tblx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t fstint_lid1           : 3;  /**< [ 29: 27](R/W) -- */
        uint32_t fstint_lid0           : 3;  /**< [ 26: 24](R/W) -- */
        uint32_t layer7_offset         : 7;  /**< [ 23: 17](R/W) -- */
        uint32_t layer6_offset         : 7;  /**< [ 16: 10](R/W) -- */
        uint32_t layer5_offset         : 7;  /**< [  9:  3](R/W) -- */
        uint32_t layer4_offset         : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field LAYER4_OFFSET from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t layer4_offset         : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field LAYER4_OFFSET from previous word. */
        uint32_t layer5_offset         : 7;  /**< [  9:  3](R/W) -- */
        uint32_t layer6_offset         : 7;  /**< [ 16: 10](R/W) -- */
        uint32_t layer7_offset         : 7;  /**< [ 23: 17](R/W) -- */
        uint32_t fstint_lid0           : 3;  /**< [ 26: 24](R/W) -- */
        uint32_t fstint_lid1           : 3;  /**< [ 29: 27](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_tpl_tblx_w2 bdk_tns_sde_ldex_cfg_tpl_tblx_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=255)))
        return 0x842060204008ll + 0x8000ll * ((a) & 0x1) + 0x10ll * ((b) & 0xff);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_TPL_TBLX_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(a,b) bdk_tns_sde_ldex_cfg_tpl_tblx_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(a,b) "TNS_SDE_LDEX_CFG_TPL_TBLX_W2"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ttl_fl_neng
 *
 * TNS SDE LDE Configuration Total Fail Next Engine Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_ttl_fl_neng
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ttl_fl_neng_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ttl_fl_neng_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ttl_fl_neng bdk_tns_sde_ldex_cfg_ttl_fl_neng_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207280ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_TTL_FL_NENG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(a) bdk_tns_sde_ldex_cfg_ttl_fl_neng_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(a) "TNS_SDE_LDEX_CFG_TTL_FL_NENG"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ttl_fl_pcmd
 *
 * TNS SDE LDE Configuration Total Fail Packet Command Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_ttl_fl_pcmd
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ttl_fl_pcmd bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207278ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_TTL_FL_PCMD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(a) bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(a) "TNS_SDE_LDEX_CFG_TTL_FL_PCMD"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_cfg_ttl_fl_rcod
 *
 * TNS SDE LDE Configuration Total Fail Reason Code Registers
 * --
 */
union bdk_tns_sde_ldex_cfg_ttl_fl_rcod
{
    uint32_t u;
    struct bdk_tns_sde_ldex_cfg_ttl_fl_rcod_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_cfg_ttl_fl_rcod_s cn; */
};
typedef union bdk_tns_sde_ldex_cfg_ttl_fl_rcod bdk_tns_sde_ldex_cfg_ttl_fl_rcod_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020727cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_CFG_TTL_FL_RCOD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(a) bdk_tns_sde_ldex_cfg_ttl_fl_rcod_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(a) "TNS_SDE_LDEX_CFG_TTL_FL_RCOD"
#define device_bar_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_acmrh_w0
 *
 * TNS SDE LDE Debug ACMRH Word 0 Registers
 * Capture acmrh info for debug
 */
union bdk_tns_sde_ldex_dbg_acmrh_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_acmrh_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t probe_acm_rslt_exp_vector : 2;/**< [ 31: 30](R/W/H) -- */
        uint32_t probe_acm_rslt_valid_vector : 4;/**< [ 29: 26](R/W/H) -- */
        uint32_t output_arbiter_req_vector : 2;/**< [ 25: 24](R/W/H) -- */
        uint32_t output_arbiter_grant_vector : 2;/**< [ 23: 22](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t out_pktcmd            : 2;  /**< [ 19: 18](R/W/H) -- */
        uint32_t out_reasoncode        : 10; /**< [ 17:  8](R/W/H) -- */
        uint32_t out_nxtengine         : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_nxtengine         : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t out_reasoncode        : 10; /**< [ 17:  8](R/W/H) -- */
        uint32_t out_pktcmd            : 2;  /**< [ 19: 18](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t output_arbiter_grant_vector : 2;/**< [ 23: 22](R/W/H) -- */
        uint32_t output_arbiter_req_vector : 2;/**< [ 25: 24](R/W/H) -- */
        uint32_t probe_acm_rslt_valid_vector : 4;/**< [ 29: 26](R/W/H) -- */
        uint32_t probe_acm_rslt_exp_vector : 2;/**< [ 31: 30](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_acmrh_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_acmrh_w0 bdk_tns_sde_ldex_dbg_acmrh_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072d4ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_ACMRH_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(a) bdk_tns_sde_ldex_dbg_acmrh_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(a) "TNS_SDE_LDEX_DBG_ACMRH_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_acmrh_w1
 *
 * TNS SDE LDE Debug ACMRH Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_ACMRH_W0
 */
union bdk_tns_sde_ldex_dbg_acmrh_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_acmrh_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t acm_rslt_ln0_in_drdy  : 1;  /**< [ 31: 31](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_reqid : 4;  /**< [ 30: 27](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_smp_event : 1;/**< [ 26: 26](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_drop  : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t probe_srdy            : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t probe_drdy            : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t probe_acm_reqid       : 4;  /**< [ 22: 19](R/W/H) -- */
        uint32_t probe_waiting_time    : 16; /**< [ 18:  3](R/W/H) -- */
        uint32_t probe_timeout         : 1;  /**< [  2:  2](R/W/H) -- */
        uint32_t probe_acm_rslt_exp_vector : 2;/**< [  1:  0](R/W/H) Continuation of MSBs of field PROBE_ACM_RSLT_EXPECTED_VECTOR from previous
                                                                 word. */
#else /* Word 0 - Little Endian */
        uint32_t probe_acm_rslt_exp_vector : 2;/**< [  1:  0](R/W/H) Continuation of MSBs of field PROBE_ACM_RSLT_EXPECTED_VECTOR from previous
                                                                 word. */
        uint32_t probe_timeout         : 1;  /**< [  2:  2](R/W/H) -- */
        uint32_t probe_waiting_time    : 16; /**< [ 18:  3](R/W/H) -- */
        uint32_t probe_acm_reqid       : 4;  /**< [ 22: 19](R/W/H) -- */
        uint32_t probe_drdy            : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t probe_srdy            : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_drop  : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_smp_event : 1;/**< [ 26: 26](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_reqid : 4;  /**< [ 30: 27](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_drdy  : 1;  /**< [ 31: 31](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_acmrh_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_acmrh_w1 bdk_tns_sde_ldex_dbg_acmrh_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072d8ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_ACMRH_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(a) bdk_tns_sde_ldex_dbg_acmrh_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(a) "TNS_SDE_LDEX_DBG_ACMRH_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_acmrh_w2
 *
 * TNS SDE LDE Debug ACMRH Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_ACMRH_W0
 */
union bdk_tns_sde_ldex_dbg_acmrh_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_acmrh_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t input_buf_usage       : 5;  /**< [ 31: 27](R/W/H) -- */
        uint32_t bypass_buf_in_srdy    : 1;  /**< [ 26: 26](R/W/H) -- */
        uint32_t bypass_buf_in_drdy    : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t bypass_buf_usage      : 3;  /**< [ 24: 22](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_srdy : 1; /**< [ 21: 21](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_drdy : 1; /**< [ 20: 20](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_reqid : 4;/**< [ 19: 16](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_smp_event : 1;/**< [ 15: 15](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_srdy : 1; /**< [ 14: 14](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_drdy : 1; /**< [ 13: 13](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_reqid : 4;/**< [ 12:  9](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_smp_event : 1;/**< [  8:  8](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_srdy : 1; /**< [  7:  7](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_drdy : 1; /**< [  6:  6](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_reqid : 4;/**< [  5:  2](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_smp_event : 1;/**< [  1:  1](R/W/H) -- */
        uint32_t acm_rslt_ln0_in_srdy  : 1;  /**< [  0:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_rslt_ln0_in_srdy  : 1;  /**< [  0:  0](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_smp_event : 1;/**< [  1:  1](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_reqid : 4;/**< [  5:  2](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_drdy : 1; /**< [  6:  6](R/W/H) -- */
        uint32_t acm_rslt_lane1_in_srdy : 1; /**< [  7:  7](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_smp_event : 1;/**< [  8:  8](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_reqid : 4;/**< [ 12:  9](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_drdy : 1; /**< [ 13: 13](R/W/H) -- */
        uint32_t acm_rslt_lane2_in_srdy : 1; /**< [ 14: 14](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_smp_event : 1;/**< [ 15: 15](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_reqid : 4;/**< [ 19: 16](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_drdy : 1; /**< [ 20: 20](R/W/H) -- */
        uint32_t acm_rslt_lane3_in_srdy : 1; /**< [ 21: 21](R/W/H) -- */
        uint32_t bypass_buf_usage      : 3;  /**< [ 24: 22](R/W/H) -- */
        uint32_t bypass_buf_in_drdy    : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t bypass_buf_in_srdy    : 1;  /**< [ 26: 26](R/W/H) -- */
        uint32_t input_buf_usage       : 5;  /**< [ 31: 27](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_acmrh_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_acmrh_w2 bdk_tns_sde_ldex_dbg_acmrh_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072dcll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_ACMRH_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(a) bdk_tns_sde_ldex_dbg_acmrh_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(a) "TNS_SDE_LDEX_DBG_ACMRH_W2"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_acmrh_w3
 *
 * TNS SDE LDE Debug ACMRH Word 3 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_ACMRH_W0
 */
union bdk_tns_sde_ldex_dbg_acmrh_w3
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_acmrh_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t locked                : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t input_buf_in_srdy     : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t input_buf_in_drdy     : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t in_acm_reqid          : 4;  /**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t in_acm_reqid          : 4;  /**< [  3:  0](R/W/H) -- */
        uint32_t input_buf_in_drdy     : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t input_buf_in_srdy     : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t locked                : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_acmrh_w3_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_acmrh_w3 bdk_tns_sde_ldex_dbg_acmrh_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072e0ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_ACMRH_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(a) bdk_tns_sde_ldex_dbg_acmrh_w3_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(a) "TNS_SDE_LDEX_DBG_ACMRH_W3"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ifif
 *
 * TNS SDE LDE Debug Input FIFO Registers
 * Capture input_fifo info for debug
 */
union bdk_tns_sde_ldex_dbg_ifif
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ifif_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t locked                : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [  3:  3](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  2:  2](R/W/H) -- */
        uint32_t fifo_usage            : 2;  /**< [  1:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_usage            : 2;  /**< [  1:  0](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  2:  2](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [  3:  3](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t locked                : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ifif_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ifif bdk_tns_sde_ldex_dbg_ifif_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_IFIF(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_IFIF(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020504cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_IFIF", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_IFIF(a) bdk_tns_sde_ldex_dbg_ifif_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_IFIF(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_IFIF(a) "TNS_SDE_LDEX_DBG_IFIF"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_IFIF(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_IFIF(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_IFIF(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfcp_bits_w0
 *
 * TNS SDE LDE Debug KFCP Bits Word 0 Registers
 * Capture kfcp_bits_extract info for debug
 */
union bdk_tns_sde_ldex_dbg_kfcp_bits_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfcp_bits_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t out_logicallayer3_8lsbs : 8;/**< [ 31: 24](R/W/H) -- */
        uint32_t out_logicallayer2_8lsbs : 8;/**< [ 23: 16](R/W/H) -- */
        uint32_t out_logicallayer1_8lsbs : 8;/**< [ 15:  8](R/W/H) -- */
        uint32_t out_logicallayer0_8lsbs : 8;/**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_logicallayer0_8lsbs : 8;/**< [  7:  0](R/W/H) -- */
        uint32_t out_logicallayer1_8lsbs : 8;/**< [ 15:  8](R/W/H) -- */
        uint32_t out_logicallayer2_8lsbs : 8;/**< [ 23: 16](R/W/H) -- */
        uint32_t out_logicallayer3_8lsbs : 8;/**< [ 31: 24](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfcp_bits_w0 bdk_tns_sde_ldex_dbg_kfcp_bits_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207038ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFCP_BITS_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(a) bdk_tns_sde_ldex_dbg_kfcp_bits_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(a) "TNS_SDE_LDEX_DBG_KFCP_BITS_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfcp_bits_w1
 *
 * TNS SDE LDE Debug KFCP Bits Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_KFCP_BITS_W0
 */
union bdk_tns_sde_ldex_dbg_kfcp_bits_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfcp_bits_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t out_lmdata_8lsbs      : 7;  /**< [ 31: 25](R/W/H) -- */
        uint32_t out_lmhit             : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t out_nextengine        : 8;  /**< [ 23: 16](R/W/H) -- */
        uint32_t out_token_scratchpad_8lsbs : 8;/**< [ 15:  8](R/W/H) -- */
        uint32_t out_token_common_bits : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_token_common_bits : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t out_token_scratchpad_8lsbs : 8;/**< [ 15:  8](R/W/H) -- */
        uint32_t out_nextengine        : 8;  /**< [ 23: 16](R/W/H) -- */
        uint32_t out_lmhit             : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t out_lmdata_8lsbs      : 7;  /**< [ 31: 25](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfcp_bits_w1 bdk_tns_sde_ldex_dbg_kfcp_bits_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020703cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFCP_BITS_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(a) bdk_tns_sde_ldex_dbg_kfcp_bits_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(a) "TNS_SDE_LDEX_DBG_KFCP_BITS_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfcp_bits_w2
 *
 * TNS SDE LDE Debug KFCP Bits Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_KFCP_BITS_W0
 */
union bdk_tns_sde_ldex_dbg_kfcp_bits_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfcp_bits_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t locked                : 1;  /**< [ 13: 13](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 12: 12](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 11: 11](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  9:  9](R/W/H) -- */
        uint32_t out_metadata_8lsbs    : 8;  /**< [  8:  1](R/W/H) -- */
        uint32_t out_lmdata_8lsbs      : 1;  /**< [  0:  0](R/W/H) Continuation of MSBs of field OUT_LMDATA_8LSBS from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t out_lmdata_8lsbs      : 1;  /**< [  0:  0](R/W/H) Continuation of MSBs of field OUT_LMDATA_8LSBS from previous word. */
        uint32_t out_metadata_8lsbs    : 8;  /**< [  8:  1](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  9:  9](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 11: 11](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 12: 12](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 13: 13](R/W/H) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfcp_bits_w2 bdk_tns_sde_ldex_dbg_kfcp_bits_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207040ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFCP_BITS_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(a) bdk_tns_sde_ldex_dbg_kfcp_bits_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(a) "TNS_SDE_LDEX_DBG_KFCP_BITS_W2"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfcp_kfit
 *
 * TNS SDE LDE Debug KFCP KFIT Registers
 * Capture kfcp_kfit info for debug
 */
union bdk_tns_sde_ldex_dbg_kfcp_kfit
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfcp_kfit_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_22_31        : 10;
        uint32_t locked                : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 19: 19](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 18: 18](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t out_kfit6_se_profileid_inst : 4;/**< [ 16: 13](R/W/H) -- */
        uint32_t out_kfit6_se_cmd_envec_inst : 5;/**< [ 12:  8](R/W/H) -- */
        uint32_t out_kfit0_1st_inst_8lsbs : 8;/**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_kfit0_1st_inst_8lsbs : 8;/**< [  7:  0](R/W/H) -- */
        uint32_t out_kfit6_se_cmd_envec_inst : 5;/**< [ 12:  8](R/W/H) -- */
        uint32_t out_kfit6_se_profileid_inst : 4;/**< [ 16: 13](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 18: 18](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 19: 19](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t reserved_22_31        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfcp_kfit_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfcp_kfit bdk_tns_sde_ldex_dbg_kfcp_kfit_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060206c44ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFCP_KFIT", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(a) bdk_tns_sde_ldex_dbg_kfcp_kfit_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(a) "TNS_SDE_LDEX_DBG_KFCP_KFIT"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfcp_mlcd_w0
 *
 * TNS SDE LDE Debug KFCP MUXLUT Cloud Info Word 0 Registers
 * Capture kfcp_muxlut_cloud info for debug
 */
union bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t stg1_out_data_8lsbs   : 2;  /**< [ 31: 30](R/W/H) -- */
        uint32_t stg2_out_srdy         : 1;  /**< [ 29: 29](R/W/H) -- */
        uint32_t stg2_out_drdy         : 1;  /**< [ 28: 28](R/W/H) -- */
        uint32_t stg2_out_data         : 28; /**< [ 27:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg2_out_data         : 28; /**< [ 27:  0](R/W/H) -- */
        uint32_t stg2_out_drdy         : 1;  /**< [ 28: 28](R/W/H) -- */
        uint32_t stg2_out_srdy         : 1;  /**< [ 29: 29](R/W/H) -- */
        uint32_t stg1_out_data_8lsbs   : 2;  /**< [ 31: 30](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0 bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207044ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFCP_MLCD_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(a) bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(a) "TNS_SDE_LDEX_DBG_KFCP_MLCD_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfcp_mlcd_w1
 *
 * TNS SDE LDE Debug KFCP MUXLUT Cloud Info Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_KFCP_MLCD_W0
 */
union bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t locked                : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 19: 19](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 18: 18](R/W/H) -- */
        uint32_t stg0_out_srdy         : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t stg0_out_drdy         : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t stg0_out_data_8lsbs   : 8;  /**< [ 15:  8](R/W/H) -- */
        uint32_t stg1_out_srdy         : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t stg1_out_drdy         : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t stg1_out_data_8lsbs   : 6;  /**< [  5:  0](R/W/H) Continuation of MSBs of field STAGE1_OUT_DATA_8LSBS from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t stg1_out_data_8lsbs   : 6;  /**< [  5:  0](R/W/H) Continuation of MSBs of field STAGE1_OUT_DATA_8LSBS from previous word. */
        uint32_t stg1_out_drdy         : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t stg1_out_srdy         : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t stg0_out_data_8lsbs   : 8;  /**< [ 15:  8](R/W/H) -- */
        uint32_t stg0_out_drdy         : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t stg0_out_srdy         : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 18: 18](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 19: 19](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1 bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207048ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFCP_MLCD_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(a) bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(a) "TNS_SDE_LDEX_DBG_KFCP_MLCD_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfdp_core
 *
 * TNS SDE LDE Debug KFDP Core Registers
 * Capture kfdp_core info for debug
 */
union bdk_tns_sde_ldex_dbg_kfdp_core
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfdp_core_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t locked                : 1;  /**< [ 11: 11](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [  9:  9](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [  8:  8](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t out_se_profileid      : 3;  /**< [  6:  4](R/W/H) -- */
        uint32_t out_se_cmd_envec      : 4;  /**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_se_cmd_envec      : 4;  /**< [  3:  0](R/W/H) -- */
        uint32_t out_se_profileid      : 3;  /**< [  6:  4](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [  8:  8](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [  9:  9](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 11: 11](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfdp_core_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfdp_core bdk_tns_sde_ldex_dbg_kfdp_core_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205058ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFDP_CORE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(a) bdk_tns_sde_ldex_dbg_kfdp_core_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(a) "TNS_SDE_LDEX_DBG_KFDP_CORE"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_kfdp_ridg
 *
 * TNS SDE LDE Debug KFDP Request ID General Info Registers
 * Capture kfdp_reqid_gen info for debug
 */
union bdk_tns_sde_ldex_dbg_kfdp_ridg
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_kfdp_ridg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t locked                : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 22: 22](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t out_se_reqid          : 6;  /**< [ 19: 14](R/W/H) -- */
        uint32_t outstanding_se_reqs_cnt : 7;/**< [ 13:  7](R/W/H) -- */
        uint32_t se_merge_done_valid   : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t se_merge_done_reqid   : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_merge_done_reqid   : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t se_merge_done_valid   : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t outstanding_se_reqs_cnt : 7;/**< [ 13:  7](R/W/H) -- */
        uint32_t out_se_reqid          : 6;  /**< [ 19: 14](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 22: 22](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_kfdp_ridg_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_kfdp_ridg bdk_tns_sde_ldex_dbg_kfdp_ridg_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020505cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_KFDP_RIDG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(a) bdk_tns_sde_ldex_dbg_kfdp_ridg_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(a) "TNS_SDE_LDEX_DBG_KFDP_RIDG"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_dbg_mgr_info_w0
 *
 * TNS SDE LDE Debug Merger Info Word 0 Registers
 * Capture merger info for debug
 */
union bdk_tns_sde_ldex_dbg_mgr_info_w0
{
    uint64_t u;
    struct bdk_tns_sde_ldex_dbg_mgr_info_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t se_rslt_lane1_in_sorry : 1; /**< [ 63: 63](R/W/H) -- */
        uint64_t se_rslt_lane1_in_hit  : 1;  /**< [ 62: 62](R/W/H) -- */
        uint64_t se_rslt_ln0_in_srdy   : 1;  /**< [ 61: 61](R/W/H) -- */
        uint64_t se_rslt_ln0_in_drdy   : 1;  /**< [ 60: 60](R/W/H) -- */
        uint64_t se_rslt_ln0_in_reqid  : 6;  /**< [ 59: 54](R/W/H) -- */
        uint64_t se_rslt_ln0_in_dualid : 1;  /**< [ 53: 53](R/W/H) -- */
        uint64_t se_rslt_ln0_in_sorry  : 1;  /**< [ 52: 52](R/W/H) -- */
        uint64_t se_rslt_ln0_in_hit    : 1;  /**< [ 51: 51](R/W/H) -- */
        uint64_t probe_srdy            : 1;  /**< [ 50: 50](R/W/H) -- */
        uint64_t probe_drdy            : 1;  /**< [ 49: 49](R/W/H) -- */
        uint64_t probe_se_reqid        : 6;  /**< [ 48: 43](R/W/H) -- */
        uint64_t probe_waiting_time    : 16; /**< [ 42: 27](R/W/H) -- */
        uint64_t probe_timeout         : 1;  /**< [ 26: 26](R/W/H) -- */
        uint64_t probe_se_rslt_exp_vector : 8;/**< [ 25: 18](R/W/H) -- */
        uint64_t probe_se_rslt_valid_vector : 8;/**< [ 17: 10](R/W/H) -- */
        uint64_t out_srdy              : 1;  /**< [  9:  9](R/W/H) -- */
        uint64_t out_drdy              : 1;  /**< [  8:  8](R/W/H) -- */
        uint64_t out_se_rslt_sorry_vector : 4;/**< [  7:  4](R/W/H) -- */
        uint64_t out_se_rslt_hit_vector : 4; /**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t out_se_rslt_hit_vector : 4; /**< [  3:  0](R/W/H) -- */
        uint64_t out_se_rslt_sorry_vector : 4;/**< [  7:  4](R/W/H) -- */
        uint64_t out_drdy              : 1;  /**< [  8:  8](R/W/H) -- */
        uint64_t out_srdy              : 1;  /**< [  9:  9](R/W/H) -- */
        uint64_t probe_se_rslt_valid_vector : 8;/**< [ 17: 10](R/W/H) -- */
        uint64_t probe_se_rslt_exp_vector : 8;/**< [ 25: 18](R/W/H) -- */
        uint64_t probe_timeout         : 1;  /**< [ 26: 26](R/W/H) -- */
        uint64_t probe_waiting_time    : 16; /**< [ 42: 27](R/W/H) -- */
        uint64_t probe_se_reqid        : 6;  /**< [ 48: 43](R/W/H) -- */
        uint64_t probe_drdy            : 1;  /**< [ 49: 49](R/W/H) -- */
        uint64_t probe_srdy            : 1;  /**< [ 50: 50](R/W/H) -- */
        uint64_t se_rslt_ln0_in_hit    : 1;  /**< [ 51: 51](R/W/H) -- */
        uint64_t se_rslt_ln0_in_sorry  : 1;  /**< [ 52: 52](R/W/H) -- */
        uint64_t se_rslt_ln0_in_dualid : 1;  /**< [ 53: 53](R/W/H) -- */
        uint64_t se_rslt_ln0_in_reqid  : 6;  /**< [ 59: 54](R/W/H) -- */
        uint64_t se_rslt_ln0_in_drdy   : 1;  /**< [ 60: 60](R/W/H) -- */
        uint64_t se_rslt_ln0_in_srdy   : 1;  /**< [ 61: 61](R/W/H) -- */
        uint64_t se_rslt_lane1_in_hit  : 1;  /**< [ 62: 62](R/W/H) -- */
        uint64_t se_rslt_lane1_in_sorry : 1; /**< [ 63: 63](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_mgr_info_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_mgr_info_w0 bdk_tns_sde_ldex_dbg_mgr_info_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207358ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_MGR_INFO_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(a) bdk_tns_sde_ldex_dbg_mgr_info_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(a) "TNS_SDE_LDEX_DBG_MGR_INFO_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_dbg_mgr_info_w1
 *
 * TNS SDE LDE Debug Merger Info Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_MGR_INFO_W0
 */
union bdk_tns_sde_ldex_dbg_mgr_info_w1
{
    uint64_t u;
    struct bdk_tns_sde_ldex_dbg_mgr_info_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_54_63        : 10;
        uint64_t locked                : 1;  /**< [ 53: 53](R/W/H) -- */
        uint64_t token_buf_in_srdy     : 1;  /**< [ 52: 52](R/W/H) -- */
        uint64_t token_buf_in_drdy     : 1;  /**< [ 51: 51](R/W/H) -- */
        uint64_t in_se_profileid       : 3;  /**< [ 50: 48](R/W/H) -- */
        uint64_t in_se_cmd_envec       : 4;  /**< [ 47: 44](R/W/H) -- */
        uint64_t in_se_reqid           : 6;  /**< [ 43: 38](R/W/H) -- */
        uint64_t token_buf_usage       : 7;  /**< [ 37: 31](R/W/H) -- */
        uint64_t se_rslt_lane3_in_srdy : 1;  /**< [ 30: 30](R/W/H) -- */
        uint64_t se_rslt_lane3_in_drdy : 1;  /**< [ 29: 29](R/W/H) -- */
        uint64_t se_rslt_lane3_in_reqid : 6; /**< [ 28: 23](R/W/H) -- */
        uint64_t se_rslt_lane3_in_dualid : 1;/**< [ 22: 22](R/W/H) -- */
        uint64_t se_rslt_lane3_in_sorry : 1; /**< [ 21: 21](R/W/H) -- */
        uint64_t se_rslt_lane3_in_hit  : 1;  /**< [ 20: 20](R/W/H) -- */
        uint64_t se_rslt_lane2_in_srdy : 1;  /**< [ 19: 19](R/W/H) -- */
        uint64_t se_rslt_lane2_in_drdy : 1;  /**< [ 18: 18](R/W/H) -- */
        uint64_t se_rslt_lane2_in_reqid : 6; /**< [ 17: 12](R/W/H) -- */
        uint64_t se_rslt_lane2_in_dualid : 1;/**< [ 11: 11](R/W/H) -- */
        uint64_t se_rslt_lane2_in_sorry : 1; /**< [ 10: 10](R/W/H) -- */
        uint64_t se_rslt_lane2_in_hit  : 1;  /**< [  9:  9](R/W/H) -- */
        uint64_t se_rslt_lane1_in_srdy : 1;  /**< [  8:  8](R/W/H) -- */
        uint64_t se_rslt_lane1_in_drdy : 1;  /**< [  7:  7](R/W/H) -- */
        uint64_t se_rslt_lane1_in_reqid : 6; /**< [  6:  1](R/W/H) -- */
        uint64_t se_rslt_lane1_in_dualid : 1;/**< [  0:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_rslt_lane1_in_dualid : 1;/**< [  0:  0](R/W/H) -- */
        uint64_t se_rslt_lane1_in_reqid : 6; /**< [  6:  1](R/W/H) -- */
        uint64_t se_rslt_lane1_in_drdy : 1;  /**< [  7:  7](R/W/H) -- */
        uint64_t se_rslt_lane1_in_srdy : 1;  /**< [  8:  8](R/W/H) -- */
        uint64_t se_rslt_lane2_in_hit  : 1;  /**< [  9:  9](R/W/H) -- */
        uint64_t se_rslt_lane2_in_sorry : 1; /**< [ 10: 10](R/W/H) -- */
        uint64_t se_rslt_lane2_in_dualid : 1;/**< [ 11: 11](R/W/H) -- */
        uint64_t se_rslt_lane2_in_reqid : 6; /**< [ 17: 12](R/W/H) -- */
        uint64_t se_rslt_lane2_in_drdy : 1;  /**< [ 18: 18](R/W/H) -- */
        uint64_t se_rslt_lane2_in_srdy : 1;  /**< [ 19: 19](R/W/H) -- */
        uint64_t se_rslt_lane3_in_hit  : 1;  /**< [ 20: 20](R/W/H) -- */
        uint64_t se_rslt_lane3_in_sorry : 1; /**< [ 21: 21](R/W/H) -- */
        uint64_t se_rslt_lane3_in_dualid : 1;/**< [ 22: 22](R/W/H) -- */
        uint64_t se_rslt_lane3_in_reqid : 6; /**< [ 28: 23](R/W/H) -- */
        uint64_t se_rslt_lane3_in_drdy : 1;  /**< [ 29: 29](R/W/H) -- */
        uint64_t se_rslt_lane3_in_srdy : 1;  /**< [ 30: 30](R/W/H) -- */
        uint64_t token_buf_usage       : 7;  /**< [ 37: 31](R/W/H) -- */
        uint64_t in_se_reqid           : 6;  /**< [ 43: 38](R/W/H) -- */
        uint64_t in_se_cmd_envec       : 4;  /**< [ 47: 44](R/W/H) -- */
        uint64_t in_se_profileid       : 3;  /**< [ 50: 48](R/W/H) -- */
        uint64_t token_buf_in_drdy     : 1;  /**< [ 51: 51](R/W/H) -- */
        uint64_t token_buf_in_srdy     : 1;  /**< [ 52: 52](R/W/H) -- */
        uint64_t locked                : 1;  /**< [ 53: 53](R/W/H) -- */
        uint64_t reserved_54_63        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_mgr_info_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_mgr_info_w1 bdk_tns_sde_ldex_dbg_mgr_info_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207360ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_MGR_INFO_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(a) bdk_tns_sde_ldex_dbg_mgr_info_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(a) "TNS_SDE_LDEX_DBG_MGR_INFO_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_dbg_ofcp_bits
 *
 * TNS SDE LDE Debug OFCP Bits Registers
 * Capture ofcp_bits_extracted info for debug
 */
union bdk_tns_sde_ldex_dbg_ofcp_bits
{
    uint64_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_bits_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_45_63        : 19;
        uint64_t locked                : 1;  /**< [ 44: 44](R/W/H) -- */
        uint64_t in_srdy               : 1;  /**< [ 43: 43](R/W/H) -- */
        uint64_t in_drdy               : 1;  /**< [ 42: 42](R/W/H) -- */
        uint64_t out_srdy              : 1;  /**< [ 41: 41](R/W/H) -- */
        uint64_t out_drdy              : 1;  /**< [ 40: 40](R/W/H) -- */
        uint64_t out_subtoken0_8lsbs   : 8;  /**< [ 39: 32](R/W/H) -- */
        uint64_t out_subtoken0_valid   : 1;  /**< [ 31: 31](R/W/H) -- */
        uint64_t out_se_rslt_8lsbs     : 8;  /**< [ 30: 23](R/W/H) -- */
        uint64_t out_se_rslt_hit_vector : 4; /**< [ 22: 19](R/W/H) -- */
        uint64_t out_se_rslt_sorry_vector : 4;/**< [ 18: 15](R/W/H) -- */
        uint64_t out_profileid         : 3;  /**< [ 14: 12](R/W/H) -- */
        uint64_t out_cmd_envec         : 4;  /**< [ 11:  8](R/W/H) -- */
        uint64_t out_muxxor_bits       : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t out_muxxor_bits       : 8;  /**< [  7:  0](R/W/H) -- */
        uint64_t out_cmd_envec         : 4;  /**< [ 11:  8](R/W/H) -- */
        uint64_t out_profileid         : 3;  /**< [ 14: 12](R/W/H) -- */
        uint64_t out_se_rslt_sorry_vector : 4;/**< [ 18: 15](R/W/H) -- */
        uint64_t out_se_rslt_hit_vector : 4; /**< [ 22: 19](R/W/H) -- */
        uint64_t out_se_rslt_8lsbs     : 8;  /**< [ 30: 23](R/W/H) -- */
        uint64_t out_subtoken0_valid   : 1;  /**< [ 31: 31](R/W/H) -- */
        uint64_t out_subtoken0_8lsbs   : 8;  /**< [ 39: 32](R/W/H) -- */
        uint64_t out_drdy              : 1;  /**< [ 40: 40](R/W/H) -- */
        uint64_t out_srdy              : 1;  /**< [ 41: 41](R/W/H) -- */
        uint64_t in_drdy               : 1;  /**< [ 42: 42](R/W/H) -- */
        uint64_t in_srdy               : 1;  /**< [ 43: 43](R/W/H) -- */
        uint64_t locked                : 1;  /**< [ 44: 44](R/W/H) -- */
        uint64_t reserved_45_63        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_bits_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_bits bdk_tns_sde_ldex_dbg_ofcp_bits_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207168ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_BITS", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(a) bdk_tns_sde_ldex_dbg_ofcp_bits_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(a) "TNS_SDE_LDEX_DBG_OFCP_BITS"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_mlcd_w0
 *
 * TNS SDE LDE Debug OFCP MUXLUT Cloud Info Word 0 Registers
 * Capture ofcp_muxlut_cloud info for debug
 */
union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t stg4_out_data         : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg4_out_data         : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0 bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207174ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_MLCD_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(a) bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(a) "TNS_SDE_LDEX_DBG_OFCP_MLCD_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_mlcd_w1
 *
 * TNS SDE LDE Debug OFCP MUXLUT Cloud Info Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_MLCD_W0
 */
union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t stg2_out_data_8lsbs   : 4;  /**< [ 31: 28](R/W/H) -- */
        uint32_t stg3_out_srdy         : 1;  /**< [ 27: 27](R/W/H) -- */
        uint32_t stg3_out_drdy         : 1;  /**< [ 26: 26](R/W/H) -- */
        uint32_t stg3_out_data_8lsbs   : 8;  /**< [ 25: 18](R/W/H) -- */
        uint32_t stg4_out_srdy         : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t stg4_out_drdy         : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t stg4_out_data         : 16; /**< [ 15:  0](R/W/H) Continuation of MSBs of field STAGE4_OUT_DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t stg4_out_data         : 16; /**< [ 15:  0](R/W/H) Continuation of MSBs of field STAGE4_OUT_DATA from previous word. */
        uint32_t stg4_out_drdy         : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t stg4_out_srdy         : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t stg3_out_data_8lsbs   : 8;  /**< [ 25: 18](R/W/H) -- */
        uint32_t stg3_out_drdy         : 1;  /**< [ 26: 26](R/W/H) -- */
        uint32_t stg3_out_srdy         : 1;  /**< [ 27: 27](R/W/H) -- */
        uint32_t stg2_out_data_8lsbs   : 4;  /**< [ 31: 28](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1 bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207178ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_MLCD_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(a) bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(a) "TNS_SDE_LDEX_DBG_OFCP_MLCD_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_mlcd_w2
 *
 * TNS SDE LDE Debug OFCP MUXLUT Cloud Info Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_MLCD_W0
 */
union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t locked                : 1;  /**< [ 28: 28](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 27: 27](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 26: 26](R/W/H) -- */
        uint32_t stg0_out_srdy         : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t stg0_out_drdy         : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t stg0_out_data_8lsbs   : 8;  /**< [ 23: 16](R/W/H) -- */
        uint32_t stg1_out_srdy         : 1;  /**< [ 15: 15](R/W/H) -- */
        uint32_t stg1_out_drdy         : 1;  /**< [ 14: 14](R/W/H) -- */
        uint32_t stg1_out_data_8lsbs   : 8;  /**< [ 13:  6](R/W/H) -- */
        uint32_t stg2_out_srdy         : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t stg2_out_drdy         : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t stg2_out_data_8lsbs   : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field STAGE2_OUT_DATA_8LSBS from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t stg2_out_data_8lsbs   : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field STAGE2_OUT_DATA_8LSBS from previous word. */
        uint32_t stg2_out_drdy         : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t stg2_out_srdy         : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t stg1_out_data_8lsbs   : 8;  /**< [ 13:  6](R/W/H) -- */
        uint32_t stg1_out_drdy         : 1;  /**< [ 14: 14](R/W/H) -- */
        uint32_t stg1_out_srdy         : 1;  /**< [ 15: 15](R/W/H) -- */
        uint32_t stg0_out_data_8lsbs   : 8;  /**< [ 23: 16](R/W/H) -- */
        uint32_t stg0_out_drdy         : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t stg0_out_srdy         : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 26: 26](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 27: 27](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 28: 28](R/W/H) -- */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2 bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020717cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_MLCD_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(a) bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(a) "TNS_SDE_LDEX_DBG_OFCP_MLCD_W2"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_mxcd
 *
 * TNS SDE LDE Debug OFCP MUXXOR Cloud Registers
 * Capture ofcp_muxxor_cloud info for debug
 */
union bdk_tns_sde_ldex_dbg_ofcp_mxcd
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_mxcd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t locked                : 1;  /**< [ 12: 12](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 11: 11](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [  9:  9](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  8:  8](R/W/H) -- */
        uint32_t out_muxxor_bits       : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_muxxor_bits       : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [  8:  8](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [  9:  9](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 11: 11](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 12: 12](R/W/H) -- */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_mxcd_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_mxcd bdk_tns_sde_ldex_dbg_ofcp_mxcd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207170ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_MXCD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(a) bdk_tns_sde_ldex_dbg_ofcp_mxcd_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(a) "TNS_SDE_LDEX_DBG_OFCP_MXCD"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_ofit_w0
 *
 * TNS SDE LDE Debug OFCP OFIT Word 0 Registers
 * Capture ofcp_ofit info for debug
 */
union bdk_tns_sde_ldex_dbg_ofcp_ofit_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t out_ofit3_exp_inst_8lsbs : 7;/**< [ 31: 25](R/W/H) -- */
        uint32_t out_ofit2_mir_bm_inst_8lsbs : 8;/**< [ 24: 17](R/W/H) -- */
        uint32_t out_ofit1_hashsel_inst : 2; /**< [ 16: 15](R/W/H) -- */
        uint32_t out_ofit1_tt_inst     : 2;  /**< [ 14: 13](R/W/H) -- */
        uint32_t out_ofit0_nextengine_inst : 9;/**< [ 12:  4](R/W/H) -- */
        uint32_t out_ofit0_slavelanesel_inst : 4;/**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_ofit0_slavelanesel_inst : 4;/**< [  3:  0](R/W/H) -- */
        uint32_t out_ofit0_nextengine_inst : 9;/**< [ 12:  4](R/W/H) -- */
        uint32_t out_ofit1_tt_inst     : 2;  /**< [ 14: 13](R/W/H) -- */
        uint32_t out_ofit1_hashsel_inst : 2; /**< [ 16: 15](R/W/H) -- */
        uint32_t out_ofit2_mir_bm_inst_8lsbs : 8;/**< [ 24: 17](R/W/H) -- */
        uint32_t out_ofit3_exp_inst_8lsbs : 7;/**< [ 31: 25](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_ofit_w0 bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060202184ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_OFIT_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(a) bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(a) "TNS_SDE_LDEX_DBG_OFCP_OFIT_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_ofit_w1
 *
 * TNS SDE LDE Debug OFCP OFIT Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_OFIT_W0
 */
union bdk_tns_sde_ldex_dbg_ofcp_ofit_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t out_ofit8_1st_inst_8lsbs : 5;/**< [ 31: 27](R/W/H) -- */
        uint32_t out_ofit6_1st_inst_8lsbs : 8;/**< [ 26: 19](R/W/H) -- */
        uint32_t out_ofit5_1st_inst_8lsbs : 8;/**< [ 18: 11](R/W/H) -- */
        uint32_t out_ofit4_rewrptr6inins_inst : 2;/**< [ 10:  9](R/W/H) -- */
        uint32_t out_ofit4_rewrptr0_inst_8lsbs : 8;/**< [  8:  1](R/W/H) -- */
        uint32_t out_ofit3_exp_inst_8lsbs : 1;/**< [  0:  0](R/W/H) Continuation of MSBs of field OUT_OFIT3_EXP_INST_8LSBS from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t out_ofit3_exp_inst_8lsbs : 1;/**< [  0:  0](R/W/H) Continuation of MSBs of field OUT_OFIT3_EXP_INST_8LSBS from previous word. */
        uint32_t out_ofit4_rewrptr0_inst_8lsbs : 8;/**< [  8:  1](R/W/H) -- */
        uint32_t out_ofit4_rewrptr6inins_inst : 2;/**< [ 10:  9](R/W/H) -- */
        uint32_t out_ofit5_1st_inst_8lsbs : 8;/**< [ 18: 11](R/W/H) -- */
        uint32_t out_ofit6_1st_inst_8lsbs : 8;/**< [ 26: 19](R/W/H) -- */
        uint32_t out_ofit8_1st_inst_8lsbs : 5;/**< [ 31: 27](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_ofit_w1 bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060202188ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_OFIT_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(a) bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(a) "TNS_SDE_LDEX_DBG_OFCP_OFIT_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofcp_ofit_w2
 *
 * TNS SDE LDE Debug OFCP OFIT Word 2 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_OFIT_W0
 */
union bdk_tns_sde_ldex_dbg_ofcp_ofit_w2
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t locked                : 1;  /**< [ 19: 19](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 18: 18](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 15: 15](R/W/H) -- */
        uint32_t out_ofit9_lm_cmd_inst : 2;  /**< [ 14: 13](R/W/H) -- */
        uint32_t out_ofit9_1st_inst_8lsbs : 8;/**< [ 12:  5](R/W/H) -- */
        uint32_t out_ofit8_second_inst : 2;  /**< [  4:  3](R/W/H) -- */
        uint32_t out_ofit8_1st_inst_8lsbs : 3;/**< [  2:  0](R/W/H) Continuation of MSBs of field OUT_OFIT8_FIRST_INST_8LSBS from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t out_ofit8_1st_inst_8lsbs : 3;/**< [  2:  0](R/W/H) Continuation of MSBs of field OUT_OFIT8_FIRST_INST_8LSBS from previous word. */
        uint32_t out_ofit8_second_inst : 2;  /**< [  4:  3](R/W/H) -- */
        uint32_t out_ofit9_1st_inst_8lsbs : 8;/**< [ 12:  5](R/W/H) -- */
        uint32_t out_ofit9_lm_cmd_inst : 2;  /**< [ 14: 13](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 15: 15](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 18: 18](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 19: 19](R/W/H) -- */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofcp_ofit_w2 bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020218cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFCP_OFIT_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(a) bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(a) "TNS_SDE_LDEX_DBG_OFCP_OFIT_W2"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofdp_acmridg
 *
 * TNS SDE LDE Debug OFDP ACM Request ID General Info Registers
 * Capture odfp_acm_reqid_gen info for debug
 */
union bdk_tns_sde_ldex_dbg_ofdp_acmridg
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofdp_acmridg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t locked                : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_srdy : 1;/**< [ 22: 22](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_drdy : 1;/**< [ 21: 21](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_reqid : 4;/**< [ 20: 17](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_cmd_envec : 4;/**< [ 16: 13](R/W/H) -- */
        uint32_t out_to_acmrh_byp_buf_srdy : 1;/**< [ 12: 12](R/W/H) -- */
        uint32_t out_to_acmrh_byp_buf_drdy : 1;/**< [ 11: 11](R/W/H) -- */
        uint32_t bypass_en             : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t outstanding_acm_reqs_cnt : 5;/**< [  9:  5](R/W/H) -- */
        uint32_t acm_merge_done_valid  : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t acm_merge_done_reqid  : 4;  /**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_merge_done_reqid  : 4;  /**< [  3:  0](R/W/H) -- */
        uint32_t acm_merge_done_valid  : 1;  /**< [  4:  4](R/W/H) -- */
        uint32_t outstanding_acm_reqs_cnt : 5;/**< [  9:  5](R/W/H) -- */
        uint32_t bypass_en             : 1;  /**< [ 10: 10](R/W/H) -- */
        uint32_t out_to_acmrh_byp_buf_drdy : 1;/**< [ 11: 11](R/W/H) -- */
        uint32_t out_to_acmrh_byp_buf_srdy : 1;/**< [ 12: 12](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_cmd_envec : 4;/**< [ 16: 13](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_reqid : 4;/**< [ 20: 17](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_drdy : 1;/**< [ 21: 21](R/W/H) -- */
        uint32_t out_to_acmrh_in_buf_srdy : 1;/**< [ 22: 22](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofdp_acmridg_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofdp_acmridg bdk_tns_sde_ldex_dbg_ofdp_acmridg_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072d0ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFDP_ACMRIDG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(a) bdk_tns_sde_ldex_dbg_ofdp_acmridg_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(a) "TNS_SDE_LDEX_DBG_OFDP_ACMRIDG"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ofdp_core
 *
 * TNS SDE LDE Debug OFDP Core Registers
 * Capture odfp_core info for debug
 */
union bdk_tns_sde_ldex_dbg_ofdp_core
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ofdp_core_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t locked                : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 22: 22](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t out_lm_req_cmd        : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t out_lm_req_key_8lsbs  : 8;  /**< [ 19: 12](R/W/H) -- */
        uint32_t out_acm_req_cmd_envec : 4;  /**< [ 11:  8](R/W/H) -- */
        uint32_t out_acm_req_ln0_addr_8lsbs : 8;/**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_acm_req_ln0_addr_8lsbs : 8;/**< [  7:  0](R/W/H) -- */
        uint32_t out_acm_req_cmd_envec : 4;  /**< [ 11:  8](R/W/H) -- */
        uint32_t out_lm_req_key_8lsbs  : 8;  /**< [ 19: 12](R/W/H) -- */
        uint32_t out_lm_req_cmd        : 1;  /**< [ 20: 20](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 21: 21](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 22: 22](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [ 23: 23](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [ 24: 24](R/W/H) -- */
        uint32_t locked                : 1;  /**< [ 25: 25](R/W/H) -- */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ofdp_core_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ofdp_core bdk_tns_sde_ldex_dbg_ofdp_core_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072ccll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_OFDP_CORE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(a) bdk_tns_sde_ldex_dbg_ofdp_core_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(a) "TNS_SDE_LDEX_DBG_OFDP_CORE"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_dbg_tmp_tbl
 *
 * TNS SDE LDE Debug Template Table Registers
 * Capture templateid lookup info for debug
 */
union bdk_tns_sde_ldex_dbg_tmp_tbl
{
    uint64_t u;
    struct bdk_tns_sde_ldex_dbg_tmp_tbl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_54_63        : 10;
        uint64_t locked                : 1;  /**< [ 53: 53](R/W/H) -- */
        uint64_t in_srdy               : 1;  /**< [ 52: 52](R/W/H) -- */
        uint64_t in_drdy               : 1;  /**< [ 51: 51](R/W/H) -- */
        uint64_t in_template_id        : 8;  /**< [ 50: 43](R/W/H) -- */
        uint64_t in_tt                 : 1;  /**< [ 42: 42](R/W/H) -- */
        uint64_t out_srdy              : 1;  /**< [ 41: 41](R/W/H) -- */
        uint64_t out_drdy              : 1;  /**< [ 40: 40](R/W/H) -- */
        uint64_t out_metadata_8lsbs    : 8;  /**< [ 39: 32](R/W/H) -- */
        uint64_t out_logical_offset3   : 7;  /**< [ 31: 25](R/W/H) -- */
        uint64_t out_logical_offset2   : 7;  /**< [ 24: 18](R/W/H) -- */
        uint64_t out_logical_offset1   : 7;  /**< [ 17: 11](R/W/H) -- */
        uint64_t out_logical_offset0   : 7;  /**< [ 10:  4](R/W/H) -- */
        uint64_t out_valid_layers_cnt  : 4;  /**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t out_valid_layers_cnt  : 4;  /**< [  3:  0](R/W/H) -- */
        uint64_t out_logical_offset0   : 7;  /**< [ 10:  4](R/W/H) -- */
        uint64_t out_logical_offset1   : 7;  /**< [ 17: 11](R/W/H) -- */
        uint64_t out_logical_offset2   : 7;  /**< [ 24: 18](R/W/H) -- */
        uint64_t out_logical_offset3   : 7;  /**< [ 31: 25](R/W/H) -- */
        uint64_t out_metadata_8lsbs    : 8;  /**< [ 39: 32](R/W/H) -- */
        uint64_t out_drdy              : 1;  /**< [ 40: 40](R/W/H) -- */
        uint64_t out_srdy              : 1;  /**< [ 41: 41](R/W/H) -- */
        uint64_t in_tt                 : 1;  /**< [ 42: 42](R/W/H) -- */
        uint64_t in_template_id        : 8;  /**< [ 50: 43](R/W/H) -- */
        uint64_t in_drdy               : 1;  /**< [ 51: 51](R/W/H) -- */
        uint64_t in_srdy               : 1;  /**< [ 52: 52](R/W/H) -- */
        uint64_t locked                : 1;  /**< [ 53: 53](R/W/H) -- */
        uint64_t reserved_54_63        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_tmp_tbl_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_tmp_tbl bdk_tns_sde_ldex_dbg_tmp_tbl_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TMP_TBL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TMP_TBL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205050ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_TMP_TBL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(a) bdk_tns_sde_ldex_dbg_tmp_tbl_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(a) "TNS_SDE_LDEX_DBG_TMP_TBL"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ttl_lb_w0
 *
 * TNS SDE LDE Debug Total Loopback Word 0 Registers
 * Capture ttl and loopback info for debug
 */
union bdk_tns_sde_ldex_dbg_ttl_lb_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ttl_lb_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t in_ttl                : 6;  /**< [ 31: 26](R/W/H) -- */
        uint32_t in_nextengine         : 8;  /**< [ 25: 18](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t out_ttl               : 6;  /**< [ 15: 10](R/W/H) -- */
        uint32_t out_nextengine        : 8;  /**< [  9:  2](R/W/H) -- */
        uint32_t out_is_ttl_fail       : 1;  /**< [  1:  1](R/W/H) -- */
        uint32_t out_is_loopback       : 1;  /**< [  0:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t out_is_loopback       : 1;  /**< [  0:  0](R/W/H) -- */
        uint32_t out_is_ttl_fail       : 1;  /**< [  1:  1](R/W/H) -- */
        uint32_t out_nextengine        : 8;  /**< [  9:  2](R/W/H) -- */
        uint32_t out_ttl               : 6;  /**< [ 15: 10](R/W/H) -- */
        uint32_t out_drdy              : 1;  /**< [ 16: 16](R/W/H) -- */
        uint32_t out_srdy              : 1;  /**< [ 17: 17](R/W/H) -- */
        uint32_t in_nextengine         : 8;  /**< [ 25: 18](R/W/H) -- */
        uint32_t in_ttl                : 6;  /**< [ 31: 26](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ttl_lb_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ttl_lb_w0 bdk_tns_sde_ldex_dbg_ttl_lb_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072e4ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_TTL_LB_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(a) bdk_tns_sde_ldex_dbg_ttl_lb_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(a) "TNS_SDE_LDEX_DBG_TTL_LB_W0"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_dbg_ttl_lb_w1
 *
 * TNS SDE LDE Debug Total Loopback Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_TTL_LB_W0
 */
union bdk_tns_sde_ldex_dbg_ttl_lb_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_dbg_ttl_lb_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t locked                : 1;  /**< [  2:  2](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [  1:  1](R/W/H) -- */
        uint32_t in_drdy               : 1;  /**< [  0:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t in_drdy               : 1;  /**< [  0:  0](R/W/H) -- */
        uint32_t in_srdy               : 1;  /**< [  1:  1](R/W/H) -- */
        uint32_t locked                : 1;  /**< [  2:  2](R/W/H) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_dbg_ttl_lb_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_dbg_ttl_lb_w1 bdk_tns_sde_ldex_dbg_ttl_lb_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072e8ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_DBG_TTL_LB_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(a) bdk_tns_sde_ldex_dbg_ttl_lb_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(a) "TNS_SDE_LDEX_DBG_TTL_LB_W1"
#define device_bar_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp0_bypm_dmux
 *
 * TNS SDE LDE KFCP Stage 0 Bypassmux Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage0_bypassmux cells
 * - 32 cells
 */
union bdk_tns_sde_ldex_kfcp0_bypm_dmux
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp0_bypm_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t mux_sel               : 9;  /**< [  8:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux_sel               : 9;  /**< [  8:  0](R/W/H) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp0_bypm_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp0_bypm_dmux bdk_tns_sde_ldex_kfcp0_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207010ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP0_BYPM_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(a) bdk_tns_sde_ldex_kfcp0_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(a) "TNS_SDE_LDEX_KFCP0_BYPM_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_kfcp0_ml_dlut
 *
 * TNS SDE LDE KFCP Stage 0 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all kfcp_stage0_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_kfcp0_ml_dlut
{
    uint64_t u;
    struct bdk_tns_sde_ldex_kfcp0_ml_dlut_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp0_ml_dlut_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp0_ml_dlut bdk_tns_sde_ldex_kfcp0_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207008ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP0_ML_DLUT", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(a) bdk_tns_sde_ldex_kfcp0_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(a) "TNS_SDE_LDEX_KFCP0_ML_DLUT"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_kfcp0_ml_dmux
 *
 * TNS SDE LDE KFCP Stage 0 MUXLUT Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage0_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_kfcp0_ml_dmux
{
    uint64_t u;
    struct bdk_tns_sde_ldex_kfcp0_ml_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_54_63        : 10;
        uint64_t mux5_sel              : 9;  /**< [ 53: 45](R/W/H) -- */
        uint64_t mux4_sel              : 9;  /**< [ 44: 36](R/W/H) -- */
        uint64_t mux3_sel              : 9;  /**< [ 35: 27](R/W/H) -- */
        uint64_t mux2_sel              : 9;  /**< [ 26: 18](R/W/H) -- */
        uint64_t mux1_sel              : 9;  /**< [ 17:  9](R/W/H) -- */
        uint64_t mux0_sel              : 9;  /**< [  8:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t mux0_sel              : 9;  /**< [  8:  0](R/W/H) -- */
        uint64_t mux1_sel              : 9;  /**< [ 17:  9](R/W/H) -- */
        uint64_t mux2_sel              : 9;  /**< [ 26: 18](R/W/H) -- */
        uint64_t mux3_sel              : 9;  /**< [ 35: 27](R/W/H) -- */
        uint64_t mux4_sel              : 9;  /**< [ 44: 36](R/W/H) -- */
        uint64_t mux5_sel              : 9;  /**< [ 53: 45](R/W/H) -- */
        uint64_t reserved_54_63        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp0_ml_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp0_ml_dmux bdk_tns_sde_ldex_kfcp0_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207000ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP0_ML_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(a) bdk_tns_sde_ldex_kfcp0_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(a) "TNS_SDE_LDEX_KFCP0_ML_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp1_bypm_dmux
 *
 * TNS SDE LDE KFCP Stage 1 Bypassmux Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage1_bypassmux cells
 * - 32 cells
 */
union bdk_tns_sde_ldex_kfcp1_bypm_dmux
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp1_bypm_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp1_bypm_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp1_bypm_dmux bdk_tns_sde_ldex_kfcp1_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207024ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP1_BYPM_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(a) bdk_tns_sde_ldex_kfcp1_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(a) "TNS_SDE_LDEX_KFCP1_BYPM_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp1_ml_dlut_w#
 *
 * TNS SDE LDE KFCP Stage 1 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all kfcp_stage1_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_kfcp1_ml_dlut_wx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lut                   : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lut                   : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp1_ml_dlut_wx bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=1)))
        return 0x84206020701cll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP1_ML_DLUT_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(a,b) bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(a,b) "TNS_SDE_LDEX_KFCP1_ML_DLUT_WX"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp1_ml_dmux_w0
 *
 * TNS SDE LDE KFCP Stage 1 MUXLUT Dynamic MUX Word 0 Registers
 * A dynamic register for configuring all muxes in all kfcp_stage1_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_kfcp1_ml_dmux_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mux5_sel              : 2;  /**< [ 31: 30](R/W/H) -- */
        uint32_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint32_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint32_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint32_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint32_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint32_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint32_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint32_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint32_t mux5_sel              : 2;  /**< [ 31: 30](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp1_ml_dmux_w0 bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207014ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP1_ML_DMUX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(a) bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(a) "TNS_SDE_LDEX_KFCP1_ML_DMUX_W0"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp1_ml_dmux_w1
 *
 * TNS SDE LDE KFCP Stage 1 MUXLUT Dynamic MUX Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_KFCP1_ML_DMUX_W0
 */
union bdk_tns_sde_ldex_kfcp1_ml_dmux_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mux5_sel              : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field MUX5_SEL from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t mux5_sel              : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field MUX5_SEL from previous word. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp1_ml_dmux_w1 bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207018ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP1_ML_DMUX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(a) bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(a) "TNS_SDE_LDEX_KFCP1_ML_DMUX_W1"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_kfcp2_ml_dlut
 *
 * TNS SDE LDE KFCP Stage 2 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all kfcp_stage2_muxlut cells -
 * 28 cells
 */
union bdk_tns_sde_ldex_kfcp2_ml_dlut
{
    uint64_t u;
    struct bdk_tns_sde_ldex_kfcp2_ml_dlut_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp2_ml_dlut_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp2_ml_dlut bdk_tns_sde_ldex_kfcp2_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207030ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP2_ML_DLUT", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(a) bdk_tns_sde_ldex_kfcp2_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(a) "TNS_SDE_LDEX_KFCP2_ML_DLUT"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_kfcp2_ml_dmux
 *
 * TNS SDE LDE KFCP Stage 2 MUXLUT Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage2_muxlut cells -
 * 28 cells
 */
union bdk_tns_sde_ldex_kfcp2_ml_dmux
{
    uint64_t u;
    struct bdk_tns_sde_ldex_kfcp2_ml_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t mux5_sel              : 6;  /**< [ 35: 30](R/W/H) -- */
        uint64_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint64_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint64_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint64_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint64_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
        uint64_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint64_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint64_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint64_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint64_t mux5_sel              : 6;  /**< [ 35: 30](R/W/H) -- */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp2_ml_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp2_ml_dmux bdk_tns_sde_ldex_kfcp2_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207028ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP2_ML_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(a) bdk_tns_sde_ldex_kfcp2_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(a) "TNS_SDE_LDEX_KFCP2_ML_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp_cloud_lock
 *
 * TNS SDE LDE KFCP Cloud Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_kfcp_cloud_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp_cloud_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp_cloud_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp_cloud_lock bdk_tns_sde_ldex_kfcp_cloud_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020705cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP_CLOUD_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(a) bdk_tns_sde_ldex_kfcp_cloud_lock_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(a) "TNS_SDE_LDEX_KFCP_CLOUD_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp_cloud_spad
 *
 * TNS SDE LDE KFCP Cloud ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_kfcp_cloud_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp_cloud_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp_cloud_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp_cloud_spad bdk_tns_sde_ldex_kfcp_cloud_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207060ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP_CLOUD_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(a) bdk_tns_sde_ldex_kfcp_cloud_spad_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(a) "TNS_SDE_LDEX_KFCP_CLOUD_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp_int_en_hi
 *
 * TNS SDE LDE KFCP Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfcp_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp_int_en_hi bdk_tns_sde_ldex_kfcp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207050ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(a) bdk_tns_sde_ldex_kfcp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(a) "TNS_SDE_LDEX_KFCP_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp_int_en_lo
 *
 * TNS SDE LDE KFCP Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfcp_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp_int_en_lo bdk_tns_sde_ldex_kfcp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207054ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(a) bdk_tns_sde_ldex_kfcp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(a) "TNS_SDE_LDEX_KFCP_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp_int_frc
 *
 * TNS SDE LDE KFCP Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfcp_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](WO) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](WO) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](WO) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](WO) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](WO) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](WO) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](WO) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](WO) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](WO) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](WO) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](WO) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](WO) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](WO) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](WO) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](WO) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp_int_frc bdk_tns_sde_ldex_kfcp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207058ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(a) bdk_tns_sde_ldex_kfcp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(a) "TNS_SDE_LDEX_KFCP_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfcp_int_w1c
 *
 * TNS SDE LDE KFCP Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfcp_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfcp_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W1C/H) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W1C/H) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W1C/H) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W1C/H) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W1C/H) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W1C/H) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W1C/H) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W1C/H) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W1C/H) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W1C/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfcp_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_kfcp_int_w1c bdk_tns_sde_ldex_kfcp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020704cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFCP_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(a) bdk_tns_sde_ldex_kfcp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(a) "TNS_SDE_LDEX_KFCP_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfdp_int_en_hi
 *
 * TNS SDE LDE KFDP Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfdp_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfdp_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfdp_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_kfdp_int_en_hi bdk_tns_sde_ldex_kfdp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205028ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFDP_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(a) bdk_tns_sde_ldex_kfdp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(a) "TNS_SDE_LDEX_KFDP_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfdp_int_en_lo
 *
 * TNS SDE LDE KFDP Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfdp_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfdp_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfdp_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_kfdp_int_en_lo bdk_tns_sde_ldex_kfdp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020502cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFDP_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(a) bdk_tns_sde_ldex_kfdp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(a) "TNS_SDE_LDEX_KFDP_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfdp_int_frc
 *
 * TNS SDE LDE KFDP Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfdp_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfdp_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](WO) -- */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](WO) -- */
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](WO) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfdp_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_kfdp_int_frc bdk_tns_sde_ldex_kfdp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205030ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFDP_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(a) bdk_tns_sde_ldex_kfdp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(a) "TNS_SDE_LDEX_KFDP_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfdp_int_w1c
 *
 * TNS SDE LDE KFDP Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_kfdp_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfdp_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_reqid_out_unexpected : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t se_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfdp_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_kfdp_int_w1c bdk_tns_sde_ldex_kfdp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205024ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFDP_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(a) bdk_tns_sde_ldex_kfdp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(a) "TNS_SDE_LDEX_KFDP_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfit_lock
 *
 * TNS SDE LDE KFIT Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_kfit_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfit_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfit_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_kfit_lock bdk_tns_sde_ldex_kfit_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060206c48ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFIT_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFIT_LOCK(a) bdk_tns_sde_ldex_kfit_lock_t
#define bustype_BDK_TNS_SDE_LDEX_KFIT_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFIT_LOCK(a) "TNS_SDE_LDEX_KFIT_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_KFIT_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFIT_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFIT_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfit_spad
 *
 * TNS SDE LDE KFIT ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_kfit_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfit_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfit_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_kfit_spad bdk_tns_sde_ldex_kfit_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060206c4cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFIT_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFIT_SPAD(a) bdk_tns_sde_ldex_kfit_spad_t
#define bustype_BDK_TNS_SDE_LDEX_KFIT_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFIT_SPAD(a) "TNS_SDE_LDEX_KFIT_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_KFIT_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFIT_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFIT_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfm_ecc_ctl_cd
 *
 * TNS SDE LDE KFMISC ECC Control Disable Correction Registers
 * --
 */
union bdk_tns_sde_ldex_kfm_ecc_ctl_cd
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfm_ecc_ctl_cd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t tpl_table             : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tpl_table             : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfm_ecc_ctl_cd_s cn; */
};
typedef union bdk_tns_sde_ldex_kfm_ecc_ctl_cd bdk_tns_sde_ldex_kfm_ecc_ctl_cd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205010ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFM_ECC_CTL_CD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(a) bdk_tns_sde_ldex_kfm_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(a) "TNS_SDE_LDEX_KFM_ECC_CTL_CD"
#define device_bar_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfm_ecc_ctl_fd
 *
 * TNS SDE LDE KFMISC ECC Control Flip Double Bit Registers
 * --
 */
union bdk_tns_sde_ldex_kfm_ecc_ctl_fd
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfm_ecc_ctl_fd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t tpl_table             : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tpl_table             : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfm_ecc_ctl_fd_s cn; */
};
typedef union bdk_tns_sde_ldex_kfm_ecc_ctl_fd bdk_tns_sde_ldex_kfm_ecc_ctl_fd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020500cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFM_ECC_CTL_FD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(a) bdk_tns_sde_ldex_kfm_ecc_ctl_fd_t
#define bustype_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(a) "TNS_SDE_LDEX_KFM_ECC_CTL_FD"
#define device_bar_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfm_ecc_ctl_fs
 *
 * TNS SDE LDE KFMISC ECC Control Flip Single Bit Registers
 * --
 */
union bdk_tns_sde_ldex_kfm_ecc_ctl_fs
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfm_ecc_ctl_fs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t tpl_table             : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tpl_table             : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfm_ecc_ctl_fs_s cn; */
};
typedef union bdk_tns_sde_ldex_kfm_ecc_ctl_fs bdk_tns_sde_ldex_kfm_ecc_ctl_fs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205008ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFM_ECC_CTL_FS", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(a) bdk_tns_sde_ldex_kfm_ecc_ctl_fs_t
#define bustype_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(a) "TNS_SDE_LDEX_KFM_ECC_CTL_FS"
#define device_bar_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfmisc_dbg_cptr
 *
 * TNS SDE LDE KFMISC Debug Caputure Registers
 * --
 */
union bdk_tns_sde_ldex_kfmisc_dbg_cptr
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfmisc_dbg_cptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfmisc_dbg_cptr_s cn; */
};
typedef union bdk_tns_sde_ldex_kfmisc_dbg_cptr bdk_tns_sde_ldex_kfmisc_dbg_cptr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205048ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFMISC_DBG_CPTR", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(a) bdk_tns_sde_ldex_kfmisc_dbg_cptr_t
#define bustype_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(a) "TNS_SDE_LDEX_KFMISC_DBG_CPTR"
#define device_bar_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfmisc_lock
 *
 * TNS SDE LDE KFMISC Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_kfmisc_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfmisc_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfmisc_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_kfmisc_lock bdk_tns_sde_ldex_kfmisc_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205060ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFMISC_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFMISC_LOCK(a) bdk_tns_sde_ldex_kfmisc_lock_t
#define bustype_BDK_TNS_SDE_LDEX_KFMISC_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFMISC_LOCK(a) "TNS_SDE_LDEX_KFMISC_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_KFMISC_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFMISC_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFMISC_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_kfmisc_spad
 *
 * TNS SDE LDE KFMISC ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_kfmisc_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_kfmisc_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_kfmisc_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_kfmisc_spad bdk_tns_sde_ldex_kfmisc_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205064ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_KFMISC_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_KFMISC_SPAD(a) bdk_tns_sde_ldex_kfmisc_spad_t
#define bustype_BDK_TNS_SDE_LDEX_KFMISC_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_KFMISC_SPAD(a) "TNS_SDE_LDEX_KFMISC_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_KFMISC_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_KFMISC_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_KFMISC_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldea_int_en_hi
 *
 * TNS SDE LDE LDEA Interrrupt Enable High Registers
 * --
 */
union bdk_tns_sde_ldex_ldea_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldea_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](R/W) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldea_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_ldea_int_en_hi bdk_tns_sde_ldex_ldea_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205038ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEA_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(a) bdk_tns_sde_ldex_ldea_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(a) "TNS_SDE_LDEX_LDEA_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldea_int_en_lo
 *
 * TNS SDE LDE LDEA Interrrupt Enable Low Registers
 * --
 */
union bdk_tns_sde_ldex_ldea_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldea_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](R/W) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](R/W) -- */
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldea_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_ldea_int_en_lo bdk_tns_sde_ldex_ldea_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020503cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEA_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(a) bdk_tns_sde_ldex_ldea_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(a) "TNS_SDE_LDEX_LDEA_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldea_int_frc
 *
 * TNS SDE LDE LDEA Interrrupt Force Registers
 * --
 */
union bdk_tns_sde_ldex_ldea_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldea_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](WO) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](WO) -- */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](WO) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](WO) -- */
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](WO) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldea_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_ldea_int_frc bdk_tns_sde_ldex_ldea_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205040ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEA_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(a) bdk_tns_sde_ldex_ldea_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(a) "TNS_SDE_LDEX_LDEA_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldea_int_w1c
 *
 * TNS SDE LDE LDEA Interrrupt W1C Registers
 * --
 */
union bdk_tns_sde_ldex_ldea_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldea_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t isme_lde_lanem_dfc_rx_ovfl : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldea_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_ldea_int_w1c bdk_tns_sde_ldex_ldea_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205034ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEA_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(a) bdk_tns_sde_ldex_ldea_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(a) "TNS_SDE_LDEX_LDEA_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldeb_int_en_hi
 *
 * TNS SDE LDE LDEB Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ldeb_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldeb_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](R/W) -- */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldeb_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_ldeb_int_en_hi bdk_tns_sde_ldex_ldeb_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072b8ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEB_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(a) bdk_tns_sde_ldex_ldeb_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(a) "TNS_SDE_LDEX_LDEB_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldeb_int_en_lo
 *
 * TNS SDE LDE LDEB Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ldeb_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldeb_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](R/W) -- */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](R/W) -- */
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldeb_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_ldeb_int_en_lo bdk_tns_sde_ldex_ldeb_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072bcll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEB_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(a) bdk_tns_sde_ldex_ldeb_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(a) "TNS_SDE_LDEX_LDEB_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldeb_int_frc
 *
 * TNS SDE LDE LDEB Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ldeb_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldeb_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](WO) -- */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](WO) -- */
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](WO) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldeb_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_ldeb_int_frc bdk_tns_sde_ldex_ldeb_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072c0ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEB_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(a) bdk_tns_sde_ldex_ldeb_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(a) "TNS_SDE_LDEX_LDEB_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ldeb_int_w1c
 *
 * TNS SDE LDE LDEB Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ldeb_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ldeb_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t ldea_ldeb_dfc_rx_ovfl : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ldeb_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_ldeb_int_w1c bdk_tns_sde_ldex_ldeb_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072b4ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_LDEB_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(a) bdk_tns_sde_ldex_ldeb_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(a) "TNS_SDE_LDEX_LDEB_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_mgr_ecc_ctl_cd
 *
 * TNS SDE LDE Merger ECC Control Disable Correction Registers
 * --
 */
union bdk_tns_sde_ldex_mgr_ecc_ctl_cd
{
    uint32_t u;
    struct bdk_tns_sde_ldex_mgr_ecc_ctl_cd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t input_storage         : 1;  /**< [  8:  8](R/W) -- */
        uint32_t se_rslt_buffer7       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t se_rslt_buffer6       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t se_rslt_buffer5       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t se_rslt_buffer4       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t se_rslt_buffer3       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_rslt_buffer2       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_rslt_buffer1       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_rslt_buffer0       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_rslt_buffer0       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t se_rslt_buffer1       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_rslt_buffer2       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_rslt_buffer3       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_rslt_buffer4       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t se_rslt_buffer5       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t se_rslt_buffer6       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t se_rslt_buffer7       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t input_storage         : 1;  /**< [  8:  8](R/W) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_ecc_ctl_cd_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_ecc_ctl_cd bdk_tns_sde_ldex_mgr_ecc_ctl_cd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207334ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_ECC_CTL_CD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(a) bdk_tns_sde_ldex_mgr_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(a) "TNS_SDE_LDEX_MGR_ECC_CTL_CD"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_mgr_ecc_ctl_fd
 *
 * TNS SDE LDE Merger ECC Control Flip Double Bit Registers
 * --
 */
union bdk_tns_sde_ldex_mgr_ecc_ctl_fd
{
    uint32_t u;
    struct bdk_tns_sde_ldex_mgr_ecc_ctl_fd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t input_storage         : 12; /**< [ 19:  8](R/W) -- */
        uint32_t se_rslt_buffer7       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t se_rslt_buffer6       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t se_rslt_buffer5       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t se_rslt_buffer4       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t se_rslt_buffer3       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_rslt_buffer2       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_rslt_buffer1       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_rslt_buffer0       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_rslt_buffer0       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t se_rslt_buffer1       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_rslt_buffer2       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_rslt_buffer3       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_rslt_buffer4       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t se_rslt_buffer5       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t se_rslt_buffer6       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t se_rslt_buffer7       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t input_storage         : 12; /**< [ 19:  8](R/W) -- */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_ecc_ctl_fd_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_ecc_ctl_fd bdk_tns_sde_ldex_mgr_ecc_ctl_fd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207330ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_ECC_CTL_FD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(a) bdk_tns_sde_ldex_mgr_ecc_ctl_fd_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(a) "TNS_SDE_LDEX_MGR_ECC_CTL_FD"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_mgr_ecc_ctl_fs
 *
 * TNS SDE LDE Merger ECC Control Flip Single Bit Registers
 * --
 */
union bdk_tns_sde_ldex_mgr_ecc_ctl_fs
{
    uint32_t u;
    struct bdk_tns_sde_ldex_mgr_ecc_ctl_fs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t input_storage         : 12; /**< [ 19:  8](R/W) -- */
        uint32_t se_rslt_buffer7       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t se_rslt_buffer6       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t se_rslt_buffer5       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t se_rslt_buffer4       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t se_rslt_buffer3       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_rslt_buffer2       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_rslt_buffer1       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_rslt_buffer0       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_rslt_buffer0       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t se_rslt_buffer1       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_rslt_buffer2       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_rslt_buffer3       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_rslt_buffer4       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t se_rslt_buffer5       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t se_rslt_buffer6       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t se_rslt_buffer7       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t input_storage         : 12; /**< [ 19:  8](R/W) -- */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_ecc_ctl_fs_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_ecc_ctl_fs bdk_tns_sde_ldex_mgr_ecc_ctl_fs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020732cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_ECC_CTL_FS", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(a) bdk_tns_sde_ldex_mgr_ecc_ctl_fs_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(a) "TNS_SDE_LDEX_MGR_ECC_CTL_FS"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_mgr_int_en_hi
 *
 * TNS SDE LDE Merger Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_mgr_int_en_hi
{
    uint64_t u;
    struct bdk_tns_sde_ldex_mgr_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](R/W) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](R/W) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](R/W) -- */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](R/W) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](R/W) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](R/W) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](R/W) -- */
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_int_en_hi bdk_tns_sde_ldex_mgr_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207340ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(a) bdk_tns_sde_ldex_mgr_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(a) "TNS_SDE_LDEX_MGR_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_mgr_int_en_lo
 *
 * TNS SDE LDE Merger Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_mgr_int_en_lo
{
    uint64_t u;
    struct bdk_tns_sde_ldex_mgr_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](R/W) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](R/W) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](R/W) -- */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](R/W) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](R/W) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](R/W) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](R/W) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](R/W) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](R/W) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](R/W) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](R/W) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](R/W) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](R/W) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](R/W) -- */
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_int_en_lo bdk_tns_sde_ldex_mgr_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207348ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(a) bdk_tns_sde_ldex_mgr_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(a) "TNS_SDE_LDEX_MGR_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_mgr_int_frc
 *
 * TNS SDE LDE Merger Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_mgr_int_frc
{
    uint64_t u;
    struct bdk_tns_sde_ldex_mgr_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](WO) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](WO) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](WO) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](WO) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](WO) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](WO) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](WO) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](WO) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](WO) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](WO) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](WO) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](WO) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](WO) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](WO) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](WO) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](WO) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](WO) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](WO) -- */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](WO) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](WO) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](WO) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](WO) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](WO) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](WO) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](WO) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](WO) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](WO) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](WO) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](WO) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](WO) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](WO) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](WO) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](WO) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](WO) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](WO) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](WO) -- */
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](WO) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_int_frc bdk_tns_sde_ldex_mgr_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207350ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_FRC(a) bdk_tns_sde_ldex_mgr_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_FRC(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_FRC(a) "TNS_SDE_LDEX_MGR_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_mgr_int_w1c
 *
 * TNS SDE LDE Merger Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_mgr_int_w1c
{
    uint64_t u;
    struct bdk_tns_sde_ldex_mgr_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](R/W1C/H) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](R/W1C/H) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](R/W1C/H) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](R/W1C/H) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](R/W1C/H) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](R/W1C/H) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](R/W1C/H) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](R/W1C/H) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](R/W1C/H) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](R/W1C/H) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](R/W1C/H) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](R/W1C/H) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](R/W1C/H) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](R/W1C/H) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](R/W1C/H) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](R/W1C/H) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](R/W1C/H) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](R/W1C/H) -- */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t se_rslt_buffer0_ecc_db_err : 1;/**< [  0:  0](R/W1C/H) -- */
        uint64_t se_rslt_buffer0_ecc_sb_err : 1;/**< [  1:  1](R/W1C/H) -- */
        uint64_t se_rslt_buffer1_ecc_db_err : 1;/**< [  2:  2](R/W1C/H) -- */
        uint64_t se_rslt_buffer1_ecc_sb_err : 1;/**< [  3:  3](R/W1C/H) -- */
        uint64_t se_rslt_buffer2_ecc_db_err : 1;/**< [  4:  4](R/W1C/H) -- */
        uint64_t se_rslt_buffer2_ecc_sb_err : 1;/**< [  5:  5](R/W1C/H) -- */
        uint64_t se_rslt_buffer3_ecc_db_err : 1;/**< [  6:  6](R/W1C/H) -- */
        uint64_t se_rslt_buffer3_ecc_sb_err : 1;/**< [  7:  7](R/W1C/H) -- */
        uint64_t se_rslt_buffer4_ecc_db_err : 1;/**< [  8:  8](R/W1C/H) -- */
        uint64_t se_rslt_buffer4_ecc_sb_err : 1;/**< [  9:  9](R/W1C/H) -- */
        uint64_t se_rslt_buffer5_ecc_db_err : 1;/**< [ 10: 10](R/W1C/H) -- */
        uint64_t se_rslt_buffer5_ecc_sb_err : 1;/**< [ 11: 11](R/W1C/H) -- */
        uint64_t se_rslt_buffer6_ecc_db_err : 1;/**< [ 12: 12](R/W1C/H) -- */
        uint64_t se_rslt_buffer6_ecc_sb_err : 1;/**< [ 13: 13](R/W1C/H) -- */
        uint64_t se_rslt_buffer7_ecc_db_err : 1;/**< [ 14: 14](R/W1C/H) -- */
        uint64_t se_rslt_buffer7_ecc_sb_err : 1;/**< [ 15: 15](R/W1C/H) -- */
        uint64_t token_buf_ecc_db_err  : 12; /**< [ 27: 16](R/W1C/H) -- */
        uint64_t token_buf_ecc_sb_err  : 12; /**< [ 39: 28](R/W1C/H) -- */
        uint64_t merge_timeout         : 1;  /**< [ 40: 40](R/W1C/H) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_int_w1c bdk_tns_sde_ldex_mgr_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207338ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_W1C(a) bdk_tns_sde_ldex_mgr_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_W1C(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_W1C(a) "TNS_SDE_LDEX_MGR_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_mgr_lde_type
 *
 * TNS SDE LDE Merger LDE Type Registers
 * --
 */
union bdk_tns_sde_ldex_mgr_lde_type
{
    uint32_t u;
    struct bdk_tns_sde_ldex_mgr_lde_type_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_lde_type_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_lde_type bdk_tns_sde_ldex_mgr_lde_type_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207328ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_LDE_TYPE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(a) bdk_tns_sde_ldex_mgr_lde_type_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(a) "TNS_SDE_LDEX_MGR_LDE_TYPE"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_mgr_lock
 *
 * TNS SDE LDE Merger Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_mgr_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_mgr_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_lock bdk_tns_sde_ldex_mgr_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207368ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_LOCK(a) bdk_tns_sde_ldex_mgr_lock_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_MGR_LOCK(a) "TNS_SDE_LDEX_MGR_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_mgr_spad
 *
 * TNS SDE LDE Merger ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_mgr_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_mgr_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_mgr_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_mgr_spad bdk_tns_sde_ldex_mgr_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020736cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_MGR_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_MGR_SPAD(a) bdk_tns_sde_ldex_mgr_spad_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_MGR_SPAD(a) "TNS_SDE_LDEX_MGR_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_MGR_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_MGR_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_MGR_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp0_bypm_dmux
 *
 * TNS SDE LDE OFCP Stage 0 Bypassmux Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage0_bypassmux cells
 * - 32 cells
 */
union bdk_tns_sde_ldex_ofcp0_bypm_dmux
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp0_bypm_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t mux_sel               : 9;  /**< [  8:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux_sel               : 9;  /**< [  8:  0](R/W/H) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp0_bypm_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp0_bypm_dmux bdk_tns_sde_ldex_ofcp0_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207118ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP0_BYPM_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(a) bdk_tns_sde_ldex_ofcp0_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(a) "TNS_SDE_LDEX_OFCP0_BYPM_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp0_ml_dlut
 *
 * TNS SDE LDE OFCP Stage 0 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all ofcp_stage0_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp0_ml_dlut
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp0_ml_dlut_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp0_ml_dlut_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp0_ml_dlut bdk_tns_sde_ldex_ofcp0_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207110ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP0_ML_DLUT", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(a) bdk_tns_sde_ldex_ofcp0_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(a) "TNS_SDE_LDEX_OFCP0_ML_DLUT"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp0_ml_dmux
 *
 * TNS SDE LDE OFCP Stage 0 MUXLUT Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all ofcp_stage0_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp0_ml_dmux
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp0_ml_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_54_63        : 10;
        uint64_t mux5_sel              : 9;  /**< [ 53: 45](R/W/H) -- */
        uint64_t mux4_sel              : 9;  /**< [ 44: 36](R/W/H) -- */
        uint64_t mux3_sel              : 9;  /**< [ 35: 27](R/W/H) -- */
        uint64_t mux2_sel              : 9;  /**< [ 26: 18](R/W/H) -- */
        uint64_t mux1_sel              : 9;  /**< [ 17:  9](R/W/H) -- */
        uint64_t mux0_sel              : 9;  /**< [  8:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t mux0_sel              : 9;  /**< [  8:  0](R/W/H) -- */
        uint64_t mux1_sel              : 9;  /**< [ 17:  9](R/W/H) -- */
        uint64_t mux2_sel              : 9;  /**< [ 26: 18](R/W/H) -- */
        uint64_t mux3_sel              : 9;  /**< [ 35: 27](R/W/H) -- */
        uint64_t mux4_sel              : 9;  /**< [ 44: 36](R/W/H) -- */
        uint64_t mux5_sel              : 9;  /**< [ 53: 45](R/W/H) -- */
        uint64_t reserved_54_63        : 10;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp0_ml_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp0_ml_dmux bdk_tns_sde_ldex_ofcp0_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207108ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP0_ML_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(a) bdk_tns_sde_ldex_ofcp0_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(a) "TNS_SDE_LDEX_OFCP0_ML_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp1_bypm_dmux
 *
 * TNS SDE LDE OFCP Stage 1 Bypassmux Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage1_bypassmux cells
 * - 32 cells
 */
union bdk_tns_sde_ldex_ofcp1_bypm_dmux
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp1_bypm_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp1_bypm_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp1_bypm_dmux bdk_tns_sde_ldex_ofcp1_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020712cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP1_BYPM_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(a) bdk_tns_sde_ldex_ofcp1_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(a) "TNS_SDE_LDEX_OFCP1_BYPM_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp1_ml_dlut_w#
 *
 * TNS SDE LDE OFCP Stage 1 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all ofcp_stage1_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp1_ml_dlut_wx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lut                   : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lut                   : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp1_ml_dlut_wx bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=1)))
        return 0x842060207124ll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP1_ML_DLUT_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(a,b) bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(a,b) "TNS_SDE_LDEX_OFCP1_ML_DLUT_WX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp1_ml_dmux_w0
 *
 * TNS SDE LDE OFCP Stage 1 MUXLUT Dynamic MUX Word 0 Registers
 * A dynamic register for configuring all muxes in all ofcp_stage1_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp1_ml_dmux_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mux5_sel              : 2;  /**< [ 31: 30](R/W/H) -- */
        uint32_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint32_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint32_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint32_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint32_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint32_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint32_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint32_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint32_t mux5_sel              : 2;  /**< [ 31: 30](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp1_ml_dmux_w0 bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020711cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP1_ML_DMUX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(a) bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(a) "TNS_SDE_LDEX_OFCP1_ML_DMUX_W0"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp1_ml_dmux_w1
 *
 * TNS SDE LDE OFCP Stage 1 MUXLUT Dynamic MUX Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_OFCP1_ML_DMUX_W0
 */
union bdk_tns_sde_ldex_ofcp1_ml_dmux_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mux5_sel              : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field MUX5_SEL from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t mux5_sel              : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field MUX5_SEL from previous word. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp1_ml_dmux_w1 bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207120ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP1_ML_DMUX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(a) bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(a) "TNS_SDE_LDEX_OFCP1_ML_DMUX_W1"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp2_bypm_dmux
 *
 * TNS SDE LDE OFCP Stage 2 Bypassmux Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage2_bypassmux cells
 * - 32 cells
 */
union bdk_tns_sde_ldex_ofcp2_bypm_dmux
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp2_bypm_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp2_bypm_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp2_bypm_dmux bdk_tns_sde_ldex_ofcp2_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207140ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP2_BYPM_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(a) bdk_tns_sde_ldex_ofcp2_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(a) "TNS_SDE_LDEX_OFCP2_BYPM_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp2_ml_dlut
 *
 * TNS SDE LDE OFCP Stage 2 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all ofcp_stage2_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp2_ml_dlut
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp2_ml_dlut_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp2_ml_dlut_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp2_ml_dlut bdk_tns_sde_ldex_ofcp2_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207138ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP2_ML_DLUT", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(a) bdk_tns_sde_ldex_ofcp2_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(a) "TNS_SDE_LDEX_OFCP2_ML_DLUT"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp2_ml_dmux
 *
 * TNS SDE LDE OFCP Stage 2 MUXLUT Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all ofcp_stage2_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp2_ml_dmux
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp2_ml_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t mux5_sel              : 6;  /**< [ 35: 30](R/W/H) -- */
        uint64_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint64_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint64_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint64_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint64_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
        uint64_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint64_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint64_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint64_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint64_t mux5_sel              : 6;  /**< [ 35: 30](R/W/H) -- */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp2_ml_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp2_ml_dmux bdk_tns_sde_ldex_ofcp2_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207130ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP2_ML_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(a) bdk_tns_sde_ldex_ofcp2_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(a) "TNS_SDE_LDEX_OFCP2_ML_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp3_bypm_dmux
 *
 * TNS SDE LDE OFCP Stage 3 Bypassmux Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all kfcp_stage3_bypassmux cells
 * - 32 cells
 */
union bdk_tns_sde_ldex_ofcp3_bypm_dmux
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp3_bypm_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux_sel               : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp3_bypm_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp3_bypm_dmux bdk_tns_sde_ldex_ofcp3_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207154ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP3_BYPM_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(a) bdk_tns_sde_ldex_ofcp3_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(a) "TNS_SDE_LDEX_OFCP3_BYPM_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp3_ml_dlut_w#
 *
 * TNS SDE LDE OFCP Stage 3 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all ofcp_stage3_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp3_ml_dlut_wx
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lut                   : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lut                   : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp3_ml_dlut_wx bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=1)))
        return 0x84206020714cll + 0x8000ll * ((a) & 0x1) + 4ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP3_ML_DLUT_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(a,b) bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(a,b) "TNS_SDE_LDEX_OFCP3_ML_DLUT_WX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp3_ml_dmux_w0
 *
 * TNS SDE LDE OFCP Stage 3 MUXLUT Dynamic MUX Word 0 Registers
 * A dynamic register for configuring all muxes in all ofcp_stage3_muxlut cells -
 * 32 cells
 */
union bdk_tns_sde_ldex_ofcp3_ml_dmux_w0
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mux5_sel              : 2;  /**< [ 31: 30](R/W/H) -- */
        uint32_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint32_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint32_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint32_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint32_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint32_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint32_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint32_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint32_t mux5_sel              : 2;  /**< [ 31: 30](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp3_ml_dmux_w0 bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207144ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP3_ML_DMUX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(a) bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(a) "TNS_SDE_LDEX_OFCP3_ML_DMUX_W0"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp3_ml_dmux_w1
 *
 * TNS SDE LDE OFCP Stage 3 MUXLUT Dynamic MUX Word 1 Registers
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_OFCP3_ML_DMUX_W0
 */
union bdk_tns_sde_ldex_ofcp3_ml_dmux_w1
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mux5_sel              : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field MUX5_SEL from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t mux5_sel              : 4;  /**< [  3:  0](R/W/H) Continuation of MSBs of field MUX5_SEL from previous word. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp3_ml_dmux_w1 bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207148ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP3_ML_DMUX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(a) bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(a) "TNS_SDE_LDEX_OFCP3_ML_DMUX_W1"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp4_ml_dlut
 *
 * TNS SDE LDE OFCP Stage 4 MUXLUT Dynamic LUT Registers
 * A dynamic register for configuring all luts in all ofcp_stage4_muxlut cells -
 * 48 cells
 */
union bdk_tns_sde_ldex_ofcp4_ml_dlut
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp4_ml_dlut_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t lut                   : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp4_ml_dlut_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp4_ml_dlut bdk_tns_sde_ldex_ofcp4_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207160ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP4_ML_DLUT", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(a) bdk_tns_sde_ldex_ofcp4_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(a) "TNS_SDE_LDEX_OFCP4_ML_DLUT"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp4_ml_dmux
 *
 * TNS SDE LDE OFCP Stage 4 MUXLUT Dynamic MUX Registers
 * A dynamic register for configuring all muxes in all ofcp_stage4_muxlut cells -
 * 48 cells
 */
union bdk_tns_sde_ldex_ofcp4_ml_dmux
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp4_ml_dmux_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t mux5_sel              : 6;  /**< [ 35: 30](R/W/H) -- */
        uint64_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint64_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint64_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint64_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint64_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t mux0_sel              : 6;  /**< [  5:  0](R/W/H) -- */
        uint64_t mux1_sel              : 6;  /**< [ 11:  6](R/W/H) -- */
        uint64_t mux2_sel              : 6;  /**< [ 17: 12](R/W/H) -- */
        uint64_t mux3_sel              : 6;  /**< [ 23: 18](R/W/H) -- */
        uint64_t mux4_sel              : 6;  /**< [ 29: 24](R/W/H) -- */
        uint64_t mux5_sel              : 6;  /**< [ 35: 30](R/W/H) -- */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp4_ml_dmux_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp4_ml_dmux bdk_tns_sde_ldex_ofcp4_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207158ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP4_ML_DMUX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(a) bdk_tns_sde_ldex_ofcp4_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(a) "TNS_SDE_LDEX_OFCP4_ML_DMUX"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp_cloud_lock
 *
 * TNS SDE LDE OFCP Cloud Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_ofcp_cloud_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp_cloud_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_cloud_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_cloud_lock bdk_tns_sde_ldex_ofcp_cloud_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207190ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_CLOUD_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(a) bdk_tns_sde_ldex_ofcp_cloud_lock_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(a) "TNS_SDE_LDEX_OFCP_CLOUD_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp_cloud_spad
 *
 * TNS SDE LDE OFCP Cloud ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_ofcp_cloud_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp_cloud_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_cloud_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_cloud_spad bdk_tns_sde_ldex_ofcp_cloud_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207194ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_CLOUD_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(a) bdk_tns_sde_ldex_ofcp_cloud_spad_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(a) "TNS_SDE_LDEX_OFCP_CLOUD_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp_int_en_hi
 *
 * TNS SDE LDE OFCP Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofcp_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](R/W) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](R/W) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](R/W) -- */
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_int_en_hi bdk_tns_sde_ldex_ofcp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207184ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(a) bdk_tns_sde_ldex_ofcp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(a) "TNS_SDE_LDEX_OFCP_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp_int_en_lo
 *
 * TNS SDE LDE OFCP Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofcp_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](R/W) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](R/W) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](R/W) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](R/W) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](R/W) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](R/W) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](R/W) -- */
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_int_en_lo bdk_tns_sde_ldex_ofcp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207188ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(a) bdk_tns_sde_ldex_ofcp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(a) "TNS_SDE_LDEX_OFCP_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp_int_frc
 *
 * TNS SDE LDE OFCP Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofcp_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](WO) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](WO) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](WO) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](WO) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](WO) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](WO) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](WO) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](WO) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](WO) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](WO) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](WO) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](WO) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](WO) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](WO) -- */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](WO) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](WO) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](WO) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](WO) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](WO) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](WO) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](WO) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](WO) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](WO) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](WO) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](WO) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](WO) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](WO) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](WO) -- */
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](WO) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_int_frc bdk_tns_sde_ldex_ofcp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020718cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(a) bdk_tns_sde_ldex_ofcp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(a) "TNS_SDE_LDEX_OFCP_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofcp_int_w1c
 *
 * TNS SDE LDE OFCP Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofcp_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofcp_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](R/W1C/H) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](R/W1C/H) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](R/W1C/H) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](R/W1C/H) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](R/W1C/H) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](R/W1C/H) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](R/W1C/H) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W1C/H) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W1C/H) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W1C/H) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W1C/H) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W1C/H) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  3:  3](R/W1C/H) -- */
        uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  4:  4](R/W1C/H) -- */
        uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  5:  5](R/W1C/H) -- */
        uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  6:  6](R/W1C/H) -- */
        uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [  7:  7](R/W1C/H) -- */
        uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [  8:  8](R/W1C/H) -- */
        uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [  9:  9](R/W1C/H) -- */
        uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 10: 10](R/W1C/H) -- */
        uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< [ 11: 11](R/W1C/H) -- */
        uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< [ 12: 12](R/W1C/H) -- */
        uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< [ 13: 13](R/W1C/H) -- */
        uint32_t muxxor_dsy_chn_cfg_perr : 1;/**< [ 14: 14](R/W1C/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_int_w1c bdk_tns_sde_ldex_ofcp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207180ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(a) bdk_tns_sde_ldex_ofcp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(a) "TNS_SDE_LDEX_OFCP_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_lde#_ofcp_mxxr_dyn
 *
 * TNS SDE LDE OFCP MUXXOR DYN Registers
 * A dynamic register for configuring all cfg_ofcp_muxxor cells - 8 cells
 */
union bdk_tns_sde_ldex_ofcp_mxxr_dyn
{
    uint64_t u;
    struct bdk_tns_sde_ldex_ofcp_mxxr_dyn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t muxa_srcid            : 4;  /**< [ 57: 54](R/W/H) -- */
        uint64_t muxa_bytestartposn    : 7;  /**< [ 53: 47](R/W/H) -- */
        uint64_t muxa_shiftby          : 3;  /**< [ 46: 44](R/W/H) -- */
        uint64_t muxa_shiftdir         : 1;  /**< [ 43: 43](R/W/H) -- */
        uint64_t muxa_bitmask          : 16; /**< [ 42: 27](R/W/H) -- */
        uint64_t muxb_srcid            : 4;  /**< [ 26: 23](R/W/H) -- */
        uint64_t muxb_bytestartposn    : 7;  /**< [ 22: 16](R/W/H) -- */
        uint64_t muxb_bitmask          : 16; /**< [ 15:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t muxb_bitmask          : 16; /**< [ 15:  0](R/W/H) -- */
        uint64_t muxb_bytestartposn    : 7;  /**< [ 22: 16](R/W/H) -- */
        uint64_t muxb_srcid            : 4;  /**< [ 26: 23](R/W/H) -- */
        uint64_t muxa_bitmask          : 16; /**< [ 42: 27](R/W/H) -- */
        uint64_t muxa_shiftdir         : 1;  /**< [ 43: 43](R/W/H) -- */
        uint64_t muxa_shiftby          : 3;  /**< [ 46: 44](R/W/H) -- */
        uint64_t muxa_bytestartposn    : 7;  /**< [ 53: 47](R/W/H) -- */
        uint64_t muxa_srcid            : 4;  /**< [ 57: 54](R/W/H) -- */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofcp_mxxr_dyn_s cn; */
};
typedef union bdk_tns_sde_ldex_ofcp_mxxr_dyn bdk_tns_sde_ldex_ofcp_mxxr_dyn_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207100ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFCP_MXXR_DYN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(a) bdk_tns_sde_ldex_ofcp_mxxr_dyn_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(a) "TNS_SDE_LDEX_OFCP_MXXR_DYN"
#define device_bar_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofdp_int_en_hi
 *
 * TNS SDE LDE OFDP Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofdp_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofdp_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](R/W) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofdp_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_ofdp_int_en_hi bdk_tns_sde_ldex_ofdp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207288ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFDP_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(a) bdk_tns_sde_ldex_ofdp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(a) "TNS_SDE_LDEX_OFDP_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofdp_int_en_lo
 *
 * TNS SDE LDE OFDP Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofdp_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofdp_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](R/W) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](R/W) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W) -- */
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofdp_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_ofdp_int_en_lo bdk_tns_sde_ldex_ofdp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020728cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFDP_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(a) bdk_tns_sde_ldex_ofdp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(a) "TNS_SDE_LDEX_OFDP_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofdp_int_frc
 *
 * TNS SDE LDE OFDP Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofdp_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofdp_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](WO) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](WO) -- */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](WO) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](WO) -- */
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](WO) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofdp_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_ofdp_int_frc bdk_tns_sde_ldex_ofdp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207290ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFDP_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(a) bdk_tns_sde_ldex_ofdp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(a) "TNS_SDE_LDEX_OFDP_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofdp_int_w1c
 *
 * TNS SDE LDE OFDP Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ofdp_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofdp_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t acm_reqid_out_unexpected : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t acm_req_token_bypass  : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofdp_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_ofdp_int_w1c bdk_tns_sde_ldex_ofdp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060207284ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFDP_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(a) bdk_tns_sde_ldex_ofdp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(a) "TNS_SDE_LDEX_OFDP_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofit_lock
 *
 * TNS SDE LDE OFIT Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_ofit_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofit_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofit_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_ofit_lock bdk_tns_sde_ldex_ofit_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060202190ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFIT_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFIT_LOCK(a) bdk_tns_sde_ldex_ofit_lock_t
#define bustype_BDK_TNS_SDE_LDEX_OFIT_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFIT_LOCK(a) "TNS_SDE_LDEX_OFIT_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_OFIT_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFIT_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFIT_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofit_spad
 *
 * TNS SDE LDE OFIT ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_ofit_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofit_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofit_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_ofit_spad bdk_tns_sde_ldex_ofit_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060202194ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFIT_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFIT_SPAD(a) bdk_tns_sde_ldex_ofit_spad_t
#define bustype_BDK_TNS_SDE_LDEX_OFIT_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFIT_SPAD(a) "TNS_SDE_LDEX_OFIT_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_OFIT_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFIT_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFIT_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofmisc_dbg_cptr
 *
 * TNS SDE LDE OFMISC Debug Caputure Registers
 * --
 */
union bdk_tns_sde_ldex_ofmisc_dbg_cptr
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofmisc_dbg_cptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofmisc_dbg_cptr_s cn; */
};
typedef union bdk_tns_sde_ldex_ofmisc_dbg_cptr bdk_tns_sde_ldex_ofmisc_dbg_cptr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072c8ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFMISC_DBG_CPTR", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(a) bdk_tns_sde_ldex_ofmisc_dbg_cptr_t
#define bustype_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(a) "TNS_SDE_LDEX_OFMISC_DBG_CPTR"
#define device_bar_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofmisc_lock
 *
 * TNS SDE LDE OFMISC Lock Registers
 * Lock Register
 */
union bdk_tns_sde_ldex_ofmisc_lock
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofmisc_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofmisc_lock_s cn; */
};
typedef union bdk_tns_sde_ldex_ofmisc_lock bdk_tns_sde_ldex_ofmisc_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072ecll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFMISC_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFMISC_LOCK(a) bdk_tns_sde_ldex_ofmisc_lock_t
#define bustype_BDK_TNS_SDE_LDEX_OFMISC_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFMISC_LOCK(a) "TNS_SDE_LDEX_OFMISC_LOCK"
#define device_bar_BDK_TNS_SDE_LDEX_OFMISC_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFMISC_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFMISC_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ofmisc_spad
 *
 * TNS SDE LDE OFMISC ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_ldex_ofmisc_spad
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ofmisc_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ofmisc_spad_s cn; */
};
typedef union bdk_tns_sde_ldex_ofmisc_spad bdk_tns_sde_ldex_ofmisc_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072f0ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_OFMISC_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_OFMISC_SPAD(a) bdk_tns_sde_ldex_ofmisc_spad_t
#define bustype_BDK_TNS_SDE_LDEX_OFMISC_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_OFMISC_SPAD(a) "TNS_SDE_LDEX_OFMISC_SPAD"
#define device_bar_BDK_TNS_SDE_LDEX_OFMISC_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_OFMISC_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_OFMISC_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_tlom_int_en_hi
 *
 * TNS SDE LDE TLOM Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_tlom_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_tlom_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](R/W) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](R/W) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](R/W) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](R/W) -- */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](R/W) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](R/W) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](R/W) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](R/W) -- */
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_tlom_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_tlom_int_en_hi bdk_tns_sde_ldex_tlom_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205018ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TLOM_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(a) bdk_tns_sde_ldex_tlom_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(a) "TNS_SDE_LDEX_TLOM_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_tlom_int_en_lo
 *
 * TNS SDE LDE TLOM Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_tlom_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_tlom_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](R/W) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](R/W) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](R/W) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](R/W) -- */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](R/W) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](R/W) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](R/W) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](R/W) -- */
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_tlom_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_tlom_int_en_lo bdk_tns_sde_ldex_tlom_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206020501cll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TLOM_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(a) bdk_tns_sde_ldex_tlom_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(a) "TNS_SDE_LDEX_TLOM_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_tlom_int_frc
 *
 * TNS SDE LDE TLOM Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_tlom_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_tlom_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](WO) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](WO) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](WO) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](WO) -- */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](WO) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](WO) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](WO) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](WO) -- */
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](WO) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_tlom_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_tlom_int_frc bdk_tns_sde_ldex_tlom_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205020ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TLOM_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(a) bdk_tns_sde_ldex_tlom_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(a) "TNS_SDE_LDEX_TLOM_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_tlom_int_w1c
 *
 * TNS SDE LDE TLOM Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_tlom_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_tlom_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](R/W1C/H) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](R/W1C/H) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t layer_offset_out_of_range : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t fstint_lid0_gt_fstint_lid1 : 1;/**< [  1:  1](R/W1C/H) -- */
        uint32_t valid_layer_cnt_less_than_4 : 1;/**< [  2:  2](R/W1C/H) -- */
        uint32_t template_table_ecc_db_err : 1;/**< [  3:  3](R/W1C/H) -- */
        uint32_t template_table_ecc_sb_err : 1;/**< [  4:  4](R/W1C/H) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_tlom_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_tlom_int_w1c bdk_tns_sde_ldex_tlom_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842060205014ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TLOM_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(a) bdk_tns_sde_ldex_tlom_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(a) "TNS_SDE_LDEX_TLOM_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ttl_int_en_hi
 *
 * TNS SDE LDE Total Interrrupt Enable High Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ttl_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ttl_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ttl_fail              : 1;  /**< [  1:  1](R/W) -- */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](R/W) -- */
        uint32_t ttl_fail              : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ttl_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_ldex_ttl_int_en_hi bdk_tns_sde_ldex_ttl_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072a8ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TTL_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(a) bdk_tns_sde_ldex_ttl_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(a) "TNS_SDE_LDEX_TTL_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ttl_int_en_lo
 *
 * TNS SDE LDE Total Interrrupt Enable Low Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ttl_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ttl_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ttl_fail              : 1;  /**< [  1:  1](R/W) -- */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](R/W) -- */
        uint32_t ttl_fail              : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ttl_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_ldex_ttl_int_en_lo bdk_tns_sde_ldex_ttl_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072acll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TTL_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(a) bdk_tns_sde_ldex_ttl_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(a) "TNS_SDE_LDEX_TTL_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ttl_int_frc
 *
 * TNS SDE LDE Total Interrrupt Force Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ttl_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ttl_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ttl_fail              : 1;  /**< [  1:  1](WO) -- */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](WO) -- */
        uint32_t ttl_fail              : 1;  /**< [  1:  1](WO) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ttl_int_frc_s cn; */
};
typedef union bdk_tns_sde_ldex_ttl_int_frc bdk_tns_sde_ldex_ttl_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072b0ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TTL_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_FRC(a) bdk_tns_sde_ldex_ttl_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_FRC(a) "TNS_SDE_LDEX_TTL_INT_FRC"
#define device_bar_BDK_TNS_SDE_LDEX_TTL_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_FRC(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_lde#_ttl_int_w1c
 *
 * TNS SDE LDE Total Interrrupt W1C Registers
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
union bdk_tns_sde_ldex_ttl_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_ldex_ttl_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t ttl_fail              : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t cfg_ttl_fail_nxt_eng_inval : 1;/**< [  0:  0](R/W1C/H) -- */
        uint32_t ttl_fail              : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_ldex_ttl_int_w1c_s cn; */
};
typedef union bdk_tns_sde_ldex_ttl_int_w1c bdk_tns_sde_ldex_ttl_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x8420602072a4ll + 0x8000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_LDEX_TTL_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_W1C(a) bdk_tns_sde_ldex_ttl_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_W1C(a) "TNS_SDE_LDEX_TTL_INT_W1C"
#define device_bar_BDK_TNS_SDE_LDEX_TTL_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_W1C(a) (a)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_arb_out_ct
 *
 * TNS SDE MRE Bottom Arbitor Out Count Register
 * --
 */
union bdk_tns_sde_mreb_arb_out_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_arb_out_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of tokens leaving the arbiter */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of tokens leaving the arbiter */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_arb_out_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_arb_out_ct bdk_tns_sde_mreb_arb_out_ct_t;

#define BDK_TNS_SDE_MREB_ARB_OUT_CT BDK_TNS_SDE_MREB_ARB_OUT_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804c4ll;
    __bdk_csr_fatal("TNS_SDE_MREB_ARB_OUT_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_ARB_OUT_CT bdk_tns_sde_mreb_arb_out_ct_t
#define bustype_BDK_TNS_SDE_MREB_ARB_OUT_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_ARB_OUT_CT "TNS_SDE_MREB_ARB_OUT_CT"
#define device_bar_BDK_TNS_SDE_MREB_ARB_OUT_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_ARB_OUT_CT 0
#define arguments_BDK_TNS_SDE_MREB_ARB_OUT_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_arb_out_stepper
 *
 * TNS SDE MRE Bottom Arbitor Out Stepper Register
 * Controls the single stepper debug logic on the output of the arbiter.
 */
union bdk_tns_sde_mreb_arb_out_stepper
{
    uint32_t u;
    struct bdk_tns_sde_mreb_arb_out_stepper_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t gap                   : 8;  /**< [  9:  2](R/W) If 0, step function is enabled. If !=0, this is the minimum gap intruduced
                                                                 between requests leaving the arbiter. */
        uint32_t en                    : 1;  /**< [  1:  1](R/W) Enables the single step feature. When enabled a single entry will be popped
                                                                 from the page fifos every time step transitions from 0 to 1 */
        uint32_t step                  : 1;  /**< [  0:  0](R/W) Step. When changed from 0 to 1, a single entry will be popped from the fifos
                                                                 and admitted to the MRE processing pipeline */
#else /* Word 0 - Little Endian */
        uint32_t step                  : 1;  /**< [  0:  0](R/W) Step. When changed from 0 to 1, a single entry will be popped from the fifos
                                                                 and admitted to the MRE processing pipeline */
        uint32_t en                    : 1;  /**< [  1:  1](R/W) Enables the single step feature. When enabled a single entry will be popped
                                                                 from the page fifos every time step transitions from 0 to 1 */
        uint32_t gap                   : 8;  /**< [  9:  2](R/W) If 0, step function is enabled. If !=0, this is the minimum gap intruduced
                                                                 between requests leaving the arbiter. */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_arb_out_stepper_s cn; */
};
typedef union bdk_tns_sde_mreb_arb_out_stepper bdk_tns_sde_mreb_arb_out_stepper_t;

#define BDK_TNS_SDE_MREB_ARB_OUT_STEPPER BDK_TNS_SDE_MREB_ARB_OUT_STEPPER_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_STEPPER_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_STEPPER_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780404ll;
    __bdk_csr_fatal("TNS_SDE_MREB_ARB_OUT_STEPPER", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER bdk_tns_sde_mreb_arb_out_stepper_t
#define bustype_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER "TNS_SDE_MREB_ARB_OUT_STEPPER"
#define device_bar_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER 0
#define arguments_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_arbiter_sta
 *
 * TNS SDE MRE Bottom Arbiter Status Register
 * Indicates the next winner of the arbitration. The address indicates the page in
 * the token and header memory that will be read.
 */
union bdk_tns_sde_mreb_arbiter_sta
{
    uint32_t u;
    struct bdk_tns_sde_mreb_arbiter_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t bank                  : 2;  /**< [  8:  7](RO/H) Winning bank. */
        uint32_t addr                  : 7;  /**< [  6:  0](RO/H) Address of the winning token. */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 7;  /**< [  6:  0](RO/H) Address of the winning token. */
        uint32_t bank                  : 2;  /**< [  8:  7](RO/H) Winning bank. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_arbiter_sta_s cn; */
};
typedef union bdk_tns_sde_mreb_arbiter_sta bdk_tns_sde_mreb_arbiter_sta_t;

#define BDK_TNS_SDE_MREB_ARBITER_STA BDK_TNS_SDE_MREB_ARBITER_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_ARBITER_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_ARBITER_STA_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804c0ll;
    __bdk_csr_fatal("TNS_SDE_MREB_ARBITER_STA", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_ARBITER_STA bdk_tns_sde_mreb_arbiter_sta_t
#define bustype_BDK_TNS_SDE_MREB_ARBITER_STA BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_ARBITER_STA "TNS_SDE_MREB_ARBITER_STA"
#define device_bar_BDK_TNS_SDE_MREB_ARBITER_STA 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_ARBITER_STA 0
#define arguments_BDK_TNS_SDE_MREB_ARBITER_STA -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_copies_ct
 *
 * TNS SDE MRE Bottom Copies Count Register
 * --
 */
union bdk_tns_sde_mreb_copies_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_copies_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of copies not suppressed by MRE. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of copies not suppressed by MRE. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_copies_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_copies_ct bdk_tns_sde_mreb_copies_ct_t;

#define BDK_TNS_SDE_MREB_COPIES_CT BDK_TNS_SDE_MREB_COPIES_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_COPIES_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_COPIES_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804d8ll;
    __bdk_csr_fatal("TNS_SDE_MREB_COPIES_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_COPIES_CT bdk_tns_sde_mreb_copies_ct_t
#define bustype_BDK_TNS_SDE_MREB_COPIES_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_COPIES_CT "TNS_SDE_MREB_COPIES_CT"
#define device_bar_BDK_TNS_SDE_MREB_COPIES_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_COPIES_CT 0
#define arguments_BDK_TNS_SDE_MREB_COPIES_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_drp_ct
 *
 * TNS SDE MRE Bottom Drop Count Register
 * --
 */
union bdk_tns_sde_mreb_drp_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_drp_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of copies issued but marked as 'drop' by MRE. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of copies issued but marked as 'drop' by MRE. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_drp_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_drp_ct bdk_tns_sde_mreb_drp_ct_t;

#define BDK_TNS_SDE_MREB_DRP_CT BDK_TNS_SDE_MREB_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_DRP_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804dcll;
    __bdk_csr_fatal("TNS_SDE_MREB_DRP_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_DRP_CT bdk_tns_sde_mreb_drp_ct_t
#define bustype_BDK_TNS_SDE_MREB_DRP_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_DRP_CT "TNS_SDE_MREB_DRP_CT"
#define device_bar_BDK_TNS_SDE_MREB_DRP_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_DRP_CT 0
#define arguments_BDK_TNS_SDE_MREB_DRP_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_feedback_ct
 *
 * TNS SDE MRE Bottom Feedback Count Register
 * --
 */
union bdk_tns_sde_mreb_feedback_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_feedback_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of times a response from SE caused another request to be issued. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of times a response from SE caused another request to be issued. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_feedback_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_feedback_ct bdk_tns_sde_mreb_feedback_ct_t;

#define BDK_TNS_SDE_MREB_FEEDBACK_CT BDK_TNS_SDE_MREB_FEEDBACK_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_FEEDBACK_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_FEEDBACK_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804e0ll;
    __bdk_csr_fatal("TNS_SDE_MREB_FEEDBACK_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_FEEDBACK_CT bdk_tns_sde_mreb_feedback_ct_t
#define bustype_BDK_TNS_SDE_MREB_FEEDBACK_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_FEEDBACK_CT "TNS_SDE_MREB_FEEDBACK_CT"
#define device_bar_BDK_TNS_SDE_MREB_FEEDBACK_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_FEEDBACK_CT 0
#define arguments_BDK_TNS_SDE_MREB_FEEDBACK_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_filter_cfg
 *
 * TNS SDE MRE Bottom Filter Configuration Register
 * Configures the Filter feature. The filter feature may select any contiguous 3
 * bytes from the Scratchpad, or the IVif. The selcted data is masked
 * (based on this register) and matched against a 24 bit field in the MDT
 * table.
 */
union bdk_tns_sde_mreb_filter_cfg
{
    uint32_t u;
    struct bdk_tns_sde_mreb_filter_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t mask                  : 24; /**< [ 26:  3](R/W) Mask to apply to the data */
        uint32_t sel                   : 3;  /**< [  2:  0](R/W) '"Selects the field in the token to use: \n
                                                                 0 - scratchpad bytes 2, 1, 0 \n
                                                                 1 - scratchpad bytes 3, 2, 1 \n
                                                                 2 - scratchpad bytes 4, 3, 2 \n
                                                                 3 - scratchpad bytes 5, 4, 3 \n
                                                                 4 - scratchpad bytes 6, 5, 4 \n
                                                                 5 - scratchpad bytes 7, 6, 5 \n
                                                                 6 - reserved \n
                                                                 7 - IVIF' */
#else /* Word 0 - Little Endian */
        uint32_t sel                   : 3;  /**< [  2:  0](R/W) '"Selects the field in the token to use: \n
                                                                 0 - scratchpad bytes 2, 1, 0 \n
                                                                 1 - scratchpad bytes 3, 2, 1 \n
                                                                 2 - scratchpad bytes 4, 3, 2 \n
                                                                 3 - scratchpad bytes 5, 4, 3 \n
                                                                 4 - scratchpad bytes 6, 5, 4 \n
                                                                 5 - scratchpad bytes 7, 6, 5 \n
                                                                 6 - reserved \n
                                                                 7 - IVIF' */
        uint32_t mask                  : 24; /**< [ 26:  3](R/W) Mask to apply to the data */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_filter_cfg_s cn; */
};
typedef union bdk_tns_sde_mreb_filter_cfg bdk_tns_sde_mreb_filter_cfg_t;

#define BDK_TNS_SDE_MREB_FILTER_CFG BDK_TNS_SDE_MREB_FILTER_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_FILTER_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_FILTER_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780400ll;
    __bdk_csr_fatal("TNS_SDE_MREB_FILTER_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_FILTER_CFG bdk_tns_sde_mreb_filter_cfg_t
#define bustype_BDK_TNS_SDE_MREB_FILTER_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_FILTER_CFG "TNS_SDE_MREB_FILTER_CFG"
#define device_bar_BDK_TNS_SDE_MREB_FILTER_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_FILTER_CFG 0
#define arguments_BDK_TNS_SDE_MREB_FILTER_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_hbuf_cyc_ct
 *
 * TNS SDE MRE Bottom Header Buffer Cycle Count Register
 * --
 */
union bdk_tns_sde_mreb_hbuf_cyc_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_hbuf_cyc_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of cycles written to header buffer. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of cycles written to header buffer. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_hbuf_cyc_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_hbuf_cyc_ct bdk_tns_sde_mreb_hbuf_cyc_ct_t;

#define BDK_TNS_SDE_MREB_HBUF_CYC_CT BDK_TNS_SDE_MREB_HBUF_CYC_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_CYC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_CYC_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804e4ll;
    __bdk_csr_fatal("TNS_SDE_MREB_HBUF_CYC_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_HBUF_CYC_CT bdk_tns_sde_mreb_hbuf_cyc_ct_t
#define bustype_BDK_TNS_SDE_MREB_HBUF_CYC_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_HBUF_CYC_CT "TNS_SDE_MREB_HBUF_CYC_CT"
#define device_bar_BDK_TNS_SDE_MREB_HBUF_CYC_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_HBUF_CYC_CT 0
#define arguments_BDK_TNS_SDE_MREB_HBUF_CYC_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_hbuf_pkt_ct
 *
 * TNS SDE MRE Bottom Header Buffer Packet Count Register
 * --
 */
union bdk_tns_sde_mreb_hbuf_pkt_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_hbuf_pkt_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of packets written to header buffer. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of packets written to header buffer. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_hbuf_pkt_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_hbuf_pkt_ct bdk_tns_sde_mreb_hbuf_pkt_ct_t;

#define BDK_TNS_SDE_MREB_HBUF_PKT_CT BDK_TNS_SDE_MREB_HBUF_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_PKT_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804e8ll;
    __bdk_csr_fatal("TNS_SDE_MREB_HBUF_PKT_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_HBUF_PKT_CT bdk_tns_sde_mreb_hbuf_pkt_ct_t
#define bustype_BDK_TNS_SDE_MREB_HBUF_PKT_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_HBUF_PKT_CT "TNS_SDE_MREB_HBUF_PKT_CT"
#define device_bar_BDK_TNS_SDE_MREB_HBUF_PKT_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_HBUF_PKT_CT 0
#define arguments_BDK_TNS_SDE_MREB_HBUF_PKT_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_hmem_free_inst
 *
 * TNS SDE MRE Bottom Header Memory Free Instruction Register
 * --
 */
union bdk_tns_sde_mreb_hmem_free_inst
{
    uint32_t u;
    struct bdk_tns_sde_mreb_hmem_free_inst_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of operations issued instructing the hdr memory to return the page to
                                                                 the free pool. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of operations issued instructing the hdr memory to return the page to
                                                                 the free pool. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_hmem_free_inst_s cn; */
};
typedef union bdk_tns_sde_mreb_hmem_free_inst bdk_tns_sde_mreb_hmem_free_inst_t;

#define BDK_TNS_SDE_MREB_HMEM_FREE_INST BDK_TNS_SDE_MREB_HMEM_FREE_INST_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_HMEM_FREE_INST_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_HMEM_FREE_INST_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804ecll;
    __bdk_csr_fatal("TNS_SDE_MREB_HMEM_FREE_INST", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_HMEM_FREE_INST bdk_tns_sde_mreb_hmem_free_inst_t
#define bustype_BDK_TNS_SDE_MREB_HMEM_FREE_INST BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_HMEM_FREE_INST "TNS_SDE_MREB_HMEM_FREE_INST"
#define device_bar_BDK_TNS_SDE_MREB_HMEM_FREE_INST 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_HMEM_FREE_INST 0
#define arguments_BDK_TNS_SDE_MREB_HMEM_FREE_INST -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_lock
 *
 * TNS SDE MRE Bottom Lock Register
 * Lock Register
 */
union bdk_tns_sde_mreb_lock
{
    uint32_t u;
    struct bdk_tns_sde_mreb_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_lock_s cn; */
};
typedef union bdk_tns_sde_mreb_lock bdk_tns_sde_mreb_lock_t;

#define BDK_TNS_SDE_MREB_LOCK BDK_TNS_SDE_MREB_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804f4ll;
    __bdk_csr_fatal("TNS_SDE_MREB_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_LOCK bdk_tns_sde_mreb_lock_t
#define bustype_BDK_TNS_SDE_MREB_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_LOCK "TNS_SDE_MREB_LOCK"
#define device_bar_BDK_TNS_SDE_MREB_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_LOCK 0
#define arguments_BDK_TNS_SDE_MREB_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_pipegrid_ct
 *
 * TNS SDE MRE Bottom PipeGrid Count Register
 * --
 */
union bdk_tns_sde_mreb_pipegrid_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_pipegrid_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of tokens sent to pipegrid. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of tokens sent to pipegrid. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_pipegrid_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_pipegrid_ct bdk_tns_sde_mreb_pipegrid_ct_t;

#define BDK_TNS_SDE_MREB_PIPEGRID_CT BDK_TNS_SDE_MREB_PIPEGRID_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_PIPEGRID_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_PIPEGRID_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804f0ll;
    __bdk_csr_fatal("TNS_SDE_MREB_PIPEGRID_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_PIPEGRID_CT bdk_tns_sde_mreb_pipegrid_ct_t
#define bustype_BDK_TNS_SDE_MREB_PIPEGRID_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_PIPEGRID_CT "TNS_SDE_MREB_PIPEGRID_CT"
#define device_bar_BDK_TNS_SDE_MREB_PIPEGRID_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_PIPEGRID_CT 0
#define arguments_BDK_TNS_SDE_MREB_PIPEGRID_CT -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mreb_rcv
 *
 * TNS SDE MRE Bottom Receive Store Data Register
 * Valid vector for each of the two receive stores. The receive store contains the
 * data returned from
 * SE requests.
 */
union bdk_tns_sde_mreb_rcv
{
    uint64_t u;
    struct bdk_tns_sde_mreb_rcv_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t store_0_vld           : 32; /**< [ 63: 32](RO/H) -- */
        uint64_t store_1_vld           : 32; /**< [ 31:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t store_1_vld           : 32; /**< [ 31:  0](RO/H) -- */
        uint64_t store_0_vld           : 32; /**< [ 63: 32](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_rcv_s cn; */
};
typedef union bdk_tns_sde_mreb_rcv bdk_tns_sde_mreb_rcv_t;

#define BDK_TNS_SDE_MREB_RCV BDK_TNS_SDE_MREB_RCV_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_RCV_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_RCV_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804b0ll;
    __bdk_csr_fatal("TNS_SDE_MREB_RCV", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_RCV bdk_tns_sde_mreb_rcv_t
#define bustype_BDK_TNS_SDE_MREB_RCV BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MREB_RCV "TNS_SDE_MREB_RCV"
#define device_bar_BDK_TNS_SDE_MREB_RCV 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_RCV 0
#define arguments_BDK_TNS_SDE_MREB_RCV -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_req
 *
 * TNS SDE MRE Bottom Request Register
 * Current value of the req counter. Counts outstanding requests to SE MRE is
 * waiting for.
 */
union bdk_tns_sde_mreb_req
{
    uint32_t u;
    struct bdk_tns_sde_mreb_req_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t counter               : 8;  /**< [  7:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t counter               : 8;  /**< [  7:  0](RO/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_req_s cn; */
};
typedef union bdk_tns_sde_mreb_req bdk_tns_sde_mreb_req_t;

#define BDK_TNS_SDE_MREB_REQ BDK_TNS_SDE_MREB_REQ_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_REQ_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_REQ_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804b8ll;
    __bdk_csr_fatal("TNS_SDE_MREB_REQ", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_REQ bdk_tns_sde_mreb_req_t
#define bustype_BDK_TNS_SDE_MREB_REQ BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_REQ "TNS_SDE_MREB_REQ"
#define device_bar_BDK_TNS_SDE_MREB_REQ 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_REQ 0
#define arguments_BDK_TNS_SDE_MREB_REQ -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_se_req_ct
 *
 * TNS SDE MRE Bottom Search Request Count Register
 * --
 */
union bdk_tns_sde_mreb_se_req_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_se_req_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of requests issued to SE. (At input of DFC module). */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of requests issued to SE. (At input of DFC module). */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_se_req_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_se_req_ct bdk_tns_sde_mreb_se_req_ct_t;

#define BDK_TNS_SDE_MREB_SE_REQ_CT BDK_TNS_SDE_MREB_SE_REQ_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SE_REQ_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SE_REQ_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804c8ll;
    __bdk_csr_fatal("TNS_SDE_MREB_SE_REQ_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_SE_REQ_CT bdk_tns_sde_mreb_se_req_ct_t
#define bustype_BDK_TNS_SDE_MREB_SE_REQ_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_SE_REQ_CT "TNS_SDE_MREB_SE_REQ_CT"
#define device_bar_BDK_TNS_SDE_MREB_SE_REQ_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_SE_REQ_CT 0
#define arguments_BDK_TNS_SDE_MREB_SE_REQ_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_se_resp0_ct
 *
 * TNS SDE MRE Bottom Search Response 0 Count Register
 * --
 */
union bdk_tns_sde_mreb_se_resp0_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_se_resp0_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of responses received from SE on lane 0. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of responses received from SE on lane 0. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_se_resp0_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_se_resp0_ct bdk_tns_sde_mreb_se_resp0_ct_t;

#define BDK_TNS_SDE_MREB_SE_RESP0_CT BDK_TNS_SDE_MREB_SE_RESP0_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP0_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP0_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804ccll;
    __bdk_csr_fatal("TNS_SDE_MREB_SE_RESP0_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_SE_RESP0_CT bdk_tns_sde_mreb_se_resp0_ct_t
#define bustype_BDK_TNS_SDE_MREB_SE_RESP0_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_SE_RESP0_CT "TNS_SDE_MREB_SE_RESP0_CT"
#define device_bar_BDK_TNS_SDE_MREB_SE_RESP0_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_SE_RESP0_CT 0
#define arguments_BDK_TNS_SDE_MREB_SE_RESP0_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_se_resp1_ct
 *
 * TNS SDE MRE Bottom Search Response 1 Count Register
 * --
 */
union bdk_tns_sde_mreb_se_resp1_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_se_resp1_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of responses received from SE on lane 1. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of responses received from SE on lane 1. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_se_resp1_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_se_resp1_ct bdk_tns_sde_mreb_se_resp1_ct_t;

#define BDK_TNS_SDE_MREB_SE_RESP1_CT BDK_TNS_SDE_MREB_SE_RESP1_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP1_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP1_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804d0ll;
    __bdk_csr_fatal("TNS_SDE_MREB_SE_RESP1_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_SE_RESP1_CT bdk_tns_sde_mreb_se_resp1_ct_t
#define bustype_BDK_TNS_SDE_MREB_SE_RESP1_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_SE_RESP1_CT "TNS_SDE_MREB_SE_RESP1_CT"
#define device_bar_BDK_TNS_SDE_MREB_SE_RESP1_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_SE_RESP1_CT 0
#define arguments_BDK_TNS_SDE_MREB_SE_RESP1_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_spad
 *
 * TNS SDE MRE Bottom ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_mreb_spad
{
    uint32_t u;
    struct bdk_tns_sde_mreb_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_spad_s cn; */
};
typedef union bdk_tns_sde_mreb_spad bdk_tns_sde_mreb_spad_t;

#define BDK_TNS_SDE_MREB_SPAD BDK_TNS_SDE_MREB_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804f8ll;
    __bdk_csr_fatal("TNS_SDE_MREB_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_SPAD bdk_tns_sde_mreb_spad_t
#define bustype_BDK_TNS_SDE_MREB_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_SPAD "TNS_SDE_MREB_SPAD"
#define device_bar_BDK_TNS_SDE_MREB_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_SPAD 0
#define arguments_BDK_TNS_SDE_MREB_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_sprsd_ct
 *
 * TNS SDE MRE Bottom Suppressed Count Register
 * --
 */
union bdk_tns_sde_mreb_sprsd_ct
{
    uint32_t u;
    struct bdk_tns_sde_mreb_sprsd_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of copies suppressed by MRE. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of copies suppressed by MRE. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_sprsd_ct_s cn; */
};
typedef union bdk_tns_sde_mreb_sprsd_ct bdk_tns_sde_mreb_sprsd_ct_t;

#define BDK_TNS_SDE_MREB_SPRSD_CT BDK_TNS_SDE_MREB_SPRSD_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SPRSD_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SPRSD_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804d4ll;
    __bdk_csr_fatal("TNS_SDE_MREB_SPRSD_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_SPRSD_CT bdk_tns_sde_mreb_sprsd_ct_t
#define bustype_BDK_TNS_SDE_MREB_SPRSD_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_SPRSD_CT "TNS_SDE_MREB_SPRSD_CT"
#define device_bar_BDK_TNS_SDE_MREB_SPRSD_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_SPRSD_CT 0
#define arguments_BDK_TNS_SDE_MREB_SPRSD_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_tkn_mem_adr
 *
 * TNS SDE MRE Bottom Token Memory Address Register
 * --
 */
union bdk_tns_sde_mreb_tkn_mem_adr
{
    uint32_t u;
    struct bdk_tns_sde_mreb_tkn_mem_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t page                  : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t page                  : 7;  /**< [  6:  0](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_tkn_mem_adr_s cn; */
};
typedef union bdk_tns_sde_mreb_tkn_mem_adr bdk_tns_sde_mreb_tkn_mem_adr_t;

#define BDK_TNS_SDE_MREB_TKN_MEM_ADR BDK_TNS_SDE_MREB_TKN_MEM_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780408ll;
    __bdk_csr_fatal("TNS_SDE_MREB_TKN_MEM_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_TKN_MEM_ADR bdk_tns_sde_mreb_tkn_mem_adr_t
#define bustype_BDK_TNS_SDE_MREB_TKN_MEM_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_TKN_MEM_ADR "TNS_SDE_MREB_TKN_MEM_ADR"
#define device_bar_BDK_TNS_SDE_MREB_TKN_MEM_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_TKN_MEM_ADR 0
#define arguments_BDK_TNS_SDE_MREB_TKN_MEM_ADR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_tkn_mem_dat_w#
 *
 * TNS SDE MRE Bottom Token Memory Data Registers
 * Bits 31..20 of registers ending in _W40 are unused.
 */
union bdk_tns_sde_mreb_tkn_mem_dat_wx
{
    uint32_t u;
    struct bdk_tns_sde_mreb_tkn_mem_dat_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_data            : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t token_data            : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_tkn_mem_dat_wx_s cn; */
};
typedef union bdk_tns_sde_mreb_tkn_mem_dat_wx bdk_tns_sde_mreb_tkn_mem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=40))
        return 0x84206078040cll + 4ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SDE_MREB_TKN_MEM_DAT_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(a) bdk_tns_sde_mreb_tkn_mem_dat_wx_t
#define bustype_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(a) "TNS_SDE_MREB_TKN_MEM_DAT_WX"
#define device_bar_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(a) (a)
#define arguments_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mreb_tkn_mem_ecc_err
 *
 * TNS SDE MRE Bottom Token Memory ECC Error Register
 * --
 */
union bdk_tns_sde_mreb_tkn_mem_ecc_err
{
    uint32_t u;
    struct bdk_tns_sde_mreb_tkn_mem_ecc_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t log                   : 28; /**< [ 27:  0](R/W/H) Data logged is defined as {captured, token_mem_db_err[9:0],
                                                                 token_mem_sb_err[9:0], token_mem_rd_addr_d[6:0]} */
#else /* Word 0 - Little Endian */
        uint32_t log                   : 28; /**< [ 27:  0](R/W/H) Data logged is defined as {captured, token_mem_db_err[9:0],
                                                                 token_mem_sb_err[9:0], token_mem_rd_addr_d[6:0]} */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mreb_tkn_mem_ecc_err_s cn; */
};
typedef union bdk_tns_sde_mreb_tkn_mem_ecc_err bdk_tns_sde_mreb_tkn_mem_ecc_err_t;

#define BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607804bcll;
    __bdk_csr_fatal("TNS_SDE_MREB_TKN_MEM_ECC_ERR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR bdk_tns_sde_mreb_tkn_mem_ecc_err_t
#define bustype_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR "TNS_SDE_MREB_TKN_MEM_ECC_ERR"
#define device_bar_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR 0
#define arguments_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_arbiter_cfg_w0
 *
 * TNS SDE MRE Top Arbiter Configuration Word 0 Register
 * Controls the behaviour of the arbiter in the MRE.
 */
union bdk_tns_sde_mret_arbiter_cfg_w0
{
    uint32_t u;
    struct bdk_tns_sde_mret_arbiter_cfg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wrr_weight2           : 8;  /**< [ 31: 24](R/W) Weight to be used for priority 1, if part of the WRR arbitration */
        uint32_t wrr_weight1           : 12; /**< [ 23: 12](R/W) Weight to be used for priority 2, if part of the WRR arbitration */
        uint32_t wrr_weight0           : 12; /**< [ 11:  0](R/W) Weight to be used for priority 3, if part of the WRR arbitration */
#else /* Word 0 - Little Endian */
        uint32_t wrr_weight0           : 12; /**< [ 11:  0](R/W) Weight to be used for priority 3, if part of the WRR arbitration */
        uint32_t wrr_weight1           : 12; /**< [ 23: 12](R/W) Weight to be used for priority 2, if part of the WRR arbitration */
        uint32_t wrr_weight2           : 8;  /**< [ 31: 24](R/W) Weight to be used for priority 1, if part of the WRR arbitration */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_arbiter_cfg_w0_s cn; */
};
typedef union bdk_tns_sde_mret_arbiter_cfg_w0 bdk_tns_sde_mret_arbiter_cfg_w0_t;

#define BDK_TNS_SDE_MRET_ARBITER_CFG_W0 BDK_TNS_SDE_MRET_ARBITER_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780034ll;
    __bdk_csr_fatal("TNS_SDE_MRET_ARBITER_CFG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 bdk_tns_sde_mret_arbiter_cfg_w0_t
#define bustype_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 "TNS_SDE_MRET_ARBITER_CFG_W0"
#define device_bar_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 0
#define arguments_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_arbiter_cfg_w1
 *
 * TNS SDE MRE Top Arbiter Configuration Word 1 Register
 * Continuation of structure defined in TNS_SDE_MRET_ARBITER_CFG_W0
 */
union bdk_tns_sde_mret_arbiter_cfg_w1
{
    uint32_t u;
    struct bdk_tns_sde_mret_arbiter_cfg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t wrr_bypass            : 4;  /**< [ 19: 16](R/W) Indicates which priorities should bypass the WRR portion of the arbiter and
                                                                 directly pass on to the strict priority arbiter. */
        uint32_t wrr_weight3           : 12; /**< [ 15:  4](R/W) Weight to be used for priority 0, if part of the WRR arbitration */
        uint32_t wrr_weight2           : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field WRR_WEIGHT2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t wrr_weight2           : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field WRR_WEIGHT2 from previous word. */
        uint32_t wrr_weight3           : 12; /**< [ 15:  4](R/W) Weight to be used for priority 0, if part of the WRR arbitration */
        uint32_t wrr_bypass            : 4;  /**< [ 19: 16](R/W) Indicates which priorities should bypass the WRR portion of the arbiter and
                                                                 directly pass on to the strict priority arbiter. */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_arbiter_cfg_w1_s cn; */
};
typedef union bdk_tns_sde_mret_arbiter_cfg_w1 bdk_tns_sde_mret_arbiter_cfg_w1_t;

#define BDK_TNS_SDE_MRET_ARBITER_CFG_W1 BDK_TNS_SDE_MRET_ARBITER_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780038ll;
    __bdk_csr_fatal("TNS_SDE_MRET_ARBITER_CFG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 bdk_tns_sde_mret_arbiter_cfg_w1_t
#define bustype_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 "TNS_SDE_MRET_ARBITER_CFG_W1"
#define device_bar_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 0
#define arguments_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_cfg2
 *
 * TNS SDE MRE Top Configuration2 Register
 * --
 */
union bdk_tns_sde_mret_cfg2
{
    uint64_t u;
    struct bdk_tns_sde_mret_cfg2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_42_63        : 22;
        uint64_t page_fifo_prio3_flip_sb_ecc : 1;/**< [ 41: 41](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio3_flip_db_ecc : 1;/**< [ 40: 40](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio2_flip_sb_ecc : 1;/**< [ 39: 39](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio2_flip_db_ecc : 1;/**< [ 38: 38](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio1_flip_sb_ecc : 1;/**< [ 37: 37](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio1_flip_db_ecc : 1;/**< [ 36: 36](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio0_flip_sb_ecc : 1;/**< [ 35: 35](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio0_flip_db_ecc : 1;/**< [ 34: 34](R/W) Force dual bit ecc error. */
        uint64_t token_mem_bank_flip_sb_ecc : 10;/**< [ 33: 24](R/W) Force single bit ecc error. */
        uint64_t token_mem_bank_flip_db_ecc : 10;/**< [ 23: 14](R/W) Force dual bit ecc error. */
        uint64_t freelist_flip_sb_ecc  : 1;  /**< [ 13: 13](R/W) Force single bit ecc error. */
        uint64_t freelist_flip_db_ecc  : 1;  /**< [ 12: 12](R/W) Force dual bit ecc error. */
        uint64_t hdr_mem_flip_sb_ecc   : 4;  /**< [ 11:  8](R/W) Force single bit ecc error. */
        uint64_t hdr_mem_flip_db_ecc   : 4;  /**< [  7:  4](R/W) Force dual bit ecc error. */
        uint64_t cntx_mem_flip_sb_ecc  : 2;  /**< [  3:  2](R/W) Force single bit ecc error. */
        uint64_t cntx_mem_flip_db_ecc  : 2;  /**< [  1:  0](R/W) Force dual bit ecc error. */
#else /* Word 0 - Little Endian */
        uint64_t cntx_mem_flip_db_ecc  : 2;  /**< [  1:  0](R/W) Force dual bit ecc error. */
        uint64_t cntx_mem_flip_sb_ecc  : 2;  /**< [  3:  2](R/W) Force single bit ecc error. */
        uint64_t hdr_mem_flip_db_ecc   : 4;  /**< [  7:  4](R/W) Force dual bit ecc error. */
        uint64_t hdr_mem_flip_sb_ecc   : 4;  /**< [ 11:  8](R/W) Force single bit ecc error. */
        uint64_t freelist_flip_db_ecc  : 1;  /**< [ 12: 12](R/W) Force dual bit ecc error. */
        uint64_t freelist_flip_sb_ecc  : 1;  /**< [ 13: 13](R/W) Force single bit ecc error. */
        uint64_t token_mem_bank_flip_db_ecc : 10;/**< [ 23: 14](R/W) Force dual bit ecc error. */
        uint64_t token_mem_bank_flip_sb_ecc : 10;/**< [ 33: 24](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio0_flip_db_ecc : 1;/**< [ 34: 34](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio0_flip_sb_ecc : 1;/**< [ 35: 35](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio1_flip_db_ecc : 1;/**< [ 36: 36](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio1_flip_sb_ecc : 1;/**< [ 37: 37](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio2_flip_db_ecc : 1;/**< [ 38: 38](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio2_flip_sb_ecc : 1;/**< [ 39: 39](R/W) Force single bit ecc error. */
        uint64_t page_fifo_prio3_flip_db_ecc : 1;/**< [ 40: 40](R/W) Force dual bit ecc error. */
        uint64_t page_fifo_prio3_flip_sb_ecc : 1;/**< [ 41: 41](R/W) Force single bit ecc error. */
        uint64_t reserved_42_63        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_cfg2_s cn; */
};
typedef union bdk_tns_sde_mret_cfg2 bdk_tns_sde_mret_cfg2_t;

#define BDK_TNS_SDE_MRET_CFG2 BDK_TNS_SDE_MRET_CFG2_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780020ll;
    __bdk_csr_fatal("TNS_SDE_MRET_CFG2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CFG2 bdk_tns_sde_mret_cfg2_t
#define bustype_BDK_TNS_SDE_MRET_CFG2 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_CFG2 "TNS_SDE_MRET_CFG2"
#define device_bar_BDK_TNS_SDE_MRET_CFG2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CFG2 0
#define arguments_BDK_TNS_SDE_MRET_CFG2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_cfg_null_ptr
 *
 * TNS SDE MRE Top Configuration NULL Pointer Register
 * --
 */
union bdk_tns_sde_mret_cfg_null_ptr
{
    uint32_t u;
    struct bdk_tns_sde_mret_cfg_null_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t value                 : 18; /**< [ 17:  0](R/W) Value to be used as NULL pointer in the MDT table. */
#else /* Word 0 - Little Endian */
        uint32_t value                 : 18; /**< [ 17:  0](R/W) Value to be used as NULL pointer in the MDT table. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_cfg_null_ptr_s cn; */
};
typedef union bdk_tns_sde_mret_cfg_null_ptr bdk_tns_sde_mret_cfg_null_ptr_t;

#define BDK_TNS_SDE_MRET_CFG_NULL_PTR BDK_TNS_SDE_MRET_CFG_NULL_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_NULL_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_NULL_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780008ll;
    __bdk_csr_fatal("TNS_SDE_MRET_CFG_NULL_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CFG_NULL_PTR bdk_tns_sde_mret_cfg_null_ptr_t
#define bustype_BDK_TNS_SDE_MRET_CFG_NULL_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_CFG_NULL_PTR "TNS_SDE_MRET_CFG_NULL_PTR"
#define device_bar_BDK_TNS_SDE_MRET_CFG_NULL_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CFG_NULL_PTR 0
#define arguments_BDK_TNS_SDE_MRET_CFG_NULL_PTR -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_cfg_rcod
 *
 * TNS SDE MRE Top Configuration Reason Code Register
 * Stores the reason code used for various conditions for which the MRE would send
 * out a token with packet command = DROP.
 */
union bdk_tns_sde_mret_cfg_rcod
{
    uint64_t u;
    struct bdk_tns_sde_mret_cfg_rcod_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t ttl_fail              : 10; /**< [ 39: 30](R/W) The tokens internal TTL expired, and this copy was not entirely suppressed. */
        uint64_t first_live_fail       : 10; /**< [ 29: 20](R/W) The node in the tree was first_live entry and the first live check did not
                                                                 pass. */
        uint64_t mirror_fail           : 10; /**< [ 19: 10](R/W) The node in the tree was a mirror entry and the mirror check did not pass. */
        uint64_t filter                : 10; /**< [  9:  0](R/W) The token was filtered using the filter feature. */
#else /* Word 0 - Little Endian */
        uint64_t filter                : 10; /**< [  9:  0](R/W) The token was filtered using the filter feature. */
        uint64_t mirror_fail           : 10; /**< [ 19: 10](R/W) The node in the tree was a mirror entry and the mirror check did not pass. */
        uint64_t first_live_fail       : 10; /**< [ 29: 20](R/W) The node in the tree was first_live entry and the first live check did not
                                                                 pass. */
        uint64_t ttl_fail              : 10; /**< [ 39: 30](R/W) The tokens internal TTL expired, and this copy was not entirely suppressed. */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_cfg_rcod_s cn; */
};
typedef union bdk_tns_sde_mret_cfg_rcod bdk_tns_sde_mret_cfg_rcod_t;

#define BDK_TNS_SDE_MRET_CFG_RCOD BDK_TNS_SDE_MRET_CFG_RCOD_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_RCOD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_RCOD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780018ll;
    __bdk_csr_fatal("TNS_SDE_MRET_CFG_RCOD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CFG_RCOD bdk_tns_sde_mret_cfg_rcod_t
#define bustype_BDK_TNS_SDE_MRET_CFG_RCOD BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_CFG_RCOD "TNS_SDE_MRET_CFG_RCOD"
#define device_bar_BDK_TNS_SDE_MRET_CFG_RCOD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CFG_RCOD 0
#define arguments_BDK_TNS_SDE_MRET_CFG_RCOD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_cfg_w0
 *
 * TNS SDE MRE Top Configuration Word 0 Register
 * General Config for MRE
 */
union bdk_tns_sde_mret_cfg_w0
{
    uint32_t u;
    struct bdk_tns_sde_mret_cfg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pkt_cmd_for_drop      : 2;  /**< [ 31: 30](R/W) Packet Command value be used when MRE decides to suppress the copy */
        uint32_t mre_en                : 1;  /**< [ 29: 29](R/W) -- */
        uint32_t memwr_cntrl_fl_init   : 1;  /**< [ 28: 28](R/W) A transition from 0 to 1 on each of these signals
                                                                 triggers the freelist initialization of the corresponding
                                                                 MemWrCntrl module. */
        uint32_t hdr_mem_read_req_thr  : 4;  /**< [ 27: 24](R/W) Number of outstanding requests issued to the header memory.
                                                                 Should be set equal to the read latency to the memory. */
        uint32_t mre_output_shp_timebase : 8;/**< [ 23: 16](R/W) -- */
        uint32_t mre_output_shp_allowed : 8; /**< [ 15:  8](R/W) MRE will be allowed a maximum number of mre_output_shaper_allowed Tokens
                                                                 to be injected into the PipeGrid, every mre_output_shaper_timebase
                                                                 clock cycles. */
        uint32_t freelist_usage_threshold : 8;/**< [  7:  0](R/W) Usage threshold for the freelist. When the level of entries in the freelist
                                                                 drops below this level,
                                                                 FC will be asserted for all priorities in the channel. */
#else /* Word 0 - Little Endian */
        uint32_t freelist_usage_threshold : 8;/**< [  7:  0](R/W) Usage threshold for the freelist. When the level of entries in the freelist
                                                                 drops below this level,
                                                                 FC will be asserted for all priorities in the channel. */
        uint32_t mre_output_shp_allowed : 8; /**< [ 15:  8](R/W) MRE will be allowed a maximum number of mre_output_shaper_allowed Tokens
                                                                 to be injected into the PipeGrid, every mre_output_shaper_timebase
                                                                 clock cycles. */
        uint32_t mre_output_shp_timebase : 8;/**< [ 23: 16](R/W) -- */
        uint32_t hdr_mem_read_req_thr  : 4;  /**< [ 27: 24](R/W) Number of outstanding requests issued to the header memory.
                                                                 Should be set equal to the read latency to the memory. */
        uint32_t memwr_cntrl_fl_init   : 1;  /**< [ 28: 28](R/W) A transition from 0 to 1 on each of these signals
                                                                 triggers the freelist initialization of the corresponding
                                                                 MemWrCntrl module. */
        uint32_t mre_en                : 1;  /**< [ 29: 29](R/W) -- */
        uint32_t pkt_cmd_for_drop      : 2;  /**< [ 31: 30](R/W) Packet Command value be used when MRE decides to suppress the copy */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_cfg_w0_s cn; */
};
typedef union bdk_tns_sde_mret_cfg_w0 bdk_tns_sde_mret_cfg_w0_t;

#define BDK_TNS_SDE_MRET_CFG_W0 BDK_TNS_SDE_MRET_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078000cll;
    __bdk_csr_fatal("TNS_SDE_MRET_CFG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CFG_W0 bdk_tns_sde_mret_cfg_w0_t
#define bustype_BDK_TNS_SDE_MRET_CFG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_CFG_W0 "TNS_SDE_MRET_CFG_W0"
#define device_bar_BDK_TNS_SDE_MRET_CFG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CFG_W0 0
#define arguments_BDK_TNS_SDE_MRET_CFG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_cfg_w1
 *
 * TNS SDE MRE Top Configuration Word 1 Register
 * Continuation of structure defined in TNS_SDE_MRET_CFG_W0
 */
union bdk_tns_sde_mret_cfg_w1
{
    uint32_t u;
    struct bdk_tns_sde_mret_cfg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t freecache_rst         : 4;  /**< [ 17: 14](R/W) Resets the cache of prefetched free entries received from HDBF. 1 bit per
                                                                 channel. */
        uint32_t suppress_en           : 1;  /**< [ 13: 13](R/W) If cleared, all packets that should be suppressed are dropped instead. */
        uint32_t nxt_engine_urw        : 8;  /**< [ 12:  5](R/W) Nxt_engine code for the URW module. This will be used for any packets dropped
                                                                 by MRE." */
        uint32_t hdbf_freepage_cache_thr : 4;/**< [  4:  1](R/W) Number of unused free entry requests queued by MRE */
        uint32_t freepage_return_en    : 1;  /**< [  0:  0](R/W) Enables returning entries to the freelist */
#else /* Word 0 - Little Endian */
        uint32_t freepage_return_en    : 1;  /**< [  0:  0](R/W) Enables returning entries to the freelist */
        uint32_t hdbf_freepage_cache_thr : 4;/**< [  4:  1](R/W) Number of unused free entry requests queued by MRE */
        uint32_t nxt_engine_urw        : 8;  /**< [ 12:  5](R/W) Nxt_engine code for the URW module. This will be used for any packets dropped
                                                                 by MRE." */
        uint32_t suppress_en           : 1;  /**< [ 13: 13](R/W) If cleared, all packets that should be suppressed are dropped instead. */
        uint32_t freecache_rst         : 4;  /**< [ 17: 14](R/W) Resets the cache of prefetched free entries received from HDBF. 1 bit per
                                                                 channel. */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_cfg_w1_s cn; */
};
typedef union bdk_tns_sde_mret_cfg_w1 bdk_tns_sde_mret_cfg_w1_t;

#define BDK_TNS_SDE_MRET_CFG_W1 BDK_TNS_SDE_MRET_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780010ll;
    __bdk_csr_fatal("TNS_SDE_MRET_CFG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CFG_W1 bdk_tns_sde_mret_cfg_w1_t
#define bustype_BDK_TNS_SDE_MRET_CFG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_CFG_W1 "TNS_SDE_MRET_CFG_W1"
#define device_bar_BDK_TNS_SDE_MRET_CFG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CFG_W1 0
#define arguments_BDK_TNS_SDE_MRET_CFG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_ctx_mem_ecc_err
 *
 * TNS SDE MRE Top Contex Memory ECC Error Register
 * --
 */
union bdk_tns_sde_mret_ctx_mem_ecc_err
{
    uint32_t u;
    struct bdk_tns_sde_mret_ctx_mem_ecc_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t log                   : 12; /**< [ 11:  0](R/W/H) Data logged is defined as {captured, cntx_mem_db_err[1:0],
                                                                 cntx_mem_sb_err[1:0], cntx_mem_rd_addr_d[6:0]} */
#else /* Word 0 - Little Endian */
        uint32_t log                   : 12; /**< [ 11:  0](R/W/H) Data logged is defined as {captured, cntx_mem_db_err[1:0],
                                                                 cntx_mem_sb_err[1:0], cntx_mem_rd_addr_d[6:0]} */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_ctx_mem_ecc_err_s cn; */
};
typedef union bdk_tns_sde_mret_ctx_mem_ecc_err bdk_tns_sde_mret_ctx_mem_ecc_err_t;

#define BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800fcll;
    __bdk_csr_fatal("TNS_SDE_MRET_CTX_MEM_ECC_ERR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR bdk_tns_sde_mret_ctx_mem_ecc_err_t
#define bustype_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR "TNS_SDE_MRET_CTX_MEM_ECC_ERR"
#define device_bar_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR 0
#define arguments_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_ctxt_mem_adr
 *
 * TNS SDE MRE Top Contex Memory Address Register
 * --
 */
union bdk_tns_sde_mret_ctxt_mem_adr
{
    uint32_t u;
    struct bdk_tns_sde_mret_ctxt_mem_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t page                  : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t page                  : 7;  /**< [  6:  0](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_ctxt_mem_adr_s cn; */
};
typedef union bdk_tns_sde_mret_ctxt_mem_adr bdk_tns_sde_mret_ctxt_mem_adr_t;

#define BDK_TNS_SDE_MRET_CTXT_MEM_ADR BDK_TNS_SDE_MRET_CTXT_MEM_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078009cll;
    __bdk_csr_fatal("TNS_SDE_MRET_CTXT_MEM_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CTXT_MEM_ADR bdk_tns_sde_mret_ctxt_mem_adr_t
#define bustype_BDK_TNS_SDE_MRET_CTXT_MEM_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_CTXT_MEM_ADR "TNS_SDE_MRET_CTXT_MEM_ADR"
#define device_bar_BDK_TNS_SDE_MRET_CTXT_MEM_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CTXT_MEM_ADR 0
#define arguments_BDK_TNS_SDE_MRET_CTXT_MEM_ADR -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_ctxt_mem_dat_w#
 *
 * TNS SDE MRE Top Contex Memory Data Registers
 * Bits 63..40 of registers ending in _W2 are unused.
 */
union bdk_tns_sde_mret_ctxt_mem_dat_wx
{
    uint64_t u;
    struct bdk_tns_sde_mret_ctxt_mem_dat_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cntxt_mem_data        : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t cntxt_mem_data        : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_ctxt_mem_dat_wx_s cn; */
};
typedef union bdk_tns_sde_mret_ctxt_mem_dat_wx bdk_tns_sde_mret_ctxt_mem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2))
        return 0x8420607800a0ll + 8ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_MRET_CTXT_MEM_DAT_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(a) bdk_tns_sde_mret_ctxt_mem_dat_wx_t
#define bustype_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(a) "TNS_SDE_MRET_CTXT_MEM_DAT_WX"
#define device_bar_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(a) (a)
#define arguments_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_dbg_sel
 *
 * TNS SDE MRE Top Debug Selector Register
 * --
 */
union bdk_tns_sde_mret_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_mret_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_mret_dbg_sel bdk_tns_sde_mret_dbg_sel_t;

#define BDK_TNS_SDE_MRET_DBG_SEL BDK_TNS_SDE_MRET_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780004ll;
    __bdk_csr_fatal("TNS_SDE_MRET_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_DBG_SEL bdk_tns_sde_mret_dbg_sel_t
#define bustype_BDK_TNS_SDE_MRET_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_DBG_SEL "TNS_SDE_MRET_DBG_SEL"
#define device_bar_BDK_TNS_SDE_MRET_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_DBG_SEL 0
#define arguments_BDK_TNS_SDE_MRET_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_ecc_ctl_cd
 *
 * TNS SDE MRE Top ECC Control Disable Correction Register
 * If set each bit disables ECC correction for the corresponding memory.
 */
union bdk_tns_sde_mret_ecc_ctl_cd
{
    uint32_t u;
    struct bdk_tns_sde_mret_ecc_ctl_cd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t hdr_mem               : 1;  /**< [  7:  7](R/W) -- */
        uint32_t cntx_mem              : 1;  /**< [  6:  6](R/W) -- */
        uint32_t token_mem             : 1;  /**< [  5:  5](R/W) -- */
        uint32_t freelist              : 1;  /**< [  4:  4](R/W) -- */
        uint32_t page_fifo             : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t page_fifo             : 4;  /**< [  3:  0](R/W) -- */
        uint32_t freelist              : 1;  /**< [  4:  4](R/W) -- */
        uint32_t token_mem             : 1;  /**< [  5:  5](R/W) -- */
        uint32_t cntx_mem              : 1;  /**< [  6:  6](R/W) -- */
        uint32_t hdr_mem               : 1;  /**< [  7:  7](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_ecc_ctl_cd_s cn; */
};
typedef union bdk_tns_sde_mret_ecc_ctl_cd bdk_tns_sde_mret_ecc_ctl_cd_t;

#define BDK_TNS_SDE_MRET_ECC_CTL_CD BDK_TNS_SDE_MRET_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_ECC_CTL_CD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780014ll;
    __bdk_csr_fatal("TNS_SDE_MRET_ECC_CTL_CD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_ECC_CTL_CD bdk_tns_sde_mret_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_MRET_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_ECC_CTL_CD "TNS_SDE_MRET_ECC_CTL_CD"
#define device_bar_BDK_TNS_SDE_MRET_ECC_CTL_CD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_MRET_ECC_CTL_CD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_feature_en
 *
 * TNS SDE MRE Top Feature Enable Register
 * Allows enabling or disabling individual MRE features.
 */
union bdk_tns_sde_mret_feature_en
{
    uint32_t u;
    struct bdk_tns_sde_mret_feature_en_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t use_alt_evif          : 1;  /**< [  9:  9](R/W) When enabled token.common_static.sde_control.reserved_0[0] will be set to
                                                                 mdt_table_data.set_use_alt_evif */
        uint32_t l3_ptr                : 1;  /**< [  8:  8](R/W) When enabled a two-tier linked list structure is possible. When disabled the
                                                                 corresponding 18 bits in the MDT are reserved. */
        uint32_t last_entry            : 1;  /**< [  7:  7](R/W) Enables the last entry feature globally for MRE. If disabled, the corresponding
                                                                 bit in the MDT is reserved, and mre_last_copy
                                                                 will be set when the end of the tree has been reached. If enabled, the
                                                                 mre_last_copy bit is set from the the
                                                                 mdt_table.last_entry bit. */
        uint32_t first_live            : 1;  /**< [  6:  6](R/W) Enables the first Live feature globally for MRE. If disabled, the 2
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t mirror_filter         : 1;  /**< [  5:  5](R/W) Enables the mirror filter feature globally for MRE. If disabled, the 5
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t evif_mod              : 1;  /**< [  4:  4](R/W) Enables eVif modification globally for MRE. If disabled, the 21 corresponding
                                                                 bits in the MDT are reserved. */
        uint32_t nxt_engine            : 1;  /**< [  3:  3](R/W) Enables the nxt_engine in the MDT globally for MRE. If disabled, the 8
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t filter                : 1;  /**< [  2:  2](R/W) Enables the filter feature in the MDT globally for MRE. If disabled, the 25
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t ttl_check             : 1;  /**< [  1:  1](R/W) Enables the internal TTL check. */
        uint32_t ttl_dec               : 1;  /**< [  0:  0](R/W) Enables the internal TTL decrement. */
#else /* Word 0 - Little Endian */
        uint32_t ttl_dec               : 1;  /**< [  0:  0](R/W) Enables the internal TTL decrement. */
        uint32_t ttl_check             : 1;  /**< [  1:  1](R/W) Enables the internal TTL check. */
        uint32_t filter                : 1;  /**< [  2:  2](R/W) Enables the filter feature in the MDT globally for MRE. If disabled, the 25
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t nxt_engine            : 1;  /**< [  3:  3](R/W) Enables the nxt_engine in the MDT globally for MRE. If disabled, the 8
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t evif_mod              : 1;  /**< [  4:  4](R/W) Enables eVif modification globally for MRE. If disabled, the 21 corresponding
                                                                 bits in the MDT are reserved. */
        uint32_t mirror_filter         : 1;  /**< [  5:  5](R/W) Enables the mirror filter feature globally for MRE. If disabled, the 5
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t first_live            : 1;  /**< [  6:  6](R/W) Enables the first Live feature globally for MRE. If disabled, the 2
                                                                 corresponding bits in the MDT are reserved. */
        uint32_t last_entry            : 1;  /**< [  7:  7](R/W) Enables the last entry feature globally for MRE. If disabled, the corresponding
                                                                 bit in the MDT is reserved, and mre_last_copy
                                                                 will be set when the end of the tree has been reached. If enabled, the
                                                                 mre_last_copy bit is set from the the
                                                                 mdt_table.last_entry bit. */
        uint32_t l3_ptr                : 1;  /**< [  8:  8](R/W) When enabled a two-tier linked list structure is possible. When disabled the
                                                                 corresponding 18 bits in the MDT are reserved. */
        uint32_t use_alt_evif          : 1;  /**< [  9:  9](R/W) When enabled token.common_static.sde_control.reserved_0[0] will be set to
                                                                 mdt_table_data.set_use_alt_evif */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_feature_en_s cn; */
};
typedef union bdk_tns_sde_mret_feature_en bdk_tns_sde_mret_feature_en_t;

#define BDK_TNS_SDE_MRET_FEATURE_EN BDK_TNS_SDE_MRET_FEATURE_EN_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FEATURE_EN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FEATURE_EN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780028ll;
    __bdk_csr_fatal("TNS_SDE_MRET_FEATURE_EN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_FEATURE_EN bdk_tns_sde_mret_feature_en_t
#define bustype_BDK_TNS_SDE_MRET_FEATURE_EN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_FEATURE_EN "TNS_SDE_MRET_FEATURE_EN"
#define device_bar_BDK_TNS_SDE_MRET_FEATURE_EN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_FEATURE_EN 0
#define arguments_BDK_TNS_SDE_MRET_FEATURE_EN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_fl0_fif_ptr
 *
 * TNS SDE MRE Top Freelist 0 FIFO Pointer Register
 * --
 */
union bdk_tns_sde_mret_fl0_fif_ptr
{
    uint32_t u;
    struct bdk_tns_sde_mret_fl0_fif_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the freelist fifo." */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the freelist fifo." */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
#else /* Word 0 - Little Endian */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the freelist fifo." */
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the freelist fifo." */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_fl0_fif_ptr_s cn; */
};
typedef union bdk_tns_sde_mret_fl0_fif_ptr bdk_tns_sde_mret_fl0_fif_ptr_t;

#define BDK_TNS_SDE_MRET_FL0_FIF_PTR BDK_TNS_SDE_MRET_FL0_FIF_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FL0_FIF_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FL0_FIF_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800e0ll;
    __bdk_csr_fatal("TNS_SDE_MRET_FL0_FIF_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_FL0_FIF_PTR bdk_tns_sde_mret_fl0_fif_ptr_t
#define bustype_BDK_TNS_SDE_MRET_FL0_FIF_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_FL0_FIF_PTR "TNS_SDE_MRET_FL0_FIF_PTR"
#define device_bar_BDK_TNS_SDE_MRET_FL0_FIF_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_FL0_FIF_PTR 0
#define arguments_BDK_TNS_SDE_MRET_FL0_FIF_PTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_flst_bk0_adr
 *
 * TNS SDE MRE Top Freelist Bank 0 Address Register
 * --
 */
union bdk_tns_sde_mret_flst_bk0_adr
{
    uint32_t u;
    struct bdk_tns_sde_mret_flst_bk0_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t line                  : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t line                  : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_flst_bk0_adr_s cn; */
};
typedef union bdk_tns_sde_mret_flst_bk0_adr bdk_tns_sde_mret_flst_bk0_adr_t;

#define BDK_TNS_SDE_MRET_FLST_BK0_ADR BDK_TNS_SDE_MRET_FLST_BK0_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078004cll;
    __bdk_csr_fatal("TNS_SDE_MRET_FLST_BK0_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_FLST_BK0_ADR bdk_tns_sde_mret_flst_bk0_adr_t
#define bustype_BDK_TNS_SDE_MRET_FLST_BK0_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_FLST_BK0_ADR "TNS_SDE_MRET_FLST_BK0_ADR"
#define device_bar_BDK_TNS_SDE_MRET_FLST_BK0_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_FLST_BK0_ADR 0
#define arguments_BDK_TNS_SDE_MRET_FLST_BK0_ADR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_flst_bk0_dat
 *
 * TNS SDE MRE Top Freelist Bank 0 Data Register
 * --
 */
union bdk_tns_sde_mret_flst_bk0_dat
{
    uint32_t u;
    struct bdk_tns_sde_mret_flst_bk0_dat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_flst_bk0_dat_s cn; */
};
typedef union bdk_tns_sde_mret_flst_bk0_dat bdk_tns_sde_mret_flst_bk0_dat_t;

#define BDK_TNS_SDE_MRET_FLST_BK0_DAT BDK_TNS_SDE_MRET_FLST_BK0_DAT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_DAT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_DAT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780050ll;
    __bdk_csr_fatal("TNS_SDE_MRET_FLST_BK0_DAT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_FLST_BK0_DAT bdk_tns_sde_mret_flst_bk0_dat_t
#define bustype_BDK_TNS_SDE_MRET_FLST_BK0_DAT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_FLST_BK0_DAT "TNS_SDE_MRET_FLST_BK0_DAT"
#define device_bar_BDK_TNS_SDE_MRET_FLST_BK0_DAT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_FLST_BK0_DAT 0
#define arguments_BDK_TNS_SDE_MRET_FLST_BK0_DAT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_flst_dbg_cfg
 *
 * TNS SDE MRE Top Freelist Debug Configuration Register
 * This register should not be modified from its default values, unless you know
 * what you are doing.
 */
union bdk_tns_sde_mret_flst_dbg_cfg
{
    uint32_t u;
    struct bdk_tns_sde_mret_flst_dbg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t ch0_enqen             : 1;  /**< [  3:  3](R/W) -- */
        uint32_t ch0_deqen             : 1;  /**< [  2:  2](R/W) -- */
        uint32_t ch0_contenq           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t ch0_contdeq           : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ch0_contdeq           : 1;  /**< [  0:  0](R/W) -- */
        uint32_t ch0_contenq           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t ch0_deqen             : 1;  /**< [  2:  2](R/W) -- */
        uint32_t ch0_enqen             : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_flst_dbg_cfg_s cn; */
};
typedef union bdk_tns_sde_mret_flst_dbg_cfg bdk_tns_sde_mret_flst_dbg_cfg_t;

#define BDK_TNS_SDE_MRET_FLST_DBG_CFG BDK_TNS_SDE_MRET_FLST_DBG_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_DBG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_DBG_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800dcll;
    __bdk_csr_fatal("TNS_SDE_MRET_FLST_DBG_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_FLST_DBG_CFG bdk_tns_sde_mret_flst_dbg_cfg_t
#define bustype_BDK_TNS_SDE_MRET_FLST_DBG_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_FLST_DBG_CFG "TNS_SDE_MRET_FLST_DBG_CFG"
#define device_bar_BDK_TNS_SDE_MRET_FLST_DBG_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_FLST_DBG_CFG 0
#define arguments_BDK_TNS_SDE_MRET_FLST_DBG_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_flst_sta
 *
 * TNS SDE MRE Top Freelist Status Register
 * --
 */
union bdk_tns_sde_mret_flst_sta
{
    uint32_t u;
    struct bdk_tns_sde_mret_flst_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t ch0_full              : 1;  /**< [  8:  8](RO/H) Indicates there are no outstanding entries. */
        uint32_t ch0_usage             : 8;  /**< [  7:  0](RO/H) Number of entries in the freelist. */
#else /* Word 0 - Little Endian */
        uint32_t ch0_usage             : 8;  /**< [  7:  0](RO/H) Number of entries in the freelist. */
        uint32_t ch0_full              : 1;  /**< [  8:  8](RO/H) Indicates there are no outstanding entries. */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_flst_sta_s cn; */
};
typedef union bdk_tns_sde_mret_flst_sta bdk_tns_sde_mret_flst_sta_t;

#define BDK_TNS_SDE_MRET_FLST_STA BDK_TNS_SDE_MRET_FLST_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_STA_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800d8ll;
    __bdk_csr_fatal("TNS_SDE_MRET_FLST_STA", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_FLST_STA bdk_tns_sde_mret_flst_sta_t
#define bustype_BDK_TNS_SDE_MRET_FLST_STA BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_FLST_STA "TNS_SDE_MRET_FLST_STA"
#define device_bar_BDK_TNS_SDE_MRET_FLST_STA 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_FLST_STA 0
#define arguments_BDK_TNS_SDE_MRET_FLST_STA -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_hdrcyc_ct
 *
 * TNS SDE MRE Top Header Cycle Count Register
 * --
 */
union bdk_tns_sde_mret_hdrcyc_ct
{
    uint32_t u;
    struct bdk_tns_sde_mret_hdrcyc_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of cycles of data received on channel 0 */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of cycles of data received on channel 0 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_hdrcyc_ct_s cn; */
};
typedef union bdk_tns_sde_mret_hdrcyc_ct bdk_tns_sde_mret_hdrcyc_ct_t;

#define BDK_TNS_SDE_MRET_HDRCYC_CT BDK_TNS_SDE_MRET_HDRCYC_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_HDRCYC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HDRCYC_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780100ll;
    __bdk_csr_fatal("TNS_SDE_MRET_HDRCYC_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_HDRCYC_CT bdk_tns_sde_mret_hdrcyc_ct_t
#define bustype_BDK_TNS_SDE_MRET_HDRCYC_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_HDRCYC_CT "TNS_SDE_MRET_HDRCYC_CT"
#define device_bar_BDK_TNS_SDE_MRET_HDRCYC_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_HDRCYC_CT 0
#define arguments_BDK_TNS_SDE_MRET_HDRCYC_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_hmem_adr
 *
 * TNS SDE MRE Top Header Memory Address Register
 * --
 */
union bdk_tns_sde_mret_hmem_adr
{
    uint32_t u;
    struct bdk_tns_sde_mret_hmem_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t line                  : 2;  /**< [  8:  7](R/W) -- */
        uint32_t page                  : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t page                  : 7;  /**< [  6:  0](R/W) -- */
        uint32_t line                  : 2;  /**< [  8:  7](R/W) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_hmem_adr_s cn; */
};
typedef union bdk_tns_sde_mret_hmem_adr bdk_tns_sde_mret_hmem_adr_t;

#define BDK_TNS_SDE_MRET_HMEM_ADR BDK_TNS_SDE_MRET_HMEM_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780054ll;
    __bdk_csr_fatal("TNS_SDE_MRET_HMEM_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_HMEM_ADR bdk_tns_sde_mret_hmem_adr_t
#define bustype_BDK_TNS_SDE_MRET_HMEM_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_HMEM_ADR "TNS_SDE_MRET_HMEM_ADR"
#define device_bar_BDK_TNS_SDE_MRET_HMEM_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_HMEM_ADR 0
#define arguments_BDK_TNS_SDE_MRET_HMEM_ADR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_hmem_dat_w#
 *
 * TNS SDE MRE Top Header Memory Data Registers
 * Bits 31..2 of registers ending in _W16 are unused.
 */
union bdk_tns_sde_mret_hmem_dat_wx
{
    uint32_t u;
    struct bdk_tns_sde_mret_hmem_dat_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hdr_mem_data          : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdr_mem_data          : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_hmem_dat_wx_s cn; */
};
typedef union bdk_tns_sde_mret_hmem_dat_wx bdk_tns_sde_mret_hmem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_MRET_HMEM_DAT_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_DAT_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=16))
        return 0x842060780058ll + 4ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_MRET_HMEM_DAT_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_HMEM_DAT_WX(a) bdk_tns_sde_mret_hmem_dat_wx_t
#define bustype_BDK_TNS_SDE_MRET_HMEM_DAT_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_HMEM_DAT_WX(a) "TNS_SDE_MRET_HMEM_DAT_WX"
#define device_bar_BDK_TNS_SDE_MRET_HMEM_DAT_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_HMEM_DAT_WX(a) (a)
#define arguments_BDK_TNS_SDE_MRET_HMEM_DAT_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_hmem_ecc_err
 *
 * TNS SDE MRE Top Header Memory ECC Error Register
 * --
 */
union bdk_tns_sde_mret_hmem_ecc_err
{
    uint32_t u;
    struct bdk_tns_sde_mret_hmem_ecc_err_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t log                   : 18; /**< [ 17:  0](R/W/H) Data logged is defined as {locked, hdr_mem_db_err[3:0], hdr_mem_sb_err[3:0],
                                                                 hdr_mem_rd_addr_d[8:0]} */
#else /* Word 0 - Little Endian */
        uint32_t log                   : 18; /**< [ 17:  0](R/W/H) Data logged is defined as {locked, hdr_mem_db_err[3:0], hdr_mem_sb_err[3:0],
                                                                 hdr_mem_rd_addr_d[8:0]} */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_hmem_ecc_err_s cn; */
};
typedef union bdk_tns_sde_mret_hmem_ecc_err bdk_tns_sde_mret_hmem_ecc_err_t;

#define BDK_TNS_SDE_MRET_HMEM_ECC_ERR BDK_TNS_SDE_MRET_HMEM_ECC_ERR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ECC_ERR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ECC_ERR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800f8ll;
    __bdk_csr_fatal("TNS_SDE_MRET_HMEM_ECC_ERR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_HMEM_ECC_ERR bdk_tns_sde_mret_hmem_ecc_err_t
#define bustype_BDK_TNS_SDE_MRET_HMEM_ECC_ERR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_HMEM_ECC_ERR "TNS_SDE_MRET_HMEM_ECC_ERR"
#define device_bar_BDK_TNS_SDE_MRET_HMEM_ECC_ERR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_HMEM_ECC_ERR 0
#define arguments_BDK_TNS_SDE_MRET_HMEM_ECC_ERR -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_int_en_hi
 *
 * TNS SDE MRE Top Interrrupt Enable High Register
 * Interrupts for the MRE module
 */
union bdk_tns_sde_mret_int_en_hi
{
    uint64_t u;
    struct bdk_tns_sde_mret_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](R/W) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](R/W) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](R/W) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](R/W) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](R/W) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](R/W) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](R/W) -- */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](R/W) -- */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](R/W) Indicates a two-bit error was detected in the context RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](R/W) Indicates a single-bit error was detected in the context RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](R/W) Indicates a two-bit error was detected in the header RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](R/W) Indicates a single-bit error was detected in the header RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](R/W) Indicates a two-bit error was detected in the token RAM. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](R/W) Indicates a single-bit error was detected in the token RAM. */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](R/W) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](R/W) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](R/W) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](R/W) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](R/W) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](R/W) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](R/W) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](R/W) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](R/W) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](R/W) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](R/W) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](R/W) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](R/W) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](R/W) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](R/W) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](R/W) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else /* Word 0 - Little Endian */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](R/W) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](R/W) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](R/W) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](R/W) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](R/W) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](R/W) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](R/W) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](R/W) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](R/W) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](R/W) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](R/W) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](R/W) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](R/W) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](R/W) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](R/W) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](R/W) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](R/W) Indicates a single-bit error was detected in the token RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](R/W) Indicates a two-bit error was detected in the token RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](R/W) Indicates a single-bit error was detected in the header RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](R/W) Indicates a two-bit error was detected in the header RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](R/W) Indicates a single-bit error was detected in the context RAM. */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](R/W) Indicates a two-bit error was detected in the context RAM. */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](R/W) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](R/W) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](R/W) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](R/W) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](R/W) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](R/W) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](R/W) -- */
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](R/W) -- */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_mret_int_en_hi bdk_tns_sde_mret_int_en_hi_t;

#define BDK_TNS_SDE_MRET_INT_EN_HI BDK_TNS_SDE_MRET_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800c0ll;
    __bdk_csr_fatal("TNS_SDE_MRET_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_INT_EN_HI bdk_tns_sde_mret_int_en_hi_t
#define bustype_BDK_TNS_SDE_MRET_INT_EN_HI BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_INT_EN_HI "TNS_SDE_MRET_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_MRET_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_MRET_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_int_en_lo
 *
 * TNS SDE MRE Top Interrrupt Enable Low Register
 * Interrupts for the MRE module
 */
union bdk_tns_sde_mret_int_en_lo
{
    uint64_t u;
    struct bdk_tns_sde_mret_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](R/W) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](R/W) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](R/W) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](R/W) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](R/W) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](R/W) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](R/W) -- */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](R/W) -- */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](R/W) Indicates a two-bit error was detected in the context RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](R/W) Indicates a single-bit error was detected in the context RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](R/W) Indicates a two-bit error was detected in the header RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](R/W) Indicates a single-bit error was detected in the header RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](R/W) Indicates a two-bit error was detected in the token RAM. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](R/W) Indicates a single-bit error was detected in the token RAM. */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](R/W) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](R/W) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](R/W) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](R/W) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](R/W) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](R/W) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](R/W) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](R/W) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](R/W) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](R/W) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](R/W) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](R/W) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](R/W) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](R/W) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](R/W) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](R/W) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else /* Word 0 - Little Endian */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](R/W) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](R/W) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](R/W) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](R/W) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](R/W) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](R/W) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](R/W) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](R/W) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](R/W) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](R/W) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](R/W) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](R/W) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](R/W) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](R/W) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](R/W) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](R/W) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](R/W) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](R/W) Indicates a single-bit error was detected in the token RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](R/W) Indicates a two-bit error was detected in the token RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](R/W) Indicates a single-bit error was detected in the header RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](R/W) Indicates a two-bit error was detected in the header RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](R/W) Indicates a single-bit error was detected in the context RAM. */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](R/W) Indicates a two-bit error was detected in the context RAM. */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](R/W) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](R/W) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](R/W) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](R/W) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](R/W) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](R/W) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](R/W) -- */
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](R/W) -- */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_mret_int_en_lo bdk_tns_sde_mret_int_en_lo_t;

#define BDK_TNS_SDE_MRET_INT_EN_LO BDK_TNS_SDE_MRET_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800c8ll;
    __bdk_csr_fatal("TNS_SDE_MRET_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_INT_EN_LO bdk_tns_sde_mret_int_en_lo_t
#define bustype_BDK_TNS_SDE_MRET_INT_EN_LO BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_INT_EN_LO "TNS_SDE_MRET_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_MRET_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_MRET_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_int_frc
 *
 * TNS SDE MRE Top Interrrupt Force Register
 * Interrupts for the MRE module
 */
union bdk_tns_sde_mret_int_frc
{
    uint64_t u;
    struct bdk_tns_sde_mret_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](WO) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](WO) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](WO) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](WO) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](WO) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](WO) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](WO) -- */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](WO) -- */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](WO) Indicates a two-bit error was detected in the context RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](WO) Indicates a single-bit error was detected in the context RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](WO) Indicates a two-bit error was detected in the header RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](WO) Indicates a single-bit error was detected in the header RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](WO) Indicates a two-bit error was detected in the token RAM. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](WO) Indicates a single-bit error was detected in the token RAM. */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](WO) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](WO) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](WO) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](WO) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](WO) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](WO) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](WO) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](WO) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](WO) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](WO) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](WO) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](WO) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](WO) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](WO) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](WO) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](WO) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](WO) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](WO) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else /* Word 0 - Little Endian */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](WO) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](WO) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](WO) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](WO) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](WO) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](WO) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](WO) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](WO) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](WO) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](WO) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](WO) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](WO) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](WO) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](WO) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](WO) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](WO) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](WO) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](WO) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](WO) Indicates a single-bit error was detected in the token RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](WO) Indicates a two-bit error was detected in the token RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](WO) Indicates a single-bit error was detected in the header RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](WO) Indicates a two-bit error was detected in the header RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](WO) Indicates a single-bit error was detected in the context RAM. */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](WO) Indicates a two-bit error was detected in the context RAM. */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](WO) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](WO) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](WO) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](WO) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](WO) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](WO) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](WO) -- */
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](WO) -- */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_int_frc_s cn; */
};
typedef union bdk_tns_sde_mret_int_frc bdk_tns_sde_mret_int_frc_t;

#define BDK_TNS_SDE_MRET_INT_FRC BDK_TNS_SDE_MRET_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800d0ll;
    __bdk_csr_fatal("TNS_SDE_MRET_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_INT_FRC bdk_tns_sde_mret_int_frc_t
#define bustype_BDK_TNS_SDE_MRET_INT_FRC BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_INT_FRC "TNS_SDE_MRET_INT_FRC"
#define device_bar_BDK_TNS_SDE_MRET_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_INT_FRC 0
#define arguments_BDK_TNS_SDE_MRET_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_mret_int_w1c
 *
 * TNS SDE MRE Top Interrrupt W1C Register
 * Interrupts for the MRE module
 */
union bdk_tns_sde_mret_int_w1c
{
    uint64_t u;
    struct bdk_tns_sde_mret_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](R/W1C/H) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](R/W1C/H) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](R/W1C/H) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](R/W1C/H) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](R/W1C/H) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](R/W1C/H) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](R/W1C/H) -- */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](R/W1C/H) -- */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](R/W1C/H) Indicates a two-bit error was detected in the context RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](R/W1C/H) Indicates a single-bit error was detected in the context RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](R/W1C/H) Indicates a two-bit error was detected in the header RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](R/W1C/H) Indicates a single-bit error was detected in the header RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](R/W1C/H) Indicates a two-bit error was detected in the token RAM. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](R/W1C/H) Indicates a single-bit error was detected in the token RAM. */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](R/W1C/H) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](R/W1C/H) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](R/W1C/H) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](R/W1C/H) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](R/W1C/H) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](R/W1C/H) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](R/W1C/H) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](R/W1C/H) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](R/W1C/H) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](R/W1C/H) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](R/W1C/H) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](R/W1C/H) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](R/W1C/H) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](R/W1C/H) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](R/W1C/H) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](R/W1C/H) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](R/W1C/H) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](R/W1C/H) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else /* Word 0 - Little Endian */
        uint64_t arbiter_token_fifo_ovfl_intr : 1;/**< [  0:  0](R/W1C/H) Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
        uint64_t ctx_store_rd_timeout_intr : 1;/**< [  1:  1](R/W1C/H) Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
        uint64_t se_data_incorrect_intr : 1; /**< [  2:  2](R/W1C/H) Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
        uint64_t rcv_store_1_rd_wr_same_intr : 1;/**< [  3:  3](R/W1C/H) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_0_rd_wr_same_intr : 1;/**< [  4:  4](R/W1C/H) Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
        uint64_t rcv_store_1_wr2vld_intr : 1;/**< [  5:  5](R/W1C/H) Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
        uint64_t rcv_store_0_wr2vld_intr : 1;/**< [  6:  6](R/W1C/H) Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
        uint64_t freecache_ovfl_int    : 1;  /**< [  7:  7](R/W1C/H) Indicates one of the freecaches has overflown. This should never happen. */
        uint64_t freecache_cnt_ovfl_int : 1; /**< [  8:  8](R/W1C/H) Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
        uint64_t freecache_cnt_undrn_int : 1;/**< [  9:  9](R/W1C/H) Indicates one of the freecache counters has underrun. This should never happen. */
        uint64_t req_ct_thr_xcd        : 1;  /**< [ 10: 10](R/W1C/H) Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
        uint64_t req_ct_undr           : 1;  /**< [ 11: 11](R/W1C/H) Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
        uint64_t req_ct_ovfl           : 1;  /**< [ 12: 12](R/W1C/H) Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
        uint64_t page_fifo_fsm_error   : 1;  /**< [ 13: 13](R/W1C/H) Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
        uint64_t freelist_fifo_sb_err  : 1;  /**< [ 14: 14](R/W1C/H) Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
        uint64_t freelist_fifo_db_err  : 1;  /**< [ 15: 15](R/W1C/H) Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
        uint64_t page_fifo_ovfl        : 1;  /**< [ 16: 16](R/W1C/H) Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
        uint64_t freelist_fifo_undr    : 1;  /**< [ 17: 17](R/W1C/H) Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
        uint64_t token_mem_sb_err      : 10; /**< [ 27: 18](R/W1C/H) Indicates a single-bit error was detected in the token RAM. */
        uint64_t token_mem_db_err      : 10; /**< [ 37: 28](R/W1C/H) Indicates a two-bit error was detected in the token RAM. */
        uint64_t hdr_mem_sb_err        : 4;  /**< [ 41: 38](R/W1C/H) Indicates a single-bit error was detected in the header RAM. */
        uint64_t hdr_mem_db_err        : 4;  /**< [ 45: 42](R/W1C/H) Indicates a two-bit error was detected in the header RAM. */
        uint64_t cntx_mem_sb_err       : 2;  /**< [ 47: 46](R/W1C/H) Indicates a single-bit error was detected in the context RAM. */
        uint64_t cntx_mem_db_err       : 2;  /**< [ 49: 48](R/W1C/H) Indicates a two-bit error was detected in the context RAM. */
        uint64_t page_fifo0_prio0_sb_err : 1;/**< [ 50: 50](R/W1C/H) -- */
        uint64_t page_fifo0_prio0_db_err : 1;/**< [ 51: 51](R/W1C/H) -- */
        uint64_t page_fifo0_prio1_sb_err : 1;/**< [ 52: 52](R/W1C/H) -- */
        uint64_t page_fifo0_prio1_db_err : 1;/**< [ 53: 53](R/W1C/H) -- */
        uint64_t page_fifo0_prio2_sb_err : 1;/**< [ 54: 54](R/W1C/H) -- */
        uint64_t page_fifo0_prio2_db_err : 1;/**< [ 55: 55](R/W1C/H) -- */
        uint64_t page_fifo0_prio3_sb_err : 1;/**< [ 56: 56](R/W1C/H) -- */
        uint64_t page_fifo0_prio3_db_err : 1;/**< [ 57: 57](R/W1C/H) -- */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_int_w1c_s cn; */
};
typedef union bdk_tns_sde_mret_int_w1c bdk_tns_sde_mret_int_w1c_t;

#define BDK_TNS_SDE_MRET_INT_W1C BDK_TNS_SDE_MRET_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800b8ll;
    __bdk_csr_fatal("TNS_SDE_MRET_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_INT_W1C bdk_tns_sde_mret_int_w1c_t
#define bustype_BDK_TNS_SDE_MRET_INT_W1C BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_MRET_INT_W1C "TNS_SDE_MRET_INT_W1C"
#define device_bar_BDK_TNS_SDE_MRET_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_INT_W1C 0
#define arguments_BDK_TNS_SDE_MRET_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_lock
 *
 * TNS SDE MRE Top Lock Register
 * Lock Register
 */
union bdk_tns_sde_mret_lock
{
    uint32_t u;
    struct bdk_tns_sde_mret_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_lock_s cn; */
};
typedef union bdk_tns_sde_mret_lock bdk_tns_sde_mret_lock_t;

#define BDK_TNS_SDE_MRET_LOCK BDK_TNS_SDE_MRET_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780108ll;
    __bdk_csr_fatal("TNS_SDE_MRET_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_LOCK bdk_tns_sde_mret_lock_t
#define bustype_BDK_TNS_SDE_MRET_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_LOCK "TNS_SDE_MRET_LOCK"
#define device_bar_BDK_TNS_SDE_MRET_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_LOCK 0
#define arguments_BDK_TNS_SDE_MRET_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_mdt_req_cfg
 *
 * TNS SDE MRE Top MDT Request Configuration Register
 * Controls the number and type of SE requests issued byt the MRE
 * module for the purpose of MDT traversal.
 */
union bdk_tns_sde_mret_mdt_req_cfg
{
    uint32_t u;
    struct bdk_tns_sde_mret_mdt_req_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t mdt_prfl_id           : 7;  /**< [ 20: 14](R/W) Profile ID used when issueing the MDT read request to SE. Note:
                                                                 the SE profile identified here MUST be programmed to use only
                                                                 the first table slot, and that tabel must be programmed to return
                                                                 64 bits of data only, and on lane 0. */
        uint32_t mdt_cmd_en            : 4;  /**< [ 13: 10](R/W) CMD enable bit vector used when issueing the MDT read request.
                                                                 This should never be changed from its default value of 4'b0001. */
        uint32_t outstanding_mre_request_thr : 8;/**< [  9:  2](R/W) Number of outstanding MDT read requests the MRE issues before
                                                                 flowcontrolling the pipe. */
        uint32_t channel_select_mode   : 2;  /**< [  1:  0](R/W) Defines the way the outgoing channel is assigned on the replicated Tokens:
                                                                 2'h0: Same as incoming token (default)
                                                                 2'h1: Round robin (based on incoming token: all tokens generated from a
                                                                 given token will be assigned the same value
                                                                 2'h2: From L3-ECMP hash [1:0]. If hash_select = 0, uses l3_ecmp_hash_a,
                                                                 else uses l3_ecmp_hash_b. */
#else /* Word 0 - Little Endian */
        uint32_t channel_select_mode   : 2;  /**< [  1:  0](R/W) Defines the way the outgoing channel is assigned on the replicated Tokens:
                                                                 2'h0: Same as incoming token (default)
                                                                 2'h1: Round robin (based on incoming token: all tokens generated from a
                                                                 given token will be assigned the same value
                                                                 2'h2: From L3-ECMP hash [1:0]. If hash_select = 0, uses l3_ecmp_hash_a,
                                                                 else uses l3_ecmp_hash_b. */
        uint32_t outstanding_mre_request_thr : 8;/**< [  9:  2](R/W) Number of outstanding MDT read requests the MRE issues before
                                                                 flowcontrolling the pipe. */
        uint32_t mdt_cmd_en            : 4;  /**< [ 13: 10](R/W) CMD enable bit vector used when issueing the MDT read request.
                                                                 This should never be changed from its default value of 4'b0001. */
        uint32_t mdt_prfl_id           : 7;  /**< [ 20: 14](R/W) Profile ID used when issueing the MDT read request to SE. Note:
                                                                 the SE profile identified here MUST be programmed to use only
                                                                 the first table slot, and that tabel must be programmed to return
                                                                 64 bits of data only, and on lane 0. */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_mdt_req_cfg_s cn; */
};
typedef union bdk_tns_sde_mret_mdt_req_cfg bdk_tns_sde_mret_mdt_req_cfg_t;

#define BDK_TNS_SDE_MRET_MDT_REQ_CFG BDK_TNS_SDE_MRET_MDT_REQ_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_MDT_REQ_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_MDT_REQ_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780030ll;
    __bdk_csr_fatal("TNS_SDE_MRET_MDT_REQ_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_MDT_REQ_CFG bdk_tns_sde_mret_mdt_req_cfg_t
#define bustype_BDK_TNS_SDE_MRET_MDT_REQ_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_MDT_REQ_CFG "TNS_SDE_MRET_MDT_REQ_CFG"
#define device_bar_BDK_TNS_SDE_MRET_MDT_REQ_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_MDT_REQ_CFG 0
#define arguments_BDK_TNS_SDE_MRET_MDT_REQ_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_mdt_resp_cfg
 *
 * TNS SDE MRE Top MDT Response Configuration Register
 * Controls behavior of the MRE related to the SE data reception.
 */
union bdk_tns_sde_mret_mdt_resp_cfg
{
    uint32_t u;
    struct bdk_tns_sde_mret_mdt_resp_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t ctx_store_rd_timeout  : 16; /**< [ 15:  0](R/W) This controls the timeout value (in clock cycles) for the context store read.
                                                                 If data is available and the data is not read, the timeout counter is
                                                                 incremented. Else it is zeroed out. When the counter reaches this value, an
                                                                 interrupt is asserted. */
#else /* Word 0 - Little Endian */
        uint32_t ctx_store_rd_timeout  : 16; /**< [ 15:  0](R/W) This controls the timeout value (in clock cycles) for the context store read.
                                                                 If data is available and the data is not read, the timeout counter is
                                                                 incremented. Else it is zeroed out. When the counter reaches this value, an
                                                                 interrupt is asserted. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_mdt_resp_cfg_s cn; */
};
typedef union bdk_tns_sde_mret_mdt_resp_cfg bdk_tns_sde_mret_mdt_resp_cfg_t;

#define BDK_TNS_SDE_MRET_MDT_RESP_CFG BDK_TNS_SDE_MRET_MDT_RESP_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_MDT_RESP_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_MDT_RESP_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078002cll;
    __bdk_csr_fatal("TNS_SDE_MRET_MDT_RESP_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_MDT_RESP_CFG bdk_tns_sde_mret_mdt_resp_cfg_t
#define bustype_BDK_TNS_SDE_MRET_MDT_RESP_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_MDT_RESP_CFG "TNS_SDE_MRET_MDT_RESP_CFG"
#define device_bar_BDK_TNS_SDE_MRET_MDT_RESP_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_MDT_RESP_CFG 0
#define arguments_BDK_TNS_SDE_MRET_MDT_RESP_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif0_adr
 *
 * TNS SDE MRE Top Page FIF 0 Address Register
 * --
 */
union bdk_tns_sde_mret_pg_fif0_adr
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif0_adr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t prio                  : 2;  /**< [  9:  8](R/W) -- */
        uint32_t addr                  : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 8;  /**< [  7:  0](R/W) -- */
        uint32_t prio                  : 2;  /**< [  9:  8](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif0_adr_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif0_adr bdk_tns_sde_mret_pg_fif0_adr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_ADR BDK_TNS_SDE_MRET_PG_FIF0_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_ADR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780044ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF0_ADR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_ADR bdk_tns_sde_mret_pg_fif0_adr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_ADR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_ADR "TNS_SDE_MRET_PG_FIF0_ADR"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF0_ADR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_ADR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_ADR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif0_dat
 *
 * TNS SDE MRE Top Page FIF 0 Data Register
 * --
 */
union bdk_tns_sde_mret_pg_fif0_dat
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif0_dat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif0_dat_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif0_dat bdk_tns_sde_mret_pg_fif0_dat_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_DAT BDK_TNS_SDE_MRET_PG_FIF0_DAT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_DAT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_DAT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780048ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF0_DAT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_DAT bdk_tns_sde_mret_pg_fif0_dat_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_DAT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_DAT "TNS_SDE_MRET_PG_FIF0_DAT"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF0_DAT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_DAT 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_DAT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif0_pr0_ptr
 *
 * TNS SDE MRE Top Page FIF 0 Priority 0 Pointer Register
 * --
 */
union bdk_tns_sde_mret_pg_fif0_pr0_ptr
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif0_pr0_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
#else /* Word 0 - Little Endian */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif0_pr0_ptr_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif0_pr0_ptr bdk_tns_sde_mret_pg_fif0_pr0_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800e8ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF0_PR0_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR bdk_tns_sde_mret_pg_fif0_pr0_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR "TNS_SDE_MRET_PG_FIF0_PR0_PTR"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif0_pr1_ptr
 *
 * TNS SDE MRE Top Page FIF 0 Priority 1 Pointer Register
 * --
 */
union bdk_tns_sde_mret_pg_fif0_pr1_ptr
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif0_pr1_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
#else /* Word 0 - Little Endian */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif0_pr1_ptr_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif0_pr1_ptr bdk_tns_sde_mret_pg_fif0_pr1_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800ecll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF0_PR1_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR bdk_tns_sde_mret_pg_fif0_pr1_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR "TNS_SDE_MRET_PG_FIF0_PR1_PTR"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif0_pr2_ptr
 *
 * TNS SDE MRE Top Page FIF 0 Priority 2 Pointer Register
 * --
 */
union bdk_tns_sde_mret_pg_fif0_pr2_ptr
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif0_pr2_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
#else /* Word 0 - Little Endian */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif0_pr2_ptr_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif0_pr2_ptr bdk_tns_sde_mret_pg_fif0_pr2_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800f0ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF0_PR2_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR bdk_tns_sde_mret_pg_fif0_pr2_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR "TNS_SDE_MRET_PG_FIF0_PR2_PTR"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif0_pr3_ptr
 *
 * TNS SDE MRE Top Page FIF 0 Priority 3 Pointer Register
 * --
 */
union bdk_tns_sde_mret_pg_fif0_pr3_ptr
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif0_pr3_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
#else /* Word 0 - Little Endian */
        uint32_t empty                 : 1;  /**< [  0:  0](R/W/H) Fifo empty indication" */
        uint32_t full                  : 1;  /**< [  1:  1](R/W/H) Fifo full indication" */
        uint32_t rdptr                 : 7;  /**< [  8:  2](R/W/H) The read pointer of the page fifo." */
        uint32_t wrptr                 : 7;  /**< [ 15:  9](R/W/H) The write pointer of the page fifo." */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif0_pr3_ptr_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif0_pr3_ptr bdk_tns_sde_mret_pg_fif0_pr3_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800f4ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF0_PR3_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR bdk_tns_sde_mret_pg_fif0_pr3_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR "TNS_SDE_MRET_PG_FIF0_PR3_PTR"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif_cfg_w0
 *
 * TNS SDE MRE Top Page FIFO Configuration Word 0 Register
 * Controls the thresholds of the page fifos for each bank
 */
union bdk_tns_sde_mret_pg_fif_cfg_w0
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif_cfg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t prio_thr3             : 8;  /**< [ 31: 24](R/W) Threshold for priority 0 */
        uint32_t prio_thr2             : 8;  /**< [ 23: 16](R/W) Threshold for priority 1 */
        uint32_t prio_thr1             : 8;  /**< [ 15:  8](R/W) Threshold for priority 2 */
        uint32_t prio_thr0             : 8;  /**< [  7:  0](R/W) Threshold for priority 3 */
#else /* Word 0 - Little Endian */
        uint32_t prio_thr0             : 8;  /**< [  7:  0](R/W) Threshold for priority 3 */
        uint32_t prio_thr1             : 8;  /**< [ 15:  8](R/W) Threshold for priority 2 */
        uint32_t prio_thr2             : 8;  /**< [ 23: 16](R/W) Threshold for priority 1 */
        uint32_t prio_thr3             : 8;  /**< [ 31: 24](R/W) Threshold for priority 0 */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif_cfg_w0_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif_cfg_w0 bdk_tns_sde_mret_pg_fif_cfg_w0_t;

#define BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 BDK_TNS_SDE_MRET_PG_FIF_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078003cll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF_CFG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 bdk_tns_sde_mret_pg_fif_cfg_w0_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 "TNS_SDE_MRET_PG_FIF_CFG_W0"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif_cfg_w1
 *
 * TNS SDE MRE Top Page FIFO Configuration Word 1 Register
 * Continuation of structure defined in TNS_SDE_MRET_PG_FIF_CFG_W0
 */
union bdk_tns_sde_mret_pg_fif_cfg_w1
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif_cfg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bank_thr              : 8;  /**< [  7:  0](R/W) Total Threshold for the entire bank */
#else /* Word 0 - Little Endian */
        uint32_t bank_thr              : 8;  /**< [  7:  0](R/W) Total Threshold for the entire bank */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif_cfg_w1_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif_cfg_w1 bdk_tns_sde_mret_pg_fif_cfg_w1_t;

#define BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 BDK_TNS_SDE_MRET_PG_FIF_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780040ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF_CFG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 bdk_tns_sde_mret_pg_fif_cfg_w1_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 "TNS_SDE_MRET_PG_FIF_CFG_W1"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_pg_fif_dbg_cfg
 *
 * TNS SDE MRE Top Page FIFO Debug Configuration Register
 * This register should not be modified from its default values, unless you know
 * what you are doing.
 */
union bdk_tns_sde_mret_pg_fif_dbg_cfg
{
    uint32_t u;
    struct bdk_tns_sde_mret_pg_fif_dbg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t fifo0_prio3_enqen     : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t fifo0_prio3_deqen     : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t fifo0_prio3_contenq   : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t fifo0_prio3_contdeq   : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t fifo0_prio2_enqen     : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t fifo0_prio2_deqen     : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t fifo0_prio2_contenq   : 1;  /**< [  9:  9](R/W) -- */
        uint32_t fifo0_prio2_contdeq   : 1;  /**< [  8:  8](R/W) -- */
        uint32_t fifo0_prio1_enqen     : 1;  /**< [  7:  7](R/W) -- */
        uint32_t fifo0_prio1_deqen     : 1;  /**< [  6:  6](R/W) -- */
        uint32_t fifo0_prio1_contenq   : 1;  /**< [  5:  5](R/W) -- */
        uint32_t fifo0_prio1_contdeq   : 1;  /**< [  4:  4](R/W) -- */
        uint32_t fifo0_prio0_enqen     : 1;  /**< [  3:  3](R/W) -- */
        uint32_t fifo0_prio0_deqen     : 1;  /**< [  2:  2](R/W) -- */
        uint32_t fifo0_prio0_contenq   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t fifo0_prio0_contdeq   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo0_prio0_contdeq   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t fifo0_prio0_contenq   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t fifo0_prio0_deqen     : 1;  /**< [  2:  2](R/W) -- */
        uint32_t fifo0_prio0_enqen     : 1;  /**< [  3:  3](R/W) -- */
        uint32_t fifo0_prio1_contdeq   : 1;  /**< [  4:  4](R/W) -- */
        uint32_t fifo0_prio1_contenq   : 1;  /**< [  5:  5](R/W) -- */
        uint32_t fifo0_prio1_deqen     : 1;  /**< [  6:  6](R/W) -- */
        uint32_t fifo0_prio1_enqen     : 1;  /**< [  7:  7](R/W) -- */
        uint32_t fifo0_prio2_contdeq   : 1;  /**< [  8:  8](R/W) -- */
        uint32_t fifo0_prio2_contenq   : 1;  /**< [  9:  9](R/W) -- */
        uint32_t fifo0_prio2_deqen     : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t fifo0_prio2_enqen     : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t fifo0_prio3_contdeq   : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t fifo0_prio3_contenq   : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t fifo0_prio3_deqen     : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t fifo0_prio3_enqen     : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_pg_fif_dbg_cfg_s cn; */
};
typedef union bdk_tns_sde_mret_pg_fif_dbg_cfg bdk_tns_sde_mret_pg_fif_dbg_cfg_t;

#define BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420607800e4ll;
    __bdk_csr_fatal("TNS_SDE_MRET_PG_FIF_DBG_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG bdk_tns_sde_mret_pg_fif_dbg_cfg_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG "TNS_SDE_MRET_PG_FIF_DBG_CFG"
#define device_bar_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_spad
 *
 * TNS SDE MRE Top ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_mret_spad
{
    uint32_t u;
    struct bdk_tns_sde_mret_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_spad_s cn; */
};
typedef union bdk_tns_sde_mret_spad bdk_tns_sde_mret_spad_t;

#define BDK_TNS_SDE_MRET_SPAD BDK_TNS_SDE_MRET_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206078010cll;
    __bdk_csr_fatal("TNS_SDE_MRET_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_SPAD bdk_tns_sde_mret_spad_t
#define bustype_BDK_TNS_SDE_MRET_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_SPAD "TNS_SDE_MRET_SPAD"
#define device_bar_BDK_TNS_SDE_MRET_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_SPAD 0
#define arguments_BDK_TNS_SDE_MRET_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_sta
 *
 * TNS SDE MRE Top Status Register
 * Status register for general status of the MRE module
 */
union bdk_tns_sde_mret_sta
{
    uint32_t u;
    struct bdk_tns_sde_mret_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t memwr_cntrl_fl_init_done : 1;/**< [  0:  0](RO/H) Indicates the corresponding MemWrCntrl
                                                                 has completed its freelist initialization. */
#else /* Word 0 - Little Endian */
        uint32_t memwr_cntrl_fl_init_done : 1;/**< [  0:  0](RO/H) Indicates the corresponding MemWrCntrl
                                                                 has completed its freelist initialization. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_sta_s cn; */
};
typedef union bdk_tns_sde_mret_sta bdk_tns_sde_mret_sta_t;

#define BDK_TNS_SDE_MRET_STA BDK_TNS_SDE_MRET_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_STA_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780000ll;
    __bdk_csr_fatal("TNS_SDE_MRET_STA", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_STA bdk_tns_sde_mret_sta_t
#define bustype_BDK_TNS_SDE_MRET_STA BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_STA "TNS_SDE_MRET_STA"
#define device_bar_BDK_TNS_SDE_MRET_STA 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_STA 0
#define arguments_BDK_TNS_SDE_MRET_STA -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_mret_tkn_in_ct
 *
 * TNS SDE MRE Top Token In Count Register
 * --
 */
union bdk_tns_sde_mret_tkn_in_ct
{
    uint32_t u;
    struct bdk_tns_sde_mret_tkn_in_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of tokens received on channel 0 */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W/H) Number of tokens received on channel 0 */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_mret_tkn_in_ct_s cn; */
};
typedef union bdk_tns_sde_mret_tkn_in_ct bdk_tns_sde_mret_tkn_in_ct_t;

#define BDK_TNS_SDE_MRET_TKN_IN_CT BDK_TNS_SDE_MRET_TKN_IN_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_TKN_IN_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_TKN_IN_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060780104ll;
    __bdk_csr_fatal("TNS_SDE_MRET_TKN_IN_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_MRET_TKN_IN_CT bdk_tns_sde_mret_tkn_in_ct_t
#define bustype_BDK_TNS_SDE_MRET_TKN_IN_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_MRET_TKN_IN_CT "TNS_SDE_MRET_TKN_IN_CT"
#define device_bar_BDK_TNS_SDE_MRET_TKN_IN_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_MRET_TKN_IN_CT 0
#define arguments_BDK_TNS_SDE_MRET_TKN_IN_CT -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_parser_int_en_hi
 *
 * TNS SDE Parser Interrrupt Enable High Register
 * --
 */
union bdk_tns_sde_parser_int_en_hi
{
    uint64_t u;
    struct bdk_tns_sde_parser_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](R/W) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](R/W) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](R/W) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](R/W) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](R/W) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](R/W) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](R/W) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](R/W) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](R/W) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](R/W) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](R/W) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](R/W) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](R/W) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](R/W) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](R/W) -- */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](R/W) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](R/W) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](R/W) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](R/W) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](R/W) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](R/W) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](R/W) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](R/W) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](R/W) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](R/W) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](R/W) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](R/W) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](R/W) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](R/W) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](R/W) -- */
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](R/W) -- */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_parser_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_parser_int_en_hi bdk_tns_sde_parser_int_en_hi_t;

#define BDK_TNS_SDE_PARSER_INT_EN_HI BDK_TNS_SDE_PARSER_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060740010ll;
    __bdk_csr_fatal("TNS_SDE_PARSER_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PARSER_INT_EN_HI bdk_tns_sde_parser_int_en_hi_t
#define bustype_BDK_TNS_SDE_PARSER_INT_EN_HI BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PARSER_INT_EN_HI "TNS_SDE_PARSER_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_PARSER_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PARSER_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_PARSER_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_parser_int_en_lo
 *
 * TNS SDE Parser Interrrupt Enable Low Register
 * --
 */
union bdk_tns_sde_parser_int_en_lo
{
    uint64_t u;
    struct bdk_tns_sde_parser_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](R/W) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](R/W) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](R/W) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](R/W) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](R/W) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](R/W) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](R/W) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](R/W) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](R/W) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](R/W) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](R/W) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](R/W) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](R/W) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](R/W) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](R/W) -- */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](R/W) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](R/W) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](R/W) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](R/W) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](R/W) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](R/W) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](R/W) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](R/W) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](R/W) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](R/W) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](R/W) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](R/W) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](R/W) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](R/W) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](R/W) -- */
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](R/W) -- */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_parser_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_parser_int_en_lo bdk_tns_sde_parser_int_en_lo_t;

#define BDK_TNS_SDE_PARSER_INT_EN_LO BDK_TNS_SDE_PARSER_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060740018ll;
    __bdk_csr_fatal("TNS_SDE_PARSER_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PARSER_INT_EN_LO bdk_tns_sde_parser_int_en_lo_t
#define bustype_BDK_TNS_SDE_PARSER_INT_EN_LO BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PARSER_INT_EN_LO "TNS_SDE_PARSER_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_PARSER_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PARSER_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_PARSER_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_parser_int_frc
 *
 * TNS SDE Parser Interrrupt Force Register
 * --
 */
union bdk_tns_sde_parser_int_frc
{
    uint64_t u;
    struct bdk_tns_sde_parser_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](WO) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](WO) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](WO) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](WO) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](WO) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](WO) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](WO) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](WO) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](WO) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](WO) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](WO) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](WO) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](WO) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](WO) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](WO) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](WO) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](WO) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](WO) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](WO) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](WO) -- */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](WO) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](WO) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](WO) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](WO) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](WO) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](WO) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](WO) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](WO) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](WO) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](WO) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](WO) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](WO) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](WO) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](WO) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](WO) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](WO) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](WO) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](WO) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](WO) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](WO) -- */
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](WO) -- */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_parser_int_frc_s cn; */
};
typedef union bdk_tns_sde_parser_int_frc bdk_tns_sde_parser_int_frc_t;

#define BDK_TNS_SDE_PARSER_INT_FRC BDK_TNS_SDE_PARSER_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060740020ll;
    __bdk_csr_fatal("TNS_SDE_PARSER_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PARSER_INT_FRC bdk_tns_sde_parser_int_frc_t
#define bustype_BDK_TNS_SDE_PARSER_INT_FRC BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PARSER_INT_FRC "TNS_SDE_PARSER_INT_FRC"
#define device_bar_BDK_TNS_SDE_PARSER_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PARSER_INT_FRC 0
#define arguments_BDK_TNS_SDE_PARSER_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_parser_int_w1c
 *
 * TNS SDE Parser Interrrupt W1C Register
 * --
 */
union bdk_tns_sde_parser_int_w1c
{
    uint64_t u;
    struct bdk_tns_sde_parser_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_55_63        : 9;
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](R/W1C/H) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](R/W1C/H) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](R/W1C/H) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](R/W1C/H) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](R/W1C/H) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](R/W1C/H) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](R/W1C/H) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](R/W1C/H) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](R/W1C/H) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](R/W1C/H) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](R/W1C/H) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](R/W1C/H) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](R/W1C/H) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](R/W1C/H) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](R/W1C/H) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](R/W1C/H) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](R/W1C/H) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t templateid_sb_err     : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint64_t templateid_db_err     : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint64_t templateid_miss       : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint64_t mac2router_sb_err     : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint64_t mac2router_db_err     : 1;  /**< [  4:  4](R/W1C/H) -- */
        uint64_t mac2router_miss       : 1;  /**< [  5:  5](R/W1C/H) -- */
        uint64_t ch0_kpu_sram_sb_err   : 6;  /**< [ 11:  6](R/W1C/H) -- */
        uint64_t ch0_kpu_sram_db_err   : 6;  /**< [ 17: 12](R/W1C/H) -- */
        uint64_t ch0_kpu_tcam_sb_err   : 5;  /**< [ 22: 18](R/W1C/H) -- */
        uint64_t ch0_kpu_tcam_db_err   : 5;  /**< [ 27: 23](R/W1C/H) -- */
        uint64_t ch0_kpu_tcam_miss     : 5;  /**< [ 32: 28](R/W1C/H) -- */
        uint64_t nextengine_mem_sb_err : 1;  /**< [ 33: 33](R/W1C/H) -- */
        uint64_t nextengine_mem_db_err : 1;  /**< [ 34: 34](R/W1C/H) -- */
        uint64_t qos_mem_sb_err        : 1;  /**< [ 35: 35](R/W1C/H) -- */
        uint64_t qos_mem_db_err        : 1;  /**< [ 36: 36](R/W1C/H) -- */
        uint64_t tokencmd_mem_sb_err   : 1;  /**< [ 37: 37](R/W1C/H) -- */
        uint64_t tokencmd_mem_db_err   : 1;  /**< [ 38: 38](R/W1C/H) -- */
        uint64_t header_mem_sb_err     : 4;  /**< [ 42: 39](R/W1C/H) -- */
        uint64_t header_mem_db_err     : 4;  /**< [ 46: 43](R/W1C/H) -- */
        uint64_t info_mem_sb_err       : 4;  /**< [ 50: 47](R/W1C/H) -- */
        uint64_t info_mem_db_err       : 4;  /**< [ 54: 51](R/W1C/H) -- */
        uint64_t reserved_55_63        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_parser_int_w1c_s cn; */
};
typedef union bdk_tns_sde_parser_int_w1c bdk_tns_sde_parser_int_w1c_t;

#define BDK_TNS_SDE_PARSER_INT_W1C BDK_TNS_SDE_PARSER_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060740008ll;
    __bdk_csr_fatal("TNS_SDE_PARSER_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PARSER_INT_W1C bdk_tns_sde_parser_int_w1c_t
#define bustype_BDK_TNS_SDE_PARSER_INT_W1C BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PARSER_INT_W1C "TNS_SDE_PARSER_INT_W1C"
#define device_bar_BDK_TNS_SDE_PARSER_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PARSER_INT_W1C 0
#define arguments_BDK_TNS_SDE_PARSER_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_parser_lock
 *
 * TNS SDE Parser Lock Register
 * Lock Register
 */
union bdk_tns_sde_parser_lock
{
    uint32_t u;
    struct bdk_tns_sde_parser_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_parser_lock_s cn; */
};
typedef union bdk_tns_sde_parser_lock bdk_tns_sde_parser_lock_t;

#define BDK_TNS_SDE_PARSER_LOCK BDK_TNS_SDE_PARSER_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060740028ll;
    __bdk_csr_fatal("TNS_SDE_PARSER_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PARSER_LOCK bdk_tns_sde_parser_lock_t
#define bustype_BDK_TNS_SDE_PARSER_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PARSER_LOCK "TNS_SDE_PARSER_LOCK"
#define device_bar_BDK_TNS_SDE_PARSER_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PARSER_LOCK 0
#define arguments_BDK_TNS_SDE_PARSER_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_parser_spad
 *
 * TNS SDE Parser ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_parser_spad
{
    uint32_t u;
    struct bdk_tns_sde_parser_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_parser_spad_s cn; */
};
typedef union bdk_tns_sde_parser_spad bdk_tns_sde_parser_spad_t;

#define BDK_TNS_SDE_PARSER_SPAD BDK_TNS_SDE_PARSER_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206074002cll;
    __bdk_csr_fatal("TNS_SDE_PARSER_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PARSER_SPAD bdk_tns_sde_parser_spad_t
#define bustype_BDK_TNS_SDE_PARSER_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PARSER_SPAD "TNS_SDE_PARSER_SPAD"
#define device_bar_BDK_TNS_SDE_PARSER_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PARSER_SPAD 0
#define arguments_BDK_TNS_SDE_PARSER_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_kpu_dbg_w0
 *
 * TNS SDE PE KPU KPU Debug Word 0 Registers
 * Provides debug information about last TCAM entry
 */
union bdk_tns_sde_pe_kpux_kpu_dbg_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_kpu_dbg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 24; /**< [ 31:  8](R/W/H) -- */
        uint32_t hit                   : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t addr                  : 7;  /**< [  6:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 7;  /**< [  6:  0](R/W/H) -- */
        uint32_t hit                   : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t key                   : 24; /**< [ 31:  8](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_kpu_dbg_w0_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_kpu_dbg_w0 bdk_tns_sde_pe_kpux_kpu_dbg_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206071a004ll + 0x4000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_KPU_DBG_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(a) bdk_tns_sde_pe_kpux_kpu_dbg_w0_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(a) "TNS_SDE_PE_KPUX_KPU_DBG_W0"
#define device_bar_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_kpu_dbg_w1
 *
 * TNS SDE PE KPU KPU Debug Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_KPU_DBG_W0
 */
union bdk_tns_sde_pe_kpux_kpu_dbg_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_kpu_dbg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_kpu_dbg_w1_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_kpu_dbg_w1 bdk_tns_sde_pe_kpux_kpu_dbg_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206071a008ll + 0x4000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_KPU_DBG_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(a) bdk_tns_sde_pe_kpux_kpu_dbg_w1_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(a) "TNS_SDE_PE_KPUX_KPU_DBG_W1"
#define device_bar_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_kpu_dbg_w2
 *
 * TNS SDE PE KPU KPU Debug Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_KPU_DBG_W0
 */
union bdk_tns_sde_pe_kpux_kpu_dbg_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_kpu_dbg_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t enable                : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t valid                 : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t pindex                : 5;  /**< [  4:  0](R/W/H) If programmed to a value between 0 - 16 will capture only that ports entry */
#else /* Word 0 - Little Endian */
        uint32_t pindex                : 5;  /**< [  4:  0](R/W/H) If programmed to a value between 0 - 16 will capture only that ports entry */
        uint32_t valid                 : 1;  /**< [  5:  5](R/W/H) -- */
        uint32_t enable                : 1;  /**< [  6:  6](R/W/H) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_kpu_dbg_w2_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_kpu_dbg_w2 bdk_tns_sde_pe_kpux_kpu_dbg_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206071a00cll + 0x4000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_KPU_DBG_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(a) bdk_tns_sde_pe_kpux_kpu_dbg_w2_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(a) "TNS_SDE_PE_KPUX_KPU_DBG_W2"
#define device_bar_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_kpu_ecc_ctl
 *
 * TNS SDE PE KPU KPU ECC Control Registers
 * --
 */
union bdk_tns_sde_pe_kpux_kpu_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_kpu_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t cor_dis               : 1;  /**< [  2:  2](R/W) -- */
        uint32_t flip_sb               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t flip_db               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t flip_db               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t flip_sb               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t cor_dis               : 1;  /**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_kpu_ecc_ctl_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_kpu_ecc_ctl bdk_tns_sde_pe_kpux_kpu_ecc_ctl_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206071a000ll + 0x4000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_KPU_ECC_CTL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(a) bdk_tns_sde_pe_kpux_kpu_ecc_ctl_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(a) "TNS_SDE_PE_KPUX_KPU_ECC_CTL"
#define device_bar_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(a) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_kpu#_kpu_sram#_w0
 *
 * TNS SDE PE KPU KPU Sram Word 0 Registers
 * KPU SRAM
 * Bits[63:56] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_kpux_kpu_sramx_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_kpux_kpu_sramx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata1             : 17; /**< [ 63: 47](R/W) -- */
        uint64_t lyrptradvance0        : 6;  /**< [ 46: 41](R/W) -- */
        uint64_t lyrptradvance1        : 6;  /**< [ 40: 35](R/W) -- */
        uint64_t transitionid          : 4;  /**< [ 34: 31](R/W) -- */
        uint64_t push2stack            : 2;  /**< [ 30: 29](R/W) -- */
        uint64_t parsedone             : 1;  /**< [ 28: 28](R/W) -- */
        uint64_t layertype0            : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t layertype1            : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t offset0               : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t offset1               : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t offset2               : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t offset2               : 6;  /**< [  5:  0](R/W) -- */
        uint64_t offset1               : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t offset0               : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t layertype1            : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t layertype0            : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t parsedone             : 1;  /**< [ 28: 28](R/W) -- */
        uint64_t push2stack            : 2;  /**< [ 30: 29](R/W) -- */
        uint64_t transitionid          : 4;  /**< [ 34: 31](R/W) -- */
        uint64_t lyrptradvance1        : 6;  /**< [ 40: 35](R/W) -- */
        uint64_t lyrptradvance0        : 6;  /**< [ 46: 41](R/W) -- */
        uint64_t metadata1             : 17; /**< [ 63: 47](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_kpu_sramx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_kpu_sramx_w0 bdk_tns_sde_pe_kpux_kpu_sramx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060719000ll + 0x4000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_KPU_SRAMX_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(a,b) bdk_tns_sde_pe_kpux_kpu_sramx_w0_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(a,b) "TNS_SDE_PE_KPUX_KPU_SRAMX_W0"
#define device_bar_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_pe_kpu#_kpu_sram#_w1
 *
 * TNS SDE PE KPU KPU Sram Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_KPU_SRAM(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_kpu_sramx_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_kpux_kpu_sramx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t innereth              : 1;  /**< [ 55: 55](R/W) -- */
        uint64_t state                 : 8;  /**< [ 54: 47](R/W) -- */
        uint64_t metadata0             : 32; /**< [ 46: 15](R/W) -- */
        uint64_t metadata1             : 15; /**< [ 14:  0](R/W) Continuation of MSBs of field METADATA1 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata1             : 15; /**< [ 14:  0](R/W) Continuation of MSBs of field METADATA1 from previous word. */
        uint64_t metadata0             : 32; /**< [ 46: 15](R/W) -- */
        uint64_t state                 : 8;  /**< [ 54: 47](R/W) -- */
        uint64_t innereth              : 1;  /**< [ 55: 55](R/W) -- */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_kpu_sramx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_kpu_sramx_w1 bdk_tns_sde_pe_kpux_kpu_sramx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060719008ll + 0x4000ll * ((a) & 0x3) + 0x10ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_KPU_SRAMX_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(a,b) bdk_tns_sde_pe_kpux_kpu_sramx_w1_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(a,b) "TNS_SDE_PE_KPUX_KPU_SRAMX_W1"
#define device_bar_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_lock
 *
 * TNS SDE PE KPU Lock Registers
 * Lock Register
 */
union bdk_tns_sde_pe_kpux_lock
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_lock_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_lock bdk_tns_sde_pe_kpux_lock_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206071a010ll + 0x4000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_LOCK(a) bdk_tns_sde_pe_kpux_lock_t
#define bustype_BDK_TNS_SDE_PE_KPUX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_LOCK(a) "TNS_SDE_PE_KPUX_LOCK"
#define device_bar_BDK_TNS_SDE_PE_KPUX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_LOCK(a) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_spad
 *
 * TNS SDE PE KPU ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_pe_kpux_spad
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_spad_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_spad bdk_tns_sde_pe_kpux_spad_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206071a014ll + 0x4000ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_SPAD(a) bdk_tns_sde_pe_kpux_spad_t
#define bustype_BDK_TNS_SDE_PE_KPUX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_SPAD(a) "TNS_SDE_PE_KPUX_SPAD"
#define device_bar_BDK_TNS_SDE_PE_KPUX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_SPAD(a) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_kpu#_tcam_dat#
 *
 * TNS SDE PE KPU TCAM Data Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 */
union bdk_tns_sde_pe_kpux_tcam_datx
{
    uint64_t u;
    struct bdk_tns_sde_pe_kpux_tcam_datx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_57_63        : 7;
        uint64_t rowvalid              : 1;  /**< [ 56: 56](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t decpoint0             : 16; /**< [ 47: 32](R/W) -- */
        uint64_t decpoint1             : 16; /**< [ 31: 16](R/W) -- */
        uint64_t decpoint2             : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t decpoint2             : 16; /**< [ 15:  0](R/W) -- */
        uint64_t decpoint1             : 16; /**< [ 31: 16](R/W) -- */
        uint64_t decpoint0             : 16; /**< [ 47: 32](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 56: 56](R/W) -- */
        uint64_t reserved_57_63        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_datx_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_datx bdk_tns_sde_pe_kpux_tcam_datx_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DATX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DATX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060719800ll + 0x4000ll * ((a) & 0x3) + 8ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DATX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(a,b) bdk_tns_sde_pe_kpux_tcam_datx_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(a,b) "TNS_SDE_PE_KPUX_TCAM_DATX"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w0
 *
 * TNS SDE PE KPU TCAM Data Mask Word 0 Registers
 * This is used to access the actual KPU TCAM.
 * Bits[31:18] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w0 bdk_tns_sde_pe_kpux_tcam_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060718000ll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W0"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w1
 *
 * TNS SDE PE KPU TCAM Data Mask Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w1 bdk_tns_sde_pe_kpux_tcam_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060718004ll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W1"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w2
 *
 * TNS SDE PE KPU TCAM Data Mask Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w2 bdk_tns_sde_pe_kpux_tcam_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060718008ll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W2"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w3
 *
 * TNS SDE PE KPU TCAM Data Mask Word 3 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w3_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w3 bdk_tns_sde_pe_kpux_tcam_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x84206071800cll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W3", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W3"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w4
 *
 * TNS SDE PE KPU TCAM Data Mask Word 4 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w4
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w4_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w4 bdk_tns_sde_pe_kpux_tcam_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060718010ll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W4", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W4"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w5
 *
 * TNS SDE PE KPU TCAM Data Mask Word 5 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w5
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w5_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w5 bdk_tns_sde_pe_kpux_tcam_dmskx_w5_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060718014ll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W5", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w5_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W5"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_pe_kpu#_tcam_dmsk#_w6
 *
 * TNS SDE PE KPU TCAM Data Mask Word 6 Registers
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_kpux_tcam_dmskx_w6
{
    uint32_t u;
    struct bdk_tns_sde_pe_kpux_tcam_dmskx_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t vmvalid               : 2;  /**< [ 17: 16](R/W) -- */
        uint32_t vmdata                : 16; /**< [ 15:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 16; /**< [ 15:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
        uint32_t vmvalid               : 2;  /**< [ 17: 16](R/W) -- */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w6_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w6 bdk_tns_sde_pe_kpux_tcam_dmskx_w6_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060718018ll + 0x4000ll * ((a) & 0x3) + 0x20ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_DMSKX_W6", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(a,b) bdk_tns_sde_pe_kpux_tcam_dmskx_w6_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(a,b) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W6"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_pe_kpu#_tcam_mask#
 *
 * TNS SDE PE KPU TCAM Mask Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 */
union bdk_tns_sde_pe_kpux_tcam_maskx
{
    uint64_t u;
    struct bdk_tns_sde_pe_kpux_tcam_maskx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_57_63        : 7;
        uint64_t rowvalid              : 1;  /**< [ 56: 56](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t decpoint0             : 16; /**< [ 47: 32](R/W) -- */
        uint64_t decpoint1             : 16; /**< [ 31: 16](R/W) -- */
        uint64_t decpoint2             : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t decpoint2             : 16; /**< [ 15:  0](R/W) -- */
        uint64_t decpoint1             : 16; /**< [ 31: 16](R/W) -- */
        uint64_t decpoint0             : 16; /**< [ 47: 32](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 56: 56](R/W) -- */
        uint64_t reserved_57_63        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_kpux_tcam_maskx_s cn; */
};
typedef union bdk_tns_sde_pe_kpux_tcam_maskx bdk_tns_sde_pe_kpux_tcam_maskx_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=3) && (b<=127)))
        return 0x842060719c00ll + 0x4000ll * ((a) & 0x3) + 8ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_KPUX_TCAM_MASKX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(a,b) bdk_tns_sde_pe_kpux_tcam_maskx_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(a,b) "TNS_SDE_PE_KPUX_TCAM_MASKX"
#define device_bar_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(a,b) (a)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_cmdinfo_w0
 *
 * TNS SDE PE Layer Command Command Info Word 0 Register
 * Contains different values that are used during the token creation
 */
union bdk_tns_sde_pe_lcmd_cmdinfo_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_cmdinfo_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ismekey3mask          : 6;  /**< [ 63: 58](R/W) -- */
        uint64_t etagnxtengen          : 1;  /**< [ 57: 57](R/W) -- */
        uint64_t etagnxteng            : 8;  /**< [ 56: 49](R/W) -- */
        uint64_t errreasoncode         : 10; /**< [ 48: 39](R/W) -- */
        uint64_t errpacketcmd          : 2;  /**< [ 38: 37](R/W) -- */
        uint64_t errnxteng             : 8;  /**< [ 36: 29](R/W) Value of next engine for error packets. These packets will be marked with
                                                                 reason code as DROP */
        uint64_t pktbc                 : 14; /**< [ 28: 15](R/W) For cut through ports this is the value of pktBC assigned in the token */
        uint64_t ipv4layertype         : 5;  /**< [ 14: 10](R/W) Indicates the layer type used for IPv4 */
        uint64_t ipv6layertype         : 5;  /**< [  9:  5](R/W) Indicates the layer type used for IPv6 */
        uint64_t mplslayertype         : 5;  /**< [  4:  0](R/W) Indicates the layer type used for MPLS */
#else /* Word 0 - Little Endian */
        uint64_t mplslayertype         : 5;  /**< [  4:  0](R/W) Indicates the layer type used for MPLS */
        uint64_t ipv6layertype         : 5;  /**< [  9:  5](R/W) Indicates the layer type used for IPv6 */
        uint64_t ipv4layertype         : 5;  /**< [ 14: 10](R/W) Indicates the layer type used for IPv4 */
        uint64_t pktbc                 : 14; /**< [ 28: 15](R/W) For cut through ports this is the value of pktBC assigned in the token */
        uint64_t errnxteng             : 8;  /**< [ 36: 29](R/W) Value of next engine for error packets. These packets will be marked with
                                                                 reason code as DROP */
        uint64_t errpacketcmd          : 2;  /**< [ 38: 37](R/W) -- */
        uint64_t errreasoncode         : 10; /**< [ 48: 39](R/W) -- */
        uint64_t etagnxteng            : 8;  /**< [ 56: 49](R/W) -- */
        uint64_t etagnxtengen          : 1;  /**< [ 57: 57](R/W) -- */
        uint64_t ismekey3mask          : 6;  /**< [ 63: 58](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_cmdinfo_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w0 bdk_tns_sde_pe_lcmd_cmdinfo_w0_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 BDK_TNS_SDE_PE_LCMD_CMDINFO_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070add0ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CMDINFO_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 bdk_tns_sde_pe_lcmd_cmdinfo_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 "TNS_SDE_PE_LCMD_CMDINFO_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_cmdinfo_w1
 *
 * TNS SDE PE Layer Command Command Info Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CMDINFO_W0
 */
union bdk_tns_sde_pe_lcmd_cmdinfo_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_cmdinfo_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ismekey2mask          : 38; /**< [ 63: 26](R/W) -- */
        uint64_t ismekey3mask          : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ISMEKEY3MASK from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t ismekey3mask          : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ISMEKEY3MASK from previous word. */
        uint64_t ismekey2mask          : 38; /**< [ 63: 26](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_cmdinfo_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w1 bdk_tns_sde_pe_lcmd_cmdinfo_w1_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 BDK_TNS_SDE_PE_LCMD_CMDINFO_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070add8ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CMDINFO_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 bdk_tns_sde_pe_lcmd_cmdinfo_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 "TNS_SDE_PE_LCMD_CMDINFO_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_cmdinfo_w2
 *
 * TNS SDE PE Layer Command Command Info Word 2 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CMDINFO_W0
 */
union bdk_tns_sde_pe_lcmd_cmdinfo_w2
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_cmdinfo_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ismekey1mask          : 38; /**< [ 63: 26](R/W) -- */
        uint64_t ismekey2mask          : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ISMEKEY2MASK from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t ismekey2mask          : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ISMEKEY2MASK from previous word. */
        uint64_t ismekey1mask          : 38; /**< [ 63: 26](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_cmdinfo_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w2 bdk_tns_sde_pe_lcmd_cmdinfo_w2_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 BDK_TNS_SDE_PE_LCMD_CMDINFO_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ade0ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CMDINFO_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 bdk_tns_sde_pe_lcmd_cmdinfo_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 "TNS_SDE_PE_LCMD_CMDINFO_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_cmdinfo_w3
 *
 * TNS SDE PE Layer Command Command Info Word 3 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CMDINFO_W0
 */
union bdk_tns_sde_pe_lcmd_cmdinfo_w3
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_cmdinfo_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_58_63        : 6;
        uint64_t ismekey0mask          : 32; /**< [ 57: 26](R/W) -- */
        uint64_t ismekey1mask          : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ISMEKEY1MASK from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t ismekey1mask          : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field ISMEKEY1MASK from previous word. */
        uint64_t ismekey0mask          : 32; /**< [ 57: 26](R/W) -- */
        uint64_t reserved_58_63        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_cmdinfo_w3_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w3 bdk_tns_sde_pe_lcmd_cmdinfo_w3_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 BDK_TNS_SDE_PE_LCMD_CMDINFO_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ade8ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CMDINFO_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 bdk_tns_sde_pe_lcmd_cmdinfo_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 "TNS_SDE_PE_LCMD_CMDINFO_W3"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_cnncmd#
 *
 * TNS SDE PE Layer Command Canon Commands Registers
 * Contains canon commands for layers which match the stored layerType and
 * layerHash values
 */
union bdk_tns_sde_pe_lcmd_cnncmdx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_cnncmdx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t layertype             : 5;  /**< [ 40: 36](R/W) -- */
        uint64_t layerhash             : 4;  /**< [ 35: 32](R/W) -- */
        uint64_t contbytes             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t bitvector             : 24; /**< [ 23:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t bitvector             : 24; /**< [ 23:  0](R/W) -- */
        uint64_t contbytes             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t layerhash             : 4;  /**< [ 35: 32](R/W) -- */
        uint64_t layertype             : 5;  /**< [ 40: 36](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_cnncmdx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_cnncmdx bdk_tns_sde_pe_lcmd_cnncmdx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_CNNCMDX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CNNCMDX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=35))
        return 0x84206070a000ll + 8ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CNNCMDX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CNNCMDX(a) bdk_tns_sde_pe_lcmd_cnncmdx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CNNCMDX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_CNNCMDX(a) "TNS_SDE_PE_LCMD_CNNCMDX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CNNCMDX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CNNCMDX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_CNNCMDX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ctl_w0
 *
 * TNS SDE PE Layer Command Control Word 0 Register
 * This register is used for debug purpose only
 */
union bdk_tns_sde_pe_lcmd_ctl_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ctl_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t info_mem_spare        : 20; /**< [ 31: 12](R/W) -- */
        uint32_t info_mem_addr         : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t header_mem_addr       : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t header_mem_addr       : 6;  /**< [  5:  0](R/W) -- */
        uint32_t info_mem_addr         : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t info_mem_spare        : 20; /**< [ 31: 12](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ctl_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ctl_w0 bdk_tns_sde_pe_lcmd_ctl_w0_t;

#define BDK_TNS_SDE_PE_LCMD_CTL_W0 BDK_TNS_SDE_PE_LCMD_CTL_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad24ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CTL_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CTL_W0 bdk_tns_sde_pe_lcmd_ctl_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CTL_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_CTL_W0 "TNS_SDE_PE_LCMD_CTL_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CTL_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CTL_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CTL_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ctl_w1
 *
 * TNS SDE PE Layer Command Control Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CTL_W0
 */
union bdk_tns_sde_pe_lcmd_ctl_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ctl_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pindex_fifo_threshold : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t token_fifo_threshold  : 5;  /**< [ 27: 23](R/W) -- */
        uint32_t hdr_buff_fifo_threshold : 4;/**< [ 22: 19](R/W) -- */
        uint32_t pindex                : 5;  /**< [ 18: 14](R/W) -- */
        uint32_t linklist_entry        : 6;  /**< [ 13:  8](R/W) -- */
        uint32_t info_mem_spare        : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field INFO_MEM_SPARE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t info_mem_spare        : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field INFO_MEM_SPARE from previous word. */
        uint32_t linklist_entry        : 6;  /**< [ 13:  8](R/W) -- */
        uint32_t pindex                : 5;  /**< [ 18: 14](R/W) -- */
        uint32_t hdr_buff_fifo_threshold : 4;/**< [ 22: 19](R/W) -- */
        uint32_t token_fifo_threshold  : 5;  /**< [ 27: 23](R/W) -- */
        uint32_t pindex_fifo_threshold : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ctl_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ctl_w1 bdk_tns_sde_pe_lcmd_ctl_w1_t;

#define BDK_TNS_SDE_PE_LCMD_CTL_W1 BDK_TNS_SDE_PE_LCMD_CTL_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad28ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CTL_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CTL_W1 bdk_tns_sde_pe_lcmd_ctl_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CTL_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_CTL_W1 "TNS_SDE_PE_LCMD_CTL_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CTL_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CTL_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CTL_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ctl_w2
 *
 * TNS SDE PE Layer Command Control Word 2 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CTL_W0
 */
union bdk_tns_sde_pe_lcmd_ctl_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ctl_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t hdr_addr_fifo_threshold : 5;/**< [  7:  3](R/W) -- */
        uint32_t pindex_fifo_threshold : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field PINDEX_FIFO_THRESHOLD from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pindex_fifo_threshold : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field PINDEX_FIFO_THRESHOLD from previous word. */
        uint32_t hdr_addr_fifo_threshold : 5;/**< [  7:  3](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ctl_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ctl_w2 bdk_tns_sde_pe_lcmd_ctl_w2_t;

#define BDK_TNS_SDE_PE_LCMD_CTL_W2 BDK_TNS_SDE_PE_LCMD_CTL_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad2cll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_CTL_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_CTL_W2 bdk_tns_sde_pe_lcmd_ctl_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CTL_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_CTL_W2 "TNS_SDE_PE_LCMD_CTL_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_CTL_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_CTL_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CTL_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_errorbodyptr
 *
 * TNS SDE PE Layer Command Error Body Pointer Register
 * Format for both mask and value is {body_ptr_vld, body_ptr[13:0]}. If
 * bit in mask is set, incoming bit is compared against corresponding value
 * bit.
 * If they match, the packet is considered to be received with an error.
 */
union bdk_tns_sde_pe_lcmd_errorbodyptr
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_errorbodyptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t mask                  : 15; /**< [ 29: 15](R/W) -- */
        uint32_t value                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t value                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t mask                  : 15; /**< [ 29: 15](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_errorbodyptr_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_errorbodyptr bdk_tns_sde_pe_lcmd_errorbodyptr_t;

#define BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae14ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ERRORBODYPTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR bdk_tns_sde_pe_lcmd_errorbodyptr_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR "TNS_SDE_PE_LCMD_ERRORBODYPTR"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR 0
#define arguments_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ethernetctrl#
 *
 * TNS SDE PE Layer Command Ethernet Layer Control Registers
 * Contains the ether-type and vlan offset values that are used for etherent layer
 */
union bdk_tns_sde_pe_lcmd_ethernetctrlx
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ethernetctrlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t offset2               : 6;  /**< [ 23: 18](R/W) -- */
        uint32_t offset1               : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t offset0               : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t etagen                : 1;  /**< [  5:  5](R/W) -- */
        uint32_t layertype             : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t layertype             : 5;  /**< [  4:  0](R/W) -- */
        uint32_t etagen                : 1;  /**< [  5:  5](R/W) -- */
        uint32_t offset0               : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t offset1               : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t offset2               : 6;  /**< [ 23: 18](R/W) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ethernetctrlx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ethernetctrlx bdk_tns_sde_pe_lcmd_ethernetctrlx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2))
        return 0x84206070ad00ll + 4ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ETHERNETCTRLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(a) bdk_tns_sde_pe_lcmd_ethernetctrlx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(a) "TNS_SDE_PE_LCMD_ETHERNETCTRLX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_hashcmds#_w0
 *
 * TNS SDE PE Layer Command Hash Commands Word 0 Registers
 * Contains commands to form the hash logic input. Each command can copy a max of
 * 4 bytes
 * Bits[31:4] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_lcmd_hashcmdsx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_hashcmdsx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t layeroffset1          : 3;  /**< [ 31: 29](R/W) -- */
        uint32_t fieldlen1             : 3;  /**< [ 28: 26](R/W) -- */
        uint32_t hashmask1             : 8;  /**< [ 25: 18](R/W) -- */
        uint32_t hashmaskmsb1          : 1;  /**< [ 17: 17](R/W) -- */
        uint32_t layeroffset0          : 5;  /**< [ 16: 12](R/W) -- */
        uint32_t fieldlen0             : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t hashmask0             : 8;  /**< [  8:  1](R/W) -- */
        uint32_t hashmaskmsb0          : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t hashmaskmsb0          : 1;  /**< [  0:  0](R/W) -- */
        uint32_t hashmask0             : 8;  /**< [  8:  1](R/W) -- */
        uint32_t fieldlen0             : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t layeroffset0          : 5;  /**< [ 16: 12](R/W) -- */
        uint32_t hashmaskmsb1          : 1;  /**< [ 17: 17](R/W) -- */
        uint32_t hashmask1             : 8;  /**< [ 25: 18](R/W) -- */
        uint32_t fieldlen1             : 3;  /**< [ 28: 26](R/W) -- */
        uint32_t layeroffset1          : 3;  /**< [ 31: 29](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_hashcmdsx_w0 bdk_tns_sde_pe_lcmd_hashcmdsx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206070a200ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_HASHCMDSX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(a) bdk_tns_sde_pe_lcmd_hashcmdsx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(a) "TNS_SDE_PE_LCMD_HASHCMDSX_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_hashcmds#_w1
 *
 * TNS SDE PE Layer Command Hash Commands Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_HASHCMDS(0..31)_W0
 */
union bdk_tns_sde_pe_lcmd_hashcmdsx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_hashcmdsx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t layeroffset3          : 1;  /**< [ 31: 31](R/W) -- */
        uint32_t fieldlen3             : 3;  /**< [ 30: 28](R/W) -- */
        uint32_t hashmask3             : 8;  /**< [ 27: 20](R/W) -- */
        uint32_t hashmaskmsb3          : 1;  /**< [ 19: 19](R/W) -- */
        uint32_t layeroffset2          : 5;  /**< [ 18: 14](R/W) -- */
        uint32_t fieldlen2             : 3;  /**< [ 13: 11](R/W) -- */
        uint32_t hashmask2             : 8;  /**< [ 10:  3](R/W) -- */
        uint32_t hashmaskmsb2          : 1;  /**< [  2:  2](R/W) -- */
        uint32_t layeroffset1          : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field LAYEROFFSET1 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t layeroffset1          : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field LAYEROFFSET1 from previous word. */
        uint32_t hashmaskmsb2          : 1;  /**< [  2:  2](R/W) -- */
        uint32_t hashmask2             : 8;  /**< [ 10:  3](R/W) -- */
        uint32_t fieldlen2             : 3;  /**< [ 13: 11](R/W) -- */
        uint32_t layeroffset2          : 5;  /**< [ 18: 14](R/W) -- */
        uint32_t hashmaskmsb3          : 1;  /**< [ 19: 19](R/W) -- */
        uint32_t hashmask3             : 8;  /**< [ 27: 20](R/W) -- */
        uint32_t fieldlen3             : 3;  /**< [ 30: 28](R/W) -- */
        uint32_t layeroffset3          : 1;  /**< [ 31: 31](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_hashcmdsx_w1 bdk_tns_sde_pe_lcmd_hashcmdsx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206070a204ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_HASHCMDSX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(a) bdk_tns_sde_pe_lcmd_hashcmdsx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(a) "TNS_SDE_PE_LCMD_HASHCMDSX_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_hashcmds#_w2
 *
 * TNS SDE PE Layer Command Hash Commands Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_HASHCMDS(0..31)_W0
 */
union bdk_tns_sde_pe_lcmd_hashcmdsx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_hashcmdsx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t layeroffset3          : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field LAYEROFFSET3 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t layeroffset3          : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field LAYEROFFSET3 from previous word. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_hashcmdsx_w2 bdk_tns_sde_pe_lcmd_hashcmdsx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206070a208ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_HASHCMDSX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(a) bdk_tns_sde_pe_lcmd_hashcmdsx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(a) "TNS_SDE_PE_LCMD_HASHCMDSX_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_hashctrl_w0
 *
 * TNS SDE PE Layer Command Hash Generation Control Word 0 Register
 * Controls which polynomial is used for which hash generation. The polynomials
 * used are: 0: 2011 1: 2415 2: 2461 3: 2745 4: 2431 5: 2707 6: 2055 7: 2157.
 * Polynomials for lag are 0: 435 1: 567 2: 763 3: 551
 */
union bdk_tns_sde_pe_lcmd_hashctrl_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_hashctrl_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seed4                 : 8;  /**< [ 63: 56](R/W) -- */
        uint64_t seed3                 : 10; /**< [ 55: 46](R/W) -- */
        uint64_t seed2                 : 10; /**< [ 45: 36](R/W) -- */
        uint64_t seed1                 : 10; /**< [ 35: 26](R/W) -- */
        uint64_t seed0                 : 10; /**< [ 25: 16](R/W) -- */
        uint64_t laghasha              : 2;  /**< [ 15: 14](R/W) Indicates which hash function should be used for lag_hash_a */
        uint64_t laghashb              : 2;  /**< [ 13: 12](R/W) Indicates which hash function should be used for lag_hash_b */
        uint64_t l2ecmphasha           : 3;  /**< [ 11:  9](R/W) Indicates which hash function should be used for l2_ecmp_hash_a */
        uint64_t l2ecmphashb           : 3;  /**< [  8:  6](R/W) Indicates which hash function should be used for l2_ecmp_hash_b */
        uint64_t l3ecmphasha           : 3;  /**< [  5:  3](R/W) Indicates which hash function should be used for l3_ecmp_hash_a */
        uint64_t l3ecmphashb           : 3;  /**< [  2:  0](R/W) Indicates which hash function should be used for l3_ecmp_hash_b */
#else /* Word 0 - Little Endian */
        uint64_t l3ecmphashb           : 3;  /**< [  2:  0](R/W) Indicates which hash function should be used for l3_ecmp_hash_b */
        uint64_t l3ecmphasha           : 3;  /**< [  5:  3](R/W) Indicates which hash function should be used for l3_ecmp_hash_a */
        uint64_t l2ecmphashb           : 3;  /**< [  8:  6](R/W) Indicates which hash function should be used for l2_ecmp_hash_b */
        uint64_t l2ecmphasha           : 3;  /**< [ 11:  9](R/W) Indicates which hash function should be used for l2_ecmp_hash_a */
        uint64_t laghashb              : 2;  /**< [ 13: 12](R/W) Indicates which hash function should be used for lag_hash_b */
        uint64_t laghasha              : 2;  /**< [ 15: 14](R/W) Indicates which hash function should be used for lag_hash_a */
        uint64_t seed0                 : 10; /**< [ 25: 16](R/W) -- */
        uint64_t seed1                 : 10; /**< [ 35: 26](R/W) -- */
        uint64_t seed2                 : 10; /**< [ 45: 36](R/W) -- */
        uint64_t seed3                 : 10; /**< [ 55: 46](R/W) -- */
        uint64_t seed4                 : 8;  /**< [ 63: 56](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_hashctrl_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_hashctrl_w0 bdk_tns_sde_pe_lcmd_hashctrl_w0_t;

#define BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adf0ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_HASHCTRL_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 bdk_tns_sde_pe_lcmd_hashctrl_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 "TNS_SDE_PE_LCMD_HASHCTRL_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_hashctrl_w1
 *
 * TNS SDE PE Layer Command Hash Generation Control Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_HASHCTRL_W0
 */
union bdk_tns_sde_pe_lcmd_hashctrl_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_hashctrl_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t seed8_3               : 8;  /**< [ 63: 56](R/W) -- */
        uint64_t seed8_2               : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t seed8_1               : 8;  /**< [ 47: 40](R/W) -- */
        uint64_t seed8_0               : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t seed7                 : 10; /**< [ 31: 22](R/W) -- */
        uint64_t seed6                 : 10; /**< [ 21: 12](R/W) -- */
        uint64_t seed5                 : 10; /**< [ 11:  2](R/W) -- */
        uint64_t seed4                 : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field SEED4 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t seed4                 : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field SEED4 from previous word. */
        uint64_t seed5                 : 10; /**< [ 11:  2](R/W) -- */
        uint64_t seed6                 : 10; /**< [ 21: 12](R/W) -- */
        uint64_t seed7                 : 10; /**< [ 31: 22](R/W) -- */
        uint64_t seed8_0               : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t seed8_1               : 8;  /**< [ 47: 40](R/W) -- */
        uint64_t seed8_2               : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t seed8_3               : 8;  /**< [ 63: 56](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_hashctrl_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_hashctrl_w1 bdk_tns_sde_pe_lcmd_hashctrl_w1_t;

#define BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adf8ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_HASHCTRL_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 bdk_tns_sde_pe_lcmd_hashctrl_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 "TNS_SDE_PE_LCMD_HASHCTRL_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_hmem_dat_w#
 *
 * TNS SDE PE Layer Command Header Memory Data Registers
 * --
 */
union bdk_tns_sde_pe_lcmd_hmem_dat_wx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_hmem_dat_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_hmem_dat_wx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_hmem_dat_wx bdk_tns_sde_pe_lcmd_hmem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84206070ad30ll + 8ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_HMEM_DAT_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(a) bdk_tns_sde_pe_lcmd_hmem_dat_wx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(a) "TNS_SDE_PE_LCMD_HMEM_DAT_WX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w0
 *
 * TNS SDE PE Layer Command Info Memory Data Word 0 Register
 * --
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t timestamp             : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t timestamp             : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w0 bdk_tns_sde_pe_lcmd_imem_dat_w0_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad70ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 bdk_tns_sde_pe_lcmd_imem_dat_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 "TNS_SDE_PE_LCMD_IMEM_DAT_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w1
 *
 * TNS SDE PE Layer Command Info Memory Data Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata6             : 22; /**< [ 63: 42](R/W/H) -- */
        uint64_t metadata7             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t pkt_id                : 10; /**< [  9:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t pkt_id                : 10; /**< [  9:  0](R/W/H) -- */
        uint64_t metadata7             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata6             : 22; /**< [ 63: 42](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w1 bdk_tns_sde_pe_lcmd_imem_dat_w1_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad78ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 bdk_tns_sde_pe_lcmd_imem_dat_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 "TNS_SDE_PE_LCMD_IMEM_DAT_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w2
 *
 * TNS SDE PE Layer Command Info Memory Data Word 2 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w2
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata4             : 22; /**< [ 63: 42](R/W/H) -- */
        uint64_t metadata5             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata6             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA6 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata6             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA6 from previous word. */
        uint64_t metadata5             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata4             : 22; /**< [ 63: 42](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w2 bdk_tns_sde_pe_lcmd_imem_dat_w2_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad80ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 bdk_tns_sde_pe_lcmd_imem_dat_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 "TNS_SDE_PE_LCMD_IMEM_DAT_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w3
 *
 * TNS SDE PE Layer Command Info Memory Data Word 3 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w3
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata2             : 22; /**< [ 63: 42](R/W/H) -- */
        uint64_t metadata3             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata4             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA4 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata4             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA4 from previous word. */
        uint64_t metadata3             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata2             : 22; /**< [ 63: 42](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w3_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w3 bdk_tns_sde_pe_lcmd_imem_dat_w3_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad88ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 bdk_tns_sde_pe_lcmd_imem_dat_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 "TNS_SDE_PE_LCMD_IMEM_DAT_W3"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w4
 *
 * TNS SDE PE Layer Command Info Memory Data Word 4 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w4
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata0             : 22; /**< [ 63: 42](R/W/H) -- */
        uint64_t metadata1             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata2             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA2 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata2             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA2 from previous word. */
        uint64_t metadata1             : 32; /**< [ 41: 10](R/W/H) -- */
        uint64_t metadata0             : 22; /**< [ 63: 42](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w4_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w4 bdk_tns_sde_pe_lcmd_imem_dat_w4_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad90ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 bdk_tns_sde_pe_lcmd_imem_dat_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 "TNS_SDE_PE_LCMD_IMEM_DAT_W4"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w5
 *
 * TNS SDE PE Layer Command Info Memory Data Word 5 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w5
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t layertype2            : 5;  /**< [ 63: 59](R/W/H) -- */
        uint64_t layerhash2            : 4;  /**< [ 58: 55](R/W/H) -- */
        uint64_t layertype3            : 5;  /**< [ 54: 50](R/W/H) -- */
        uint64_t layerhash3            : 4;  /**< [ 49: 46](R/W/H) -- */
        uint64_t layertype4            : 5;  /**< [ 45: 41](R/W/H) -- */
        uint64_t layerhash4            : 4;  /**< [ 40: 37](R/W/H) -- */
        uint64_t layertype5            : 5;  /**< [ 36: 32](R/W/H) -- */
        uint64_t layerhash5            : 4;  /**< [ 31: 28](R/W/H) -- */
        uint64_t layertype6            : 5;  /**< [ 27: 23](R/W/H) -- */
        uint64_t layerhash6            : 4;  /**< [ 22: 19](R/W/H) -- */
        uint64_t layertype7            : 5;  /**< [ 18: 14](R/W/H) -- */
        uint64_t layerhash7            : 4;  /**< [ 13: 10](R/W/H) -- */
        uint64_t metadata0             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA0 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata0             : 10; /**< [  9:  0](R/W/H) Continuation of MSBs of field METADATA0 from previous word. */
        uint64_t layerhash7            : 4;  /**< [ 13: 10](R/W/H) -- */
        uint64_t layertype7            : 5;  /**< [ 18: 14](R/W/H) -- */
        uint64_t layerhash6            : 4;  /**< [ 22: 19](R/W/H) -- */
        uint64_t layertype6            : 5;  /**< [ 27: 23](R/W/H) -- */
        uint64_t layerhash5            : 4;  /**< [ 31: 28](R/W/H) -- */
        uint64_t layertype5            : 5;  /**< [ 36: 32](R/W/H) -- */
        uint64_t layerhash4            : 4;  /**< [ 40: 37](R/W/H) -- */
        uint64_t layertype4            : 5;  /**< [ 45: 41](R/W/H) -- */
        uint64_t layerhash3            : 4;  /**< [ 49: 46](R/W/H) -- */
        uint64_t layertype3            : 5;  /**< [ 54: 50](R/W/H) -- */
        uint64_t layerhash2            : 4;  /**< [ 58: 55](R/W/H) -- */
        uint64_t layertype2            : 5;  /**< [ 63: 59](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w5_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w5 bdk_tns_sde_pe_lcmd_imem_dat_w5_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad98ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W5", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 bdk_tns_sde_pe_lcmd_imem_dat_w5_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 "TNS_SDE_PE_LCMD_IMEM_DAT_W5"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w6
 *
 * TNS SDE PE Layer Command Info Memory Data Word 6 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w6
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t layerendptr2          : 6;  /**< [ 63: 58](R/W/H) -- */
        uint64_t layerendptr3          : 8;  /**< [ 57: 50](R/W/H) -- */
        uint64_t layerendptr4          : 8;  /**< [ 49: 42](R/W/H) -- */
        uint64_t layerendptr5          : 8;  /**< [ 41: 34](R/W/H) -- */
        uint64_t layerendptr6          : 8;  /**< [ 33: 26](R/W/H) -- */
        uint64_t layerendptr7          : 8;  /**< [ 25: 18](R/W/H) -- */
        uint64_t layertype0            : 5;  /**< [ 17: 13](R/W/H) -- */
        uint64_t layerhash0            : 4;  /**< [ 12:  9](R/W/H) -- */
        uint64_t layertype1            : 5;  /**< [  8:  4](R/W/H) -- */
        uint64_t layerhash1            : 4;  /**< [  3:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t layerhash1            : 4;  /**< [  3:  0](R/W/H) -- */
        uint64_t layertype1            : 5;  /**< [  8:  4](R/W/H) -- */
        uint64_t layerhash0            : 4;  /**< [ 12:  9](R/W/H) -- */
        uint64_t layertype0            : 5;  /**< [ 17: 13](R/W/H) -- */
        uint64_t layerendptr7          : 8;  /**< [ 25: 18](R/W/H) -- */
        uint64_t layerendptr6          : 8;  /**< [ 33: 26](R/W/H) -- */
        uint64_t layerendptr5          : 8;  /**< [ 41: 34](R/W/H) -- */
        uint64_t layerendptr4          : 8;  /**< [ 49: 42](R/W/H) -- */
        uint64_t layerendptr3          : 8;  /**< [ 57: 50](R/W/H) -- */
        uint64_t layerendptr2          : 6;  /**< [ 63: 58](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w6_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w6 bdk_tns_sde_pe_lcmd_imem_dat_w6_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ada0ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W6", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 bdk_tns_sde_pe_lcmd_imem_dat_w6_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 "TNS_SDE_PE_LCMD_IMEM_DAT_W6"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_imem_dat_w7
 *
 * TNS SDE PE Layer Command Info Memory Data Word 7 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 */
union bdk_tns_sde_pe_lcmd_imem_dat_w7
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_imem_dat_w7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t spare                 : 28; /**< [ 63: 36](R/W/H) -- */
        uint64_t xphexists             : 1;  /**< [ 35: 35](R/W/H) -- */
        uint64_t hts_exists            : 1;  /**< [ 34: 34](R/W/H) -- */
        uint64_t startptr              : 8;  /**< [ 33: 26](R/W/H) -- */
        uint64_t pnum                  : 8;  /**< [ 25: 18](R/W/H) -- */
        uint64_t layerendptr0          : 8;  /**< [ 17: 10](R/W/H) -- */
        uint64_t layerendptr1          : 8;  /**< [  9:  2](R/W/H) -- */
        uint64_t layerendptr2          : 2;  /**< [  1:  0](R/W/H) Continuation of MSBs of field LAYERENDPTR2 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t layerendptr2          : 2;  /**< [  1:  0](R/W/H) Continuation of MSBs of field LAYERENDPTR2 from previous word. */
        uint64_t layerendptr1          : 8;  /**< [  9:  2](R/W/H) -- */
        uint64_t layerendptr0          : 8;  /**< [ 17: 10](R/W/H) -- */
        uint64_t pnum                  : 8;  /**< [ 25: 18](R/W/H) -- */
        uint64_t startptr              : 8;  /**< [ 33: 26](R/W/H) -- */
        uint64_t hts_exists            : 1;  /**< [ 34: 34](R/W/H) -- */
        uint64_t xphexists             : 1;  /**< [ 35: 35](R/W/H) -- */
        uint64_t spare                 : 28; /**< [ 63: 36](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_imem_dat_w7_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w7 bdk_tns_sde_pe_lcmd_imem_dat_w7_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ada8ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_IMEM_DAT_W7", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 bdk_tns_sde_pe_lcmd_imem_dat_w7_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 "TNS_SDE_PE_LCMD_IMEM_DAT_W7"
#define device_bar_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_itt#_w0
 *
 * TNS SDE PE Layer Command ITT Word 0 Registers
 * Initial Token Table contains fields that will be used in the token as is
 * Bits[31:25] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_lcmd_ittx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ittx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t filter_grp_num        : 8;  /**< [ 29: 22](R/W) -- */
        uint32_t layer2qosen           : 1;  /**< [ 21: 21](R/W) -- */
        uint32_t ip2qosen              : 1;  /**< [ 20: 20](R/W) -- */
        uint32_t mpls2qosen            : 1;  /**< [ 19: 19](R/W) -- */
        uint32_t porttrafficclass      : 4;  /**< [ 18: 15](R/W) -- */
        uint32_t portdropprecedence    : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t portpcp               : 3;  /**< [ 12: 10](R/W) -- */
        uint32_t portdei               : 1;  /**< [  9:  9](R/W) -- */
        uint32_t portdscp              : 6;  /**< [  8:  3](R/W) -- */
        uint32_t portexp               : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t portexp               : 3;  /**< [  2:  0](R/W) -- */
        uint32_t portdscp              : 6;  /**< [  8:  3](R/W) -- */
        uint32_t portdei               : 1;  /**< [  9:  9](R/W) -- */
        uint32_t portpcp               : 3;  /**< [ 12: 10](R/W) -- */
        uint32_t portdropprecedence    : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t porttrafficclass      : 4;  /**< [ 18: 15](R/W) -- */
        uint32_t mpls2qosen            : 1;  /**< [ 19: 19](R/W) -- */
        uint32_t ip2qosen              : 1;  /**< [ 20: 20](R/W) -- */
        uint32_t layer2qosen           : 1;  /**< [ 21: 21](R/W) -- */
        uint32_t filter_grp_num        : 8;  /**< [ 29: 22](R/W) -- */
        uint32_t scratchpad            : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ittx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ittx_w0 bdk_tns_sde_pe_lcmd_ittx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x842060704000ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ITTX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W0(a) bdk_tns_sde_pe_lcmd_ittx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W0(a) "TNS_SDE_PE_LCMD_ITTX_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ITTX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_itt#_w1
 *
 * TNS SDE PE Layer Command ITT Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 */
union bdk_tns_sde_pe_lcmd_ittx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ittx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field SCRATCHPAD from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field SCRATCHPAD from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ittx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ittx_w1 bdk_tns_sde_pe_lcmd_ittx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x842060704004ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ITTX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W1(a) bdk_tns_sde_pe_lcmd_ittx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W1(a) "TNS_SDE_PE_LCMD_ITTX_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ITTX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_itt#_w2
 *
 * TNS SDE PE Layer Command ITT Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 */
union bdk_tns_sde_pe_lcmd_ittx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ittx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mirrorbitmask         : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t scratchpad            : 30; /**< [ 29:  0](R/W) Continuation of MSBs of field SCRATCHPAD from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 30; /**< [ 29:  0](R/W) Continuation of MSBs of field SCRATCHPAD from previous word. */
        uint32_t mirrorbitmask         : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ittx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ittx_w2 bdk_tns_sde_pe_lcmd_ittx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x842060704008ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ITTX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W2(a) bdk_tns_sde_pe_lcmd_ittx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W2(a) "TNS_SDE_PE_LCMD_ITTX_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ITTX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_itt#_w3
 *
 * TNS SDE PE Layer Command ITT Word 3 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 */
union bdk_tns_sde_pe_lcmd_ittx_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ittx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ingressvif            : 18; /**< [ 31: 14](R/W) -- */
        uint32_t mirrorbitmask         : 14; /**< [ 13:  0](R/W) Continuation of MSBs of field MIRRORBITMASK from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t mirrorbitmask         : 14; /**< [ 13:  0](R/W) Continuation of MSBs of field MIRRORBITMASK from previous word. */
        uint32_t ingressvif            : 18; /**< [ 31: 14](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ittx_w3_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ittx_w3 bdk_tns_sde_pe_lcmd_ittx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x84206070400cll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ITTX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W3(a) bdk_tns_sde_pe_lcmd_ittx_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W3(a) "TNS_SDE_PE_LCMD_ITTX_W3"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ITTX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W3(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_itt#_w4
 *
 * TNS SDE PE Layer Command ITT Word 4 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 */
union bdk_tns_sde_pe_lcmd_ittx_w4
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ittx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t etagexists            : 1;  /**< [ 24: 24](R/W) -- */
        uint32_t l2qosprofile          : 3;  /**< [ 23: 21](R/W) -- */
        uint32_t ipqosprofile          : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t mplsqosprofile        : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t pvid                  : 12; /**< [ 14:  3](R/W) -- */
        uint32_t pvidmodeallpkt        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t ingressvif            : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field INGRESSVIF from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t ingressvif            : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field INGRESSVIF from previous word. */
        uint32_t pvidmodeallpkt        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t pvid                  : 12; /**< [ 14:  3](R/W) -- */
        uint32_t mplsqosprofile        : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t ipqosprofile          : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t l2qosprofile          : 3;  /**< [ 23: 21](R/W) -- */
        uint32_t etagexists            : 1;  /**< [ 24: 24](R/W) -- */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ittx_w4_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ittx_w4 bdk_tns_sde_pe_lcmd_ittx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x842060704010ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_ITTX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W4(a) bdk_tns_sde_pe_lcmd_ittx_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W4(a) "TNS_SDE_PE_LCMD_ITTX_W4"
#define device_bar_BDK_TNS_SDE_PE_LCMD_ITTX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W4(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_lock
 *
 * TNS SDE PE Layer Command Lock Register
 * Lock Register
 */
union bdk_tns_sde_pe_lcmd_lock
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_lock_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_lock bdk_tns_sde_pe_lcmd_lock_t;

#define BDK_TNS_SDE_PE_LCMD_LOCK BDK_TNS_SDE_PE_LCMD_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae18ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_LOCK bdk_tns_sde_pe_lcmd_lock_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_LOCK "TNS_SDE_PE_LCMD_LOCK"
#define device_bar_BDK_TNS_SDE_PE_LCMD_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_LOCK 0
#define arguments_BDK_TNS_SDE_PE_LCMD_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_lsplitcmd#
 *
 * TNS SDE PE Layer Command Layer Split Command Registers
 * --
 */
union bdk_tns_sde_pe_lcmd_lsplitcmdx
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_lsplitcmdx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t layertype             : 5;  /**< [ 15: 11](R/W) -- */
        uint32_t newlayertype          : 5;  /**< [ 10:  6](R/W) -- */
        uint32_t splitbytes            : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t splitbytes            : 6;  /**< [  5:  0](R/W) -- */
        uint32_t newlayertype          : 5;  /**< [ 10:  6](R/W) -- */
        uint32_t layertype             : 5;  /**< [ 15: 11](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_lsplitcmdx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_lsplitcmdx bdk_tns_sde_pe_lcmd_lsplitcmdx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206070ad10ll + 4ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_LSPLITCMDX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(a) bdk_tns_sde_pe_lcmd_lsplitcmdx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(a) "TNS_SDE_PE_LCMD_LSPLITCMDX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ltokencmd#_w0
 *
 * TNS SDE PE Layer Command Layer Token Command Word 0 Registers
 * Contains commands that indicate how the layer portion in the token should be
 * build. Each cmd can copy a max of 8 bytes
 * Bits[31:9] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_lcmd_ltokencmdx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ltokencmdx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t fieldlen3             : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t layeroffset2          : 6;  /**< [ 29: 24](R/W) -- */
        uint32_t fieldlen2             : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t layeroffset1          : 6;  /**< [ 19: 14](R/W) -- */
        uint32_t fieldlen1             : 4;  /**< [ 13: 10](R/W) -- */
        uint32_t layeroffset0          : 6;  /**< [  9:  4](R/W) -- */
        uint32_t fieldlen0             : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t fieldlen0             : 4;  /**< [  3:  0](R/W) -- */
        uint32_t layeroffset0          : 6;  /**< [  9:  4](R/W) -- */
        uint32_t fieldlen1             : 4;  /**< [ 13: 10](R/W) -- */
        uint32_t layeroffset1          : 6;  /**< [ 19: 14](R/W) -- */
        uint32_t fieldlen2             : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t layeroffset2          : 6;  /**< [ 29: 24](R/W) -- */
        uint32_t fieldlen3             : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ltokencmdx_w0 bdk_tns_sde_pe_lcmd_ltokencmdx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206070a400ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_LTOKENCMDX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(a) bdk_tns_sde_pe_lcmd_ltokencmdx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(a) "TNS_SDE_PE_LCMD_LTOKENCMDX_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ltokencmd#_w1
 *
 * TNS SDE PE Layer Command Layer Token Command Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_LTOKENCMD(0..31)_W0
 */
union bdk_tns_sde_pe_lcmd_ltokencmdx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ltokencmdx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t fieldlen6             : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t layeroffset5          : 6;  /**< [ 27: 22](R/W) -- */
        uint32_t fieldlen5             : 4;  /**< [ 21: 18](R/W) -- */
        uint32_t layeroffset4          : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t fieldlen4             : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t layeroffset3          : 6;  /**< [  7:  2](R/W) -- */
        uint32_t fieldlen3             : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field FIELDLEN3 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t fieldlen3             : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field FIELDLEN3 from previous word. */
        uint32_t layeroffset3          : 6;  /**< [  7:  2](R/W) -- */
        uint32_t fieldlen4             : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t layeroffset4          : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t fieldlen5             : 4;  /**< [ 21: 18](R/W) -- */
        uint32_t layeroffset5          : 6;  /**< [ 27: 22](R/W) -- */
        uint32_t fieldlen6             : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ltokencmdx_w1 bdk_tns_sde_pe_lcmd_ltokencmdx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206070a404ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_LTOKENCMDX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(a) bdk_tns_sde_pe_lcmd_ltokencmdx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(a) "TNS_SDE_PE_LCMD_LTOKENCMDX_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_ltokencmd#_w2
 *
 * TNS SDE PE Layer Command Layer Token Command Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_LTOKENCMD(0..31)_W0
 */
union bdk_tns_sde_pe_lcmd_ltokencmdx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_ltokencmdx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t metalen               : 3;  /**< [  8:  6](R/W) This commands copies the meta-data, this cmd is also used for padding to make
                                                                 the total len of that layer 4B aligned. For a value of 5 1 bte padding is done */
        uint32_t layeroffset6          : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t layeroffset6          : 6;  /**< [  5:  0](R/W) -- */
        uint32_t metalen               : 3;  /**< [  8:  6](R/W) This commands copies the meta-data, this cmd is also used for padding to make
                                                                 the total len of that layer 4B aligned. For a value of 5 1 bte padding is done */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_ltokencmdx_w2 bdk_tns_sde_pe_lcmd_ltokencmdx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206070a408ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_LTOKENCMDX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(a) bdk_tns_sde_pe_lcmd_ltokencmdx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(a) "TNS_SDE_PE_LCMD_LTOKENCMDX_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_m2r_dat#
 *
 * TNS SDE PE Layer Command MAC To Router Data Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 */
union bdk_tns_sde_pe_lcmd_m2r_datx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_datx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_61_63        : 3;
        uint64_t rowvalid              : 1;  /**< [ 60: 60](R/W) -- */
        uint64_t vlan                  : 12; /**< [ 59: 48](R/W) -- */
        uint64_t macda                 : 48; /**< [ 47:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t macda                 : 48; /**< [ 47:  0](R/W) -- */
        uint64_t vlan                  : 12; /**< [ 59: 48](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 60: 60](R/W) -- */
        uint64_t reserved_61_63        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_datx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_datx bdk_tns_sde_pe_lcmd_m2r_datx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DATX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DATX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060708000ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DATX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DATX(a) bdk_tns_sde_pe_lcmd_m2r_datx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DATX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DATX(a) "TNS_SDE_PE_LCMD_M2R_DATX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DATX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DATX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DATX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dbg_w0
 *
 * TNS SDE PE Layer Command MAC To Router Debug Word 0 Register
 * --
 */
union bdk_tns_sde_pe_lcmd_m2r_dbg_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dbg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 23; /**< [ 31:  9](R/W) -- */
        uint32_t hit                   : 1;  /**< [  8:  8](R/W) -- */
        uint32_t addr                  : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 8;  /**< [  7:  0](R/W) -- */
        uint32_t hit                   : 1;  /**< [  8:  8](R/W) -- */
        uint32_t key                   : 23; /**< [ 31:  9](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dbg_w0 bdk_tns_sde_pe_lcmd_m2r_dbg_w0_t;

#define BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae08ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DBG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 bdk_tns_sde_pe_lcmd_m2r_dbg_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 "TNS_SDE_PE_LCMD_M2R_DBG_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dbg_w1
 *
 * TNS SDE PE Layer Command MAC To Router Debug Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DBG_W0
 */
union bdk_tns_sde_pe_lcmd_m2r_dbg_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dbg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dbg_w1 bdk_tns_sde_pe_lcmd_m2r_dbg_w1_t;

#define BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae0cll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DBG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 bdk_tns_sde_pe_lcmd_m2r_dbg_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 "TNS_SDE_PE_LCMD_M2R_DBG_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dbg_w2
 *
 * TNS SDE PE Layer Command MAC To Router Debug Word 2 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DBG_W0
 */
union bdk_tns_sde_pe_lcmd_m2r_dbg_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dbg_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t enable                : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t valid                 : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t pindex                : 5;  /**< [  9:  5](R/W) If programmed to a value between 0 - 16 will capture only that ports entry. if
                                                                 programmed to value beyond this range this field will indicate for which pindex
                                                                 the debug info was captured */
        uint32_t key                   : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field KEY from previous word. */
        uint32_t pindex                : 5;  /**< [  9:  5](R/W) If programmed to a value between 0 - 16 will capture only that ports entry. if
                                                                 programmed to value beyond this range this field will indicate for which pindex
                                                                 the debug info was captured */
        uint32_t valid                 : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t enable                : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dbg_w2 bdk_tns_sde_pe_lcmd_m2r_dbg_w2_t;

#define BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae10ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DBG_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 bdk_tns_sde_pe_lcmd_m2r_dbg_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 "TNS_SDE_PE_LCMD_M2R_DBG_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dmsk#_w0
 *
 * TNS SDE PE Layer Command MAC To Router Data Mask Word 0 Registers
 * This is used to access the actual KPU TCAM.
 * Bits[31:2] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_lcmd_m2r_dmskx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w0 bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060702000ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DMSKX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(a) bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(a) "TNS_SDE_PE_LCMD_M2R_DMSKX_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dmsk#_w1
 *
 * TNS SDE PE Layer Command MAC To Router Data Mask Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_m2r_dmskx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w1 bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060702004ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DMSKX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(a) bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(a) "TNS_SDE_PE_LCMD_M2R_DMSKX_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dmsk#_w2
 *
 * TNS SDE PE Layer Command MAC To Router Data Mask Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_m2r_dmskx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w2 bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060702008ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DMSKX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(a) bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(a) "TNS_SDE_PE_LCMD_M2R_DMSKX_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dmsk#_w3
 *
 * TNS SDE PE Layer Command MAC To Router Data Mask Word 3 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_m2r_dmskx_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w3 bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84206070200cll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DMSKX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(a) bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(a) "TNS_SDE_PE_LCMD_M2R_DMSKX_W3"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_dmsk#_w4
 *
 * TNS SDE PE Layer Command MAC To Router Data Mask Word 4 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_m2r_dmskx_w4
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t vmvalid               : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vmvalid               : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w4 bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060702010ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_DMSKX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(a) bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(a) "TNS_SDE_PE_LCMD_M2R_DMSKX_W4"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_m2r_mask#
 *
 * TNS SDE PE Layer Command MAC To Router Mask Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 */
union bdk_tns_sde_pe_lcmd_m2r_maskx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_maskx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_61_63        : 3;
        uint64_t rowvalid              : 1;  /**< [ 60: 60](R/W) -- */
        uint64_t vlan                  : 12; /**< [ 59: 48](R/W) -- */
        uint64_t macda                 : 48; /**< [ 47:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t macda                 : 48; /**< [ 47:  0](R/W) -- */
        uint64_t vlan                  : 12; /**< [ 59: 48](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 60: 60](R/W) -- */
        uint64_t reserved_61_63        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_maskx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_maskx bdk_tns_sde_pe_lcmd_m2r_maskx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MASKX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MASKX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060708800ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_MASKX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(a) bdk_tns_sde_pe_lcmd_m2r_maskx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(a) "TNS_SDE_PE_LCMD_M2R_MASKX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_m2r_mem#
 *
 * TNS SDE PE Layer Command MAC To Router Memory Registers
 * This memory is accessed based on hit address of mac2router TCAM. Each entry
 * maps to 4 consecutive addresses
 */
union bdk_tns_sde_pe_lcmd_m2r_memx
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_m2r_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t value3                : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t value2                : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t value1                : 4;  /**< [  7:  4](R/W) -- */
        uint32_t value0                : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t value0                : 4;  /**< [  3:  0](R/W) -- */
        uint32_t value1                : 4;  /**< [  7:  4](R/W) -- */
        uint32_t value2                : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t value3                : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_m2r_memx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_m2r_memx bdk_tns_sde_pe_lcmd_m2r_memx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x84206070ac00ll + 4ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_M2R_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(a) bdk_tns_sde_pe_lcmd_m2r_memx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(a) "TNS_SDE_PE_LCMD_M2R_MEMX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_mem_ecc_ctl
 *
 * TNS SDE PE Layer Command Memory ECC Control Register
 * --
 */
union bdk_tns_sde_pe_lcmd_mem_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_mem_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t info_mem_cor_dis      : 1;  /**< [ 26: 26](R/W) -- */
        uint32_t info_mem_flip_sb      : 4;  /**< [ 25: 22](R/W) -- */
        uint32_t info_mem_flip_db      : 4;  /**< [ 21: 18](R/W) -- */
        uint32_t header_mem_cor_dis    : 1;  /**< [ 17: 17](R/W) -- */
        uint32_t header_mem_flip_sb    : 4;  /**< [ 16: 13](R/W) -- */
        uint32_t header_mem_flip_db    : 4;  /**< [ 12:  9](R/W) -- */
        uint32_t tokencmd_mem_cor_dis  : 1;  /**< [  8:  8](R/W) -- */
        uint32_t tokencmd_mem_flip_sb  : 1;  /**< [  7:  7](R/W) -- */
        uint32_t tokencmd_mem_flip_db  : 1;  /**< [  6:  6](R/W) -- */
        uint32_t qos_mem_cor_dis       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t qos_mem_flip_sb       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t qos_mem_flip_db       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t nexteng_mem_cor_dis   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t nexteng_mem_flip_sb   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t nexteng_mem_flip_db   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t nexteng_mem_flip_db   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t nexteng_mem_flip_sb   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t nexteng_mem_cor_dis   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t qos_mem_flip_db       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t qos_mem_flip_sb       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t qos_mem_cor_dis       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t tokencmd_mem_flip_db  : 1;  /**< [  6:  6](R/W) -- */
        uint32_t tokencmd_mem_flip_sb  : 1;  /**< [  7:  7](R/W) -- */
        uint32_t tokencmd_mem_cor_dis  : 1;  /**< [  8:  8](R/W) -- */
        uint32_t header_mem_flip_db    : 4;  /**< [ 12:  9](R/W) -- */
        uint32_t header_mem_flip_sb    : 4;  /**< [ 16: 13](R/W) -- */
        uint32_t header_mem_cor_dis    : 1;  /**< [ 17: 17](R/W) -- */
        uint32_t info_mem_flip_db      : 4;  /**< [ 21: 18](R/W) -- */
        uint32_t info_mem_flip_sb      : 4;  /**< [ 25: 22](R/W) -- */
        uint32_t info_mem_cor_dis      : 1;  /**< [ 26: 26](R/W) -- */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_mem_ecc_ctl_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_mem_ecc_ctl bdk_tns_sde_pe_lcmd_mem_ecc_ctl_t;

#define BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adccll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_MEM_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL bdk_tns_sde_pe_lcmd_mem_ecc_ctl_t
#define bustype_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL "TNS_SDE_PE_LCMD_MEM_ECC_CTL"
#define device_bar_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL 0
#define arguments_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_neng#_w0
 *
 * TNS SDE PE Layer Command Next Engine Word 0 Registers
 * --
 * Bits[31:2] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_lcmd_nengx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_nengx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t egressvif             : 3;  /**< [ 31: 29](R/W) -- */
        uint32_t reasoncode            : 10; /**< [ 28: 19](R/W) -- */
        uint32_t pktcmd                : 2;  /**< [ 18: 17](R/W) -- */
        uint32_t slavelaneselect       : 3;  /**< [ 16: 14](R/W) -- */
        uint32_t nextengine            : 8;  /**< [ 13:  6](R/W) -- */
        uint32_t ttl                   : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ttl                   : 6;  /**< [  5:  0](R/W) -- */
        uint32_t nextengine            : 8;  /**< [ 13:  6](R/W) -- */
        uint32_t slavelaneselect       : 3;  /**< [ 16: 14](R/W) -- */
        uint32_t pktcmd                : 2;  /**< [ 18: 17](R/W) -- */
        uint32_t reasoncode            : 10; /**< [ 28: 19](R/W) -- */
        uint32_t egressvif             : 3;  /**< [ 31: 29](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_nengx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_nengx_w0 bdk_tns_sde_pe_lcmd_nengx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060709000ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_NENGX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_NENGX_W0(a) bdk_tns_sde_pe_lcmd_nengx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_NENGX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_NENGX_W0(a) "TNS_SDE_PE_LCMD_NENGX_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_NENGX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_NENGX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_NENGX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_neng#_w1
 *
 * TNS SDE PE Layer Command Next Engine Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_NENG(0..127)_W0
 */
union bdk_tns_sde_pe_lcmd_nengx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_nengx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lm_cmd                : 1;  /**< [ 31: 31](R/W) -- */
        uint32_t ismekeysel            : 2;  /**< [ 30: 29](R/W) -- */
        uint32_t ecmpsize              : 12; /**< [ 28: 17](R/W) -- */
        uint32_t egressvif             : 17; /**< [ 16:  0](R/W) Continuation of MSBs of field EGRESSVIF from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t egressvif             : 17; /**< [ 16:  0](R/W) Continuation of MSBs of field EGRESSVIF from previous word. */
        uint32_t ecmpsize              : 12; /**< [ 28: 17](R/W) -- */
        uint32_t ismekeysel            : 2;  /**< [ 30: 29](R/W) -- */
        uint32_t lm_cmd                : 1;  /**< [ 31: 31](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_nengx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_nengx_w1 bdk_tns_sde_pe_lcmd_nengx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060709004ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_NENGX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_NENGX_W1(a) bdk_tns_sde_pe_lcmd_nengx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_NENGX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_NENGX_W1(a) "TNS_SDE_PE_LCMD_NENGX_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_NENGX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_NENGX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_NENGX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_neng#_w2
 *
 * TNS SDE PE Layer Command Next Engine Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_NENG(0..127)_W0
 */
union bdk_tns_sde_pe_lcmd_nengx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_nengx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t rsrvd                 : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t rsrvd                 : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_nengx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_nengx_w2 bdk_tns_sde_pe_lcmd_nengx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060709008ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_NENGX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_NENGX_W2(a) bdk_tns_sde_pe_lcmd_nengx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_NENGX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_NENGX_W2(a) "TNS_SDE_PE_LCMD_NENGX_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_NENGX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_NENGX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_NENGX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_pindex2port#
 *
 * TNS SDE PE Layer Command PINDEX To Port Registers
 * --
 */
union bdk_tns_sde_pe_lcmd_pindex2portx
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_pindex2portx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pindex                : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pindex                : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_pindex2portx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_pindex2portx bdk_tns_sde_pe_lcmd_pindex2portx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x84206070a800ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_PINDEX2PORTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(a) bdk_tns_sde_pe_lcmd_pindex2portx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(a) "TNS_SDE_PE_LCMD_PINDEX2PORTX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_prsr_dbg_sel
 *
 * TNS SDE PE Layer Command Parser Debug Selector Register
 * --
 */
union bdk_tns_sde_pe_lcmd_prsr_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_prsr_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_prsr_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_prsr_dbg_sel bdk_tns_sde_pe_lcmd_prsr_dbg_sel_t;

#define BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ad20ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_PRSR_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL bdk_tns_sde_pe_lcmd_prsr_dbg_sel_t
#define bustype_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL "TNS_SDE_PE_LCMD_PRSR_DBG_SEL"
#define device_bar_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL 0
#define arguments_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_qos#
 *
 * TNS SDE PE Layer Command QoS Registers
 * QoS memory, contains per port Layer2, IP, MPLS values. There are 16 entry for
 * Layer2, 64 for IP, and 8 for MPLS
 * Layer2 is indexed using PINDEX*16+{PCP, DEI}, IP is indexed using 18*16 +
 * PINDEX*64 + DSCP, MPLS is indexed using 18*64 + 18*16 + PINDEX*8 + EXP
 */
union bdk_tns_sde_pe_lcmd_qosx
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_qosx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t trafficclass          : 4;  /**< [ 18: 15](R/W) -- */
        uint32_t dropprecedence        : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t pcp                   : 3;  /**< [ 12: 10](R/W) -- */
        uint32_t dei                   : 1;  /**< [  9:  9](R/W) -- */
        uint32_t dscp                  : 6;  /**< [  8:  3](R/W) -- */
        uint32_t exp                   : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t exp                   : 3;  /**< [  2:  0](R/W) -- */
        uint32_t dscp                  : 6;  /**< [  8:  3](R/W) -- */
        uint32_t dei                   : 1;  /**< [  9:  9](R/W) -- */
        uint32_t pcp                   : 3;  /**< [ 12: 10](R/W) -- */
        uint32_t dropprecedence        : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t trafficclass          : 4;  /**< [ 18: 15](R/W) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_qosx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_qosx bdk_tns_sde_pe_lcmd_qosx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_QOSX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_QOSX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=703))
        return 0x842060706000ll + 4ll * ((a) & 0x3ff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_QOSX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_QOSX(a) bdk_tns_sde_pe_lcmd_qosx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_QOSX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_QOSX(a) "TNS_SDE_PE_LCMD_QOSX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_QOSX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_QOSX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_QOSX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_spad
 *
 * TNS SDE PE Layer Command ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_pe_lcmd_spad
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_spad_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_spad bdk_tns_sde_pe_lcmd_spad_t;

#define BDK_TNS_SDE_PE_LCMD_SPAD BDK_TNS_SDE_PE_LCMD_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae1cll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_SPAD bdk_tns_sde_pe_lcmd_spad_t
#define bustype_BDK_TNS_SDE_PE_LCMD_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_SPAD "TNS_SDE_PE_LCMD_SPAD"
#define device_bar_BDK_TNS_SDE_PE_LCMD_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_SPAD 0
#define arguments_BDK_TNS_SDE_PE_LCMD_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w0
 *
 * TNS SDE PE Layer Command Status Word 0 Register
 * --
 */
union bdk_tns_sde_pe_lcmd_sta_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t info_mem_spare        : 12; /**< [ 31: 20](RO/H) -- */
        uint32_t hdr_buff_req_srdy     : 1;  /**< [ 19: 19](RO/H) -- */
        uint32_t hdr_buff_req_drdy     : 1;  /**< [ 18: 18](RO/H) -- */
        uint32_t hdr_buff_wr_srdy      : 1;  /**< [ 17: 17](RO/H) -- */
        uint32_t hdr_buff_wr_drdy      : 1;  /**< [ 16: 16](RO/H) -- */
        uint32_t token_srdy            : 1;  /**< [ 15: 15](RO/H) -- */
        uint32_t token_drdy            : 1;  /**< [ 14: 14](RO/H) -- */
        uint32_t token_fifo_usage      : 5;  /**< [ 13:  9](RO/H) -- */
        uint32_t hdr_buff_fifo_usage   : 4;  /**< [  8:  5](RO/H) -- */
        uint32_t hdr_addr_fifo_usage   : 5;  /**< [  4:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdr_addr_fifo_usage   : 5;  /**< [  4:  0](RO/H) -- */
        uint32_t hdr_buff_fifo_usage   : 4;  /**< [  8:  5](RO/H) -- */
        uint32_t token_fifo_usage      : 5;  /**< [ 13:  9](RO/H) -- */
        uint32_t token_drdy            : 1;  /**< [ 14: 14](RO/H) -- */
        uint32_t token_srdy            : 1;  /**< [ 15: 15](RO/H) -- */
        uint32_t hdr_buff_wr_drdy      : 1;  /**< [ 16: 16](RO/H) -- */
        uint32_t hdr_buff_wr_srdy      : 1;  /**< [ 17: 17](RO/H) -- */
        uint32_t hdr_buff_req_drdy     : 1;  /**< [ 18: 18](RO/H) -- */
        uint32_t hdr_buff_req_srdy     : 1;  /**< [ 19: 19](RO/H) -- */
        uint32_t info_mem_spare        : 12; /**< [ 31: 20](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w0 bdk_tns_sde_pe_lcmd_sta_w0_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W0 BDK_TNS_SDE_PE_LCMD_STA_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adb0ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W0 bdk_tns_sde_pe_lcmd_sta_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W0 "TNS_SDE_PE_LCMD_STA_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w1
 *
 * TNS SDE PE Layer Command Status Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 */
union bdk_tns_sde_pe_lcmd_sta_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t infoll                : 16; /**< [ 31: 16](RO/H) -- */
        uint32_t info_mem_spare        : 16; /**< [ 15:  0](RO/H) Continuation of MSBs of field INFO_MEM_SPARE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t info_mem_spare        : 16; /**< [ 15:  0](RO/H) Continuation of MSBs of field INFO_MEM_SPARE from previous word. */
        uint32_t infoll                : 16; /**< [ 31: 16](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w1 bdk_tns_sde_pe_lcmd_sta_w1_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W1 BDK_TNS_SDE_PE_LCMD_STA_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adb4ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W1 bdk_tns_sde_pe_lcmd_sta_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W1 "TNS_SDE_PE_LCMD_STA_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w2
 *
 * TNS SDE PE Layer Command Status Word 2 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 */
union bdk_tns_sde_pe_lcmd_sta_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rdinfoheadptr         : 5;  /**< [ 31: 27](RO/H) -- */
        uint32_t linklist              : 6;  /**< [ 26: 21](RO/H) -- */
        uint32_t infoll                : 21; /**< [ 20:  0](RO/H) Continuation of MSBs of field INFOLL from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t infoll                : 21; /**< [ 20:  0](RO/H) Continuation of MSBs of field INFOLL from previous word. */
        uint32_t linklist              : 6;  /**< [ 26: 21](RO/H) -- */
        uint32_t rdinfoheadptr         : 5;  /**< [ 31: 27](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w2 bdk_tns_sde_pe_lcmd_sta_w2_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W2 BDK_TNS_SDE_PE_LCMD_STA_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adb8ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W2 bdk_tns_sde_pe_lcmd_sta_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W2 "TNS_SDE_PE_LCMD_STA_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w3
 *
 * TNS SDE PE Layer Command Status Word 3 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 */
union bdk_tns_sde_pe_lcmd_sta_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t infofreecnt           : 6;  /**< [ 31: 26](RO/H) -- */
        uint32_t infotailptr           : 6;  /**< [ 25: 20](RO/H) -- */
        uint32_t infoheadptr           : 6;  /**< [ 19: 14](RO/H) -- */
        uint32_t rdinfocnt             : 7;  /**< [ 13:  7](RO/H) -- */
        uint32_t rdinfotailptr         : 6;  /**< [  6:  1](RO/H) -- */
        uint32_t rdinfoheadptr         : 1;  /**< [  0:  0](RO/H) Continuation of MSBs of field RDINFOHEADPTR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t rdinfoheadptr         : 1;  /**< [  0:  0](RO/H) Continuation of MSBs of field RDINFOHEADPTR from previous word. */
        uint32_t rdinfotailptr         : 6;  /**< [  6:  1](RO/H) -- */
        uint32_t rdinfocnt             : 7;  /**< [ 13:  7](RO/H) -- */
        uint32_t infoheadptr           : 6;  /**< [ 19: 14](RO/H) -- */
        uint32_t infotailptr           : 6;  /**< [ 25: 20](RO/H) -- */
        uint32_t infofreecnt           : 6;  /**< [ 31: 26](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w3_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w3 bdk_tns_sde_pe_lcmd_sta_w3_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W3 BDK_TNS_SDE_PE_LCMD_STA_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adbcll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W3 bdk_tns_sde_pe_lcmd_sta_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W3 "TNS_SDE_PE_LCMD_STA_W3"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W3 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w4
 *
 * TNS SDE PE Layer Command Status Word 4 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 */
union bdk_tns_sde_pe_lcmd_sta_w4
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t rdtailptr             : 6;  /**< [ 31: 26](RO/H) -- */
        uint32_t rdheadptr             : 6;  /**< [ 25: 20](RO/H) -- */
        uint32_t freetailptr           : 6;  /**< [ 19: 14](RO/H) -- */
        uint32_t freeheadptr           : 6;  /**< [ 13:  8](RO/H) -- */
        uint32_t freecnt               : 7;  /**< [  7:  1](RO/H) -- */
        uint32_t infofreecnt           : 1;  /**< [  0:  0](RO/H) Continuation of MSBs of field INFOFREECNT from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t infofreecnt           : 1;  /**< [  0:  0](RO/H) Continuation of MSBs of field INFOFREECNT from previous word. */
        uint32_t freecnt               : 7;  /**< [  7:  1](RO/H) -- */
        uint32_t freeheadptr           : 6;  /**< [ 13:  8](RO/H) -- */
        uint32_t freetailptr           : 6;  /**< [ 19: 14](RO/H) -- */
        uint32_t rdheadptr             : 6;  /**< [ 25: 20](RO/H) -- */
        uint32_t rdtailptr             : 6;  /**< [ 31: 26](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w4_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w4 bdk_tns_sde_pe_lcmd_sta_w4_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W4 BDK_TNS_SDE_PE_LCMD_STA_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adc0ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W4 bdk_tns_sde_pe_lcmd_sta_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W4 "TNS_SDE_PE_LCMD_STA_W4"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W4 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w5
 *
 * TNS SDE PE Layer Command Status Word 5 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 */
union bdk_tns_sde_pe_lcmd_sta_w5
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hdr_buff_fifo_cnt     : 1;  /**< [ 31: 31](RO/H) -- */
        uint32_t q_empty               : 17; /**< [ 30: 14](RO/H) -- */
        uint32_t pindex_cnt            : 7;  /**< [ 13:  7](RO/H) -- */
        uint32_t rdcnt                 : 7;  /**< [  6:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t rdcnt                 : 7;  /**< [  6:  0](RO/H) -- */
        uint32_t pindex_cnt            : 7;  /**< [ 13:  7](RO/H) -- */
        uint32_t q_empty               : 17; /**< [ 30: 14](RO/H) -- */
        uint32_t hdr_buff_fifo_cnt     : 1;  /**< [ 31: 31](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w5_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w5 bdk_tns_sde_pe_lcmd_sta_w5_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W5 BDK_TNS_SDE_PE_LCMD_STA_W5_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W5_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adc4ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W5", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W5 bdk_tns_sde_pe_lcmd_sta_w5_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W5 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W5 "TNS_SDE_PE_LCMD_STA_W5"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W5 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W5 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W5 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_sta_w6
 *
 * TNS SDE PE Layer Command Status Word 6 Register
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 */
union bdk_tns_sde_pe_lcmd_sta_w6
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_sta_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t hdr_buff_fifo_cnt     : 3;  /**< [  2:  0](RO/H) Continuation of MSBs of field HDR_BUFF_FIFO_CNT from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t hdr_buff_fifo_cnt     : 3;  /**< [  2:  0](RO/H) Continuation of MSBs of field HDR_BUFF_FIFO_CNT from previous word. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_sta_w6_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_sta_w6 bdk_tns_sde_pe_lcmd_sta_w6_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W6 BDK_TNS_SDE_PE_LCMD_STA_W6_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W6_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070adc8ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_STA_W6", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W6 bdk_tns_sde_pe_lcmd_sta_w6_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W6 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W6 "TNS_SDE_PE_LCMD_STA_W6"
#define device_bar_BDK_TNS_SDE_PE_LCMD_STA_W6 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W6 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W6 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_tid_dat#
 *
 * TNS SDE PE Layer Command Template ID Data Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 */
union bdk_tns_sde_pe_lcmd_tid_datx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_tid_datx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t layertype7            : 5;  /**< [ 39: 35](R/W) -- */
        uint64_t layertype6            : 5;  /**< [ 34: 30](R/W) -- */
        uint64_t layertype5            : 5;  /**< [ 29: 25](R/W) -- */
        uint64_t layertype4            : 5;  /**< [ 24: 20](R/W) -- */
        uint64_t layertype3            : 5;  /**< [ 19: 15](R/W) -- */
        uint64_t layertype2            : 5;  /**< [ 14: 10](R/W) -- */
        uint64_t layertype1            : 5;  /**< [  9:  5](R/W) -- */
        uint64_t layertype0            : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t layertype0            : 5;  /**< [  4:  0](R/W) -- */
        uint64_t layertype1            : 5;  /**< [  9:  5](R/W) -- */
        uint64_t layertype2            : 5;  /**< [ 14: 10](R/W) -- */
        uint64_t layertype3            : 5;  /**< [ 19: 15](R/W) -- */
        uint64_t layertype4            : 5;  /**< [ 24: 20](R/W) -- */
        uint64_t layertype5            : 5;  /**< [ 29: 25](R/W) -- */
        uint64_t layertype6            : 5;  /**< [ 34: 30](R/W) -- */
        uint64_t layertype7            : 5;  /**< [ 39: 35](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_datx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_datx bdk_tns_sde_pe_lcmd_tid_datx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DATX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DATX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060707000ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DATX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DATX(a) bdk_tns_sde_pe_lcmd_tid_datx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DATX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DATX(a) "TNS_SDE_PE_LCMD_TID_DATX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DATX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DATX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DATX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_tid_dbg
 *
 * TNS SDE PE Layer Command Template ID Debug Register
 * --
 */
union bdk_tns_sde_pe_lcmd_tid_dbg
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_tid_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_56_63        : 8;
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) -- */
        uint64_t valid                 : 1;  /**< [ 54: 54](R/W) -- */
        uint64_t pindex                : 5;  /**< [ 53: 49](R/W) If programmed to a value between 0 - 16 will capture only that ports entry */
        uint64_t key                   : 40; /**< [ 48:  9](R/W) -- */
        uint64_t hit                   : 1;  /**< [  8:  8](R/W) -- */
        uint64_t addr                  : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t addr                  : 8;  /**< [  7:  0](R/W) -- */
        uint64_t hit                   : 1;  /**< [  8:  8](R/W) -- */
        uint64_t key                   : 40; /**< [ 48:  9](R/W) -- */
        uint64_t pindex                : 5;  /**< [ 53: 49](R/W) If programmed to a value between 0 - 16 will capture only that ports entry */
        uint64_t valid                 : 1;  /**< [ 54: 54](R/W) -- */
        uint64_t enable                : 1;  /**< [ 55: 55](R/W) -- */
        uint64_t reserved_56_63        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_dbg_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_dbg bdk_tns_sde_pe_lcmd_tid_dbg_t;

#define BDK_TNS_SDE_PE_LCMD_TID_DBG BDK_TNS_SDE_PE_LCMD_TID_DBG_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DBG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206070ae00ll;
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DBG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DBG bdk_tns_sde_pe_lcmd_tid_dbg_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DBG BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DBG "TNS_SDE_PE_LCMD_TID_DBG"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DBG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DBG 0
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DBG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_tid_dmsk#_w0
 *
 * TNS SDE PE Layer Command Template ID Data Mask Word 0 Registers
 * Template Id TCAM Data
 * Bits[31:2] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_lcmd_tid_dmskx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_tid_dmskx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w0 bdk_tns_sde_pe_lcmd_tid_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060700000ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DMSKX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(a) bdk_tns_sde_pe_lcmd_tid_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(a) "TNS_SDE_PE_LCMD_TID_DMSKX_W0"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_tid_dmsk#_w1
 *
 * TNS SDE PE Layer Command Template ID Data Mask Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_tid_dmskx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_tid_dmskx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w1 bdk_tns_sde_pe_lcmd_tid_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060700004ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DMSKX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(a) bdk_tns_sde_pe_lcmd_tid_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(a) "TNS_SDE_PE_LCMD_TID_DMSKX_W1"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_tid_dmsk#_w2
 *
 * TNS SDE PE Layer Command Template ID Data Mask Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_tid_dmskx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_tid_dmskx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w2 bdk_tns_sde_pe_lcmd_tid_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060700008ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DMSKX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(a) bdk_tns_sde_pe_lcmd_tid_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(a) "TNS_SDE_PE_LCMD_TID_DMSKX_W2"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_tid_dmsk#_w3
 *
 * TNS SDE PE Layer Command Template ID Data Mask Word 3 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_tid_dmskx_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_tid_dmskx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w3_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w3 bdk_tns_sde_pe_lcmd_tid_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84206070000cll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DMSKX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(a) bdk_tns_sde_pe_lcmd_tid_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(a) "TNS_SDE_PE_LCMD_TID_DMSKX_W3"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_lcmd_tid_dmsk#_w4
 *
 * TNS SDE PE Layer Command Template ID Data Mask Word 4 Registers
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 */
union bdk_tns_sde_pe_lcmd_tid_dmskx_w4
{
    uint32_t u;
    struct bdk_tns_sde_pe_lcmd_tid_dmskx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t vmvalid               : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vmvalid               : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w4_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w4 bdk_tns_sde_pe_lcmd_tid_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060700010ll + 0x20ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_DMSKX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(a) bdk_tns_sde_pe_lcmd_tid_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(a) "TNS_SDE_PE_LCMD_TID_DMSKX_W4"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_tid_mask#
 *
 * TNS SDE PE Layer Command Template ID Mask Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 */
union bdk_tns_sde_pe_lcmd_tid_maskx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_tid_maskx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t layertype7            : 5;  /**< [ 39: 35](R/W) -- */
        uint64_t layertype6            : 5;  /**< [ 34: 30](R/W) -- */
        uint64_t layertype5            : 5;  /**< [ 29: 25](R/W) -- */
        uint64_t layertype4            : 5;  /**< [ 24: 20](R/W) -- */
        uint64_t layertype3            : 5;  /**< [ 19: 15](R/W) -- */
        uint64_t layertype2            : 5;  /**< [ 14: 10](R/W) -- */
        uint64_t layertype1            : 5;  /**< [  9:  5](R/W) -- */
        uint64_t layertype0            : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t layertype0            : 5;  /**< [  4:  0](R/W) -- */
        uint64_t layertype1            : 5;  /**< [  9:  5](R/W) -- */
        uint64_t layertype2            : 5;  /**< [ 14: 10](R/W) -- */
        uint64_t layertype3            : 5;  /**< [ 19: 15](R/W) -- */
        uint64_t layertype4            : 5;  /**< [ 24: 20](R/W) -- */
        uint64_t layertype5            : 5;  /**< [ 29: 25](R/W) -- */
        uint64_t layertype6            : 5;  /**< [ 34: 30](R/W) -- */
        uint64_t layertype7            : 5;  /**< [ 39: 35](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tid_maskx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tid_maskx bdk_tns_sde_pe_lcmd_tid_maskx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_MASKX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_MASKX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060707800ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TID_MASKX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TID_MASKX(a) bdk_tns_sde_pe_lcmd_tid_maskx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_MASKX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_TID_MASKX(a) "TNS_SDE_PE_LCMD_TID_MASKX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TID_MASKX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_MASKX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_MASKX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_lcmd_tokencmds#
 *
 * TNS SDE PE Layer Command Token Commands Registers
 * --
 */
union bdk_tns_sde_pe_lcmd_tokencmdsx
{
    uint64_t u;
    struct bdk_tns_sde_pe_lcmd_tokencmdsx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_34_63        : 30;
        uint64_t inrethm2rloc          : 7;  /**< [ 33: 27](R/W) -- */
        uint64_t hashaen               : 8;  /**< [ 26: 19](R/W) -- */
        uint64_t hashben               : 8;  /**< [ 18: 11](R/W) -- */
        uint64_t firstvldlayer         : 3;  /**< [ 10:  8](R/W) -- */
        uint64_t templateid            : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t templateid            : 8;  /**< [  7:  0](R/W) -- */
        uint64_t firstvldlayer         : 3;  /**< [ 10:  8](R/W) -- */
        uint64_t hashben               : 8;  /**< [ 18: 11](R/W) -- */
        uint64_t hashaen               : 8;  /**< [ 26: 19](R/W) -- */
        uint64_t inrethm2rloc          : 7;  /**< [ 33: 27](R/W) -- */
        uint64_t reserved_34_63        : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_lcmd_tokencmdsx_s cn; */
};
typedef union bdk_tns_sde_pe_lcmd_tokencmdsx bdk_tns_sde_pe_lcmd_tokencmdsx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842060709800ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_LCMD_TOKENCMDSX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(a) bdk_tns_sde_pe_lcmd_tokencmdsx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(a) "TNS_SDE_PE_LCMD_TOKENCMDSX"
#define device_bar_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(a) (a)
#define arguments_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_control
 *
 * TNS SDE PE SKPU Control Register
 * Misc control bits for the entire parser
 */
union bdk_tns_sde_pe_skpu_control
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t use_ivif_for_ikt_index : 1; /**< [ 26: 26](R/W) If cleared the address to access the IKT is the src_port provided from the
                                                                 datapath. If set the IKT is looked up using xph.ivif[7:0]
                                                                 if xph is present (else it is looked up using src_port as usual). */
        uint32_t hdr_threshold         : 7;  /**< [ 25: 19](R/W) Controls number of headers that can exist in the KPU's. To turn off headers
                                                                 from rx, prog it to 0. For normal mode prog 42, for ull change it to 10.
                                                                 (8*kpus + 2). Value has to be less than 64 */
        uint32_t ull_token_mode        : 1;  /**< [ 18: 18](R/W) Used to control when the token is sent in the ull mode. If set to 0, the token
                                                                 is sent when the full 64B are received. If set to 1, the token is sent when the
                                                                 32B are received. */
        uint32_t cut_through           : 17; /**< [ 17:  1](R/W) If set to 1, indicates that port is in cut through mode */
        uint32_t ull_mode              : 1;  /**< [  0:  0](R/W) If set to 1, indicates that parser is operating in ultra low latency mode */
#else /* Word 0 - Little Endian */
        uint32_t ull_mode              : 1;  /**< [  0:  0](R/W) If set to 1, indicates that parser is operating in ultra low latency mode */
        uint32_t cut_through           : 17; /**< [ 17:  1](R/W) If set to 1, indicates that port is in cut through mode */
        uint32_t ull_token_mode        : 1;  /**< [ 18: 18](R/W) Used to control when the token is sent in the ull mode. If set to 0, the token
                                                                 is sent when the full 64B are received. If set to 1, the token is sent when the
                                                                 32B are received. */
        uint32_t hdr_threshold         : 7;  /**< [ 25: 19](R/W) Controls number of headers that can exist in the KPU's. To turn off headers
                                                                 from rx, prog it to 0. For normal mode prog 42, for ull change it to 10.
                                                                 (8*kpus + 2). Value has to be less than 64 */
        uint32_t use_ivif_for_ikt_index : 1; /**< [ 26: 26](R/W) If cleared the address to access the IKT is the src_port provided from the
                                                                 datapath. If set the IKT is looked up using xph.ivif[7:0]
                                                                 if xph is present (else it is looked up using src_port as usual). */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_control_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_control bdk_tns_sde_pe_skpu_control_t;

#define BDK_TNS_SDE_PE_SKPU_CONTROL BDK_TNS_SDE_PE_SKPU_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_CONTROL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714000ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_CONTROL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_CONTROL bdk_tns_sde_pe_skpu_control_t
#define bustype_BDK_TNS_SDE_PE_SKPU_CONTROL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_CONTROL "TNS_SDE_PE_SKPU_CONTROL"
#define device_bar_BDK_TNS_SDE_PE_SKPU_CONTROL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_CONTROL 0
#define arguments_BDK_TNS_SDE_PE_SKPU_CONTROL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_ecc_ctl
 *
 * TNS SDE PE SKPU ECC Control Register
 * --
 */
union bdk_tns_sde_pe_skpu_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t cor_dis               : 1;  /**< [  4:  4](R/W) -- */
        uint32_t flip_sb               : 2;  /**< [  3:  2](R/W) -- */
        uint32_t flip_db               : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t flip_db               : 2;  /**< [  1:  0](R/W) -- */
        uint32_t flip_sb               : 2;  /**< [  3:  2](R/W) -- */
        uint32_t cor_dis               : 1;  /**< [  4:  4](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_ecc_ctl_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_ecc_ctl bdk_tns_sde_pe_skpu_ecc_ctl_t;

#define BDK_TNS_SDE_PE_SKPU_ECC_CTL BDK_TNS_SDE_PE_SKPU_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714008ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_ECC_CTL bdk_tns_sde_pe_skpu_ecc_ctl_t
#define bustype_BDK_TNS_SDE_PE_SKPU_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_ECC_CTL "TNS_SDE_PE_SKPU_ECC_CTL"
#define device_bar_BDK_TNS_SDE_PE_SKPU_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_ECC_CTL 0
#define arguments_BDK_TNS_SDE_PE_SKPU_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_ikt#_w0
 *
 * TNS SDE PE SKPU Initial KPU Table Word 0 Registers
 * Initial KPU Table contains fields to start the parsing
 * Bits[63:36] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_skpu_iktx_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_iktx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t decpointoffset2       : 2;  /**< [ 63: 62](R/W) -- */
        uint64_t decpointoffset3       : 6;  /**< [ 61: 56](R/W) -- */
        uint64_t decpointoffset4       : 6;  /**< [ 55: 50](R/W) -- */
        uint64_t decpointoffset5       : 6;  /**< [ 49: 44](R/W) -- */
        uint64_t decpointoffset6       : 6;  /**< [ 43: 38](R/W) -- */
        uint64_t decpointoffset7       : 6;  /**< [ 37: 32](R/W) -- */
        uint64_t decpointoffset8       : 6;  /**< [ 31: 26](R/W) -- */
        uint64_t decpointoffset9       : 6;  /**< [ 25: 20](R/W) -- */
        uint64_t decpointoffset10      : 6;  /**< [ 19: 14](R/W) -- */
        uint64_t decpointoffset11      : 6;  /**< [ 13:  8](R/W) -- */
        uint64_t pnum                  : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t pnum                  : 8;  /**< [  7:  0](R/W) -- */
        uint64_t decpointoffset11      : 6;  /**< [ 13:  8](R/W) -- */
        uint64_t decpointoffset10      : 6;  /**< [ 19: 14](R/W) -- */
        uint64_t decpointoffset9       : 6;  /**< [ 25: 20](R/W) -- */
        uint64_t decpointoffset8       : 6;  /**< [ 31: 26](R/W) -- */
        uint64_t decpointoffset7       : 6;  /**< [ 37: 32](R/W) -- */
        uint64_t decpointoffset6       : 6;  /**< [ 43: 38](R/W) -- */
        uint64_t decpointoffset5       : 6;  /**< [ 49: 44](R/W) -- */
        uint64_t decpointoffset4       : 6;  /**< [ 55: 50](R/W) -- */
        uint64_t decpointoffset3       : 6;  /**< [ 61: 56](R/W) -- */
        uint64_t decpointoffset2       : 2;  /**< [ 63: 62](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_iktx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_iktx_w0 bdk_tns_sde_pe_skpu_iktx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x842060710000ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_IKTX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_IKTX_W0(a) bdk_tns_sde_pe_skpu_iktx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_IKTX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_IKTX_W0(a) "TNS_SDE_PE_SKPU_IKTX_W0"
#define device_bar_BDK_TNS_SDE_PE_SKPU_IKTX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_IKTX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_IKTX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_ikt#_w1
 *
 * TNS SDE PE SKPU Initial KPU Table Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_IKT(0..136)_W0
 */
union bdk_tns_sde_pe_skpu_iktx_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_iktx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_36_63        : 28;
        uint64_t xphexists             : 1;  /**< [ 35: 35](R/W) -- */
        uint64_t hts_exists            : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t chnum                 : 2;  /**< [ 33: 32](R/W) -- */
        uint64_t initialstate          : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t initialpktptr         : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpointoffset0       : 6;  /**< [ 15: 10](R/W) -- */
        uint64_t decpointoffset1       : 6;  /**< [  9:  4](R/W) -- */
        uint64_t decpointoffset2       : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field DECPOINTOFFSET2 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t decpointoffset2       : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field DECPOINTOFFSET2 from previous word. */
        uint64_t decpointoffset1       : 6;  /**< [  9:  4](R/W) -- */
        uint64_t decpointoffset0       : 6;  /**< [ 15: 10](R/W) -- */
        uint64_t initialpktptr         : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t initialstate          : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t chnum                 : 2;  /**< [ 33: 32](R/W) -- */
        uint64_t hts_exists            : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t xphexists             : 1;  /**< [ 35: 35](R/W) -- */
        uint64_t reserved_36_63        : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_iktx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_iktx_w1 bdk_tns_sde_pe_skpu_iktx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=136))
        return 0x842060710008ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_IKTX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_IKTX_W1(a) bdk_tns_sde_pe_skpu_iktx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_IKTX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_IKTX_W1(a) "TNS_SDE_PE_SKPU_IKTX_W1"
#define device_bar_BDK_TNS_SDE_PE_SKPU_IKTX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_IKTX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_IKTX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_ikt_dbg
 *
 * TNS SDE PE SKPU Initial KPU Table Debug Register
 * --
 */
union bdk_tns_sde_pe_skpu_ikt_dbg
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_ikt_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t rx_srdy               : 1;  /**< [  8:  8](RO/H) -- */
        uint32_t rx_drdy               : 1;  /**< [  7:  7](RO/H) -- */
        uint32_t hdr_cnt               : 7;  /**< [  6:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdr_cnt               : 7;  /**< [  6:  0](RO/H) -- */
        uint32_t rx_drdy               : 1;  /**< [  7:  7](RO/H) -- */
        uint32_t rx_srdy               : 1;  /**< [  8:  8](RO/H) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_ikt_dbg_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_ikt_dbg bdk_tns_sde_pe_skpu_ikt_dbg_t;

#define BDK_TNS_SDE_PE_SKPU_IKT_DBG BDK_TNS_SDE_PE_SKPU_IKT_DBG_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKT_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKT_DBG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714004ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_IKT_DBG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_IKT_DBG bdk_tns_sde_pe_skpu_ikt_dbg_t
#define bustype_BDK_TNS_SDE_PE_SKPU_IKT_DBG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_IKT_DBG "TNS_SDE_PE_SKPU_IKT_DBG"
#define device_bar_BDK_TNS_SDE_PE_SKPU_IKT_DBG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_IKT_DBG 0
#define arguments_BDK_TNS_SDE_PE_SKPU_IKT_DBG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_lock
 *
 * TNS SDE PE SKPU Lock Register
 * Lock Register
 */
union bdk_tns_sde_pe_skpu_lock
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_lock_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_lock bdk_tns_sde_pe_skpu_lock_t;

#define BDK_TNS_SDE_PE_SKPU_LOCK BDK_TNS_SDE_PE_SKPU_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206071401cll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_LOCK bdk_tns_sde_pe_skpu_lock_t
#define bustype_BDK_TNS_SDE_PE_SKPU_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_LOCK "TNS_SDE_PE_SKPU_LOCK"
#define device_bar_BDK_TNS_SDE_PE_SKPU_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_LOCK 0
#define arguments_BDK_TNS_SDE_PE_SKPU_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_skpu_dbg_w0
 *
 * TNS SDE PE SKPU SKPU Debug Word 0 Register
 * Provides debug information about last TCAM entry
 */
union bdk_tns_sde_pe_skpu_skpu_dbg_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_skpu_dbg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 24; /**< [ 31:  8](R/W/H) -- */
        uint32_t hit                   : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t addr                  : 7;  /**< [  6:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 7;  /**< [  6:  0](R/W/H) -- */
        uint32_t hit                   : 1;  /**< [  7:  7](R/W/H) -- */
        uint32_t key                   : 24; /**< [ 31:  8](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_dbg_w0_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w0 bdk_tns_sde_pe_skpu_skpu_dbg_w0_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206071400cll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_DBG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 bdk_tns_sde_pe_skpu_skpu_dbg_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 "TNS_SDE_PE_SKPU_SKPU_DBG_W0"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_skpu_dbg_w1
 *
 * TNS SDE PE SKPU SKPU Debug Word 1 Register
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_DBG_W0
 */
union bdk_tns_sde_pe_skpu_skpu_dbg_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_skpu_dbg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_dbg_w1_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w1 bdk_tns_sde_pe_skpu_skpu_dbg_w1_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714010ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_DBG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 bdk_tns_sde_pe_skpu_skpu_dbg_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 "TNS_SDE_PE_SKPU_SKPU_DBG_W1"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_skpu_dbg_w2
 *
 * TNS SDE PE SKPU SKPU Debug Word 2 Register
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_DBG_W0
 */
union bdk_tns_sde_pe_skpu_skpu_dbg_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_skpu_dbg_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_dbg_w2_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w2 bdk_tns_sde_pe_skpu_skpu_dbg_w2_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714014ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_DBG_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 bdk_tns_sde_pe_skpu_skpu_dbg_w2_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 "TNS_SDE_PE_SKPU_SKPU_DBG_W2"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_skpu_dbg_w3
 *
 * TNS SDE PE SKPU SKPU Debug Word 3 Register
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_DBG_W0
 */
union bdk_tns_sde_pe_skpu_skpu_dbg_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_skpu_dbg_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t enable                : 1;  /**< [ 22: 22](R/W/H) Will only capture an entry when enable=1 AND valid=0 */
        uint32_t valid                 : 1;  /**< [ 21: 21](R/W/H) A value of 1, indicates that an entry was captured */
        uint32_t pindex                : 5;  /**< [ 20: 16](R/W/H) If programmed to a value between 0 - 16 will capture only that ports entry */
        uint32_t key                   : 16; /**< [ 15:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 16; /**< [ 15:  0](R/W/H) Continuation of MSBs of field KEY from previous word. */
        uint32_t pindex                : 5;  /**< [ 20: 16](R/W/H) If programmed to a value between 0 - 16 will capture only that ports entry */
        uint32_t valid                 : 1;  /**< [ 21: 21](R/W/H) A value of 1, indicates that an entry was captured */
        uint32_t enable                : 1;  /**< [ 22: 22](R/W/H) Will only capture an entry when enable=1 AND valid=0 */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_dbg_w3_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w3 bdk_tns_sde_pe_skpu_skpu_dbg_w3_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714018ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_DBG_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 bdk_tns_sde_pe_skpu_skpu_dbg_w3_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 "TNS_SDE_PE_SKPU_SKPU_DBG_W3"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_skpu_sram#_w0
 *
 * TNS SDE PE SKPU SKPU Sram Word 0 Registers
 * KPU SRAM
 * Bits[63:35] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_skpu_skpu_sramx_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_skpu_sramx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata2             : 6;  /**< [ 63: 58](R/W) -- */
        uint64_t lyrptradvance0        : 6;  /**< [ 57: 52](R/W) -- */
        uint64_t lyrptradvance1        : 6;  /**< [ 51: 46](R/W) -- */
        uint64_t lyrptradvance2        : 6;  /**< [ 45: 40](R/W) -- */
        uint64_t transitionid          : 4;  /**< [ 39: 36](R/W) -- */
        uint64_t push2stack            : 2;  /**< [ 35: 34](R/W) -- */
        uint64_t parsedone             : 1;  /**< [ 33: 33](R/W) -- */
        uint64_t layertype0            : 5;  /**< [ 32: 28](R/W) -- */
        uint64_t layertype1            : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t layertype2            : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t offset0               : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t offset1               : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t offset2               : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t offset2               : 6;  /**< [  5:  0](R/W) -- */
        uint64_t offset1               : 6;  /**< [ 11:  6](R/W) -- */
        uint64_t offset0               : 6;  /**< [ 17: 12](R/W) -- */
        uint64_t layertype2            : 5;  /**< [ 22: 18](R/W) -- */
        uint64_t layertype1            : 5;  /**< [ 27: 23](R/W) -- */
        uint64_t layertype0            : 5;  /**< [ 32: 28](R/W) -- */
        uint64_t parsedone             : 1;  /**< [ 33: 33](R/W) -- */
        uint64_t push2stack            : 2;  /**< [ 35: 34](R/W) -- */
        uint64_t transitionid          : 4;  /**< [ 39: 36](R/W) -- */
        uint64_t lyrptradvance2        : 6;  /**< [ 45: 40](R/W) -- */
        uint64_t lyrptradvance1        : 6;  /**< [ 51: 46](R/W) -- */
        uint64_t lyrptradvance0        : 6;  /**< [ 57: 52](R/W) -- */
        uint64_t metadata2             : 6;  /**< [ 63: 58](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_sramx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_sramx_w0 bdk_tns_sde_pe_skpu_skpu_sramx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060712000ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_SRAMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(a) bdk_tns_sde_pe_skpu_skpu_sramx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(a) "TNS_SDE_PE_SKPU_SKPU_SRAMX_W0"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_skpu_sram#_w1
 *
 * TNS SDE PE SKPU SKPU Sram Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_SRAM(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_skpu_sramx_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_skpu_sramx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t metadata0             : 6;  /**< [ 63: 58](R/W) -- */
        uint64_t metadata1             : 32; /**< [ 57: 26](R/W) -- */
        uint64_t metadata2             : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field METADATA2 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata2             : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field METADATA2 from previous word. */
        uint64_t metadata1             : 32; /**< [ 57: 26](R/W) -- */
        uint64_t metadata0             : 6;  /**< [ 63: 58](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_sramx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_sramx_w1 bdk_tns_sde_pe_skpu_skpu_sramx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060712008ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_SRAMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(a) bdk_tns_sde_pe_skpu_skpu_sramx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(a) "TNS_SDE_PE_SKPU_SKPU_SRAMX_W1"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_skpu_sram#_w2
 *
 * TNS SDE PE SKPU SKPU Sram Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_SRAM(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_skpu_sramx_w2
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_skpu_sramx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t innereth              : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t state                 : 8;  /**< [ 33: 26](R/W) -- */
        uint64_t metadata0             : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field METADATA0 from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t metadata0             : 26; /**< [ 25:  0](R/W) Continuation of MSBs of field METADATA0 from previous word. */
        uint64_t state                 : 8;  /**< [ 33: 26](R/W) -- */
        uint64_t innereth              : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_skpu_sramx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_skpu_sramx_w2 bdk_tns_sde_pe_skpu_skpu_sramx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060712010ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SKPU_SRAMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(a) bdk_tns_sde_pe_skpu_skpu_sramx_w2_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(a) "TNS_SDE_PE_SKPU_SKPU_SRAMX_W2"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_spad
 *
 * TNS SDE PE SKPU ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_pe_skpu_spad
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_spad_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_spad bdk_tns_sde_pe_skpu_spad_t;

#define BDK_TNS_SDE_PE_SKPU_SPAD BDK_TNS_SDE_PE_SKPU_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060714020ll;
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_SPAD bdk_tns_sde_pe_skpu_spad_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_SPAD "TNS_SDE_PE_SKPU_SPAD"
#define device_bar_BDK_TNS_SDE_PE_SKPU_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_SPAD 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SPAD -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_tcam_dat#_w0
 *
 * TNS SDE PE SKPU TCAM Data Word 0 Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT
 * Bits[63:41] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_skpu_tcam_datx_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_tcam_datx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t decpoint4             : 8;  /**< [ 63: 56](R/W) -- */
        uint64_t decpoint5             : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t decpoint6             : 8;  /**< [ 47: 40](R/W) -- */
        uint64_t decpoint7             : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t decpoint8             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t decpoint9             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint10            : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint11            : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t decpoint11            : 8;  /**< [  7:  0](R/W) -- */
        uint64_t decpoint10            : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint9             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint8             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t decpoint7             : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t decpoint6             : 8;  /**< [ 47: 40](R/W) -- */
        uint64_t decpoint5             : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t decpoint4             : 8;  /**< [ 63: 56](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_datx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_datx_w0 bdk_tns_sde_pe_skpu_tcam_datx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060713000ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DATX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(a) bdk_tns_sde_pe_skpu_tcam_datx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(a) "TNS_SDE_PE_SKPU_TCAM_DATX_W0"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_tcam_dat#_w1
 *
 * TNS SDE PE SKPU TCAM Data Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DAT(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_datx_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_tcam_datx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t decpoint0             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t decpoint1             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint2             : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint3             : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t decpoint3             : 8;  /**< [  7:  0](R/W) -- */
        uint64_t decpoint2             : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint1             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint0             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_datx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_datx_w1 bdk_tns_sde_pe_skpu_tcam_datx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060713008ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DATX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(a) bdk_tns_sde_pe_skpu_tcam_datx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(a) "TNS_SDE_PE_SKPU_TCAM_DATX_W1"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w0
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 0 Registers
 * This regiter provides access to the SKPU TCAM
 * Bits[31:18] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w0
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w0 bdk_tns_sde_pe_skpu_tcam_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060711000ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W0"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w1
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w1
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w1 bdk_tns_sde_pe_skpu_tcam_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060711004ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W1"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w2
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 2 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w2
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w2_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w2 bdk_tns_sde_pe_skpu_tcam_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060711008ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W2"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w3
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 3 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w3
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w3_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w3 bdk_tns_sde_pe_skpu_tcam_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x84206071100cll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W3"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w4
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 4 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w4
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w4_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w4 bdk_tns_sde_pe_skpu_tcam_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060711010ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W4"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w5
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 5 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w5
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w5_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w5 bdk_tns_sde_pe_skpu_tcam_dmskx_w5_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060711014ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W5", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w5_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W5"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_pe_skpu_tcam_dmsk#_w6
 *
 * TNS SDE PE SKPU TCAM Data Mask Word 6 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_dmskx_w6
{
    uint32_t u;
    struct bdk_tns_sde_pe_skpu_tcam_dmskx_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t vmvalid               : 2;  /**< [ 17: 16](R/W) -- */
        uint32_t vmdata                : 16; /**< [ 15:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t vmdata                : 16; /**< [ 15:  0](R/W) Continuation of MSBs of field VMDATA from previous word. */
        uint32_t vmvalid               : 2;  /**< [ 17: 16](R/W) -- */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w6_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w6 bdk_tns_sde_pe_skpu_tcam_dmskx_w6_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060711018ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_DMSKX_W6", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(a) bdk_tns_sde_pe_skpu_tcam_dmskx_w6_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(a) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W6"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_tcam_mask#_w0
 *
 * TNS SDE PE SKPU TCAM Mask Word 0 Registers
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT
 * Bits[63:41] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_pe_skpu_tcam_maskx_w0
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_tcam_maskx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t decpoint4             : 8;  /**< [ 63: 56](R/W) -- */
        uint64_t decpoint5             : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t decpoint6             : 8;  /**< [ 47: 40](R/W) -- */
        uint64_t decpoint7             : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t decpoint8             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t decpoint9             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint10            : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint11            : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t decpoint11            : 8;  /**< [  7:  0](R/W) -- */
        uint64_t decpoint10            : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint9             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint8             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t decpoint7             : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t decpoint6             : 8;  /**< [ 47: 40](R/W) -- */
        uint64_t decpoint5             : 8;  /**< [ 55: 48](R/W) -- */
        uint64_t decpoint4             : 8;  /**< [ 63: 56](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_maskx_w0_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_maskx_w0 bdk_tns_sde_pe_skpu_tcam_maskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060713800ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_MASKX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(a) bdk_tns_sde_pe_skpu_tcam_maskx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(a) "TNS_SDE_PE_SKPU_TCAM_MASKX_W0"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_pe_skpu_tcam_mask#_w1
 *
 * TNS SDE PE SKPU TCAM Mask Word 1 Registers
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_MASK(0..127)_W0
 */
union bdk_tns_sde_pe_skpu_tcam_maskx_w1
{
    uint64_t u;
    struct bdk_tns_sde_pe_skpu_tcam_maskx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t decpoint0             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t decpoint1             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint2             : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint3             : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t decpoint3             : 8;  /**< [  7:  0](R/W) -- */
        uint64_t decpoint2             : 8;  /**< [ 15:  8](R/W) -- */
        uint64_t decpoint1             : 8;  /**< [ 23: 16](R/W) -- */
        uint64_t decpoint0             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t currentstate          : 8;  /**< [ 39: 32](R/W) -- */
        uint64_t rowvalid              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_pe_skpu_tcam_maskx_w1_s cn; */
};
typedef union bdk_tns_sde_pe_skpu_tcam_maskx_w1 bdk_tns_sde_pe_skpu_tcam_maskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842060713808ll + 0x10ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SDE_PE_SKPU_TCAM_MASKX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(a) bdk_tns_sde_pe_skpu_tcam_maskx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(a) "TNS_SDE_PE_SKPU_TCAM_MASKX_W1"
#define device_bar_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(a) (a)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_afull_thresh
 *
 * TNS SDE URW1 Almost Full Threshold Register
 * Controls the max inflight requests.
 */
union bdk_tns_sde_urw1_afull_thresh
{
    uint32_t u;
    struct bdk_tns_sde_urw1_afull_thresh_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t vif_lat_fifo          : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vif_lat_fifo          : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_afull_thresh_s cn; */
};
typedef union bdk_tns_sde_urw1_afull_thresh bdk_tns_sde_urw1_afull_thresh_t;

#define BDK_TNS_SDE_URW1_AFULL_THRESH BDK_TNS_SDE_URW1_AFULL_THRESH_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_AFULL_THRESH_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_AFULL_THRESH_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0b8ll;
    __bdk_csr_fatal("TNS_SDE_URW1_AFULL_THRESH", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_AFULL_THRESH bdk_tns_sde_urw1_afull_thresh_t
#define bustype_BDK_TNS_SDE_URW1_AFULL_THRESH BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_AFULL_THRESH "TNS_SDE_URW1_AFULL_THRESH"
#define device_bar_BDK_TNS_SDE_URW1_AFULL_THRESH 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_AFULL_THRESH 0
#define arguments_BDK_TNS_SDE_URW1_AFULL_THRESH -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_control
 *
 * TNS SDE URW1 Control Register
 * Contains disable bits for various features
 */
union bdk_tns_sde_urw1_control
{
    uint32_t u;
    struct bdk_tns_sde_urw1_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t disable_se_vif_lkup   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t logic_rst             : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t logic_rst             : 1;  /**< [  0:  0](R/W) -- */
        uint32_t disable_se_vif_lkup   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_control_s cn; */
};
typedef union bdk_tns_sde_urw1_control bdk_tns_sde_urw1_control_t;

#define BDK_TNS_SDE_URW1_CONTROL BDK_TNS_SDE_URW1_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_CONTROL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0b0ll;
    __bdk_csr_fatal("TNS_SDE_URW1_CONTROL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_CONTROL bdk_tns_sde_urw1_control_t
#define bustype_BDK_TNS_SDE_URW1_CONTROL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_CONTROL "TNS_SDE_URW1_CONTROL"
#define device_bar_BDK_TNS_SDE_URW1_CONTROL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_CONTROL 0
#define arguments_BDK_TNS_SDE_URW1_CONTROL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_dbg_sel
 *
 * TNS SDE URW1 Debug Selector Register
 * --
 */
union bdk_tns_sde_urw1_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_urw1_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_urw1_dbg_sel bdk_tns_sde_urw1_dbg_sel_t;

#define BDK_TNS_SDE_URW1_DBG_SEL BDK_TNS_SDE_URW1_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b080ll;
    __bdk_csr_fatal("TNS_SDE_URW1_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_DBG_SEL bdk_tns_sde_urw1_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW1_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_DBG_SEL "TNS_SDE_URW1_DBG_SEL"
#define device_bar_BDK_TNS_SDE_URW1_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW1_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_dbg_sta_live
 *
 * TNS SDE URW1 Debug Status LIVE Register
 * --
 */
union bdk_tns_sde_urw1_dbg_sta_live
{
    uint32_t u;
    struct bdk_tns_sde_urw1_dbg_sta_live_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t data                  : 9;  /**< [  8:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 9;  /**< [  8:  0](RO/H) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_dbg_sta_live_s cn; */
};
typedef union bdk_tns_sde_urw1_dbg_sta_live bdk_tns_sde_urw1_dbg_sta_live_t;

#define BDK_TNS_SDE_URW1_DBG_STA_LIVE BDK_TNS_SDE_URW1_DBG_STA_LIVE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DBG_STA_LIVE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DBG_STA_LIVE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0d4ll;
    __bdk_csr_fatal("TNS_SDE_URW1_DBG_STA_LIVE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_DBG_STA_LIVE bdk_tns_sde_urw1_dbg_sta_live_t
#define bustype_BDK_TNS_SDE_URW1_DBG_STA_LIVE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_DBG_STA_LIVE "TNS_SDE_URW1_DBG_STA_LIVE"
#define device_bar_BDK_TNS_SDE_URW1_DBG_STA_LIVE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_DBG_STA_LIVE 0
#define arguments_BDK_TNS_SDE_URW1_DBG_STA_LIVE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_dbg_vlf
 *
 * TNS SDE URW1 Debug VLF Register
 * For debug hooks to VLF fifo
 */
union bdk_tns_sde_urw1_dbg_vlf
{
    uint32_t u;
    struct bdk_tns_sde_urw1_dbg_vlf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_dbg_vlf_s cn; */
};
typedef union bdk_tns_sde_urw1_dbg_vlf bdk_tns_sde_urw1_dbg_vlf_t;

#define BDK_TNS_SDE_URW1_DBG_VLF BDK_TNS_SDE_URW1_DBG_VLF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DBG_VLF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DBG_VLF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0ccll;
    __bdk_csr_fatal("TNS_SDE_URW1_DBG_VLF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_DBG_VLF bdk_tns_sde_urw1_dbg_vlf_t
#define bustype_BDK_TNS_SDE_URW1_DBG_VLF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_DBG_VLF "TNS_SDE_URW1_DBG_VLF"
#define device_bar_BDK_TNS_SDE_URW1_DBG_VLF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_DBG_VLF 0
#define arguments_BDK_TNS_SDE_URW1_DBG_VLF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_dyn_dbg_vlf
 *
 * TNS SDE URW1 DYN Debug VLF Register
 * For debug hooks to VLF fifo
 */
union bdk_tns_sde_urw1_dyn_dbg_vlf
{
    uint32_t u;
    struct bdk_tns_sde_urw1_dyn_dbg_vlf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t data                  : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_dyn_dbg_vlf_s cn; */
};
typedef union bdk_tns_sde_urw1_dyn_dbg_vlf bdk_tns_sde_urw1_dyn_dbg_vlf_t;

#define BDK_TNS_SDE_URW1_DYN_DBG_VLF BDK_TNS_SDE_URW1_DYN_DBG_VLF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DYN_DBG_VLF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DYN_DBG_VLF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0d0ll;
    __bdk_csr_fatal("TNS_SDE_URW1_DYN_DBG_VLF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_DYN_DBG_VLF bdk_tns_sde_urw1_dyn_dbg_vlf_t
#define bustype_BDK_TNS_SDE_URW1_DYN_DBG_VLF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_DYN_DBG_VLF "TNS_SDE_URW1_DYN_DBG_VLF"
#define device_bar_BDK_TNS_SDE_URW1_DYN_DBG_VLF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_DYN_DBG_VLF 0
#define arguments_BDK_TNS_SDE_URW1_DYN_DBG_VLF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_ecc_ctl_cd
 *
 * TNS SDE URW1 ECC Control Disable Correction Register
 * --
 */
union bdk_tns_sde_urw1_ecc_ctl_cd
{
    uint32_t u;
    struct bdk_tns_sde_urw1_ecc_ctl_cd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t cpu_rsn_tbl           : 1;  /**< [  6:  6](R/W) -- */
        uint32_t eflt_tbl              : 1;  /**< [  5:  5](R/W) -- */
        uint32_t evif_tbl              : 1;  /**< [  4:  4](R/W) -- */
        uint32_t ivif_tbl              : 1;  /**< [  3:  3](R/W) -- */
        uint32_t templateid_tbl        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t trt_tbl               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t vlf_fifo              : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t vlf_fifo              : 1;  /**< [  0:  0](R/W) -- */
        uint32_t trt_tbl               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t templateid_tbl        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t ivif_tbl              : 1;  /**< [  3:  3](R/W) -- */
        uint32_t evif_tbl              : 1;  /**< [  4:  4](R/W) -- */
        uint32_t eflt_tbl              : 1;  /**< [  5:  5](R/W) -- */
        uint32_t cpu_rsn_tbl           : 1;  /**< [  6:  6](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_ecc_ctl_cd_s cn; */
};
typedef union bdk_tns_sde_urw1_ecc_ctl_cd bdk_tns_sde_urw1_ecc_ctl_cd_t;

#define BDK_TNS_SDE_URW1_ECC_CTL_CD BDK_TNS_SDE_URW1_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_CD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0acll;
    __bdk_csr_fatal("TNS_SDE_URW1_ECC_CTL_CD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_ECC_CTL_CD bdk_tns_sde_urw1_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_URW1_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_ECC_CTL_CD "TNS_SDE_URW1_ECC_CTL_CD"
#define device_bar_BDK_TNS_SDE_URW1_ECC_CTL_CD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_URW1_ECC_CTL_CD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_ecc_ctl_flp_w0
 *
 * TNS SDE URW1 ECC Control Flip Word 0 Register
 * --
 */
union bdk_tns_sde_urw1_ecc_ctl_flp_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw1_ecc_ctl_flp_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sb_vlf_fifo           : 8;  /**< [ 31: 24](R/W) -- */
        uint32_t db_cpu_rsn_tbl        : 1;  /**< [ 23: 23](R/W) -- */
        uint32_t db_eflt_tbl           : 2;  /**< [ 22: 21](R/W) -- */
        uint32_t db_evif_tbl           : 2;  /**< [ 20: 19](R/W) -- */
        uint32_t db_ivif_tbl           : 2;  /**< [ 18: 17](R/W) -- */
        uint32_t db_templateid_tbl     : 2;  /**< [ 16: 15](R/W) -- */
        uint32_t db_trt_tbl            : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t db_vlf_fifo           : 13; /**< [ 12:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_vlf_fifo           : 13; /**< [ 12:  0](R/W) -- */
        uint32_t db_trt_tbl            : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t db_templateid_tbl     : 2;  /**< [ 16: 15](R/W) -- */
        uint32_t db_ivif_tbl           : 2;  /**< [ 18: 17](R/W) -- */
        uint32_t db_evif_tbl           : 2;  /**< [ 20: 19](R/W) -- */
        uint32_t db_eflt_tbl           : 2;  /**< [ 22: 21](R/W) -- */
        uint32_t db_cpu_rsn_tbl        : 1;  /**< [ 23: 23](R/W) -- */
        uint32_t sb_vlf_fifo           : 8;  /**< [ 31: 24](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_ecc_ctl_flp_w0_s cn; */
};
typedef union bdk_tns_sde_urw1_ecc_ctl_flp_w0 bdk_tns_sde_urw1_ecc_ctl_flp_w0_t;

#define BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0a4ll;
    __bdk_csr_fatal("TNS_SDE_URW1_ECC_CTL_FLP_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 bdk_tns_sde_urw1_ecc_ctl_flp_w0_t
#define bustype_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 "TNS_SDE_URW1_ECC_CTL_FLP_W0"
#define device_bar_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 0
#define arguments_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_ecc_ctl_flp_w1
 *
 * TNS SDE URW1 ECC Control Flip Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW1_ECC_CTL_FLP_W0
 */
union bdk_tns_sde_urw1_ecc_ctl_flp_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw1_ecc_ctl_flp_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t sb_cpu_rsn_tbl        : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t sb_eflt_tbl           : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t sb_evif_tbl           : 2;  /**< [ 12: 11](R/W) -- */
        uint32_t sb_ivif_tbl           : 2;  /**< [ 10:  9](R/W) -- */
        uint32_t sb_templateid_tbl     : 2;  /**< [  8:  7](R/W) -- */
        uint32_t sb_trt_tbl            : 2;  /**< [  6:  5](R/W) -- */
        uint32_t sb_vlf_fifo           : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field SB_VLF_FIFO from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t sb_vlf_fifo           : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field SB_VLF_FIFO from previous word. */
        uint32_t sb_trt_tbl            : 2;  /**< [  6:  5](R/W) -- */
        uint32_t sb_templateid_tbl     : 2;  /**< [  8:  7](R/W) -- */
        uint32_t sb_ivif_tbl           : 2;  /**< [ 10:  9](R/W) -- */
        uint32_t sb_evif_tbl           : 2;  /**< [ 12: 11](R/W) -- */
        uint32_t sb_eflt_tbl           : 2;  /**< [ 14: 13](R/W) -- */
        uint32_t sb_cpu_rsn_tbl        : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_ecc_ctl_flp_w1_s cn; */
};
typedef union bdk_tns_sde_urw1_ecc_ctl_flp_w1 bdk_tns_sde_urw1_ecc_ctl_flp_w1_t;

#define BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0a8ll;
    __bdk_csr_fatal("TNS_SDE_URW1_ECC_CTL_FLP_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 bdk_tns_sde_urw1_ecc_ctl_flp_w1_t
#define bustype_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 "TNS_SDE_URW1_ECC_CTL_FLP_W1"
#define device_bar_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 0
#define arguments_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_egr_flt_tbl#_w#
 *
 * TNS SDE URW1 EGR FLT Table Registers
 * Contains CBL bitmap. Indexed by token.filter_grp_num
 * Bits[31:9] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw1_egr_flt_tblx_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw1_egr_flt_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t eflt_data             : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t eflt_data             : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_egr_flt_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_egr_flt_tblx_wx bdk_tns_sde_urw1_egr_flt_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=255) && (b<=4)))
        return 0x842060408000ll + 0x20ll * ((a) & 0xff) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SDE_URW1_EGR_FLT_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(a,b) bdk_tns_sde_urw1_egr_flt_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(a,b) "TNS_SDE_URW1_EGR_FLT_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_urw1_evif_tbl#_w#
 *
 * TNS SDE URW1 EVIF Table Registers
 * Local Vif table.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw1_evif_tblx_wx
{
    uint64_t u;
    struct bdk_tns_sde_urw1_evif_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t evif_response         : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t evif_response         : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_evif_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_evif_tblx_wx bdk_tns_sde_urw1_evif_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_EVIF_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_EVIF_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=255) && (b<=2)))
        return 0x842060406000ll + 0x20ll * ((a) & 0xff) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_URW1_EVIF_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(a,b) bdk_tns_sde_urw1_evif_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(a,b) "TNS_SDE_URW1_EVIF_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_evif_w#
 *
 * TNS SDE URW1 EVIF Registers
 * eVif Range0_3
 * Bits 31..8 of registers ending in _W1 are unused.
 */
union bdk_tns_sde_urw1_evif_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw1_evif_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t range0_3              : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t range0_3              : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_evif_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_evif_wx bdk_tns_sde_urw1_evif_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_EVIF_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_EVIF_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206040b0bcll + 4ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_URW1_EVIF_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_EVIF_WX(a) bdk_tns_sde_urw1_evif_wx_t
#define bustype_BDK_TNS_SDE_URW1_EVIF_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_EVIF_WX(a) "TNS_SDE_URW1_EVIF_WX"
#define device_bar_BDK_TNS_SDE_URW1_EVIF_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_EVIF_WX(a) (a)
#define arguments_BDK_TNS_SDE_URW1_EVIF_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_en_hi_w0
 *
 * TNS SDE URW1 Interrrupt Enable High Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw1_int_en_hi_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_en_hi_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](R/W) -- */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](R/W) -- */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_en_hi_w0_s cn; */
};
typedef union bdk_tns_sde_urw1_int_en_hi_w0 bdk_tns_sde_urw1_int_en_hi_w0_t;

#define BDK_TNS_SDE_URW1_INT_EN_HI_W0 BDK_TNS_SDE_URW1_INT_EN_HI_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b08cll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_EN_HI_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_EN_HI_W0 bdk_tns_sde_urw1_int_en_hi_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_HI_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_EN_HI_W0 "TNS_SDE_URW1_INT_EN_HI_W0"
#define device_bar_BDK_TNS_SDE_URW1_INT_EN_HI_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_EN_HI_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_HI_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_en_hi_w1
 *
 * TNS SDE URW1 Interrrupt Enable High Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW1_INT_EN_HI_W0
 */
union bdk_tns_sde_urw1_int_en_hi_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_en_hi_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](R/W) -- */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](R/W) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](R/W) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](R/W) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_en_hi_w1_s cn; */
};
typedef union bdk_tns_sde_urw1_int_en_hi_w1 bdk_tns_sde_urw1_int_en_hi_w1_t;

#define BDK_TNS_SDE_URW1_INT_EN_HI_W1 BDK_TNS_SDE_URW1_INT_EN_HI_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b090ll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_EN_HI_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_EN_HI_W1 bdk_tns_sde_urw1_int_en_hi_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_HI_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_EN_HI_W1 "TNS_SDE_URW1_INT_EN_HI_W1"
#define device_bar_BDK_TNS_SDE_URW1_INT_EN_HI_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_EN_HI_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_HI_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_en_lo_w0
 *
 * TNS SDE URW1 Interrrupt Enable Low Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw1_int_en_lo_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_en_lo_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](R/W) -- */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](R/W) -- */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_en_lo_w0_s cn; */
};
typedef union bdk_tns_sde_urw1_int_en_lo_w0 bdk_tns_sde_urw1_int_en_lo_w0_t;

#define BDK_TNS_SDE_URW1_INT_EN_LO_W0 BDK_TNS_SDE_URW1_INT_EN_LO_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b094ll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_EN_LO_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_EN_LO_W0 bdk_tns_sde_urw1_int_en_lo_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_LO_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_EN_LO_W0 "TNS_SDE_URW1_INT_EN_LO_W0"
#define device_bar_BDK_TNS_SDE_URW1_INT_EN_LO_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_EN_LO_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_LO_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_en_lo_w1
 *
 * TNS SDE URW1 Interrrupt Enable Low Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW1_INT_EN_LO_W0
 */
union bdk_tns_sde_urw1_int_en_lo_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_en_lo_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](R/W) -- */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](R/W) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](R/W) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](R/W) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_en_lo_w1_s cn; */
};
typedef union bdk_tns_sde_urw1_int_en_lo_w1 bdk_tns_sde_urw1_int_en_lo_w1_t;

#define BDK_TNS_SDE_URW1_INT_EN_LO_W1 BDK_TNS_SDE_URW1_INT_EN_LO_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b098ll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_EN_LO_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_EN_LO_W1 bdk_tns_sde_urw1_int_en_lo_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_LO_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_EN_LO_W1 "TNS_SDE_URW1_INT_EN_LO_W1"
#define device_bar_BDK_TNS_SDE_URW1_INT_EN_LO_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_EN_LO_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_LO_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_frc_w0
 *
 * TNS SDE URW1 Interrrupt Force Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw1_int_frc_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_frc_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](WO) -- */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](WO) -- */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](WO) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_frc_w0_s cn; */
};
typedef union bdk_tns_sde_urw1_int_frc_w0 bdk_tns_sde_urw1_int_frc_w0_t;

#define BDK_TNS_SDE_URW1_INT_FRC_W0 BDK_TNS_SDE_URW1_INT_FRC_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b09cll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_FRC_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_FRC_W0 bdk_tns_sde_urw1_int_frc_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_FRC_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_FRC_W0 "TNS_SDE_URW1_INT_FRC_W0"
#define device_bar_BDK_TNS_SDE_URW1_INT_FRC_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_FRC_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_FRC_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_frc_w1
 *
 * TNS SDE URW1 Interrrupt Force Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW1_INT_FRC_W0
 */
union bdk_tns_sde_urw1_int_frc_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_frc_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](WO) -- */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](WO) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](WO) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](WO) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_frc_w1_s cn; */
};
typedef union bdk_tns_sde_urw1_int_frc_w1 bdk_tns_sde_urw1_int_frc_w1_t;

#define BDK_TNS_SDE_URW1_INT_FRC_W1 BDK_TNS_SDE_URW1_INT_FRC_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0a0ll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_FRC_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_FRC_W1 bdk_tns_sde_urw1_int_frc_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_FRC_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_FRC_W1 "TNS_SDE_URW1_INT_FRC_W1"
#define device_bar_BDK_TNS_SDE_URW1_INT_FRC_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_FRC_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_FRC_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_w1c_w0
 *
 * TNS SDE URW1 Interrrupt W1C Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw1_int_w1c_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_w1c_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](R/W1C/H) -- */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lkup_sb_err           : 25; /**< [ 24:  0](R/W1C/H) -- */
        uint32_t lkup_db_err           : 7;  /**< [ 31: 25](R/W1C/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_w1c_w0_s cn; */
};
typedef union bdk_tns_sde_urw1_int_w1c_w0 bdk_tns_sde_urw1_int_w1c_w0_t;

#define BDK_TNS_SDE_URW1_INT_W1C_W0 BDK_TNS_SDE_URW1_INT_W1C_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b084ll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_W1C_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_W1C_W0 bdk_tns_sde_urw1_int_w1c_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_W1C_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_W1C_W0 "TNS_SDE_URW1_INT_W1C_W0"
#define device_bar_BDK_TNS_SDE_URW1_INT_W1C_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_W1C_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_W1C_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_int_w1c_w1
 *
 * TNS SDE URW1 Interrrupt W1C Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW1_INT_W1C_W0
 */
union bdk_tns_sde_urw1_int_w1c_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw1_int_w1c_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](R/W1C/H) -- */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](R/W1C/H) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t lkup_db_err           : 18; /**< [ 17:  0](R/W1C/H) Continuation of MSBs of field LKUP_DB_ERR from previous word. */
        uint32_t rewrite_ptr_exceed8   : 1;  /**< [ 18: 18](R/W1C/H) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_int_w1c_w1_s cn; */
};
typedef union bdk_tns_sde_urw1_int_w1c_w1 bdk_tns_sde_urw1_int_w1c_w1_t;

#define BDK_TNS_SDE_URW1_INT_W1C_W1 BDK_TNS_SDE_URW1_INT_W1C_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b088ll;
    __bdk_csr_fatal("TNS_SDE_URW1_INT_W1C_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_INT_W1C_W1 bdk_tns_sde_urw1_int_w1c_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_W1C_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_INT_W1C_W1 "TNS_SDE_URW1_INT_W1C_W1"
#define device_bar_BDK_TNS_SDE_URW1_INT_W1C_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_INT_W1C_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_W1C_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw1_ivif_tbl#_w#
 *
 * TNS SDE URW1 IVIF Table Registers
 * Local Vif table.
 * Refer to urw/xp_urw_tbl.vh for the details of this table.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw1_ivif_tblx_wx
{
    uint64_t u;
    struct bdk_tns_sde_urw1_ivif_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t ivif_response         : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t ivif_response         : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_ivif_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_ivif_tblx_wx bdk_tns_sde_urw1_ivif_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_IVIF_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_IVIF_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=255) && (b<=2)))
        return 0x842060404000ll + 0x20ll * ((a) & 0xff) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_URW1_IVIF_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(a,b) bdk_tns_sde_urw1_ivif_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(a,b) "TNS_SDE_URW1_IVIF_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_ivif_w#
 *
 * TNS SDE URW1 IVIF Registers
 * iVif Range0_3
 * Bits 31..8 of registers ending in _W1 are unused.
 */
union bdk_tns_sde_urw1_ivif_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw1_ivif_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t range0_3              : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t range0_3              : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_ivif_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_ivif_wx bdk_tns_sde_urw1_ivif_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_IVIF_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_IVIF_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84206040b0c4ll + 4ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SDE_URW1_IVIF_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_IVIF_WX(a) bdk_tns_sde_urw1_ivif_wx_t
#define bustype_BDK_TNS_SDE_URW1_IVIF_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_IVIF_WX(a) "TNS_SDE_URW1_IVIF_WX"
#define device_bar_BDK_TNS_SDE_URW1_IVIF_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_IVIF_WX(a) (a)
#define arguments_BDK_TNS_SDE_URW1_IVIF_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_lock
 *
 * TNS SDE URW1 Lock Register
 * Lock Register
 */
union bdk_tns_sde_urw1_lock
{
    uint32_t u;
    struct bdk_tns_sde_urw1_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_lock_s cn; */
};
typedef union bdk_tns_sde_urw1_lock bdk_tns_sde_urw1_lock_t;

#define BDK_TNS_SDE_URW1_LOCK BDK_TNS_SDE_URW1_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0d8ll;
    __bdk_csr_fatal("TNS_SDE_URW1_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_LOCK bdk_tns_sde_urw1_lock_t
#define bustype_BDK_TNS_SDE_URW1_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_LOCK "TNS_SDE_URW1_LOCK"
#define device_bar_BDK_TNS_SDE_URW1_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_LOCK 0
#define arguments_BDK_TNS_SDE_URW1_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_mir_mask
 *
 * TNS SDE URW1 Mirror Mask Register
 * This holds masks for Ingress, Egress, evif and ivif Mirror.
 */
union bdk_tns_sde_urw1_mir_mask
{
    uint32_t u;
    struct bdk_tns_sde_urw1_mir_mask_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ivif                  : 16; /**< [ 31: 16](R/W) -- */
        uint32_t evif                  : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t evif                  : 16; /**< [ 15:  0](R/W) -- */
        uint32_t ivif                  : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_mir_mask_s cn; */
};
typedef union bdk_tns_sde_urw1_mir_mask bdk_tns_sde_urw1_mir_mask_t;

#define BDK_TNS_SDE_URW1_MIR_MASK BDK_TNS_SDE_URW1_MIR_MASK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_MIR_MASK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_MIR_MASK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0b4ll;
    __bdk_csr_fatal("TNS_SDE_URW1_MIR_MASK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_MIR_MASK bdk_tns_sde_urw1_mir_mask_t
#define bustype_BDK_TNS_SDE_URW1_MIR_MASK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_MIR_MASK "TNS_SDE_URW1_MIR_MASK"
#define device_bar_BDK_TNS_SDE_URW1_MIR_MASK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_MIR_MASK 0
#define arguments_BDK_TNS_SDE_URW1_MIR_MASK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_rsn_tbl#
 *
 * TNS SDE URW1 Reason Code Table Registers
 * Reason Code table used for CPU packets and cpu copies. Indexed by lower 10 bits
 * of reasonCode.
 */
union bdk_tns_sde_urw1_rsn_tblx
{
    uint32_t u;
    struct bdk_tns_sde_urw1_rsn_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t port                  : 8;  /**< [ 13:  6](R/W) -- */
        uint32_t traffic_class         : 4;  /**< [  5:  2](R/W) -- */
        uint32_t truncation            : 1;  /**< [  1:  1](R/W) -- */
        uint32_t format                : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t format                : 1;  /**< [  0:  0](R/W) -- */
        uint32_t truncation            : 1;  /**< [  1:  1](R/W) -- */
        uint32_t traffic_class         : 4;  /**< [  5:  2](R/W) -- */
        uint32_t port                  : 8;  /**< [ 13:  6](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_rsn_tblx_s cn; */
};
typedef union bdk_tns_sde_urw1_rsn_tblx bdk_tns_sde_urw1_rsn_tblx_t;

static inline uint64_t BDK_TNS_SDE_URW1_RSN_TBLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_RSN_TBLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1023))
        return 0x84206040a000ll + 4ll * ((a) & 0x3ff);
    __bdk_csr_fatal("TNS_SDE_URW1_RSN_TBLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_RSN_TBLX(a) bdk_tns_sde_urw1_rsn_tblx_t
#define bustype_BDK_TNS_SDE_URW1_RSN_TBLX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_RSN_TBLX(a) "TNS_SDE_URW1_RSN_TBLX"
#define device_bar_BDK_TNS_SDE_URW1_RSN_TBLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_RSN_TBLX(a) (a)
#define arguments_BDK_TNS_SDE_URW1_RSN_TBLX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_urw1_se_resp_tbl#
 *
 * TNS SDE URW1 Search Response Table Registers
 * Search profile table to gather vif responses.
 * This field tells if the evif response is 32 bit valid. Lower 32-bits of
 * 64-bit se lane should be valid.
 * If this bit is set, then token_id_0_32bit_format should be : 1000_0000
 */
union bdk_tns_sde_urw1_se_resp_tblx
{
    uint64_t u;
    struct bdk_tns_sde_urw1_se_resp_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_61_63        : 3;
        uint64_t token_id_0_32bit_format : 1;/**< [ 60: 60](R/W) -- */
        uint64_t token_id_0_bit_map    : 4;  /**< [ 59: 56](R/W) -- */
        uint64_t token_id_1_32bit_format : 1;/**< [ 55: 55](R/W) -- */
        uint64_t token_id_1_bit_map    : 4;  /**< [ 54: 51](R/W) -- */
        uint64_t prfid                 : 7;  /**< [ 50: 44](R/W) -- */
        uint64_t cmd_en                : 4;  /**< [ 43: 40](R/W) -- */
        uint64_t ivif_offset           : 20; /**< [ 39: 20](R/W) -- */
        uint64_t evif_offset           : 20; /**< [ 19:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t evif_offset           : 20; /**< [ 19:  0](R/W) -- */
        uint64_t ivif_offset           : 20; /**< [ 39: 20](R/W) -- */
        uint64_t cmd_en                : 4;  /**< [ 43: 40](R/W) -- */
        uint64_t prfid                 : 7;  /**< [ 50: 44](R/W) -- */
        uint64_t token_id_1_bit_map    : 4;  /**< [ 54: 51](R/W) -- */
        uint64_t token_id_1_32bit_format : 1;/**< [ 55: 55](R/W) -- */
        uint64_t token_id_0_bit_map    : 4;  /**< [ 59: 56](R/W) -- */
        uint64_t token_id_0_32bit_format : 1;/**< [ 60: 60](R/W) -- */
        uint64_t reserved_61_63        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_se_resp_tblx_s cn; */
};
typedef union bdk_tns_sde_urw1_se_resp_tblx bdk_tns_sde_urw1_se_resp_tblx_t;

static inline uint64_t BDK_TNS_SDE_URW1_SE_RESP_TBLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_SE_RESP_TBLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x84206040b000ll + 8ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_SDE_URW1_SE_RESP_TBLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_SE_RESP_TBLX(a) bdk_tns_sde_urw1_se_resp_tblx_t
#define bustype_BDK_TNS_SDE_URW1_SE_RESP_TBLX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW1_SE_RESP_TBLX(a) "TNS_SDE_URW1_SE_RESP_TBLX"
#define device_bar_BDK_TNS_SDE_URW1_SE_RESP_TBLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_SE_RESP_TBLX(a) (a)
#define arguments_BDK_TNS_SDE_URW1_SE_RESP_TBLX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_spad
 *
 * TNS SDE URW1 ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_urw1_spad
{
    uint32_t u;
    struct bdk_tns_sde_urw1_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_spad_s cn; */
};
typedef union bdk_tns_sde_urw1_spad bdk_tns_sde_urw1_spad_t;

#define BDK_TNS_SDE_URW1_SPAD BDK_TNS_SDE_URW1_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206040b0dcll;
    __bdk_csr_fatal("TNS_SDE_URW1_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_SPAD bdk_tns_sde_urw1_spad_t
#define bustype_BDK_TNS_SDE_URW1_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_SPAD "TNS_SDE_URW1_SPAD"
#define device_bar_BDK_TNS_SDE_URW1_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_SPAD 0
#define arguments_BDK_TNS_SDE_URW1_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_tpid_tbl#_w#
 *
 * TNS SDE URW1 Template ID Table Registers
 * Template ID Table contains layer offset, layerType and other tbd fields
 * Bits[31:8] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw1_tpid_tblx_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw1_tpid_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_tpid_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_tpid_tblx_wx bdk_tns_sde_urw1_tpid_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_TPID_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_TPID_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=255) && (b<=4)))
        return 0x842060400000ll + 0x20ll * ((a) & 0xff) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SDE_URW1_TPID_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_TPID_TBLX_WX(a,b) bdk_tns_sde_urw1_tpid_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_TPID_TBLX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_TPID_TBLX_WX(a,b) "TNS_SDE_URW1_TPID_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW1_TPID_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_TPID_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW1_TPID_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_urw1_trt_tbl#_w#
 *
 * TNS SDE URW1 TRT Table Registers
 * Table contains 137 bits for resolving trunks. Each bit is for a logical port.
 * Indexed by HASH1%256.
 * This hash must be same across multiple asics.
 * Bits[31:9] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw1_trt_tblx_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw1_trt_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw1_trt_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw1_trt_tblx_wx bdk_tns_sde_urw1_trt_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_TRT_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_TRT_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=255) && (b<=4)))
        return 0x842060402000ll + 0x20ll * ((a) & 0xff) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SDE_URW1_TRT_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW1_TRT_TBLX_WX(a,b) bdk_tns_sde_urw1_trt_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_TRT_TBLX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW1_TRT_TBLX_WX(a,b) "TNS_SDE_URW1_TRT_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW1_TRT_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW1_TRT_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW1_TRT_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_dbg_sel
 *
 * TNS SDE URW2A Debug Selector Register
 * --
 */
union bdk_tns_sde_urw2a_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_urw2a_dbg_sel bdk_tns_sde_urw2a_dbg_sel_t;

#define BDK_TNS_SDE_URW2A_DBG_SEL BDK_TNS_SDE_URW2A_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c58ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_DBG_SEL bdk_tns_sde_urw2a_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW2A_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_DBG_SEL "TNS_SDE_URW2A_DBG_SEL"
#define device_bar_BDK_TNS_SDE_URW2A_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW2A_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_dbg_sta_live_w#
 *
 * TNS SDE URW2A Debug Status LIVE Registers
 * Bits 31..27 of registers ending in _W6 are unused.
 */
union bdk_tns_sde_urw2a_dbg_sta_live_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_dbg_sta_live_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_dbg_sta_live_wx_s cn; */
};
typedef union bdk_tns_sde_urw2a_dbg_sta_live_wx bdk_tns_sde_urw2a_dbg_sta_live_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=6))
        return 0x842060481c3cll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SDE_URW2A_DBG_STA_LIVE_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(a) bdk_tns_sde_urw2a_dbg_sta_live_wx_t
#define bustype_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(a) "TNS_SDE_URW2A_DBG_STA_LIVE_WX"
#define device_bar_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_etag_w0
 *
 * TNS SDE URW2A ETAG Word 0 Register
 * Contains enable bits per port and modify etag enable for packet modifications
 * going to etag ports.
 */
union bdk_tns_sde_urw2a_etag_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_etag_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_etag_w0_s cn; */
};
typedef union bdk_tns_sde_urw2a_etag_w0 bdk_tns_sde_urw2a_etag_w0_t;

#define BDK_TNS_SDE_URW2A_ETAG_W0 BDK_TNS_SDE_URW2A_ETAG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c28ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_ETAG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_ETAG_W0 bdk_tns_sde_urw2a_etag_w0_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_ETAG_W0 "TNS_SDE_URW2A_ETAG_W0"
#define device_bar_BDK_TNS_SDE_URW2A_ETAG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W0 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_etag_w1
 *
 * TNS SDE URW2A ETAG Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 */
union bdk_tns_sde_urw2a_etag_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_etag_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_etag_w1_s cn; */
};
typedef union bdk_tns_sde_urw2a_etag_w1 bdk_tns_sde_urw2a_etag_w1_t;

#define BDK_TNS_SDE_URW2A_ETAG_W1 BDK_TNS_SDE_URW2A_ETAG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c2cll;
    __bdk_csr_fatal("TNS_SDE_URW2A_ETAG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_ETAG_W1 bdk_tns_sde_urw2a_etag_w1_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_ETAG_W1 "TNS_SDE_URW2A_ETAG_W1"
#define device_bar_BDK_TNS_SDE_URW2A_ETAG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W1 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_etag_w2
 *
 * TNS SDE URW2A ETAG Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 */
union bdk_tns_sde_urw2a_etag_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_etag_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_etag_w2_s cn; */
};
typedef union bdk_tns_sde_urw2a_etag_w2 bdk_tns_sde_urw2a_etag_w2_t;

#define BDK_TNS_SDE_URW2A_ETAG_W2 BDK_TNS_SDE_URW2A_ETAG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c30ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_ETAG_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_ETAG_W2 bdk_tns_sde_urw2a_etag_w2_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_ETAG_W2 "TNS_SDE_URW2A_ETAG_W2"
#define device_bar_BDK_TNS_SDE_URW2A_ETAG_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W2 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_etag_w3
 *
 * TNS SDE URW2A ETAG Word 3 Register
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 */
union bdk_tns_sde_urw2a_etag_w3
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_etag_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_etag_w3_s cn; */
};
typedef union bdk_tns_sde_urw2a_etag_w3 bdk_tns_sde_urw2a_etag_w3_t;

#define BDK_TNS_SDE_URW2A_ETAG_W3 BDK_TNS_SDE_URW2A_ETAG_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c34ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_ETAG_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_ETAG_W3 bdk_tns_sde_urw2a_etag_w3_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_ETAG_W3 "TNS_SDE_URW2A_ETAG_W3"
#define device_bar_BDK_TNS_SDE_URW2A_ETAG_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W3 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_etag_w4
 *
 * TNS SDE URW2A ETAG Word 4 Register
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 */
union bdk_tns_sde_urw2a_etag_w4
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_etag_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t modify_etag_en        : 1;  /**< [  9:  9](R/W) -- */
        uint32_t pt_en                 : 9;  /**< [  8:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 9;  /**< [  8:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
        uint32_t modify_etag_en        : 1;  /**< [  9:  9](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_etag_w4_s cn; */
};
typedef union bdk_tns_sde_urw2a_etag_w4 bdk_tns_sde_urw2a_etag_w4_t;

#define BDK_TNS_SDE_URW2A_ETAG_W4 BDK_TNS_SDE_URW2A_ETAG_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c38ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_ETAG_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_ETAG_W4 bdk_tns_sde_urw2a_etag_w4_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_ETAG_W4 "TNS_SDE_URW2A_ETAG_W4"
#define device_bar_BDK_TNS_SDE_URW2A_ETAG_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W4 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W4 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_hdr_w0
 *
 * TNS SDE URW2A Header Configuration Word 0 Register
 * Contains disable bits for various features
 */
union bdk_tns_sde_urw2a_hdr_w0
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_hdr_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lpb_pt_en             : 48; /**< [ 63: 16](R/W) -- */
        uint64_t etag_etype            : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t etag_etype            : 16; /**< [ 15:  0](R/W) -- */
        uint64_t lpb_pt_en             : 48; /**< [ 63: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_hdr_w0_s cn; */
};
typedef union bdk_tns_sde_urw2a_hdr_w0 bdk_tns_sde_urw2a_hdr_w0_t;

#define BDK_TNS_SDE_URW2A_HDR_W0 BDK_TNS_SDE_URW2A_HDR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c00ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_HDR_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_HDR_W0 bdk_tns_sde_urw2a_hdr_w0_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_HDR_W0 "TNS_SDE_URW2A_HDR_W0"
#define device_bar_BDK_TNS_SDE_URW2A_HDR_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_HDR_W0 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W0 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_hdr_w1
 *
 * TNS SDE URW2A Header Configuration Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 */
union bdk_tns_sde_urw2a_hdr_w1
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_hdr_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lpb_pt_en             : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lpb_pt_en             : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_hdr_w1_s cn; */
};
typedef union bdk_tns_sde_urw2a_hdr_w1 bdk_tns_sde_urw2a_hdr_w1_t;

#define BDK_TNS_SDE_URW2A_HDR_W1 BDK_TNS_SDE_URW2A_HDR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c08ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_HDR_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_HDR_W1 bdk_tns_sde_urw2a_hdr_w1_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_HDR_W1 "TNS_SDE_URW2A_HDR_W1"
#define device_bar_BDK_TNS_SDE_URW2A_HDR_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_HDR_W1 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_hdr_w2
 *
 * TNS SDE URW2A Header Configuration Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 */
union bdk_tns_sde_urw2a_hdr_w2
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_hdr_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cpu_xph_en            : 39; /**< [ 63: 25](R/W) -- */
        uint64_t lpb_pt_en             : 25; /**< [ 24:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lpb_pt_en             : 25; /**< [ 24:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
        uint64_t cpu_xph_en            : 39; /**< [ 63: 25](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_hdr_w2_s cn; */
};
typedef union bdk_tns_sde_urw2a_hdr_w2 bdk_tns_sde_urw2a_hdr_w2_t;

#define BDK_TNS_SDE_URW2A_HDR_W2 BDK_TNS_SDE_URW2A_HDR_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c10ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_HDR_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_HDR_W2 bdk_tns_sde_urw2a_hdr_w2_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W2 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_HDR_W2 "TNS_SDE_URW2A_HDR_W2"
#define device_bar_BDK_TNS_SDE_URW2A_HDR_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_HDR_W2 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W2 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_hdr_w3
 *
 * TNS SDE URW2A Header Configuration Word 3 Register
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 */
union bdk_tns_sde_urw2a_hdr_w3
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_hdr_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cpu_xph_en            : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_xph_en            : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_hdr_w3_s cn; */
};
typedef union bdk_tns_sde_urw2a_hdr_w3 bdk_tns_sde_urw2a_hdr_w3_t;

#define BDK_TNS_SDE_URW2A_HDR_W3 BDK_TNS_SDE_URW2A_HDR_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c18ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_HDR_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_HDR_W3 bdk_tns_sde_urw2a_hdr_w3_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W3 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_HDR_W3 "TNS_SDE_URW2A_HDR_W3"
#define device_bar_BDK_TNS_SDE_URW2A_HDR_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_HDR_W3 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W3 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_hdr_w4
 *
 * TNS SDE URW2A Header Configuration Word 4 Register
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 */
union bdk_tns_sde_urw2a_hdr_w4
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_hdr_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t use_xph_ts            : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t cpu_xph_en            : 34; /**< [ 33:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_xph_en            : 34; /**< [ 33:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
        uint64_t use_xph_ts            : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_hdr_w4_s cn; */
};
typedef union bdk_tns_sde_urw2a_hdr_w4 bdk_tns_sde_urw2a_hdr_w4_t;

#define BDK_TNS_SDE_URW2A_HDR_W4 BDK_TNS_SDE_URW2A_HDR_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c20ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_HDR_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_HDR_W4 bdk_tns_sde_urw2a_hdr_w4_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W4 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_HDR_W4 "TNS_SDE_URW2A_HDR_W4"
#define device_bar_BDK_TNS_SDE_URW2A_HDR_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_HDR_W4 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w0
 *
 * TNS SDE URW2A Insert Const Data Table Word 0 Registers
 * Contains constant 32 byte data for the 8 commands. This data defaults the
 * 32-byte layer
 * When writing, the MSBs (word 8) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bmap                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t bmap                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w0_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w0 bdk_tns_sde_urw2a_ins_ctd_tblx_w0_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481000ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w0_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W0"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w1
 *
 * TNS SDE URW2A Insert Const Data Table Word 1 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w1_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w1 bdk_tns_sde_urw2a_ins_ctd_tblx_w1_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481004ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w1_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W1"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w2
 *
 * TNS SDE URW2A Insert Const Data Table Word 2 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w2_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w2 bdk_tns_sde_urw2a_ins_ctd_tblx_w2_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481008ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w2_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W2"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w3
 *
 * TNS SDE URW2A Insert Const Data Table Word 3 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w3
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w3_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w3 bdk_tns_sde_urw2a_ins_ctd_tblx_w3_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206048100cll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w3_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W3"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w4
 *
 * TNS SDE URW2A Insert Const Data Table Word 4 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w4
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w4_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w4 bdk_tns_sde_urw2a_ins_ctd_tblx_w4_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481010ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w4_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W4"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w5
 *
 * TNS SDE URW2A Insert Const Data Table Word 5 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w5
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w5_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w5 bdk_tns_sde_urw2a_ins_ctd_tblx_w5_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481014ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W5", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w5_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W5"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w6
 *
 * TNS SDE URW2A Insert Const Data Table Word 6 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w6
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w6_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w6 bdk_tns_sde_urw2a_ins_ctd_tblx_w6_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481018ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W6", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w6_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W6"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w7
 *
 * TNS SDE URW2A Insert Const Data Table Word 7 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w7
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w7_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w7 bdk_tns_sde_urw2a_ins_ctd_tblx_w7_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x84206048101cll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W7", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w7_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W7"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_ins_ctd_tbl#_w8
 *
 * TNS SDE URW2A Insert Const Data Table Word 8 Registers
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 */
union bdk_tns_sde_urw2a_ins_ctd_tblx_w8
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_ins_ctd_tblx_w8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w8_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w8 bdk_tns_sde_urw2a_ins_ctd_tblx_w8_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060481020ll + 0x40ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_CTD_TBLX_W8", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(a) bdk_tns_sde_urw2a_ins_ctd_tblx_w8_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(a) "TNS_SDE_URW2A_INS_CTD_TBLX_W8"
#define device_bar_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(a) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_ins_mem_tbl#_w#
 *
 * TNS SDE URW2A Insert Memory Table Registers
 * Contains instructions for building the insert data.
 * Bits[63:49] in _W[3] are unused.
 * When writing, the MSBs (word 3) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw2a_ins_mem_tblx_wx
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_ins_mem_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_ins_mem_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw2a_ins_mem_tblx_wx bdk_tns_sde_urw2a_ins_mem_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=127) && (b<=3)))
        return 0x842060480000ll + 0x20ll * ((a) & 0x7f) + 8ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_URW2A_INS_MEM_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(a,b) bdk_tns_sde_urw2a_ins_mem_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(a,b) "TNS_SDE_URW2A_INS_MEM_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_lock
 *
 * TNS SDE URW2A Lock Register
 * Lock Register
 */
union bdk_tns_sde_urw2a_lock
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_lock_s cn; */
};
typedef union bdk_tns_sde_urw2a_lock bdk_tns_sde_urw2a_lock_t;

#define BDK_TNS_SDE_URW2A_LOCK BDK_TNS_SDE_URW2A_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c5cll;
    __bdk_csr_fatal("TNS_SDE_URW2A_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_LOCK bdk_tns_sde_urw2a_lock_t
#define bustype_BDK_TNS_SDE_URW2A_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_LOCK "TNS_SDE_URW2A_LOCK"
#define device_bar_BDK_TNS_SDE_URW2A_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_LOCK 0
#define arguments_BDK_TNS_SDE_URW2A_LOCK -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2a_rwmem_tbl#_w#
 *
 * TNS SDE URW2A RWMEM Table Registers
 * Each line contains 2 commands. Indexed by rewritePtr0-7[7:0]
 * Bits[63:44] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw2a_rwmem_tblx_wx
{
    uint64_t u;
    struct bdk_tns_sde_urw2a_rwmem_tblx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cmd_data              : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t cmd_data              : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_rwmem_tblx_wx_s cn; */
};
typedef union bdk_tns_sde_urw2a_rwmem_tblx_wx bdk_tns_sde_urw2a_rwmem_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=63) && (b<=1)))
        return 0x842060481800ll + 0x10ll * ((a) & 0x3f) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SDE_URW2A_RWMEM_TBLX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(a,b) bdk_tns_sde_urw2a_rwmem_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(a,b) "TNS_SDE_URW2A_RWMEM_TBLX_WX"
#define device_bar_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_sde_urw2a_spad
 *
 * TNS SDE URW2A ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_urw2a_spad
{
    uint32_t u;
    struct bdk_tns_sde_urw2a_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2a_spad_s cn; */
};
typedef union bdk_tns_sde_urw2a_spad bdk_tns_sde_urw2a_spad_t;

#define BDK_TNS_SDE_URW2A_SPAD BDK_TNS_SDE_URW2A_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060481c60ll;
    __bdk_csr_fatal("TNS_SDE_URW2A_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2A_SPAD bdk_tns_sde_urw2a_spad_t
#define bustype_BDK_TNS_SDE_URW2A_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2A_SPAD "TNS_SDE_URW2A_SPAD"
#define device_bar_BDK_TNS_SDE_URW2A_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2A_SPAD 0
#define arguments_BDK_TNS_SDE_URW2A_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_control
 *
 * TNS SDE URW2B Control Register
 * Contains disable bits for various features
 */
union bdk_tns_sde_urw2b_control
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t cut_through_mode      : 1;  /**< [  3:  3](R/W) -- */
        uint32_t logic_rst             : 1;  /**< [  2:  2](R/W) -- */
        uint32_t set_refcntvld_tosdma  : 1;  /**< [  1:  1](R/W) -- */
        uint32_t enable_selective_mtu_checking : 1;/**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t enable_selective_mtu_checking : 1;/**< [  0:  0](R/W) -- */
        uint32_t set_refcntvld_tosdma  : 1;  /**< [  1:  1](R/W) -- */
        uint32_t logic_rst             : 1;  /**< [  2:  2](R/W) -- */
        uint32_t cut_through_mode      : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_control_s cn; */
};
typedef union bdk_tns_sde_urw2b_control bdk_tns_sde_urw2b_control_t;

#define BDK_TNS_SDE_URW2B_CONTROL BDK_TNS_SDE_URW2B_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_CONTROL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050005cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_CONTROL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_CONTROL bdk_tns_sde_urw2b_control_t
#define bustype_BDK_TNS_SDE_URW2B_CONTROL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_CONTROL "TNS_SDE_URW2B_CONTROL"
#define device_bar_BDK_TNS_SDE_URW2B_CONTROL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_CONTROL 0
#define arguments_BDK_TNS_SDE_URW2B_CONTROL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_cpu_rcod_base
 *
 * TNS SDE URW2B CPU Reason Code Base Register
 * The reason codes for packets going to CPU use this value as a base
 * RCODE_NEW_ADDR  = CFG_CPU_RCODES_BASE + 3'd2;
 * RCODE_MTU_ERR   = CFG_CPU_RCODES_BASE + 3'd3;
 */
union bdk_tns_sde_urw2b_cpu_rcod_base
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_cpu_rcod_base_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t field                 : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_cpu_rcod_base_s cn; */
};
typedef union bdk_tns_sde_urw2b_cpu_rcod_base bdk_tns_sde_urw2b_cpu_rcod_base_t;

#define BDK_TNS_SDE_URW2B_CPU_RCOD_BASE BDK_TNS_SDE_URW2B_CPU_RCOD_BASE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_CPU_RCOD_BASE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_CPU_RCOD_BASE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050007cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_CPU_RCOD_BASE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE bdk_tns_sde_urw2b_cpu_rcod_base_t
#define bustype_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE "TNS_SDE_URW2B_CPU_RCOD_BASE"
#define device_bar_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE 0
#define arguments_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_dbg_sel
 *
 * TNS SDE URW2B Debug Selector Register
 * --
 */
union bdk_tns_sde_urw2b_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_urw2b_dbg_sel bdk_tns_sde_urw2b_dbg_sel_t;

#define BDK_TNS_SDE_URW2B_DBG_SEL BDK_TNS_SDE_URW2B_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500094ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_DBG_SEL bdk_tns_sde_urw2b_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW2B_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_DBG_SEL "TNS_SDE_URW2B_DBG_SEL"
#define device_bar_BDK_TNS_SDE_URW2B_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW2B_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_dbg_sta_live
 *
 * TNS SDE URW2B Debug Status LIVE Register
 * --
 */
union bdk_tns_sde_urw2b_dbg_sta_live
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_dbg_sta_live_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 6;  /**< [  5:  0](RO/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_dbg_sta_live_s cn; */
};
typedef union bdk_tns_sde_urw2b_dbg_sta_live bdk_tns_sde_urw2b_dbg_sta_live_t;

#define BDK_TNS_SDE_URW2B_DBG_STA_LIVE BDK_TNS_SDE_URW2B_DBG_STA_LIVE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_STA_LIVE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_STA_LIVE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500090ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_DBG_STA_LIVE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_DBG_STA_LIVE bdk_tns_sde_urw2b_dbg_sta_live_t
#define bustype_BDK_TNS_SDE_URW2B_DBG_STA_LIVE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_DBG_STA_LIVE "TNS_SDE_URW2B_DBG_STA_LIVE"
#define device_bar_BDK_TNS_SDE_URW2B_DBG_STA_LIVE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_DBG_STA_LIVE 0
#define arguments_BDK_TNS_SDE_URW2B_DBG_STA_LIVE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_etag_w0
 *
 * TNS SDE URW2B ETAG Word 0 Register
 * Contains enable bits per port and modify etag enable for packet modifications
 * going to etag ports.
 */
union bdk_tns_sde_urw2b_etag_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_etag_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_etag_w0_s cn; */
};
typedef union bdk_tns_sde_urw2b_etag_w0 bdk_tns_sde_urw2b_etag_w0_t;

#define BDK_TNS_SDE_URW2B_ETAG_W0 BDK_TNS_SDE_URW2B_ETAG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500038ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_ETAG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_ETAG_W0 bdk_tns_sde_urw2b_etag_w0_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_ETAG_W0 "TNS_SDE_URW2B_ETAG_W0"
#define device_bar_BDK_TNS_SDE_URW2B_ETAG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W0 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_etag_w1
 *
 * TNS SDE URW2B ETAG Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 */
union bdk_tns_sde_urw2b_etag_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_etag_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_etag_w1_s cn; */
};
typedef union bdk_tns_sde_urw2b_etag_w1 bdk_tns_sde_urw2b_etag_w1_t;

#define BDK_TNS_SDE_URW2B_ETAG_W1 BDK_TNS_SDE_URW2B_ETAG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050003cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_ETAG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_ETAG_W1 bdk_tns_sde_urw2b_etag_w1_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_ETAG_W1 "TNS_SDE_URW2B_ETAG_W1"
#define device_bar_BDK_TNS_SDE_URW2B_ETAG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W1 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_etag_w2
 *
 * TNS SDE URW2B ETAG Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 */
union bdk_tns_sde_urw2b_etag_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_etag_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_etag_w2_s cn; */
};
typedef union bdk_tns_sde_urw2b_etag_w2 bdk_tns_sde_urw2b_etag_w2_t;

#define BDK_TNS_SDE_URW2B_ETAG_W2 BDK_TNS_SDE_URW2B_ETAG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500040ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_ETAG_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_ETAG_W2 bdk_tns_sde_urw2b_etag_w2_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_ETAG_W2 "TNS_SDE_URW2B_ETAG_W2"
#define device_bar_BDK_TNS_SDE_URW2B_ETAG_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W2 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_etag_w3
 *
 * TNS SDE URW2B ETAG Word 3 Register
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 */
union bdk_tns_sde_urw2b_etag_w3
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_etag_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_etag_w3_s cn; */
};
typedef union bdk_tns_sde_urw2b_etag_w3 bdk_tns_sde_urw2b_etag_w3_t;

#define BDK_TNS_SDE_URW2B_ETAG_W3 BDK_TNS_SDE_URW2B_ETAG_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500044ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_ETAG_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_ETAG_W3 bdk_tns_sde_urw2b_etag_w3_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_ETAG_W3 "TNS_SDE_URW2B_ETAG_W3"
#define device_bar_BDK_TNS_SDE_URW2B_ETAG_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W3 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_etag_w4
 *
 * TNS SDE URW2B ETAG Word 4 Register
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 */
union bdk_tns_sde_urw2b_etag_w4
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_etag_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t modify_etag_en        : 1;  /**< [  9:  9](R/W) -- */
        uint32_t pt_en                 : 9;  /**< [  8:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t pt_en                 : 9;  /**< [  8:  0](R/W) Continuation of MSBs of field PORT_EN from previous word. */
        uint32_t modify_etag_en        : 1;  /**< [  9:  9](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_etag_w4_s cn; */
};
typedef union bdk_tns_sde_urw2b_etag_w4 bdk_tns_sde_urw2b_etag_w4_t;

#define BDK_TNS_SDE_URW2B_ETAG_W4 BDK_TNS_SDE_URW2B_ETAG_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500048ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_ETAG_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_ETAG_W4 bdk_tns_sde_urw2b_etag_w4_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_ETAG_W4 "TNS_SDE_URW2B_ETAG_W4"
#define device_bar_BDK_TNS_SDE_URW2B_ETAG_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W4 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W4 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2b_hdr_w0
 *
 * TNS SDE URW2B Header Configuration Word 0 Register
 * Contains disable bits for various features
 */
union bdk_tns_sde_urw2b_hdr_w0
{
    uint64_t u;
    struct bdk_tns_sde_urw2b_hdr_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lpb_pt_en             : 48; /**< [ 63: 16](R/W) -- */
        uint64_t etag_etype            : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t etag_etype            : 16; /**< [ 15:  0](R/W) -- */
        uint64_t lpb_pt_en             : 48; /**< [ 63: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_hdr_w0_s cn; */
};
typedef union bdk_tns_sde_urw2b_hdr_w0 bdk_tns_sde_urw2b_hdr_w0_t;

#define BDK_TNS_SDE_URW2B_HDR_W0 BDK_TNS_SDE_URW2B_HDR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500010ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_HDR_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_HDR_W0 bdk_tns_sde_urw2b_hdr_w0_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2B_HDR_W0 "TNS_SDE_URW2B_HDR_W0"
#define device_bar_BDK_TNS_SDE_URW2B_HDR_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_HDR_W0 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W0 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2b_hdr_w1
 *
 * TNS SDE URW2B Header Configuration Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 */
union bdk_tns_sde_urw2b_hdr_w1
{
    uint64_t u;
    struct bdk_tns_sde_urw2b_hdr_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t lpb_pt_en             : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lpb_pt_en             : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_hdr_w1_s cn; */
};
typedef union bdk_tns_sde_urw2b_hdr_w1 bdk_tns_sde_urw2b_hdr_w1_t;

#define BDK_TNS_SDE_URW2B_HDR_W1 BDK_TNS_SDE_URW2B_HDR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500018ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_HDR_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_HDR_W1 bdk_tns_sde_urw2b_hdr_w1_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2B_HDR_W1 "TNS_SDE_URW2B_HDR_W1"
#define device_bar_BDK_TNS_SDE_URW2B_HDR_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_HDR_W1 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2b_hdr_w2
 *
 * TNS SDE URW2B Header Configuration Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 */
union bdk_tns_sde_urw2b_hdr_w2
{
    uint64_t u;
    struct bdk_tns_sde_urw2b_hdr_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cpu_xph_en            : 39; /**< [ 63: 25](R/W) -- */
        uint64_t lpb_pt_en             : 25; /**< [ 24:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t lpb_pt_en             : 25; /**< [ 24:  0](R/W) Continuation of MSBs of field LPB_PORT_EN from previous word. */
        uint64_t cpu_xph_en            : 39; /**< [ 63: 25](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_hdr_w2_s cn; */
};
typedef union bdk_tns_sde_urw2b_hdr_w2 bdk_tns_sde_urw2b_hdr_w2_t;

#define BDK_TNS_SDE_URW2B_HDR_W2 BDK_TNS_SDE_URW2B_HDR_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500020ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_HDR_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_HDR_W2 bdk_tns_sde_urw2b_hdr_w2_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W2 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2B_HDR_W2 "TNS_SDE_URW2B_HDR_W2"
#define device_bar_BDK_TNS_SDE_URW2B_HDR_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_HDR_W2 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W2 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2b_hdr_w3
 *
 * TNS SDE URW2B Header Configuration Word 3 Register
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 */
union bdk_tns_sde_urw2b_hdr_w3
{
    uint64_t u;
    struct bdk_tns_sde_urw2b_hdr_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t cpu_xph_en            : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_xph_en            : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_hdr_w3_s cn; */
};
typedef union bdk_tns_sde_urw2b_hdr_w3 bdk_tns_sde_urw2b_hdr_w3_t;

#define BDK_TNS_SDE_URW2B_HDR_W3 BDK_TNS_SDE_URW2B_HDR_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500028ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_HDR_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_HDR_W3 bdk_tns_sde_urw2b_hdr_w3_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W3 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2B_HDR_W3 "TNS_SDE_URW2B_HDR_W3"
#define device_bar_BDK_TNS_SDE_URW2B_HDR_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_HDR_W3 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W3 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw2b_hdr_w4
 *
 * TNS SDE URW2B Header Configuration Word 4 Register
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 */
union bdk_tns_sde_urw2b_hdr_w4
{
    uint64_t u;
    struct bdk_tns_sde_urw2b_hdr_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t use_xph_ts            : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t cpu_xph_en            : 34; /**< [ 33:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t cpu_xph_en            : 34; /**< [ 33:  0](R/W) Continuation of MSBs of field CPU_XPH_EN from previous word. */
        uint64_t use_xph_ts            : 1;  /**< [ 34: 34](R/W) -- */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_hdr_w4_s cn; */
};
typedef union bdk_tns_sde_urw2b_hdr_w4 bdk_tns_sde_urw2b_hdr_w4_t;

#define BDK_TNS_SDE_URW2B_HDR_W4 BDK_TNS_SDE_URW2B_HDR_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500030ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_HDR_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_HDR_W4 bdk_tns_sde_urw2b_hdr_w4_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W4 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW2B_HDR_W4 "TNS_SDE_URW2B_HDR_W4"
#define device_bar_BDK_TNS_SDE_URW2B_HDR_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_HDR_W4 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_int_en_hi
 *
 * TNS SDE URW2B Interrrupt Enable High Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw2b_int_en_hi
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_int_en_hi_s cn; */
};
typedef union bdk_tns_sde_urw2b_int_en_hi bdk_tns_sde_urw2b_int_en_hi_t;

#define BDK_TNS_SDE_URW2B_INT_EN_HI BDK_TNS_SDE_URW2B_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500004ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_INT_EN_HI bdk_tns_sde_urw2b_int_en_hi_t
#define bustype_BDK_TNS_SDE_URW2B_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_INT_EN_HI "TNS_SDE_URW2B_INT_EN_HI"
#define device_bar_BDK_TNS_SDE_URW2B_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_URW2B_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_int_en_lo
 *
 * TNS SDE URW2B Interrrupt Enable Low Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw2b_int_en_lo
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_int_en_lo_s cn; */
};
typedef union bdk_tns_sde_urw2b_int_en_lo bdk_tns_sde_urw2b_int_en_lo_t;

#define BDK_TNS_SDE_URW2B_INT_EN_LO BDK_TNS_SDE_URW2B_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500008ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_INT_EN_LO bdk_tns_sde_urw2b_int_en_lo_t
#define bustype_BDK_TNS_SDE_URW2B_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_INT_EN_LO "TNS_SDE_URW2B_INT_EN_LO"
#define device_bar_BDK_TNS_SDE_URW2B_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_URW2B_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_int_frc
 *
 * TNS SDE URW2B Interrrupt Force Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw2b_int_frc
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](WO) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_int_frc_s cn; */
};
typedef union bdk_tns_sde_urw2b_int_frc bdk_tns_sde_urw2b_int_frc_t;

#define BDK_TNS_SDE_URW2B_INT_FRC BDK_TNS_SDE_URW2B_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050000cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_INT_FRC bdk_tns_sde_urw2b_int_frc_t
#define bustype_BDK_TNS_SDE_URW2B_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_INT_FRC "TNS_SDE_URW2B_INT_FRC"
#define device_bar_BDK_TNS_SDE_URW2B_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_INT_FRC 0
#define arguments_BDK_TNS_SDE_URW2B_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_int_w1c
 *
 * TNS SDE URW2B Interrrupt W1C Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw2b_int_w1c
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hdrsize_ovfl          : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_int_w1c_s cn; */
};
typedef union bdk_tns_sde_urw2b_int_w1c bdk_tns_sde_urw2b_int_w1c_t;

#define BDK_TNS_SDE_URW2B_INT_W1C BDK_TNS_SDE_URW2B_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500000ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_INT_W1C bdk_tns_sde_urw2b_int_w1c_t
#define bustype_BDK_TNS_SDE_URW2B_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_INT_W1C "TNS_SDE_URW2B_INT_W1C"
#define device_bar_BDK_TNS_SDE_URW2B_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_INT_W1C 0
#define arguments_BDK_TNS_SDE_URW2B_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_lock
 *
 * TNS SDE URW2B Lock Register
 * Lock Register
 */
union bdk_tns_sde_urw2b_lock
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_lock_s cn; */
};
typedef union bdk_tns_sde_urw2b_lock bdk_tns_sde_urw2b_lock_t;

#define BDK_TNS_SDE_URW2B_LOCK BDK_TNS_SDE_URW2B_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500098ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_LOCK bdk_tns_sde_urw2b_lock_t
#define bustype_BDK_TNS_SDE_URW2B_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_LOCK "TNS_SDE_URW2B_LOCK"
#define device_bar_BDK_TNS_SDE_URW2B_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_LOCK 0
#define arguments_BDK_TNS_SDE_URW2B_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mir_mask_w0
 *
 * TNS SDE URW2B Mirror Mask Word 0 Register
 * This holds masks for Ingress, Egress, evif and ivif Mirror.
 */
union bdk_tns_sde_urw2b_mir_mask_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mir_mask_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ivif                  : 16; /**< [ 31: 16](R/W) -- */
        uint32_t evif                  : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t evif                  : 16; /**< [ 15:  0](R/W) -- */
        uint32_t ivif                  : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mir_mask_w0_s cn; */
};
typedef union bdk_tns_sde_urw2b_mir_mask_w0 bdk_tns_sde_urw2b_mir_mask_w0_t;

#define BDK_TNS_SDE_URW2B_MIR_MASK_W0 BDK_TNS_SDE_URW2B_MIR_MASK_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500064ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MIR_MASK_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MIR_MASK_W0 bdk_tns_sde_urw2b_mir_mask_w0_t
#define bustype_BDK_TNS_SDE_URW2B_MIR_MASK_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MIR_MASK_W0 "TNS_SDE_URW2B_MIR_MASK_W0"
#define device_bar_BDK_TNS_SDE_URW2B_MIR_MASK_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MIR_MASK_W0 0
#define arguments_BDK_TNS_SDE_URW2B_MIR_MASK_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mir_mask_w1
 *
 * TNS SDE URW2B Mirror Mask Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2B_MIR_MASK_W0
 */
union bdk_tns_sde_urw2b_mir_mask_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mir_mask_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ing                   : 16; /**< [ 31: 16](R/W) -- */
        uint32_t egr                   : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t egr                   : 16; /**< [ 15:  0](R/W) -- */
        uint32_t ing                   : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mir_mask_w1_s cn; */
};
typedef union bdk_tns_sde_urw2b_mir_mask_w1 bdk_tns_sde_urw2b_mir_mask_w1_t;

#define BDK_TNS_SDE_URW2B_MIR_MASK_W1 BDK_TNS_SDE_URW2B_MIR_MASK_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500068ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MIR_MASK_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MIR_MASK_W1 bdk_tns_sde_urw2b_mir_mask_w1_t
#define bustype_BDK_TNS_SDE_URW2B_MIR_MASK_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MIR_MASK_W1 "TNS_SDE_URW2B_MIR_MASK_W1"
#define device_bar_BDK_TNS_SDE_URW2B_MIR_MASK_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MIR_MASK_W1 0
#define arguments_BDK_TNS_SDE_URW2B_MIR_MASK_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mre_dcnt_w0
 *
 * TNS SDE URW2B MRE Drop Count Word 0 Register
 * --
 */
union bdk_tns_sde_urw2b_mre_dcnt_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mre_dcnt_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mtu_err               : 6;  /**< [ 31: 26](RO/H) -- */
        uint32_t mre_ptr               : 13; /**< [ 25: 13](RO/H) -- */
        uint32_t qcn_sample            : 13; /**< [ 12:  0](RO/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
#else /* Word 0 - Little Endian */
        uint32_t qcn_sample            : 13; /**< [ 12:  0](RO/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t mre_ptr               : 13; /**< [ 25: 13](RO/H) -- */
        uint32_t mtu_err               : 6;  /**< [ 31: 26](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mre_dcnt_w0_s cn; */
};
typedef union bdk_tns_sde_urw2b_mre_dcnt_w0 bdk_tns_sde_urw2b_mre_dcnt_w0_t;

#define BDK_TNS_SDE_URW2B_MRE_DCNT_W0 BDK_TNS_SDE_URW2B_MRE_DCNT_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500084ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MRE_DCNT_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 bdk_tns_sde_urw2b_mre_dcnt_w0_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 "TNS_SDE_URW2B_MRE_DCNT_W0"
#define device_bar_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mre_dcnt_w1
 *
 * TNS SDE URW2B MRE Drop Count Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2B_MRE_DCNT_W0
 */
union bdk_tns_sde_urw2b_mre_dcnt_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mre_dcnt_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ing_mir               : 12; /**< [ 31: 20](RO/H) -- */
        uint32_t egr_mir               : 13; /**< [ 19:  7](RO/H) -- */
        uint32_t mtu_err               : 7;  /**< [  6:  0](RO/H) Continuation of MSBs of field MTU_ERR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t mtu_err               : 7;  /**< [  6:  0](RO/H) Continuation of MSBs of field MTU_ERR from previous word. */
        uint32_t egr_mir               : 13; /**< [ 19:  7](RO/H) -- */
        uint32_t ing_mir               : 12; /**< [ 31: 20](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mre_dcnt_w1_s cn; */
};
typedef union bdk_tns_sde_urw2b_mre_dcnt_w1 bdk_tns_sde_urw2b_mre_dcnt_w1_t;

#define BDK_TNS_SDE_URW2B_MRE_DCNT_W1 BDK_TNS_SDE_URW2B_MRE_DCNT_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500088ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MRE_DCNT_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 bdk_tns_sde_urw2b_mre_dcnt_w1_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 "TNS_SDE_URW2B_MRE_DCNT_W1"
#define device_bar_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mre_dcnt_w2
 *
 * TNS SDE URW2B MRE Drop Count Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW2B_MRE_DCNT_W0
 */
union bdk_tns_sde_urw2b_mre_dcnt_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mre_dcnt_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t ing_mir               : 1;  /**< [  0:  0](RO/H) Continuation of MSBs of field ING_MIR from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t ing_mir               : 1;  /**< [  0:  0](RO/H) Continuation of MSBs of field ING_MIR from previous word. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mre_dcnt_w2_s cn; */
};
typedef union bdk_tns_sde_urw2b_mre_dcnt_w2 bdk_tns_sde_urw2b_mre_dcnt_w2_t;

#define BDK_TNS_SDE_URW2B_MRE_DCNT_W2 BDK_TNS_SDE_URW2B_MRE_DCNT_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050008cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MRE_DCNT_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 bdk_tns_sde_urw2b_mre_dcnt_w2_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 "TNS_SDE_URW2B_MRE_DCNT_W2"
#define device_bar_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mre_pri_tbl
 *
 * TNS SDE URW2B MRE Priority Table Register
 * This is a 2-wide and 4 deep table and holds pri for various cases.
 */
union bdk_tns_sde_urw2b_mre_pri_tbl
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mre_pri_tbl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t data                  : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mre_pri_tbl_s cn; */
};
typedef union bdk_tns_sde_urw2b_mre_pri_tbl bdk_tns_sde_urw2b_mre_pri_tbl_t;

#define BDK_TNS_SDE_URW2B_MRE_PRI_TBL BDK_TNS_SDE_URW2B_MRE_PRI_TBL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_PRI_TBL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_PRI_TBL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500078ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MRE_PRI_TBL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MRE_PRI_TBL bdk_tns_sde_urw2b_mre_pri_tbl_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_PRI_TBL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MRE_PRI_TBL "TNS_SDE_URW2B_MRE_PRI_TBL"
#define device_bar_BDK_TNS_SDE_URW2B_MRE_PRI_TBL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MRE_PRI_TBL 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_PRI_TBL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mreif
 *
 * TNS SDE URW2B MRE Interface Register
 * This is a 2-wide and 4 deep table and holds pri for various cases.
 */
union bdk_tns_sde_urw2b_mreif
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mreif_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t invalid_template_id   : 8;  /**< [ 12:  5](R/W) -- */
        uint32_t enable_overwrites_ing_mir : 1;/**< [  4:  4](R/W) -- */
        uint32_t enable_overwrites_egr_mir : 1;/**< [  3:  3](R/W) -- */
        uint32_t enable_overwrites_mtu_err : 1;/**< [  2:  2](R/W) -- */
        uint32_t enable_overwrites_mre_ptr : 1;/**< [  1:  1](R/W) -- */
        uint32_t zeroout_mrelast       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t zeroout_mrelast       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t enable_overwrites_mre_ptr : 1;/**< [  1:  1](R/W) -- */
        uint32_t enable_overwrites_mtu_err : 1;/**< [  2:  2](R/W) -- */
        uint32_t enable_overwrites_egr_mir : 1;/**< [  3:  3](R/W) -- */
        uint32_t enable_overwrites_ing_mir : 1;/**< [  4:  4](R/W) -- */
        uint32_t invalid_template_id   : 8;  /**< [ 12:  5](R/W) -- */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mreif_s cn; */
};
typedef union bdk_tns_sde_urw2b_mreif bdk_tns_sde_urw2b_mreif_t;

#define BDK_TNS_SDE_URW2B_MREIF BDK_TNS_SDE_URW2B_MREIF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREIF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREIF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500080ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MREIF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MREIF bdk_tns_sde_urw2b_mreif_t
#define bustype_BDK_TNS_SDE_URW2B_MREIF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MREIF "TNS_SDE_URW2B_MREIF"
#define device_bar_BDK_TNS_SDE_URW2B_MREIF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MREIF 0
#define arguments_BDK_TNS_SDE_URW2B_MREIF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mreptr_w0
 *
 * TNS SDE URW2B MRE Pointers Word 0 Register
 * This holds MRE Pointers for Ingress, Egress and CPU cases.
 */
union bdk_tns_sde_urw2b_mreptr_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mreptr_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cpu                   : 14; /**< [ 31: 18](R/W) -- */
        uint32_t qcn_sample            : 18; /**< [ 17:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
#else /* Word 0 - Little Endian */
        uint32_t qcn_sample            : 18; /**< [ 17:  0](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t cpu                   : 14; /**< [ 31: 18](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mreptr_w0_s cn; */
};
typedef union bdk_tns_sde_urw2b_mreptr_w0 bdk_tns_sde_urw2b_mreptr_w0_t;

#define BDK_TNS_SDE_URW2B_MREPTR_W0 BDK_TNS_SDE_URW2B_MREPTR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050006cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MREPTR_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MREPTR_W0 bdk_tns_sde_urw2b_mreptr_w0_t
#define bustype_BDK_TNS_SDE_URW2B_MREPTR_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MREPTR_W0 "TNS_SDE_URW2B_MREPTR_W0"
#define device_bar_BDK_TNS_SDE_URW2B_MREPTR_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MREPTR_W0 0
#define arguments_BDK_TNS_SDE_URW2B_MREPTR_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mreptr_w1
 *
 * TNS SDE URW2B MRE Pointers Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW2B_MREPTR_W0
 */
union bdk_tns_sde_urw2b_mreptr_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mreptr_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ing                   : 10; /**< [ 31: 22](R/W) -- */
        uint32_t egr                   : 18; /**< [ 21:  4](R/W) -- */
        uint32_t cpu                   : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field CPU from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t cpu                   : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field CPU from previous word. */
        uint32_t egr                   : 18; /**< [ 21:  4](R/W) -- */
        uint32_t ing                   : 10; /**< [ 31: 22](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mreptr_w1_s cn; */
};
typedef union bdk_tns_sde_urw2b_mreptr_w1 bdk_tns_sde_urw2b_mreptr_w1_t;

#define BDK_TNS_SDE_URW2B_MREPTR_W1 BDK_TNS_SDE_URW2B_MREPTR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500070ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MREPTR_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MREPTR_W1 bdk_tns_sde_urw2b_mreptr_w1_t
#define bustype_BDK_TNS_SDE_URW2B_MREPTR_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MREPTR_W1 "TNS_SDE_URW2B_MREPTR_W1"
#define device_bar_BDK_TNS_SDE_URW2B_MREPTR_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MREPTR_W1 0
#define arguments_BDK_TNS_SDE_URW2B_MREPTR_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mreptr_w2
 *
 * TNS SDE URW2B MRE Pointers Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW2B_MREPTR_W0
 */
union bdk_tns_sde_urw2b_mreptr_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mreptr_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ing                   : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field ING from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t ing                   : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field ING from previous word. */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mreptr_w2_s cn; */
};
typedef union bdk_tns_sde_urw2b_mreptr_w2 bdk_tns_sde_urw2b_mreptr_w2_t;

#define BDK_TNS_SDE_URW2B_MREPTR_W2 BDK_TNS_SDE_URW2B_MREPTR_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500074ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_MREPTR_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MREPTR_W2 bdk_tns_sde_urw2b_mreptr_w2_t
#define bustype_BDK_TNS_SDE_URW2B_MREPTR_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MREPTR_W2 "TNS_SDE_URW2B_MREPTR_W2"
#define device_bar_BDK_TNS_SDE_URW2B_MREPTR_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MREPTR_W2 0
#define arguments_BDK_TNS_SDE_URW2B_MREPTR_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_mtu_prf_tbl_w#
 *
 * TNS SDE URW2B MTU Frofile Table Registers
 * Indexed by 3 bits of mtu_profile in the token. Outputs a 14 bit max_mtu size.
 * Bits 31..16 of registers ending in _W3 are unused.
 */
union bdk_tns_sde_urw2b_mtu_prf_tbl_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_mtu_prf_tbl_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_mtu_prf_tbl_wx_s cn; */
};
typedef union bdk_tns_sde_urw2b_mtu_prf_tbl_wx bdk_tns_sde_urw2b_mtu_prf_tbl_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84206050004cll + 4ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SDE_URW2B_MTU_PRF_TBL_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(a) bdk_tns_sde_urw2b_mtu_prf_tbl_wx_t
#define bustype_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(a) "TNS_SDE_URW2B_MTU_PRF_TBL_WX"
#define device_bar_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(a) (a)
#define arguments_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_spad
 *
 * TNS SDE URW2B ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_urw2b_spad
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_spad_s cn; */
};
typedef union bdk_tns_sde_urw2b_spad bdk_tns_sde_urw2b_spad_t;

#define BDK_TNS_SDE_URW2B_SPAD BDK_TNS_SDE_URW2B_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206050009cll;
    __bdk_csr_fatal("TNS_SDE_URW2B_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_SPAD bdk_tns_sde_urw2b_spad_t
#define bustype_BDK_TNS_SDE_URW2B_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_SPAD "TNS_SDE_URW2B_SPAD"
#define device_bar_BDK_TNS_SDE_URW2B_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_SPAD 0
#define arguments_BDK_TNS_SDE_URW2B_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw2b_tcls_pmap_tbl
 *
 * TNS SDE URW2B Traffic Class To Priority Map Table Register
 * Mapping table to map {4-bit token.traffic_class} class to 2 bit priority.
 */
union bdk_tns_sde_urw2b_tcls_pmap_tbl
{
    uint32_t u;
    struct bdk_tns_sde_urw2b_tcls_pmap_tbl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw2b_tcls_pmap_tbl_s cn; */
};
typedef union bdk_tns_sde_urw2b_tcls_pmap_tbl bdk_tns_sde_urw2b_tcls_pmap_tbl_t;

#define BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060500060ll;
    __bdk_csr_fatal("TNS_SDE_URW2B_TCLS_PMAP_TBL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL bdk_tns_sde_urw2b_tcls_pmap_tbl_t
#define bustype_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL "TNS_SDE_URW2B_TCLS_PMAP_TBL"
#define device_bar_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL 0
#define arguments_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_cnncmd_tbl#
 *
 * TNS SDE URW3 Canon Commands Table Registers
 * Contains canon commands for layers which match the stored layerType and
 * layerHash values
 */
union bdk_tns_sde_urw3_cnncmd_tblx
{
    uint64_t u;
    struct bdk_tns_sde_urw3_cnncmd_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_42_63        : 22;
        uint64_t layertype             : 6;  /**< [ 41: 36](R/W) -- */
        uint64_t layerhash             : 4;  /**< [ 35: 32](R/W) -- */
        uint64_t contbytes             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t bitvector             : 24; /**< [ 23:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t bitvector             : 24; /**< [ 23:  0](R/W) -- */
        uint64_t contbytes             : 8;  /**< [ 31: 24](R/W) -- */
        uint64_t layerhash             : 4;  /**< [ 35: 32](R/W) -- */
        uint64_t layertype             : 6;  /**< [ 41: 36](R/W) -- */
        uint64_t reserved_42_63        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_cnncmd_tblx_s cn; */
};
typedef union bdk_tns_sde_urw3_cnncmd_tblx bdk_tns_sde_urw3_cnncmd_tblx_t;

static inline uint64_t BDK_TNS_SDE_URW3_CNNCMD_TBLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_CNNCMD_TBLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=35))
        return 0x842060580400ll + 8ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SDE_URW3_CNNCMD_TBLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_CNNCMD_TBLX(a) bdk_tns_sde_urw3_cnncmd_tblx_t
#define bustype_BDK_TNS_SDE_URW3_CNNCMD_TBLX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_CNNCMD_TBLX(a) "TNS_SDE_URW3_CNNCMD_TBLX"
#define device_bar_BDK_TNS_SDE_URW3_CNNCMD_TBLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_CNNCMD_TBLX(a) (a)
#define arguments_BDK_TNS_SDE_URW3_CNNCMD_TBLX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_control
 *
 * TNS SDE URW3 Control Register
 * Contains disable bits for various features
 */
union bdk_tns_sde_urw3_control
{
    uint32_t u;
    struct bdk_tns_sde_urw3_control_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dbg_mode_donot_free_hdrbuf : 1;/**< [  3:  3](R/W) -- */
        uint32_t disable_se_ins_lkup   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t disable_txq_lkup      : 1;  /**< [  1:  1](R/W) -- */
        uint32_t logic_rst             : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t logic_rst             : 1;  /**< [  0:  0](R/W) -- */
        uint32_t disable_txq_lkup      : 1;  /**< [  1:  1](R/W) -- */
        uint32_t disable_se_ins_lkup   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t dbg_mode_donot_free_hdrbuf : 1;/**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_control_s cn; */
};
typedef union bdk_tns_sde_urw3_control bdk_tns_sde_urw3_control_t;

#define BDK_TNS_SDE_URW3_CONTROL BDK_TNS_SDE_URW3_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_CONTROL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580840ll;
    __bdk_csr_fatal("TNS_SDE_URW3_CONTROL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_CONTROL bdk_tns_sde_urw3_control_t
#define bustype_BDK_TNS_SDE_URW3_CONTROL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_CONTROL "TNS_SDE_URW3_CONTROL"
#define device_bar_BDK_TNS_SDE_URW3_CONTROL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_CONTROL 0
#define arguments_BDK_TNS_SDE_URW3_CONTROL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_dbg_lpathf
 *
 * TNS SDE URW3 Debug LPATH FIFO Register
 * For debug hooks to VLF fifo
 */
union bdk_tns_sde_urw3_dbg_lpathf
{
    uint32_t u;
    struct bdk_tns_sde_urw3_dbg_lpathf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_dbg_lpathf_s cn; */
};
typedef union bdk_tns_sde_urw3_dbg_lpathf bdk_tns_sde_urw3_dbg_lpathf_t;

#define BDK_TNS_SDE_URW3_DBG_LPATHF BDK_TNS_SDE_URW3_DBG_LPATHF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_LPATHF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_LPATHF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580894ll;
    __bdk_csr_fatal("TNS_SDE_URW3_DBG_LPATHF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_DBG_LPATHF bdk_tns_sde_urw3_dbg_lpathf_t
#define bustype_BDK_TNS_SDE_URW3_DBG_LPATHF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_DBG_LPATHF "TNS_SDE_URW3_DBG_LPATHF"
#define device_bar_BDK_TNS_SDE_URW3_DBG_LPATHF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_DBG_LPATHF 0
#define arguments_BDK_TNS_SDE_URW3_DBG_LPATHF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_dbg_sel
 *
 * TNS SDE URW3 Debug Selector Register
 * --
 */
union bdk_tns_sde_urw3_dbg_sel
{
    uint32_t u;
    struct bdk_tns_sde_urw3_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else /* Word 0 - Little Endian */
        uint32_t field_b               : 8;  /**< [  7:  0](R/W) Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
        uint32_t field_a               : 8;  /**< [ 15:  8](R/W) Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_dbg_sel_s cn; */
};
typedef union bdk_tns_sde_urw3_dbg_sel bdk_tns_sde_urw3_dbg_sel_t;

#define BDK_TNS_SDE_URW3_DBG_SEL BDK_TNS_SDE_URW3_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808acll;
    __bdk_csr_fatal("TNS_SDE_URW3_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_DBG_SEL bdk_tns_sde_urw3_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW3_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_DBG_SEL "TNS_SDE_URW3_DBG_SEL"
#define device_bar_BDK_TNS_SDE_URW3_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW3_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_dbg_sta_live
 *
 * TNS SDE URW3 Debug Status LIVE Register
 * --
 */
union bdk_tns_sde_urw3_dbg_sta_live
{
    uint64_t u;
    struct bdk_tns_sde_urw3_dbg_sta_live_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t txqif_data            : 17; /**< [ 63: 47](RO/H) -- */
        uint64_t se_vif_if_data        : 20; /**< [ 46: 27](RO/H) -- */
        uint64_t se_ins_if_data        : 12; /**< [ 26: 15](RO/H) -- */
        uint64_t hif_data              : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t hif_data              : 15; /**< [ 14:  0](RO/H) -- */
        uint64_t se_ins_if_data        : 12; /**< [ 26: 15](RO/H) -- */
        uint64_t se_vif_if_data        : 20; /**< [ 46: 27](RO/H) -- */
        uint64_t txqif_data            : 17; /**< [ 63: 47](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_dbg_sta_live_s cn; */
};
typedef union bdk_tns_sde_urw3_dbg_sta_live bdk_tns_sde_urw3_dbg_sta_live_t;

#define BDK_TNS_SDE_URW3_DBG_STA_LIVE BDK_TNS_SDE_URW3_DBG_STA_LIVE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_STA_LIVE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_STA_LIVE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808b0ll;
    __bdk_csr_fatal("TNS_SDE_URW3_DBG_STA_LIVE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_DBG_STA_LIVE bdk_tns_sde_urw3_dbg_sta_live_t
#define bustype_BDK_TNS_SDE_URW3_DBG_STA_LIVE BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_DBG_STA_LIVE "TNS_SDE_URW3_DBG_STA_LIVE"
#define device_bar_BDK_TNS_SDE_URW3_DBG_STA_LIVE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_DBG_STA_LIVE 0
#define arguments_BDK_TNS_SDE_URW3_DBG_STA_LIVE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_dbg_txq_rpf
 *
 * TNS SDE URW3 Debug TxQ Response FIFO Register
 * For debug hooks to VLF fifo
 */
union bdk_tns_sde_urw3_dbg_txq_rpf
{
    uint32_t u;
    struct bdk_tns_sde_urw3_dbg_txq_rpf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t contdeq               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t contenq               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t deqen                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t enqen                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_dbg_txq_rpf_s cn; */
};
typedef union bdk_tns_sde_urw3_dbg_txq_rpf bdk_tns_sde_urw3_dbg_txq_rpf_t;

#define BDK_TNS_SDE_URW3_DBG_TXQ_RPF BDK_TNS_SDE_URW3_DBG_TXQ_RPF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_TXQ_RPF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_TXQ_RPF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580898ll;
    __bdk_csr_fatal("TNS_SDE_URW3_DBG_TXQ_RPF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_DBG_TXQ_RPF bdk_tns_sde_urw3_dbg_txq_rpf_t
#define bustype_BDK_TNS_SDE_URW3_DBG_TXQ_RPF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_DBG_TXQ_RPF "TNS_SDE_URW3_DBG_TXQ_RPF"
#define device_bar_BDK_TNS_SDE_URW3_DBG_TXQ_RPF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_DBG_TXQ_RPF 0
#define arguments_BDK_TNS_SDE_URW3_DBG_TXQ_RPF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_dyn_dbg_lpathf
 *
 * TNS SDE URW3 DYN Debug LPATH FIFO Register
 * For debug hooks to Lpath fifo
 */
union bdk_tns_sde_urw3_dyn_dbg_lpathf
{
    uint32_t u;
    struct bdk_tns_sde_urw3_dyn_dbg_lpathf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t data                  : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_dyn_dbg_lpathf_s cn; */
};
typedef union bdk_tns_sde_urw3_dyn_dbg_lpathf bdk_tns_sde_urw3_dyn_dbg_lpathf_t;

#define BDK_TNS_SDE_URW3_DYN_DBG_LPATHF BDK_TNS_SDE_URW3_DYN_DBG_LPATHF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_LPATHF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_LPATHF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808a4ll;
    __bdk_csr_fatal("TNS_SDE_URW3_DYN_DBG_LPATHF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF bdk_tns_sde_urw3_dyn_dbg_lpathf_t
#define bustype_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF "TNS_SDE_URW3_DYN_DBG_LPATHF"
#define device_bar_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF 0
#define arguments_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_dyn_dbg_txq_rpf
 *
 * TNS SDE URW3 DYN Debug TxQ Response FIFO Register
 * For debug hooks to Lpath fifo
 */
union bdk_tns_sde_urw3_dyn_dbg_txq_rpf
{
    uint32_t u;
    struct bdk_tns_sde_urw3_dyn_dbg_txq_rpf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t data                  : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_dyn_dbg_txq_rpf_s cn; */
};
typedef union bdk_tns_sde_urw3_dyn_dbg_txq_rpf bdk_tns_sde_urw3_dyn_dbg_txq_rpf_t;

#define BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808a8ll;
    __bdk_csr_fatal("TNS_SDE_URW3_DYN_DBG_TXQ_RPF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF bdk_tns_sde_urw3_dyn_dbg_txq_rpf_t
#define bustype_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF "TNS_SDE_URW3_DYN_DBG_TXQ_RPF"
#define device_bar_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF 0
#define arguments_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_ecc_ctl_cd
 *
 * TNS SDE URW3 ECC Control Disable Correction Register
 * --
 */
union bdk_tns_sde_urw3_ecc_ctl_cd
{
    uint32_t u;
    struct bdk_tns_sde_urw3_ecc_ctl_cd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t lpath_fifo            : 1;  /**< [ 25: 25](R/W) -- */
        uint32_t resp_fifo             : 1;  /**< [ 24: 24](R/W) -- */
        uint32_t se_fifo               : 16; /**< [ 23:  8](R/W) -- */
        uint32_t se_lane_mem           : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t se_lane_mem           : 8;  /**< [  7:  0](R/W) -- */
        uint32_t se_fifo               : 16; /**< [ 23:  8](R/W) -- */
        uint32_t resp_fifo             : 1;  /**< [ 24: 24](R/W) -- */
        uint32_t lpath_fifo            : 1;  /**< [ 25: 25](R/W) -- */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ecc_ctl_cd_s cn; */
};
typedef union bdk_tns_sde_urw3_ecc_ctl_cd bdk_tns_sde_urw3_ecc_ctl_cd_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_CD BDK_TNS_SDE_URW3_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_CD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058083cll;
    __bdk_csr_fatal("TNS_SDE_URW3_ECC_CTL_CD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_CD bdk_tns_sde_urw3_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_CD "TNS_SDE_URW3_ECC_CTL_CD"
#define device_bar_BDK_TNS_SDE_URW3_ECC_CTL_CD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_CD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_ecc_ctl_flp_w0
 *
 * TNS SDE URW3 ECC Control Flip Word 0 Register
 * --
 */
union bdk_tns_sde_urw3_ecc_ctl_flp_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_ecc_ctl_flp_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t db_se_fifo            : 16; /**< [ 31: 16](R/W) -- */
        uint32_t sb_se_lane_mem        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t db_se_lane_mem        : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_se_lane_mem        : 8;  /**< [  7:  0](R/W) -- */
        uint32_t sb_se_lane_mem        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t db_se_fifo            : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ecc_ctl_flp_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_ecc_ctl_flp_w0 bdk_tns_sde_urw3_ecc_ctl_flp_w0_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580830ll;
    __bdk_csr_fatal("TNS_SDE_URW3_ECC_CTL_FLP_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 bdk_tns_sde_urw3_ecc_ctl_flp_w0_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 "TNS_SDE_URW3_ECC_CTL_FLP_W0"
#define device_bar_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_ecc_ctl_flp_w1
 *
 * TNS SDE URW3 ECC Control Flip Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW3_ECC_CTL_FLP_W0
 */
union bdk_tns_sde_urw3_ecc_ctl_flp_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_ecc_ctl_flp_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t db_lpath_fifo         : 14; /**< [ 31: 18](R/W) -- */
        uint32_t sb_resp_fifo          : 1;  /**< [ 17: 17](R/W) -- */
        uint32_t db_resp_fifo          : 1;  /**< [ 16: 16](R/W) -- */
        uint32_t sb_se_fifo            : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sb_se_fifo            : 16; /**< [ 15:  0](R/W) -- */
        uint32_t db_resp_fifo          : 1;  /**< [ 16: 16](R/W) -- */
        uint32_t sb_resp_fifo          : 1;  /**< [ 17: 17](R/W) -- */
        uint32_t db_lpath_fifo         : 14; /**< [ 31: 18](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ecc_ctl_flp_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_ecc_ctl_flp_w1 bdk_tns_sde_urw3_ecc_ctl_flp_w1_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580834ll;
    __bdk_csr_fatal("TNS_SDE_URW3_ECC_CTL_FLP_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 bdk_tns_sde_urw3_ecc_ctl_flp_w1_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 "TNS_SDE_URW3_ECC_CTL_FLP_W1"
#define device_bar_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_ecc_ctl_flp_w2
 *
 * TNS SDE URW3 ECC Control Flip Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW3_ECC_CTL_FLP_W0
 */
union bdk_tns_sde_urw3_ecc_ctl_flp_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw3_ecc_ctl_flp_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t sb_lpath_fifo         : 15; /**< [ 15:  1](R/W) -- */
        uint32_t db_lpath_fifo         : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field DB_LPATH_FIFO from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t db_lpath_fifo         : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field DB_LPATH_FIFO from previous word. */
        uint32_t sb_lpath_fifo         : 15; /**< [ 15:  1](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ecc_ctl_flp_w2_s cn; */
};
typedef union bdk_tns_sde_urw3_ecc_ctl_flp_w2 bdk_tns_sde_urw3_ecc_ctl_flp_w2_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580838ll;
    __bdk_csr_fatal("TNS_SDE_URW3_ECC_CTL_FLP_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 bdk_tns_sde_urw3_ecc_ctl_flp_w2_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 "TNS_SDE_URW3_ECC_CTL_FLP_W2"
#define device_bar_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_etag
 *
 * TNS SDE URW3 ETAG Register
 * Contains enable bits per port and modify etag enable for packet modifications
 * going to etag ports.
 */
union bdk_tns_sde_urw3_etag
{
    uint32_t u;
    struct bdk_tns_sde_urw3_etag_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t modify_etag_en        : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t modify_etag_en        : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_etag_s cn; */
};
typedef union bdk_tns_sde_urw3_etag bdk_tns_sde_urw3_etag_t;

#define BDK_TNS_SDE_URW3_ETAG BDK_TNS_SDE_URW3_ETAG_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ETAG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ETAG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580844ll;
    __bdk_csr_fatal("TNS_SDE_URW3_ETAG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_ETAG bdk_tns_sde_urw3_etag_t
#define bustype_BDK_TNS_SDE_URW3_ETAG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_ETAG "TNS_SDE_URW3_ETAG"
#define device_bar_BDK_TNS_SDE_URW3_ETAG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_ETAG 0
#define arguments_BDK_TNS_SDE_URW3_ETAG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_evif_mreptr_w0
 *
 * TNS SDE URW3 EVIF MRE Pointers Word 0 Register
 * Upper 8 bits of Evif are compared with range_lo and range_hi and if they fall
 * within, evif[17:0] AND  mask is treated as MREPTR and original header goes
 * directly to MRE.
 */
union bdk_tns_sde_urw3_evif_mreptr_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_evif_mreptr_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t range_lo              : 6;  /**< [ 31: 26](R/W) -- */
        uint32_t range_hi              : 8;  /**< [ 25: 18](R/W) -- */
        uint32_t mre_mask              : 18; /**< [ 17:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mre_mask              : 18; /**< [ 17:  0](R/W) -- */
        uint32_t range_hi              : 8;  /**< [ 25: 18](R/W) -- */
        uint32_t range_lo              : 6;  /**< [ 31: 26](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_evif_mreptr_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_evif_mreptr_w0 bdk_tns_sde_urw3_evif_mreptr_w0_t;

#define BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 BDK_TNS_SDE_URW3_EVIF_MREPTR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058089cll;
    __bdk_csr_fatal("TNS_SDE_URW3_EVIF_MREPTR_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 bdk_tns_sde_urw3_evif_mreptr_w0_t
#define bustype_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 "TNS_SDE_URW3_EVIF_MREPTR_W0"
#define device_bar_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 0
#define arguments_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_evif_mreptr_w1
 *
 * TNS SDE URW3 EVIF MRE Pointers Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW3_EVIF_MREPTR_W0
 */
union bdk_tns_sde_urw3_evif_mreptr_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_evif_mreptr_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t range_lo              : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field RANGE_LO from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t range_lo              : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field RANGE_LO from previous word. */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_evif_mreptr_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_evif_mreptr_w1 bdk_tns_sde_urw3_evif_mreptr_w1_t;

#define BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 BDK_TNS_SDE_URW3_EVIF_MREPTR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808a0ll;
    __bdk_csr_fatal("TNS_SDE_URW3_EVIF_MREPTR_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 bdk_tns_sde_urw3_evif_mreptr_w1_t
#define bustype_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 "TNS_SDE_URW3_EVIF_MREPTR_W1"
#define device_bar_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 0
#define arguments_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_ins0
 *
 * TNS SDE URW3 INS0 Register
 * INS0 Range0_3
 */
union bdk_tns_sde_urw3_ins0
{
    uint64_t u;
    struct bdk_tns_sde_urw3_ins0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ins0_s cn; */
};
typedef union bdk_tns_sde_urw3_ins0 bdk_tns_sde_urw3_ins0_t;

#define BDK_TNS_SDE_URW3_INS0 BDK_TNS_SDE_URW3_INS0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580868ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INS0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INS0 bdk_tns_sde_urw3_ins0_t
#define bustype_BDK_TNS_SDE_URW3_INS0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_INS0 "TNS_SDE_URW3_INS0"
#define device_bar_BDK_TNS_SDE_URW3_INS0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INS0 0
#define arguments_BDK_TNS_SDE_URW3_INS0 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_ins1
 *
 * TNS SDE URW3 INS1 Register
 * INS0 Range0_3
 */
union bdk_tns_sde_urw3_ins1
{
    uint64_t u;
    struct bdk_tns_sde_urw3_ins1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ins1_s cn; */
};
typedef union bdk_tns_sde_urw3_ins1 bdk_tns_sde_urw3_ins1_t;

#define BDK_TNS_SDE_URW3_INS1 BDK_TNS_SDE_URW3_INS1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580870ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INS1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INS1 bdk_tns_sde_urw3_ins1_t
#define bustype_BDK_TNS_SDE_URW3_INS1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_INS1 "TNS_SDE_URW3_INS1"
#define device_bar_BDK_TNS_SDE_URW3_INS1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INS1 0
#define arguments_BDK_TNS_SDE_URW3_INS1 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_ins2
 *
 * TNS SDE URW3 INS2 Register
 * INS0 Range0_3
 */
union bdk_tns_sde_urw3_ins2
{
    uint64_t u;
    struct bdk_tns_sde_urw3_ins2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ins2_s cn; */
};
typedef union bdk_tns_sde_urw3_ins2 bdk_tns_sde_urw3_ins2_t;

#define BDK_TNS_SDE_URW3_INS2 BDK_TNS_SDE_URW3_INS2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580878ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INS2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INS2 bdk_tns_sde_urw3_ins2_t
#define bustype_BDK_TNS_SDE_URW3_INS2 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_INS2 "TNS_SDE_URW3_INS2"
#define device_bar_BDK_TNS_SDE_URW3_INS2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INS2 0
#define arguments_BDK_TNS_SDE_URW3_INS2 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_ins3
 *
 * TNS SDE URW3 INS3 Register
 * INS0 Range0_3
 */
union bdk_tns_sde_urw3_ins3
{
    uint64_t u;
    struct bdk_tns_sde_urw3_ins3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t range0_3              : 40; /**< [ 39:  0](R/W) -- */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ins3_s cn; */
};
typedef union bdk_tns_sde_urw3_ins3 bdk_tns_sde_urw3_ins3_t;

#define BDK_TNS_SDE_URW3_INS3 BDK_TNS_SDE_URW3_INS3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580880ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INS3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INS3 bdk_tns_sde_urw3_ins3_t
#define bustype_BDK_TNS_SDE_URW3_INS3 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_INS3 "TNS_SDE_URW3_INS3"
#define device_bar_BDK_TNS_SDE_URW3_INS3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INS3 0
#define arguments_BDK_TNS_SDE_URW3_INS3 -1,-1,-1,-1

/**
 * Register (NCB) tns_sde_urw3_ins_fif#
 *
 * TNS SDE URW3 Insert FIFO Registers
 * --
 */
union bdk_tns_sde_urw3_ins_fifx
{
    uint64_t u;
    struct bdk_tns_sde_urw3_ins_fifx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_ins_fifx_s cn; */
};
typedef union bdk_tns_sde_urw3_ins_fifx bdk_tns_sde_urw3_ins_fifx_t;

static inline uint64_t BDK_TNS_SDE_URW3_INS_FIFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS_FIFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060580700ll + 8ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW3_INS_FIFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INS_FIFX(a) bdk_tns_sde_urw3_ins_fifx_t
#define bustype_BDK_TNS_SDE_URW3_INS_FIFX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_INS_FIFX(a) "TNS_SDE_URW3_INS_FIFX"
#define device_bar_BDK_TNS_SDE_URW3_INS_FIFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INS_FIFX(a) (a)
#define arguments_BDK_TNS_SDE_URW3_INS_FIFX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_en_hi_w0
 *
 * TNS SDE URW3 Interrrupt Enable High Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw3_int_en_hi_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_en_hi_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](R/W) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](R/W) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](R/W) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](R/W) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_en_hi_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_int_en_hi_w0 bdk_tns_sde_urw3_int_en_hi_w0_t;

#define BDK_TNS_SDE_URW3_INT_EN_HI_W0 BDK_TNS_SDE_URW3_INT_EN_HI_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058080cll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_EN_HI_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_EN_HI_W0 bdk_tns_sde_urw3_int_en_hi_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_HI_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_EN_HI_W0 "TNS_SDE_URW3_INT_EN_HI_W0"
#define device_bar_BDK_TNS_SDE_URW3_INT_EN_HI_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_EN_HI_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_HI_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_en_hi_w1
 *
 * TNS SDE URW3 Interrrupt Enable High Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_HI_W0
 */
union bdk_tns_sde_urw3_int_en_hi_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_en_hi_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](R/W) -- */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](R/W) -- */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_en_hi_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_int_en_hi_w1 bdk_tns_sde_urw3_int_en_hi_w1_t;

#define BDK_TNS_SDE_URW3_INT_EN_HI_W1 BDK_TNS_SDE_URW3_INT_EN_HI_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580810ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_EN_HI_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_EN_HI_W1 bdk_tns_sde_urw3_int_en_hi_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_HI_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_EN_HI_W1 "TNS_SDE_URW3_INT_EN_HI_W1"
#define device_bar_BDK_TNS_SDE_URW3_INT_EN_HI_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_EN_HI_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_HI_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_en_hi_w2
 *
 * TNS SDE URW3 Interrrupt Enable High Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_HI_W0
 */
union bdk_tns_sde_urw3_int_en_hi_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_en_hi_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](R/W) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](R/W) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](R/W) -- */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](R/W) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](R/W) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](R/W) -- */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_en_hi_w2_s cn; */
};
typedef union bdk_tns_sde_urw3_int_en_hi_w2 bdk_tns_sde_urw3_int_en_hi_w2_t;

#define BDK_TNS_SDE_URW3_INT_EN_HI_W2 BDK_TNS_SDE_URW3_INT_EN_HI_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580814ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_EN_HI_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_EN_HI_W2 bdk_tns_sde_urw3_int_en_hi_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_HI_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_EN_HI_W2 "TNS_SDE_URW3_INT_EN_HI_W2"
#define device_bar_BDK_TNS_SDE_URW3_INT_EN_HI_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_EN_HI_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_HI_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_en_lo_w0
 *
 * TNS SDE URW3 Interrrupt Enable Low Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw3_int_en_lo_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_en_lo_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](R/W) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](R/W) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](R/W) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](R/W) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](R/W) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_en_lo_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_int_en_lo_w0 bdk_tns_sde_urw3_int_en_lo_w0_t;

#define BDK_TNS_SDE_URW3_INT_EN_LO_W0 BDK_TNS_SDE_URW3_INT_EN_LO_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580818ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_EN_LO_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_EN_LO_W0 bdk_tns_sde_urw3_int_en_lo_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_LO_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_EN_LO_W0 "TNS_SDE_URW3_INT_EN_LO_W0"
#define device_bar_BDK_TNS_SDE_URW3_INT_EN_LO_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_EN_LO_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_LO_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_en_lo_w1
 *
 * TNS SDE URW3 Interrrupt Enable Low Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_LO_W0
 */
union bdk_tns_sde_urw3_int_en_lo_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_en_lo_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](R/W) -- */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](R/W) -- */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_en_lo_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_int_en_lo_w1 bdk_tns_sde_urw3_int_en_lo_w1_t;

#define BDK_TNS_SDE_URW3_INT_EN_LO_W1 BDK_TNS_SDE_URW3_INT_EN_LO_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058081cll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_EN_LO_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_EN_LO_W1 bdk_tns_sde_urw3_int_en_lo_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_LO_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_EN_LO_W1 "TNS_SDE_URW3_INT_EN_LO_W1"
#define device_bar_BDK_TNS_SDE_URW3_INT_EN_LO_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_EN_LO_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_LO_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_en_lo_w2
 *
 * TNS SDE URW3 Interrrupt Enable Low Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_LO_W0
 */
union bdk_tns_sde_urw3_int_en_lo_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_en_lo_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](R/W) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](R/W) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](R/W) -- */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](R/W) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](R/W) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](R/W) -- */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_en_lo_w2_s cn; */
};
typedef union bdk_tns_sde_urw3_int_en_lo_w2 bdk_tns_sde_urw3_int_en_lo_w2_t;

#define BDK_TNS_SDE_URW3_INT_EN_LO_W2 BDK_TNS_SDE_URW3_INT_EN_LO_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580820ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_EN_LO_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_EN_LO_W2 bdk_tns_sde_urw3_int_en_lo_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_LO_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_EN_LO_W2 "TNS_SDE_URW3_INT_EN_LO_W2"
#define device_bar_BDK_TNS_SDE_URW3_INT_EN_LO_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_EN_LO_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_LO_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_frc_w0
 *
 * TNS SDE URW3 Interrrupt Force Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw3_int_frc_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_frc_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](WO) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](WO) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](WO) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](WO) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](WO) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](WO) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](WO) -- */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](WO) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](WO) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](WO) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](WO) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](WO) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](WO) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](WO) -- */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](WO) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_frc_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_int_frc_w0 bdk_tns_sde_urw3_int_frc_w0_t;

#define BDK_TNS_SDE_URW3_INT_FRC_W0 BDK_TNS_SDE_URW3_INT_FRC_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580824ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_FRC_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_FRC_W0 bdk_tns_sde_urw3_int_frc_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_FRC_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_FRC_W0 "TNS_SDE_URW3_INT_FRC_W0"
#define device_bar_BDK_TNS_SDE_URW3_INT_FRC_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_FRC_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_FRC_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_frc_w1
 *
 * TNS SDE URW3 Interrrupt Force Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_FRC_W0
 */
union bdk_tns_sde_urw3_int_frc_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_frc_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](WO) -- */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](WO) -- */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](WO) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_frc_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_int_frc_w1 bdk_tns_sde_urw3_int_frc_w1_t;

#define BDK_TNS_SDE_URW3_INT_FRC_W1 BDK_TNS_SDE_URW3_INT_FRC_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580828ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_FRC_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_FRC_W1 bdk_tns_sde_urw3_int_frc_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_FRC_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_FRC_W1 "TNS_SDE_URW3_INT_FRC_W1"
#define device_bar_BDK_TNS_SDE_URW3_INT_FRC_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_FRC_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_FRC_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_frc_w2
 *
 * TNS SDE URW3 Interrrupt Force Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_FRC_W0
 */
union bdk_tns_sde_urw3_int_frc_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_frc_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](WO) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](WO) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](WO) -- */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](WO) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](WO) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](WO) -- */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](WO) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_frc_w2_s cn; */
};
typedef union bdk_tns_sde_urw3_int_frc_w2 bdk_tns_sde_urw3_int_frc_w2_t;

#define BDK_TNS_SDE_URW3_INT_FRC_W2 BDK_TNS_SDE_URW3_INT_FRC_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058082cll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_FRC_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_FRC_W2 bdk_tns_sde_urw3_int_frc_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_FRC_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_FRC_W2 "TNS_SDE_URW3_INT_FRC_W2"
#define device_bar_BDK_TNS_SDE_URW3_INT_FRC_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_FRC_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_FRC_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_w1c_w0
 *
 * TNS SDE URW3 Interrrupt W1C Word 0 Register
 * Channel Interrupt register low priority
 */
union bdk_tns_sde_urw3_int_w1c_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_w1c_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](R/W1C/H) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](R/W1C/H) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](R/W1C/H) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](R/W1C/H) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_resp_mem_miss   : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint32_t txq_timeout           : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t se_ins_timeout        : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t se_vif_timeout        : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint32_t seins_bad_tid_irq     : 4;  /**< [  7:  4](R/W1C/H) -- */
        uint32_t se_bad_tid_irq        : 8;  /**< [ 15:  8](R/W1C/H) -- */
        uint32_t sevif_if_sb_err       : 8;  /**< [ 23: 16](R/W1C/H) -- */
        uint32_t sevif_if_db_err       : 8;  /**< [ 31: 24](R/W1C/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_w1c_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_int_w1c_w0 bdk_tns_sde_urw3_int_w1c_w0_t;

#define BDK_TNS_SDE_URW3_INT_W1C_W0 BDK_TNS_SDE_URW3_INT_W1C_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580800ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_W1C_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_W1C_W0 bdk_tns_sde_urw3_int_w1c_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_W1C_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_W1C_W0 "TNS_SDE_URW3_INT_W1C_W0"
#define device_bar_BDK_TNS_SDE_URW3_INT_W1C_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_W1C_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_W1C_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_w1c_w1
 *
 * TNS SDE URW3 Interrrupt W1C Word 1 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_W1C_W0
 */
union bdk_tns_sde_urw3_int_w1c_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_w1c_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](R/W1C/H) -- */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t seins_if_sb_err       : 16; /**< [ 15:  0](R/W1C/H) -- */
        uint32_t seins_if_db_err       : 16; /**< [ 31: 16](R/W1C/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_w1c_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_int_w1c_w1 bdk_tns_sde_urw3_int_w1c_w1_t;

#define BDK_TNS_SDE_URW3_INT_W1C_W1 BDK_TNS_SDE_URW3_INT_W1C_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580804ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_W1C_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_W1C_W1 bdk_tns_sde_urw3_int_w1c_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_W1C_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_W1C_W1 "TNS_SDE_URW3_INT_W1C_W1"
#define device_bar_BDK_TNS_SDE_URW3_INT_W1C_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_W1C_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_W1C_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_int_w1c_w2
 *
 * TNS SDE URW3 Interrrupt W1C Word 2 Register
 * Continuation of structure defined in TNS_SDE_URW3_INT_W1C_W0
 */
union bdk_tns_sde_urw3_int_w1c_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw3_int_w1c_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](R/W1C/H) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](R/W1C/H) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t txq_if_sb_err         : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint32_t txq_if_db_err         : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t tkn_modify_sb_err     : 15; /**< [ 16:  2](R/W1C/H) -- */
        uint32_t tkn_modify_db_err     : 15; /**< [ 31: 17](R/W1C/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_int_w1c_w2_s cn; */
};
typedef union bdk_tns_sde_urw3_int_w1c_w2 bdk_tns_sde_urw3_int_w1c_w2_t;

#define BDK_TNS_SDE_URW3_INT_W1C_W2 BDK_TNS_SDE_URW3_INT_W1C_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580808ll;
    __bdk_csr_fatal("TNS_SDE_URW3_INT_W1C_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_INT_W1C_W2 bdk_tns_sde_urw3_int_w1c_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_W1C_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_INT_W1C_W2 "TNS_SDE_URW3_INT_W1C_W2"
#define device_bar_BDK_TNS_SDE_URW3_INT_W1C_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_INT_W1C_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_W1C_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_lock
 *
 * TNS SDE URW3 Lock Register
 * Lock Register
 */
union bdk_tns_sde_urw3_lock
{
    uint32_t u;
    struct bdk_tns_sde_urw3_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_lock_s cn; */
};
typedef union bdk_tns_sde_urw3_lock bdk_tns_sde_urw3_lock_t;

#define BDK_TNS_SDE_URW3_LOCK BDK_TNS_SDE_URW3_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808b8ll;
    __bdk_csr_fatal("TNS_SDE_URW3_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_LOCK bdk_tns_sde_urw3_lock_t
#define bustype_BDK_TNS_SDE_URW3_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_LOCK "TNS_SDE_URW3_LOCK"
#define device_bar_BDK_TNS_SDE_URW3_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_LOCK 0
#define arguments_BDK_TNS_SDE_URW3_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_max_in_flight
 *
 * TNS SDE URW3 Maximum In Flight Register
 * Controls the max inflight requests.
 */
union bdk_tns_sde_urw3_max_in_flight
{
    uint32_t u;
    struct bdk_tns_sde_urw3_max_in_flight_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t vif_req               : 6;  /**< [ 19: 14](R/W) -- */
        uint32_t txq_req               : 6;  /**< [ 13:  8](R/W) -- */
        uint32_t ins_req               : 6;  /**< [  7:  2](R/W) -- */
        uint32_t vif_flush_en          : 1;  /**< [  1:  1](R/W) -- */
        uint32_t ins_flush_en          : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ins_flush_en          : 1;  /**< [  0:  0](R/W) -- */
        uint32_t vif_flush_en          : 1;  /**< [  1:  1](R/W) -- */
        uint32_t ins_req               : 6;  /**< [  7:  2](R/W) -- */
        uint32_t txq_req               : 6;  /**< [ 13:  8](R/W) -- */
        uint32_t vif_req               : 6;  /**< [ 19: 14](R/W) -- */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_max_in_flight_s cn; */
};
typedef union bdk_tns_sde_urw3_max_in_flight bdk_tns_sde_urw3_max_in_flight_t;

#define BDK_TNS_SDE_URW3_MAX_IN_FLIGHT BDK_TNS_SDE_URW3_MAX_IN_FLIGHT_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_MAX_IN_FLIGHT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_MAX_IN_FLIGHT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058084cll;
    __bdk_csr_fatal("TNS_SDE_URW3_MAX_IN_FLIGHT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT bdk_tns_sde_urw3_max_in_flight_t
#define bustype_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT "TNS_SDE_URW3_MAX_IN_FLIGHT"
#define device_bar_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT 0
#define arguments_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_mir_mask
 *
 * TNS SDE URW3 Mirror Mask Register
 * This holds masks for Ingress, Egress, evif and ivif Mirror.
 */
union bdk_tns_sde_urw3_mir_mask
{
    uint32_t u;
    struct bdk_tns_sde_urw3_mir_mask_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ivif                  : 16; /**< [ 31: 16](R/W) -- */
        uint32_t evif                  : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t evif                  : 16; /**< [ 15:  0](R/W) -- */
        uint32_t ivif                  : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_mir_mask_s cn; */
};
typedef union bdk_tns_sde_urw3_mir_mask bdk_tns_sde_urw3_mir_mask_t;

#define BDK_TNS_SDE_URW3_MIR_MASK BDK_TNS_SDE_URW3_MIR_MASK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_MIR_MASK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_MIR_MASK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580848ll;
    __bdk_csr_fatal("TNS_SDE_URW3_MIR_MASK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_MIR_MASK bdk_tns_sde_urw3_mir_mask_t
#define bustype_BDK_TNS_SDE_URW3_MIR_MASK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_MIR_MASK "TNS_SDE_URW3_MIR_MASK"
#define device_bar_BDK_TNS_SDE_URW3_MIR_MASK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_MIR_MASK 0
#define arguments_BDK_TNS_SDE_URW3_MIR_MASK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_prt_em_w#
 *
 * TNS SDE URW3 Portb Based Egress Mirror Registers
 * This holds port enable for egress mirroring.
 * Bits 31..9 of registers ending in _W4 are unused.
 */
union bdk_tns_sde_urw3_prt_em_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw3_prt_em_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t en                    : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_prt_em_wx_s cn; */
};
typedef union bdk_tns_sde_urw3_prt_em_wx bdk_tns_sde_urw3_prt_em_wx_t;

static inline uint64_t BDK_TNS_SDE_URW3_PRT_EM_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_PRT_EM_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=4))
        return 0x842060580854ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SDE_URW3_PRT_EM_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_PRT_EM_WX(a) bdk_tns_sde_urw3_prt_em_wx_t
#define bustype_BDK_TNS_SDE_URW3_PRT_EM_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_PRT_EM_WX(a) "TNS_SDE_URW3_PRT_EM_WX"
#define device_bar_BDK_TNS_SDE_URW3_PRT_EM_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_PRT_EM_WX(a) (a)
#define arguments_BDK_TNS_SDE_URW3_PRT_EM_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_rr
 *
 * TNS SDE URW3 Round Robin Configuration Register
 * Arbitration cfgs to configure the arbiter
 */
union bdk_tns_sde_urw3_rr
{
    uint32_t u;
    struct bdk_tns_sde_urw3_rr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t strict_prio           : 2;  /**< [ 25: 24](R/W) -- */
        uint32_t wrr_weight0           : 12; /**< [ 23: 12](R/W) -- */
        uint32_t wrr_weight1           : 12; /**< [ 11:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t wrr_weight1           : 12; /**< [ 11:  0](R/W) -- */
        uint32_t wrr_weight0           : 12; /**< [ 23: 12](R/W) -- */
        uint32_t strict_prio           : 2;  /**< [ 25: 24](R/W) -- */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_rr_s cn; */
};
typedef union bdk_tns_sde_urw3_rr bdk_tns_sde_urw3_rr_t;

#define BDK_TNS_SDE_URW3_RR BDK_TNS_SDE_URW3_RR_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_RR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_RR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580890ll;
    __bdk_csr_fatal("TNS_SDE_URW3_RR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_RR bdk_tns_sde_urw3_rr_t
#define bustype_BDK_TNS_SDE_URW3_RR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_RR "TNS_SDE_URW3_RR"
#define device_bar_BDK_TNS_SDE_URW3_RR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_RR 0
#define arguments_BDK_TNS_SDE_URW3_RR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_se_ins_fif
 *
 * TNS SDE URW3 Search Insert FIFO Register
 * --
 */
union bdk_tns_sde_urw3_se_ins_fif
{
    uint32_t u;
    struct bdk_tns_sde_urw3_se_ins_fif_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t sel                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sel                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_se_ins_fif_s cn; */
};
typedef union bdk_tns_sde_urw3_se_ins_fif bdk_tns_sde_urw3_se_ins_fif_t;

#define BDK_TNS_SDE_URW3_SE_INS_FIF BDK_TNS_SDE_URW3_SE_INS_FIF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_SE_INS_FIF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SE_INS_FIF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84206058088cll;
    __bdk_csr_fatal("TNS_SDE_URW3_SE_INS_FIF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_SE_INS_FIF bdk_tns_sde_urw3_se_ins_fif_t
#define bustype_BDK_TNS_SDE_URW3_SE_INS_FIF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_SE_INS_FIF "TNS_SDE_URW3_SE_INS_FIF"
#define device_bar_BDK_TNS_SDE_URW3_SE_INS_FIF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_SE_INS_FIF 0
#define arguments_BDK_TNS_SDE_URW3_SE_INS_FIF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_se_vif_fif
 *
 * TNS SDE URW3 Search VIF FIFO Register
 * --
 */
union bdk_tns_sde_urw3_se_vif_fif
{
    uint32_t u;
    struct bdk_tns_sde_urw3_se_vif_fif_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t sel                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sel                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_se_vif_fif_s cn; */
};
typedef union bdk_tns_sde_urw3_se_vif_fif bdk_tns_sde_urw3_se_vif_fif_t;

#define BDK_TNS_SDE_URW3_SE_VIF_FIF BDK_TNS_SDE_URW3_SE_VIF_FIF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_SE_VIF_FIF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SE_VIF_FIF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580888ll;
    __bdk_csr_fatal("TNS_SDE_URW3_SE_VIF_FIF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_SE_VIF_FIF bdk_tns_sde_urw3_se_vif_fif_t
#define bustype_BDK_TNS_SDE_URW3_SE_VIF_FIF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_SE_VIF_FIF "TNS_SDE_URW3_SE_VIF_FIF"
#define device_bar_BDK_TNS_SDE_URW3_SE_VIF_FIF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_SE_VIF_FIF 0
#define arguments_BDK_TNS_SDE_URW3_SE_VIF_FIF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_sein_rp_tbl#_w0
 *
 * TNS SDE URW3 SEINS Response Table Word 0 Registers
 * Search profile table to gather vif responses.
 * This field tells if the evif response is 32 bit valid. Lower 32-bits of
 * 64-bit se lane should be valid.
 * If this bit is set, then token_id_0_32bit_format should be : 1000_0000
 * Bits[31:19] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw3_sein_rp_tblx_w0
{
    uint32_t u;
    struct bdk_tns_sde_urw3_sein_rp_tblx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t token_id_0_bit_map    : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t token_id_1_32bit_format : 1;/**< [ 29: 29](R/W) -- */
        uint32_t token_id_1_bit_map    : 4;  /**< [ 28: 25](R/W) -- */
        uint32_t token_id_2_32bit_format : 1;/**< [ 24: 24](R/W) -- */
        uint32_t token_id_2_bit_map    : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t token_id_3_32bit_format : 1;/**< [ 19: 19](R/W) -- */
        uint32_t token_id_3_bit_map    : 4;  /**< [ 18: 15](R/W) -- */
        uint32_t prf_id                : 7;  /**< [ 14:  8](R/W) -- */
        uint32_t prf_id_key            : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t prf_id_key            : 8;  /**< [  7:  0](R/W) -- */
        uint32_t prf_id                : 7;  /**< [ 14:  8](R/W) -- */
        uint32_t token_id_3_bit_map    : 4;  /**< [ 18: 15](R/W) -- */
        uint32_t token_id_3_32bit_format : 1;/**< [ 19: 19](R/W) -- */
        uint32_t token_id_2_bit_map    : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t token_id_2_32bit_format : 1;/**< [ 24: 24](R/W) -- */
        uint32_t token_id_1_bit_map    : 4;  /**< [ 28: 25](R/W) -- */
        uint32_t token_id_1_32bit_format : 1;/**< [ 29: 29](R/W) -- */
        uint32_t token_id_0_bit_map    : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_sein_rp_tblx_w0_s cn; */
};
typedef union bdk_tns_sde_urw3_sein_rp_tblx_w0 bdk_tns_sde_urw3_sein_rp_tblx_w0_t;

static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=23))
        return 0x842060580200ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW3_SEIN_RP_TBLX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(a) bdk_tns_sde_urw3_sein_rp_tblx_w0_t
#define bustype_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(a) "TNS_SDE_URW3_SEIN_RP_TBLX_W0"
#define device_bar_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(a) (a)
#define arguments_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_sein_rp_tbl#_w1
 *
 * TNS SDE URW3 SEINS Response Table Word 1 Registers
 * Continuation of structure defined in TNS_SDE_URW3_SEIN_RP_TBL(0..23)_W0
 */
union bdk_tns_sde_urw3_sein_rp_tblx_w1
{
    uint32_t u;
    struct bdk_tns_sde_urw3_sein_rp_tblx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t offset1               : 5;  /**< [ 31: 27](R/W) -- */
        uint32_t offset2               : 12; /**< [ 26: 15](R/W) -- */
        uint32_t offset3               : 12; /**< [ 14:  3](R/W) -- */
        uint32_t token_id_0_32bit_format : 1;/**< [  2:  2](R/W) -- */
        uint32_t token_id_0_bit_map    : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field TOKEN_ID_0_BIT_MAP from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t token_id_0_bit_map    : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field TOKEN_ID_0_BIT_MAP from previous word. */
        uint32_t token_id_0_32bit_format : 1;/**< [  2:  2](R/W) -- */
        uint32_t offset3               : 12; /**< [ 14:  3](R/W) -- */
        uint32_t offset2               : 12; /**< [ 26: 15](R/W) -- */
        uint32_t offset1               : 5;  /**< [ 31: 27](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_sein_rp_tblx_w1_s cn; */
};
typedef union bdk_tns_sde_urw3_sein_rp_tblx_w1 bdk_tns_sde_urw3_sein_rp_tblx_w1_t;

static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=23))
        return 0x842060580204ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW3_SEIN_RP_TBLX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(a) bdk_tns_sde_urw3_sein_rp_tblx_w1_t
#define bustype_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(a) "TNS_SDE_URW3_SEIN_RP_TBLX_W1"
#define device_bar_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(a) (a)
#define arguments_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_sein_rp_tbl#_w2
 *
 * TNS SDE URW3 SEINS Response Table Word 2 Registers
 * Continuation of structure defined in TNS_SDE_URW3_SEIN_RP_TBL(0..23)_W0
 */
union bdk_tns_sde_urw3_sein_rp_tblx_w2
{
    uint32_t u;
    struct bdk_tns_sde_urw3_sein_rp_tblx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t offset0               : 12; /**< [ 18:  7](R/W) -- */
        uint32_t offset1               : 7;  /**< [  6:  0](R/W) Continuation of MSBs of field OFFSET1 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t offset1               : 7;  /**< [  6:  0](R/W) Continuation of MSBs of field OFFSET1 from previous word. */
        uint32_t offset0               : 12; /**< [ 18:  7](R/W) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_sein_rp_tblx_w2_s cn; */
};
typedef union bdk_tns_sde_urw3_sein_rp_tblx_w2 bdk_tns_sde_urw3_sein_rp_tblx_w2_t;

static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=23))
        return 0x842060580208ll + 0x10ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW3_SEIN_RP_TBLX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(a) bdk_tns_sde_urw3_sein_rp_tblx_w2_t
#define bustype_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(a) "TNS_SDE_URW3_SEIN_RP_TBLX_W2"
#define device_bar_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(a) (a)
#define arguments_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_spad
 *
 * TNS SDE URW3 ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_sde_urw3_spad
{
    uint32_t u;
    struct bdk_tns_sde_urw3_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_spad_s cn; */
};
typedef union bdk_tns_sde_urw3_spad bdk_tns_sde_urw3_spad_t;

#define BDK_TNS_SDE_URW3_SPAD BDK_TNS_SDE_URW3_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420605808bcll;
    __bdk_csr_fatal("TNS_SDE_URW3_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_SPAD bdk_tns_sde_urw3_spad_t
#define bustype_BDK_TNS_SDE_URW3_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_SPAD "TNS_SDE_URW3_SPAD"
#define device_bar_BDK_TNS_SDE_URW3_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_SPAD 0
#define arguments_BDK_TNS_SDE_URW3_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_tqif#_w#
 *
 * TNS SDE URW3 TQIF Registers
 * --
 * Bits[31:14] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_sde_urw3_tqifx_wx
{
    uint32_t u;
    struct bdk_tns_sde_urw3_tqifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_tqifx_wx_s cn; */
};
typedef union bdk_tns_sde_urw3_tqifx_wx bdk_tns_sde_urw3_tqifx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW3_TQIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_TQIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=31) && (b<=2)))
        return 0x842060580000ll + 0x10ll * ((a) & 0x1f) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SDE_URW3_TQIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_TQIFX_WX(a,b) bdk_tns_sde_urw3_tqifx_wx_t
#define bustype_BDK_TNS_SDE_URW3_TQIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_TQIFX_WX(a,b) "TNS_SDE_URW3_TQIFX_WX"
#define device_bar_BDK_TNS_SDE_URW3_TQIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_TQIFX_WX(a,b) (a)
#define arguments_BDK_TNS_SDE_URW3_TQIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_sde_urw3_vif_fif#
 *
 * TNS SDE URW3 VIF FIFO Registers
 * --
 */
union bdk_tns_sde_urw3_vif_fifx
{
    uint64_t u;
    struct bdk_tns_sde_urw3_vif_fifx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_vif_fifx_s cn; */
};
typedef union bdk_tns_sde_urw3_vif_fifx bdk_tns_sde_urw3_vif_fifx_t;

static inline uint64_t BDK_TNS_SDE_URW3_VIF_FIFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_VIF_FIFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842060580600ll + 8ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SDE_URW3_VIF_FIFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_VIF_FIFX(a) bdk_tns_sde_urw3_vif_fifx_t
#define bustype_BDK_TNS_SDE_URW3_VIF_FIFX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SDE_URW3_VIF_FIFX(a) "TNS_SDE_URW3_VIF_FIFX"
#define device_bar_BDK_TNS_SDE_URW3_VIF_FIFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_VIF_FIFX(a) (a)
#define arguments_BDK_TNS_SDE_URW3_VIF_FIFX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_sde_urw3_wrr
 *
 * TNS SDE URW3 Weigted Round Robin Configuration Register
 * Controls the priority of slow path and fast path
 */
union bdk_tns_sde_urw3_wrr
{
    uint32_t u;
    struct bdk_tns_sde_urw3_wrr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t weight1               : 12; /**< [ 25: 14](R/W) -- */
        uint32_t weight0               : 12; /**< [ 13:  2](R/W) -- */
        uint32_t strict_prio           : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t strict_prio           : 2;  /**< [  1:  0](R/W) -- */
        uint32_t weight0               : 12; /**< [ 13:  2](R/W) -- */
        uint32_t weight1               : 12; /**< [ 25: 14](R/W) -- */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_sde_urw3_wrr_s cn; */
};
typedef union bdk_tns_sde_urw3_wrr bdk_tns_sde_urw3_wrr_t;

#define BDK_TNS_SDE_URW3_WRR BDK_TNS_SDE_URW3_WRR_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_WRR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_WRR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842060580850ll;
    __bdk_csr_fatal("TNS_SDE_URW3_WRR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SDE_URW3_WRR bdk_tns_sde_urw3_wrr_t
#define bustype_BDK_TNS_SDE_URW3_WRR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SDE_URW3_WRR "TNS_SDE_URW3_WRR"
#define device_bar_BDK_TNS_SDE_URW3_WRR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SDE_URW3_WRR 0
#define arguments_BDK_TNS_SDE_URW3_WRR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_int_en_hi
 *
 * TNS Search Age Memory Age Interrrupt Enable High Register
 * --
 */
union bdk_tns_se_age_mem_age_int_en_hi
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](R/W) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](R/W) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](R/W) -- */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](R/W) -- */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](R/W) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](R/W) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else /* Word 0 - Little Endian */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](R/W) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](R/W) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](R/W) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](R/W) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](R/W) -- */
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_int_en_hi_s cn; */
};
typedef union bdk_tns_se_age_mem_age_int_en_hi bdk_tns_se_age_mem_age_int_en_hi_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010014ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI bdk_tns_se_age_mem_age_int_en_hi_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI "TNS_SE_AGE_MEM_AGE_INT_EN_HI"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_int_en_lo
 *
 * TNS Search Age Memory Age Interrrupt Enable Low Register
 * --
 */
union bdk_tns_se_age_mem_age_int_en_lo
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](R/W) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](R/W) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](R/W) -- */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](R/W) -- */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](R/W) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](R/W) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else /* Word 0 - Little Endian */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](R/W) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](R/W) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](R/W) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](R/W) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](R/W) -- */
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_int_en_lo_s cn; */
};
typedef union bdk_tns_se_age_mem_age_int_en_lo bdk_tns_se_age_mem_age_int_en_lo_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010018ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO bdk_tns_se_age_mem_age_int_en_lo_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO "TNS_SE_AGE_MEM_AGE_INT_EN_LO"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_int_frc
 *
 * TNS Search Age Memory Age Interrrupt Force Register
 * --
 */
union bdk_tns_se_age_mem_age_int_frc
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](WO) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](WO) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](WO) -- */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](WO) -- */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](WO) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](WO) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else /* Word 0 - Little Endian */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](WO) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](WO) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](WO) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](WO) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](WO) -- */
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](WO) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_int_frc_s cn; */
};
typedef union bdk_tns_se_age_mem_age_int_frc bdk_tns_se_age_mem_age_int_frc_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_FRC BDK_TNS_SE_AGE_MEM_AGE_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205601001cll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC bdk_tns_se_age_mem_age_int_frc_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC "TNS_SE_AGE_MEM_AGE_INT_FRC"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_int_w1c
 *
 * TNS Search Age Memory Age Interrrupt W1C Register
 * --
 */
union bdk_tns_se_age_mem_age_int_w1c
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](R/W1C/H) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](R/W1C/H) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](R/W1C/H) -- */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](R/W1C/H) -- */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](R/W1C/H) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](R/W1C/H) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else /* Word 0 - Little Endian */
        uint32_t age_fifo_ovfl         : 1;  /**< [  0:  0](R/W1C/H) Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
        uint32_t age_fifo_non_empty    : 1;  /**< [  1:  1](R/W1C/H) There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
        uint32_t mark_db_err           : 2;  /**< [  3:  2](R/W1C/H) -- */
        uint32_t mark_sb_err           : 2;  /**< [  5:  4](R/W1C/H) -- */
        uint32_t mask_db_err           : 2;  /**< [  7:  6](R/W1C/H) -- */
        uint32_t mask_sb_err           : 2;  /**< [  9:  8](R/W1C/H) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_int_w1c_s cn; */
};
typedef union bdk_tns_se_age_mem_age_int_w1c bdk_tns_se_age_mem_age_int_w1c_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_W1C BDK_TNS_SE_AGE_MEM_AGE_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010010ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C bdk_tns_se_age_mem_age_int_w1c_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C "TNS_SE_AGE_MEM_AGE_INT_W1C"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_sta_w0
 *
 * TNS Search Age Memory Age Status Word 0 Register
 * This is a read only status register.
 */
union bdk_tns_se_age_mem_age_sta_w0
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_sta_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_data              : 32; /**< [ 31:  0](R/W/H) A bit of 0 means the corresponding entry has not been hit during past refr
                                                                 cycle. */
#else /* Word 0 - Little Endian */
        uint32_t row_data              : 32; /**< [ 31:  0](R/W/H) A bit of 0 means the corresponding entry has not been hit during past refr
                                                                 cycle. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_sta_w0_s cn; */
};
typedef union bdk_tns_se_age_mem_age_sta_w0 bdk_tns_se_age_mem_age_sta_w0_t;

#define BDK_TNS_SE_AGE_MEM_AGE_STA_W0 BDK_TNS_SE_AGE_MEM_AGE_STA_W0_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010020ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_STA_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 bdk_tns_se_age_mem_age_sta_w0_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 "TNS_SE_AGE_MEM_AGE_STA_W0"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_sta_w1
 *
 * TNS Search Age Memory Age Status Word 1 Register
 * Continuation of structure defined in TNS_SE_AGE_MEM_AGE_STA_W0
 */
union bdk_tns_se_age_mem_age_sta_w1
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_sta_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_data              : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field ROW_DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t row_data              : 32; /**< [ 31:  0](R/W/H) Continuation of MSBs of field ROW_DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_sta_w1_s cn; */
};
typedef union bdk_tns_se_age_mem_age_sta_w1 bdk_tns_se_age_mem_age_sta_w1_t;

#define BDK_TNS_SE_AGE_MEM_AGE_STA_W1 BDK_TNS_SE_AGE_MEM_AGE_STA_W1_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010024ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_STA_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 bdk_tns_se_age_mem_age_sta_w1_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 "TNS_SE_AGE_MEM_AGE_STA_W1"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_age_sta_w2
 *
 * TNS Search Age Memory Age Status Word 2 Register
 * Continuation of structure defined in TNS_SE_AGE_MEM_AGE_STA_W0
 */
union bdk_tns_se_age_mem_age_sta_w2
{
    uint32_t u;
    struct bdk_tns_se_age_mem_age_sta_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t refr_done             : 1;  /**< [ 22: 22](R/W/H) In triggered mode, done last triggered age referesh if set.
                                                                 In auto mode, currently not in refresh state if set. */
        uint32_t fifo_usage            : 7;  /**< [ 21: 15](R/W/H) -- */
        uint32_t mem_offset            : 15; /**< [ 14:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t mem_offset            : 15; /**< [ 14:  0](R/W/H) -- */
        uint32_t fifo_usage            : 7;  /**< [ 21: 15](R/W/H) -- */
        uint32_t refr_done             : 1;  /**< [ 22: 22](R/W/H) In triggered mode, done last triggered age referesh if set.
                                                                 In auto mode, currently not in refresh state if set. */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_age_sta_w2_s cn; */
};
typedef union bdk_tns_se_age_mem_age_sta_w2 bdk_tns_se_age_mem_age_sta_w2_t;

#define BDK_TNS_SE_AGE_MEM_AGE_STA_W2 BDK_TNS_SE_AGE_MEM_AGE_STA_W2_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010028ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_AGE_STA_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 bdk_tns_se_age_mem_age_sta_w2_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 "TNS_SE_AGE_MEM_AGE_STA_W2"
#define device_bar_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_bist_stdn
 *
 * TNS Search Age Memory Bist Status Done Register
 * --
 */
union bdk_tns_se_age_mem_bist_stdn
{
    uint32_t u;
    struct bdk_tns_se_age_mem_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bist_status           : 4;  /**< [  7:  4](RO/H) -- */
        uint32_t bist_done             : 4;  /**< [  3:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t bist_done             : 4;  /**< [  3:  0](RO/H) -- */
        uint32_t bist_status           : 4;  /**< [  7:  4](RO/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_bist_stdn_s cn; */
};
typedef union bdk_tns_se_age_mem_bist_stdn bdk_tns_se_age_mem_bist_stdn_t;

#define BDK_TNS_SE_AGE_MEM_BIST_STDN BDK_TNS_SE_AGE_MEM_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_BIST_STDN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010044ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_BIST_STDN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_BIST_STDN bdk_tns_se_age_mem_bist_stdn_t
#define bustype_BDK_TNS_SE_AGE_MEM_BIST_STDN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_BIST_STDN "TNS_SE_AGE_MEM_BIST_STDN"
#define device_bar_BDK_TNS_SE_AGE_MEM_BIST_STDN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_BIST_STDN 0
#define arguments_BDK_TNS_SE_AGE_MEM_BIST_STDN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_dbg_sel
 *
 * TNS Search Age Memory Debug Selector Register
 * --
 */
union bdk_tns_se_age_mem_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_age_mem_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t age_dbg_sel           : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t age_dbg_sel           : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_dbg_sel_s cn; */
};
typedef union bdk_tns_se_age_mem_dbg_sel bdk_tns_se_age_mem_dbg_sel_t;

#define BDK_TNS_SE_AGE_MEM_DBG_SEL BDK_TNS_SE_AGE_MEM_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010040ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_DBG_SEL bdk_tns_se_age_mem_dbg_sel_t
#define bustype_BDK_TNS_SE_AGE_MEM_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_DBG_SEL "TNS_SE_AGE_MEM_DBG_SEL"
#define device_bar_BDK_TNS_SE_AGE_MEM_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_DBG_SEL 0
#define arguments_BDK_TNS_SE_AGE_MEM_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_ecc_ctl
 *
 * TNS Search Age Memory ECC Control Register
 * ECC configuration for AGE memories
 */
union bdk_tns_se_age_mem_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_se_age_mem_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t mask_flip_sb_ecc      : 2;  /**< [ 11: 10](R/W) -- */
        uint32_t mask_flip_db_ecc      : 2;  /**< [  9:  8](R/W) -- */
        uint32_t mask_cor_dis          : 2;  /**< [  7:  6](R/W) -- */
        uint32_t mark_flip_sb_ecc      : 2;  /**< [  5:  4](R/W) -- */
        uint32_t mark_flip_db_ecc      : 2;  /**< [  3:  2](R/W) -- */
        uint32_t mark_cor_dis          : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mark_cor_dis          : 2;  /**< [  1:  0](R/W) -- */
        uint32_t mark_flip_db_ecc      : 2;  /**< [  3:  2](R/W) -- */
        uint32_t mark_flip_sb_ecc      : 2;  /**< [  5:  4](R/W) -- */
        uint32_t mask_cor_dis          : 2;  /**< [  7:  6](R/W) -- */
        uint32_t mask_flip_db_ecc      : 2;  /**< [  9:  8](R/W) -- */
        uint32_t mask_flip_sb_ecc      : 2;  /**< [ 11: 10](R/W) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_ecc_ctl_s cn; */
};
typedef union bdk_tns_se_age_mem_ecc_ctl bdk_tns_se_age_mem_ecc_ctl_t;

#define BDK_TNS_SE_AGE_MEM_ECC_CTL BDK_TNS_SE_AGE_MEM_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205601002cll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_ECC_CTL bdk_tns_se_age_mem_ecc_ctl_t
#define bustype_BDK_TNS_SE_AGE_MEM_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_ECC_CTL "TNS_SE_AGE_MEM_ECC_CTL"
#define device_bar_BDK_TNS_SE_AGE_MEM_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_ECC_CTL 0
#define arguments_BDK_TNS_SE_AGE_MEM_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_lock
 *
 * TNS Search Age Memory Lock Register
 * Lock Register
 */
union bdk_tns_se_age_mem_lock
{
    uint32_t u;
    struct bdk_tns_se_age_mem_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_lock_s cn; */
};
typedef union bdk_tns_se_age_mem_lock bdk_tns_se_age_mem_lock_t;

#define BDK_TNS_SE_AGE_MEM_LOCK BDK_TNS_SE_AGE_MEM_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010048ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_LOCK bdk_tns_se_age_mem_lock_t
#define bustype_BDK_TNS_SE_AGE_MEM_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_LOCK "TNS_SE_AGE_MEM_LOCK"
#define device_bar_BDK_TNS_SE_AGE_MEM_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_LOCK 0
#define arguments_BDK_TNS_SE_AGE_MEM_LOCK -1,-1,-1,-1

/**
 * Register (NCB) tns_se_age_mem_mark#d#
 *
 * TNS Search Age Memory Mark Registers
 * 0.25Mb of memory bits enables age marking for maximum 0.25M table entries. All
 * age marking memory
 * organized into 2 tiles of 64-bit by 2K-row tiles, forming a contiguous
 * address space from 0 to 4K rows.
 */
union bdk_tns_se_age_mem_markxdx
{
    uint64_t u;
    struct bdk_tns_se_age_mem_markxdx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t age_mark              : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t age_mark              : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_markxdx_s cn; */
};
typedef union bdk_tns_se_age_mem_markxdx bdk_tns_se_age_mem_markxdx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MARKXDX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MARKXDX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=2047)))
        return 0x842056000000ll + 0x4000ll * ((a) & 0x1) + 8ll * ((b) & 0x7ff);
    __bdk_csr_fatal("TNS_SE_AGE_MEM_MARKXDX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_MARKXDX(a,b) bdk_tns_se_age_mem_markxdx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MARKXDX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_AGE_MEM_MARKXDX(a,b) "TNS_SE_AGE_MEM_MARKXDX"
#define device_bar_BDK_TNS_SE_AGE_MEM_MARKXDX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_MARKXDX(a,b) (a)
#define arguments_BDK_TNS_SE_AGE_MEM_MARKXDX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_se_age_mem_mask#d#
 *
 * TNS Search Age Memory Mask Registers
 * Each age mark bit is associated with an age mask bit to disable aging of the
 * particular entry.
 */
union bdk_tns_se_age_mem_maskxdx
{
    uint64_t u;
    struct bdk_tns_se_age_mem_maskxdx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t age_mask              : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t age_mask              : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_maskxdx_s cn; */
};
typedef union bdk_tns_se_age_mem_maskxdx bdk_tns_se_age_mem_maskxdx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MASKXDX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MASKXDX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=2047)))
        return 0x842056008000ll + 0x4000ll * ((a) & 0x1) + 8ll * ((b) & 0x7ff);
    __bdk_csr_fatal("TNS_SE_AGE_MEM_MASKXDX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_MASKXDX(a,b) bdk_tns_se_age_mem_maskxdx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MASKXDX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_AGE_MEM_MASKXDX(a,b) "TNS_SE_AGE_MEM_MASKXDX"
#define device_bar_BDK_TNS_SE_AGE_MEM_MASKXDX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_MASKXDX(a,b) (a)
#define arguments_BDK_TNS_SE_AGE_MEM_MASKXDX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_mrk_ecc_log#
 *
 * TNS Search Age Memory Mark ECC Log Registers
 * These are read only
 */
union bdk_tns_se_age_mem_mrk_ecc_logx
{
    uint32_t u;
    struct bdk_tns_se_age_mem_mrk_ecc_logx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_mrk_ecc_logx_s cn; */
};
typedef union bdk_tns_se_age_mem_mrk_ecc_logx bdk_tns_se_age_mem_mrk_ecc_logx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842056010038ll + 4ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SE_AGE_MEM_MRK_ECC_LOGX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(a) bdk_tns_se_age_mem_mrk_ecc_logx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(a) "TNS_SE_AGE_MEM_MRK_ECC_LOGX"
#define device_bar_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(a) (a)
#define arguments_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_msk_ecc_log#
 *
 * TNS Search Age Memory Mask ECC Log Registers
 * These are read only
 */
union bdk_tns_se_age_mem_msk_ecc_logx
{
    uint32_t u;
    struct bdk_tns_se_age_mem_msk_ecc_logx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_msk_ecc_logx_s cn; */
};
typedef union bdk_tns_se_age_mem_msk_ecc_logx bdk_tns_se_age_mem_msk_ecc_logx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842056010030ll + 4ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SE_AGE_MEM_MSK_ECC_LOGX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(a) bdk_tns_se_age_mem_msk_ecc_logx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(a) "TNS_SE_AGE_MEM_MSK_ECC_LOGX"
#define device_bar_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(a) (a)
#define arguments_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_se_age_mem_rfrsh_w0
 *
 * TNS Search Age Memory Refresh Word 0 Register
 * --
 */
union bdk_tns_se_age_mem_rfrsh_w0
{
    uint64_t u;
    struct bdk_tns_se_age_mem_rfrsh_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t trig_cfg_bmp          : 25; /**< [ 63: 39](R/W) bitmap of age configuration to trigger age refresh, rising edge triggered */
        uint64_t en_pause              : 1;  /**< [ 38: 38](R/W) if set, hardware pauses refresh when age fifo occurpancy exceeds configured
                                                                 threshold */
        uint64_t fifo_thd              : 6;  /**< [ 37: 32](R/W) fifo usage may overshoot, maximum value ceiled at 6'd56. */
        uint64_t unit_time             : 32; /**< [ 31:  0](R/W) Unit of time for agine is number of switch-clock cycle. */
#else /* Word 0 - Little Endian */
        uint64_t unit_time             : 32; /**< [ 31:  0](R/W) Unit of time for agine is number of switch-clock cycle. */
        uint64_t fifo_thd              : 6;  /**< [ 37: 32](R/W) fifo usage may overshoot, maximum value ceiled at 6'd56. */
        uint64_t en_pause              : 1;  /**< [ 38: 38](R/W) if set, hardware pauses refresh when age fifo occurpancy exceeds configured
                                                                 threshold */
        uint64_t trig_cfg_bmp          : 25; /**< [ 63: 39](R/W) bitmap of age configuration to trigger age refresh, rising edge triggered */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_rfrsh_w0_s cn; */
};
typedef union bdk_tns_se_age_mem_rfrsh_w0 bdk_tns_se_age_mem_rfrsh_w0_t;

#define BDK_TNS_SE_AGE_MEM_RFRSH_W0 BDK_TNS_SE_AGE_MEM_RFRSH_W0_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010000ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_RFRSH_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_RFRSH_W0 bdk_tns_se_age_mem_rfrsh_w0_t
#define bustype_BDK_TNS_SE_AGE_MEM_RFRSH_W0 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_AGE_MEM_RFRSH_W0 "TNS_SE_AGE_MEM_RFRSH_W0"
#define device_bar_BDK_TNS_SE_AGE_MEM_RFRSH_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_RFRSH_W0 0
#define arguments_BDK_TNS_SE_AGE_MEM_RFRSH_W0 -1,-1,-1,-1

/**
 * Register (NCB) tns_se_age_mem_rfrsh_w1
 *
 * TNS Search Age Memory Refresh Word 1 Register
 * Continuation of structure defined in TNS_SE_AGE_MEM_RFRSH_W0
 */
union bdk_tns_se_age_mem_rfrsh_w1
{
    uint64_t u;
    struct bdk_tns_se_age_mem_rfrsh_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_40_63        : 24;
        uint64_t mode                  : 1;  /**< [ 39: 39](R/W) 1: auto refresh
                                                                 0: triggered refresh */
        uint64_t trig_cfg_bmp          : 39; /**< [ 38:  0](R/W) Continuation of MSBs of field TRIG_CFG_BMP from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t trig_cfg_bmp          : 39; /**< [ 38:  0](R/W) Continuation of MSBs of field TRIG_CFG_BMP from previous word. */
        uint64_t mode                  : 1;  /**< [ 39: 39](R/W) 1: auto refresh
                                                                 0: triggered refresh */
        uint64_t reserved_40_63        : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_rfrsh_w1_s cn; */
};
typedef union bdk_tns_se_age_mem_rfrsh_w1 bdk_tns_se_age_mem_rfrsh_w1_t;

#define BDK_TNS_SE_AGE_MEM_RFRSH_W1 BDK_TNS_SE_AGE_MEM_RFRSH_W1_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056010008ll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_RFRSH_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_RFRSH_W1 bdk_tns_se_age_mem_rfrsh_w1_t
#define bustype_BDK_TNS_SE_AGE_MEM_RFRSH_W1 BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_AGE_MEM_RFRSH_W1 "TNS_SE_AGE_MEM_RFRSH_W1"
#define device_bar_BDK_TNS_SE_AGE_MEM_RFRSH_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_RFRSH_W1 0
#define arguments_BDK_TNS_SE_AGE_MEM_RFRSH_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_mem_spad
 *
 * TNS Search Age Memory ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_age_mem_spad
{
    uint32_t u;
    struct bdk_tns_se_age_mem_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_mem_spad_s cn; */
};
typedef union bdk_tns_se_age_mem_spad bdk_tns_se_age_mem_spad_t;

#define BDK_TNS_SE_AGE_MEM_SPAD BDK_TNS_SE_AGE_MEM_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205601004cll;
    __bdk_csr_fatal("TNS_SE_AGE_MEM_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_MEM_SPAD bdk_tns_se_age_mem_spad_t
#define bustype_BDK_TNS_SE_AGE_MEM_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_MEM_SPAD "TNS_SE_AGE_MEM_SPAD"
#define device_bar_BDK_TNS_SE_AGE_MEM_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_MEM_SPAD 0
#define arguments_BDK_TNS_SE_AGE_MEM_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_tbl#_cfg_id#
 *
 * TNS Search Age Table Configuration ID Registers
 * --
 */
union bdk_tns_se_age_tblx_cfg_idx
{
    uint32_t u;
    struct bdk_tns_se_age_tblx_cfg_idx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t age_en                : 1;  /**< [  6:  6](R/W) -- */
        uint32_t cfg_id                : 6;  /**< [  5:  0](R/W) Out of the 168 total tables, only 64 table can be age enabled.
                                                                 This ID number points to one of the 64 configration entries for
                                                                 this table. */
#else /* Word 0 - Little Endian */
        uint32_t cfg_id                : 6;  /**< [  5:  0](R/W) Out of the 168 total tables, only 64 table can be age enabled.
                                                                 This ID number points to one of the 64 configration entries for
                                                                 this table. */
        uint32_t age_en                : 1;  /**< [  6:  6](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_tblx_cfg_idx_s cn; */
};
typedef union bdk_tns_se_age_tblx_cfg_idx bdk_tns_se_age_tblx_cfg_idx_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLX_CFG_IDX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLX_CFG_IDX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=83)))
        return 0x842056080000ll + 0x1000ll * ((a) & 0x1) + 4ll * ((b) & 0x7f);
    __bdk_csr_fatal("TNS_SE_AGE_TBLX_CFG_IDX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_TBLX_CFG_IDX(a,b) bdk_tns_se_age_tblx_cfg_idx_t
#define bustype_BDK_TNS_SE_AGE_TBLX_CFG_IDX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_TBLX_CFG_IDX(a,b) "TNS_SE_AGE_TBLX_CFG_IDX"
#define device_bar_BDK_TNS_SE_AGE_TBLX_CFG_IDX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_TBLX_CFG_IDX(a,b) (a)
#define arguments_BDK_TNS_SE_AGE_TBLX_CFG_IDX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_age_tbl#_lock
 *
 * TNS Search Age Table Lock Registers
 * Lock Register
 */
union bdk_tns_se_age_tblx_lock
{
    uint32_t u;
    struct bdk_tns_se_age_tblx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_tblx_lock_s cn; */
};
typedef union bdk_tns_se_age_tblx_lock bdk_tns_se_age_tblx_lock_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842056080250ll + 0x1000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SE_AGE_TBLX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_TBLX_LOCK(a) bdk_tns_se_age_tblx_lock_t
#define bustype_BDK_TNS_SE_AGE_TBLX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_TBLX_LOCK(a) "TNS_SE_AGE_TBLX_LOCK"
#define device_bar_BDK_TNS_SE_AGE_TBLX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_TBLX_LOCK(a) (a)
#define arguments_BDK_TNS_SE_AGE_TBLX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_age_tbl#_spad
 *
 * TNS Search Age Table ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_age_tblx_spad
{
    uint32_t u;
    struct bdk_tns_se_age_tblx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_tblx_spad_s cn; */
};
typedef union bdk_tns_se_age_tblx_spad bdk_tns_se_age_tblx_spad_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842056080254ll + 0x1000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SE_AGE_TBLX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_TBLX_SPAD(a) bdk_tns_se_age_tblx_spad_t
#define bustype_BDK_TNS_SE_AGE_TBLX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_AGE_TBLX_SPAD(a) "TNS_SE_AGE_TBLX_SPAD"
#define device_bar_BDK_TNS_SE_AGE_TBLX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_TBLX_SPAD(a) (a)
#define arguments_BDK_TNS_SE_AGE_TBLX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_se_age_tbl#c#
 *
 * TNS Search Age Table Registers
 * --
 */
union bdk_tns_se_age_tblxcx
{
    uint64_t u;
    struct bdk_tns_se_age_tblxcx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_39_63        : 25;
        uint64_t mark_en               : 1;  /**< [ 38: 38](R/W) enable age marking for this table */
        uint64_t period_expo           : 6;  /**< [ 37: 32](R/W) Aging cycle is 2**period_exp time unit, as defined by
                                                                 xp_se_age_refresh.unit_time */
        uint64_t mem_offset            : 15; /**< [ 31: 17](R/W) In unit of 64-bit rows */
        uint64_t mem_row_inc           : 15; /**< [ 16:  2](R/W) offset+row_inc is the last age mark memory row for each SRAM pool */
        uint64_t mask_rst_en           : 1;  /**< [  1:  1](R/W) age_mem reset is done at next aging cycle for each table.
                                                                 triggered at rising edge as sampled at start point of each aging
                                                                 cycle. */
        uint64_t mask_rst_val          : 1;  /**< [  0:  0](R/W) 1'b1 for enable aging intterupt and 1'b0 for disable. */
#else /* Word 0 - Little Endian */
        uint64_t mask_rst_val          : 1;  /**< [  0:  0](R/W) 1'b1 for enable aging intterupt and 1'b0 for disable. */
        uint64_t mask_rst_en           : 1;  /**< [  1:  1](R/W) age_mem reset is done at next aging cycle for each table.
                                                                 triggered at rising edge as sampled at start point of each aging
                                                                 cycle. */
        uint64_t mem_row_inc           : 15; /**< [ 16:  2](R/W) offset+row_inc is the last age mark memory row for each SRAM pool */
        uint64_t mem_offset            : 15; /**< [ 31: 17](R/W) In unit of 64-bit rows */
        uint64_t period_expo           : 6;  /**< [ 37: 32](R/W) Aging cycle is 2**period_exp time unit, as defined by
                                                                 xp_se_age_refresh.unit_time */
        uint64_t mark_en               : 1;  /**< [ 38: 38](R/W) enable age marking for this table */
        uint64_t reserved_39_63        : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_age_tblxcx_s cn; */
};
typedef union bdk_tns_se_age_tblxcx bdk_tns_se_age_tblxcx_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLXCX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLXCX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=31)))
        return 0x842056080150ll + 0x1000ll * ((a) & 0x1) + 8ll * ((b) & 0x1f);
    __bdk_csr_fatal("TNS_SE_AGE_TBLXCX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_AGE_TBLXCX(a,b) bdk_tns_se_age_tblxcx_t
#define bustype_BDK_TNS_SE_AGE_TBLXCX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_AGE_TBLXCX(a,b) "TNS_SE_AGE_TBLXCX"
#define device_bar_BDK_TNS_SE_AGE_TBLXCX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_AGE_TBLXCX(a,b) (a)
#define arguments_BDK_TNS_SE_AGE_TBLXCX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_se_cfg_spare
 *
 * TNS Search Configuration Spare Register
 * --
 */
union bdk_tns_se_cfg_spare
{
    uint64_t u;
    struct bdk_tns_se_cfg_spare_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t xp_se_spare           : 64; /**< [ 63:  0](R/W) Spare register with an SE debug signature 0x0FEDCBA987654321 */
#else /* Word 0 - Little Endian */
        uint64_t xp_se_spare           : 64; /**< [ 63:  0](R/W) Spare register with an SE debug signature 0x0FEDCBA987654321 */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_cfg_spare_s cn; */
};
typedef union bdk_tns_se_cfg_spare bdk_tns_se_cfg_spare_t;

#define BDK_TNS_SE_CFG_SPARE BDK_TNS_SE_CFG_SPARE_FUNC()
static inline uint64_t BDK_TNS_SE_CFG_SPARE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_CFG_SPARE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052200040ll;
    __bdk_csr_fatal("TNS_SE_CFG_SPARE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_CFG_SPARE bdk_tns_se_cfg_spare_t
#define bustype_BDK_TNS_SE_CFG_SPARE BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_CFG_SPARE "TNS_SE_CFG_SPARE"
#define device_bar_BDK_TNS_SE_CFG_SPARE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_CFG_SPARE 0
#define arguments_BDK_TNS_SE_CFG_SPARE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_direct_lock
 *
 * TNS Search Direct Lock Register
 * Lock Register
 */
union bdk_tns_se_direct_lock
{
    uint32_t u;
    struct bdk_tns_se_direct_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_direct_lock_s cn; */
};
typedef union bdk_tns_se_direct_lock bdk_tns_se_direct_lock_t;

#define BDK_TNS_SE_DIRECT_LOCK BDK_TNS_SE_DIRECT_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_DIRECT_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_DIRECT_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056102100ll;
    __bdk_csr_fatal("TNS_SE_DIRECT_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_DIRECT_LOCK bdk_tns_se_direct_lock_t
#define bustype_BDK_TNS_SE_DIRECT_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_DIRECT_LOCK "TNS_SE_DIRECT_LOCK"
#define device_bar_BDK_TNS_SE_DIRECT_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_DIRECT_LOCK 0
#define arguments_BDK_TNS_SE_DIRECT_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_direct_spad
 *
 * TNS Search Direct ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_direct_spad
{
    uint32_t u;
    struct bdk_tns_se_direct_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_direct_spad_s cn; */
};
typedef union bdk_tns_se_direct_spad bdk_tns_se_direct_spad_t;

#define BDK_TNS_SE_DIRECT_SPAD BDK_TNS_SE_DIRECT_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_DIRECT_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_DIRECT_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056102104ll;
    __bdk_csr_fatal("TNS_SE_DIRECT_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_DIRECT_SPAD bdk_tns_se_direct_spad_t
#define bustype_BDK_TNS_SE_DIRECT_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_DIRECT_SPAD "TNS_SE_DIRECT_SPAD"
#define device_bar_BDK_TNS_SE_DIRECT_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_DIRECT_SPAD 0
#define arguments_BDK_TNS_SE_DIRECT_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_direct_tbl_direct#
 *
 * TNS Search Direct Table Direct Registers
 * --
 */
union bdk_tns_se_direct_tbl_directx
{
    uint32_t u;
    struct bdk_tns_se_direct_tbl_directx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t data_size             : 4;  /**< [ 18: 15](R/W) 0x2: 64-bit
                                                                 0x4: 128-bit
                                                                 0x8: 256-bit */
        uint32_t pool                  : 3;  /**< [ 14: 12](R/W) Pool ID out of the 8 pools, which this table resides. */
        uint32_t row_blk_inc           : 6;  /**< [ 11:  6](R/W) Each table occupies row blocks [row_blk_start, row_blk_start + row_blk_inc],
                                                                 inclusive */
        uint32_t row_blk_start         : 6;  /**< [  5:  0](R/W) Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start         : 6;  /**< [  5:  0](R/W) Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
        uint32_t row_blk_inc           : 6;  /**< [ 11:  6](R/W) Each table occupies row blocks [row_blk_start, row_blk_start + row_blk_inc],
                                                                 inclusive */
        uint32_t pool                  : 3;  /**< [ 14: 12](R/W) Pool ID out of the 8 pools, which this table resides. */
        uint32_t data_size             : 4;  /**< [ 18: 15](R/W) 0x2: 64-bit
                                                                 0x4: 128-bit
                                                                 0x8: 256-bit */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_direct_tbl_directx_s cn; */
};
typedef union bdk_tns_se_direct_tbl_directx bdk_tns_se_direct_tbl_directx_t;

static inline uint64_t BDK_TNS_SE_DIRECT_TBL_DIRECTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_DIRECT_TBL_DIRECTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842056102000ll + 4ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SE_DIRECT_TBL_DIRECTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_DIRECT_TBL_DIRECTX(a) bdk_tns_se_direct_tbl_directx_t
#define bustype_BDK_TNS_SE_DIRECT_TBL_DIRECTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_DIRECT_TBL_DIRECTX(a) "TNS_SE_DIRECT_TBL_DIRECTX"
#define device_bar_BDK_TNS_SE_DIRECT_TBL_DIRECTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_DIRECT_TBL_DIRECTX(a) (a)
#define arguments_BDK_TNS_SE_DIRECT_TBL_DIRECTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_hash_hash_dbg_sel
 *
 * TNS Search Hash Hash Debug Selector Register
 * --
 */
union bdk_tns_se_hash_hash_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_hash_hash_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hash_dbg_sel          : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else /* Word 0 - Little Endian */
        uint32_t hash_dbg_sel          : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_hash_hash_dbg_sel_s cn; */
};
typedef union bdk_tns_se_hash_hash_dbg_sel bdk_tns_se_hash_hash_dbg_sel_t;

#define BDK_TNS_SE_HASH_HASH_DBG_SEL BDK_TNS_SE_HASH_HASH_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_HASH_HASH_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_HASH_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109580ll;
    __bdk_csr_fatal("TNS_SE_HASH_HASH_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_HASH_HASH_DBG_SEL bdk_tns_se_hash_hash_dbg_sel_t
#define bustype_BDK_TNS_SE_HASH_HASH_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_HASH_HASH_DBG_SEL "TNS_SE_HASH_HASH_DBG_SEL"
#define device_bar_BDK_TNS_SE_HASH_HASH_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_HASH_HASH_DBG_SEL 0
#define arguments_BDK_TNS_SE_HASH_HASH_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_hash_lock
 *
 * TNS Search Hash Lock Register
 * Lock Register
 */
union bdk_tns_se_hash_lock
{
    uint32_t u;
    struct bdk_tns_se_hash_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_hash_lock_s cn; */
};
typedef union bdk_tns_se_hash_lock bdk_tns_se_hash_lock_t;

#define BDK_TNS_SE_HASH_LOCK BDK_TNS_SE_HASH_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_HASH_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109584ll;
    __bdk_csr_fatal("TNS_SE_HASH_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_HASH_LOCK bdk_tns_se_hash_lock_t
#define bustype_BDK_TNS_SE_HASH_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_HASH_LOCK "TNS_SE_HASH_LOCK"
#define device_bar_BDK_TNS_SE_HASH_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_HASH_LOCK 0
#define arguments_BDK_TNS_SE_HASH_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_hash_spad
 *
 * TNS Search Hash ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_hash_spad
{
    uint32_t u;
    struct bdk_tns_se_hash_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_hash_spad_s cn; */
};
typedef union bdk_tns_se_hash_spad bdk_tns_se_hash_spad_t;

#define BDK_TNS_SE_HASH_SPAD BDK_TNS_SE_HASH_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_HASH_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109588ll;
    __bdk_csr_fatal("TNS_SE_HASH_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_HASH_SPAD bdk_tns_se_hash_spad_t
#define bustype_BDK_TNS_SE_HASH_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_HASH_SPAD "TNS_SE_HASH_SPAD"
#define device_bar_BDK_TNS_SE_HASH_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_HASH_SPAD 0
#define arguments_BDK_TNS_SE_HASH_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_hash_tbl_hash#_w0
 *
 * TNS Search Hash Table Hash Word 0 Registers
 * --
 */
union bdk_tns_se_hash_tbl_hashx_w0
{
    uint32_t u;
    struct bdk_tns_se_hash_tbl_hashx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_blk_start_5       : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t row_blk_start_6       : 6;  /**< [ 27: 22](R/W) -- */
        uint32_t row_blk_start_7       : 6;  /**< [ 21: 16](R/W) -- */
        uint32_t hash_func_0           : 2;  /**< [ 15: 14](R/W) Each way has a different set of 4 hash functions, choose one of them
                                                                 as hash function for way 0 (4,5,6,7 unused for 4-way hash in xpt) */
        uint32_t hash_func_1           : 2;  /**< [ 13: 12](R/W) way 1 */
        uint32_t hash_func_2           : 2;  /**< [ 11: 10](R/W) way 2 */
        uint32_t hash_func_3           : 2;  /**< [  9:  8](R/W) way 3 */
        uint32_t hash_func_4           : 2;  /**< [  7:  6](R/W) way 4 */
        uint32_t hash_func_5           : 2;  /**< [  5:  4](R/W) way 5 */
        uint32_t hash_func_6           : 2;  /**< [  3:  2](R/W) way 6 */
        uint32_t hash_func_7           : 2;  /**< [  1:  0](R/W) way 7 */
#else /* Word 0 - Little Endian */
        uint32_t hash_func_7           : 2;  /**< [  1:  0](R/W) way 7 */
        uint32_t hash_func_6           : 2;  /**< [  3:  2](R/W) way 6 */
        uint32_t hash_func_5           : 2;  /**< [  5:  4](R/W) way 5 */
        uint32_t hash_func_4           : 2;  /**< [  7:  6](R/W) way 4 */
        uint32_t hash_func_3           : 2;  /**< [  9:  8](R/W) way 3 */
        uint32_t hash_func_2           : 2;  /**< [ 11: 10](R/W) way 2 */
        uint32_t hash_func_1           : 2;  /**< [ 13: 12](R/W) way 1 */
        uint32_t hash_func_0           : 2;  /**< [ 15: 14](R/W) Each way has a different set of 4 hash functions, choose one of them
                                                                 as hash function for way 0 (4,5,6,7 unused for 4-way hash in xpt) */
        uint32_t row_blk_start_7       : 6;  /**< [ 21: 16](R/W) -- */
        uint32_t row_blk_start_6       : 6;  /**< [ 27: 22](R/W) -- */
        uint32_t row_blk_start_5       : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_hash_tbl_hashx_w0_s cn; */
};
typedef union bdk_tns_se_hash_tbl_hashx_w0 bdk_tns_se_hash_tbl_hashx_w0_t;

static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842056109400ll + 0xcll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SE_HASH_TBL_HASHX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_HASH_TBL_HASHX_W0(a) bdk_tns_se_hash_tbl_hashx_w0_t
#define bustype_BDK_TNS_SE_HASH_TBL_HASHX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_HASH_TBL_HASHX_W0(a) "TNS_SE_HASH_TBL_HASHX_W0"
#define device_bar_BDK_TNS_SE_HASH_TBL_HASHX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_HASH_TBL_HASHX_W0(a) (a)
#define arguments_BDK_TNS_SE_HASH_TBL_HASHX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_hash_tbl_hash#_w1
 *
 * TNS Search Hash Table Hash Word 1 Registers
 * Continuation of structure defined in TNS_SE_HASH_TBL_HASH(0..31)_W0
 */
union bdk_tns_se_hash_tbl_hashx_w1
{
    uint32_t u;
    struct bdk_tns_se_hash_tbl_hashx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_blk_start_0       : 6;  /**< [ 31: 26](R/W) row_blk_start of hash way 0 (4,5,6,7 unused for 4-way hash in xpt). Each bucket
                                                                 is either 256-bit or 512-bit wide. */
        uint32_t row_blk_start_1       : 6;  /**< [ 25: 20](R/W) -- */
        uint32_t row_blk_start_2       : 6;  /**< [ 19: 14](R/W) -- */
        uint32_t row_blk_start_3       : 6;  /**< [ 13:  8](R/W) -- */
        uint32_t row_blk_start_4       : 6;  /**< [  7:  2](R/W) -- */
        uint32_t row_blk_start_5       : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field ROW_BLK_START_5 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start_5       : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field ROW_BLK_START_5 from previous word. */
        uint32_t row_blk_start_4       : 6;  /**< [  7:  2](R/W) -- */
        uint32_t row_blk_start_3       : 6;  /**< [ 13:  8](R/W) -- */
        uint32_t row_blk_start_2       : 6;  /**< [ 19: 14](R/W) -- */
        uint32_t row_blk_start_1       : 6;  /**< [ 25: 20](R/W) -- */
        uint32_t row_blk_start_0       : 6;  /**< [ 31: 26](R/W) row_blk_start of hash way 0 (4,5,6,7 unused for 4-way hash in xpt). Each bucket
                                                                 is either 256-bit or 512-bit wide. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_hash_tbl_hashx_w1_s cn; */
};
typedef union bdk_tns_se_hash_tbl_hashx_w1 bdk_tns_se_hash_tbl_hashx_w1_t;

static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842056109404ll + 0xcll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SE_HASH_TBL_HASHX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_HASH_TBL_HASHX_W1(a) bdk_tns_se_hash_tbl_hashx_w1_t
#define bustype_BDK_TNS_SE_HASH_TBL_HASHX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_HASH_TBL_HASHX_W1(a) "TNS_SE_HASH_TBL_HASHX_W1"
#define device_bar_BDK_TNS_SE_HASH_TBL_HASHX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_HASH_TBL_HASHX_W1(a) (a)
#define arguments_BDK_TNS_SE_HASH_TBL_HASHX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_hash_tbl_hash#_w2
 *
 * TNS Search Hash Table Hash Word 2 Registers
 * Continuation of structure defined in TNS_SE_HASH_TBL_HASH(0..31)_W0
 */
union bdk_tns_se_hash_tbl_hashx_w2
{
    uint32_t u;
    struct bdk_tns_se_hash_tbl_hashx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t key_size              : 4;  /**< [ 18: 15](R/W) 32-bit key: 32/96/224-bit data
                                                                 64-bit key: 64/192-bit data
                                                                 72-bit key: 56/184-bit data
                                                                 128-bit key: 128-bit data
                                                                 256-bit key: 256-bit data (have to be dual-tile entry) */
        uint32_t bucket_cnt            : 4;  /**< [ 14: 11](R/W) 32-bit key and 32-bit data is 256/64=4-bucket hash
                                                                 128-bit key and 128-bit data is 256/256=1-bucket hash */
        uint32_t way_bmp               : 8;  /**< [ 10:  3](R/W) Which WAY(i), any buckt[i] uses pool 0. Valid i=0,1,2,3 */
        uint32_t way_depth             : 3;  /**< [  2:  0](R/W) hash bucket depths is 2^(10+way_depth), up to 32K-entries,
                                                                 so way_depth is ceiled at 3'd5. */
#else /* Word 0 - Little Endian */
        uint32_t way_depth             : 3;  /**< [  2:  0](R/W) hash bucket depths is 2^(10+way_depth), up to 32K-entries,
                                                                 so way_depth is ceiled at 3'd5. */
        uint32_t way_bmp               : 8;  /**< [ 10:  3](R/W) Which WAY(i), any buckt[i] uses pool 0. Valid i=0,1,2,3 */
        uint32_t bucket_cnt            : 4;  /**< [ 14: 11](R/W) 32-bit key and 32-bit data is 256/64=4-bucket hash
                                                                 128-bit key and 128-bit data is 256/256=1-bucket hash */
        uint32_t key_size              : 4;  /**< [ 18: 15](R/W) 32-bit key: 32/96/224-bit data
                                                                 64-bit key: 64/192-bit data
                                                                 72-bit key: 56/184-bit data
                                                                 128-bit key: 128-bit data
                                                                 256-bit key: 256-bit data (have to be dual-tile entry) */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_hash_tbl_hashx_w2_s cn; */
};
typedef union bdk_tns_se_hash_tbl_hashx_w2 bdk_tns_se_hash_tbl_hashx_w2_t;

static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842056109408ll + 0xcll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SE_HASH_TBL_HASHX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_HASH_TBL_HASHX_W2(a) bdk_tns_se_hash_tbl_hashx_w2_t
#define bustype_BDK_TNS_SE_HASH_TBL_HASHX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_HASH_TBL_HASHX_W2(a) "TNS_SE_HASH_TBL_HASHX_W2"
#define device_bar_BDK_TNS_SE_HASH_TBL_HASHX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_HASH_TBL_HASHX_W2(a) (a)
#define arguments_BDK_TNS_SE_HASH_TBL_HASHX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_int_ro_w0
 *
 * TNS Search Interrrupt Read Only Word 0 Register
 * --
 */
union bdk_tns_se_int_ro_w0
{
    uint32_t u;
    struct bdk_tns_se_int_ro_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tcam_scrb_db2         : 2;  /**< [ 31: 30](RO/H) -- */
        uint32_t tcam_scrb_db3         : 6;  /**< [ 29: 24](RO/H) -- */
        uint32_t tcam_scrb_db4         : 6;  /**< [ 23: 18](RO/H) -- */
        uint32_t tcam_scrb_db5         : 6;  /**< [ 17: 12](RO/H) -- */
        uint32_t tcam_scrb_db6         : 6;  /**< [ 11:  6](RO/H) -- */
        uint32_t tcam_scrb_db7         : 6;  /**< [  5:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t tcam_scrb_db7         : 6;  /**< [  5:  0](RO/H) -- */
        uint32_t tcam_scrb_db6         : 6;  /**< [ 11:  6](RO/H) -- */
        uint32_t tcam_scrb_db5         : 6;  /**< [ 17: 12](RO/H) -- */
        uint32_t tcam_scrb_db4         : 6;  /**< [ 23: 18](RO/H) -- */
        uint32_t tcam_scrb_db3         : 6;  /**< [ 29: 24](RO/H) -- */
        uint32_t tcam_scrb_db2         : 2;  /**< [ 31: 30](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_int_ro_w0_s cn; */
};
typedef union bdk_tns_se_int_ro_w0 bdk_tns_se_int_ro_w0_t;

#define BDK_TNS_SE_INT_RO_W0 BDK_TNS_SE_INT_RO_W0_FUNC()
static inline uint64_t BDK_TNS_SE_INT_RO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_INT_RO_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052201040ll;
    __bdk_csr_fatal("TNS_SE_INT_RO_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_INT_RO_W0 bdk_tns_se_int_ro_w0_t
#define bustype_BDK_TNS_SE_INT_RO_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_INT_RO_W0 "TNS_SE_INT_RO_W0"
#define device_bar_BDK_TNS_SE_INT_RO_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_INT_RO_W0 0
#define arguments_BDK_TNS_SE_INT_RO_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_int_ro_w1
 *
 * TNS Search Interrrupt Read Only Word 1 Register
 * Continuation of structure defined in TNS_SE_INT_RO_W0
 */
union bdk_tns_se_int_ro_w1
{
    uint32_t u;
    struct bdk_tns_se_int_ro_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t sram_pair             : 8;  /**< [ 31: 24](RO/H) -- */
        uint32_t tsram                 : 8;  /**< [ 23: 16](RO/H) -- */
        uint32_t tcam_scrb_db0         : 6;  /**< [ 15: 10](RO/H) -- */
        uint32_t tcam_scrb_db1         : 6;  /**< [  9:  4](RO/H) -- */
        uint32_t tcam_scrb_db2         : 4;  /**< [  3:  0](RO/H) Continuation of MSBs of field TCAM_SCRUB_DB2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tcam_scrb_db2         : 4;  /**< [  3:  0](RO/H) Continuation of MSBs of field TCAM_SCRUB_DB2 from previous word. */
        uint32_t tcam_scrb_db1         : 6;  /**< [  9:  4](RO/H) -- */
        uint32_t tcam_scrb_db0         : 6;  /**< [ 15: 10](RO/H) -- */
        uint32_t tsram                 : 8;  /**< [ 23: 16](RO/H) -- */
        uint32_t sram_pair             : 8;  /**< [ 31: 24](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_int_ro_w1_s cn; */
};
typedef union bdk_tns_se_int_ro_w1 bdk_tns_se_int_ro_w1_t;

#define BDK_TNS_SE_INT_RO_W1 BDK_TNS_SE_INT_RO_W1_FUNC()
static inline uint64_t BDK_TNS_SE_INT_RO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_INT_RO_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052201044ll;
    __bdk_csr_fatal("TNS_SE_INT_RO_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_INT_RO_W1 bdk_tns_se_int_ro_w1_t
#define bustype_BDK_TNS_SE_INT_RO_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_INT_RO_W1 "TNS_SE_INT_RO_W1"
#define device_bar_BDK_TNS_SE_INT_RO_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_INT_RO_W1 0
#define arguments_BDK_TNS_SE_INT_RO_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_int_ro_w2
 *
 * TNS Search Interrrupt Read Only Word 2 Register
 * Continuation of structure defined in TNS_SE_INT_RO_W0
 */
union bdk_tns_se_int_ro_w2
{
    uint32_t u;
    struct bdk_tns_se_int_ro_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t unused_tmp            : 29; /**< [ 31:  3](RO/H) -- */
        uint32_t se0                   : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t se1                   : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t age                   : 1;  /**< [  0:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t age                   : 1;  /**< [  0:  0](RO/H) -- */
        uint32_t se1                   : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t se0                   : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t unused_tmp            : 29; /**< [ 31:  3](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_int_ro_w2_s cn; */
};
typedef union bdk_tns_se_int_ro_w2 bdk_tns_se_int_ro_w2_t;

#define BDK_TNS_SE_INT_RO_W2 BDK_TNS_SE_INT_RO_W2_FUNC()
static inline uint64_t BDK_TNS_SE_INT_RO_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_INT_RO_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052201048ll;
    __bdk_csr_fatal("TNS_SE_INT_RO_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_INT_RO_W2 bdk_tns_se_int_ro_w2_t
#define bustype_BDK_TNS_SE_INT_RO_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_INT_RO_W2 "TNS_SE_INT_RO_W2"
#define device_bar_BDK_TNS_SE_INT_RO_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_INT_RO_W2 0
#define arguments_BDK_TNS_SE_INT_RO_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_lde_srch_cmd#_w0
 *
 * TNS Search LDE Search Command Word 0 Registers
 * Search command configuration, command 4*i through 4*i+3 constitute search
 * profile i.
 * LDE j can request for search profiel j*8 through j*8+7.
 * So, LDE j perform search of profile p, then commdn i looks up search
 * command configuration
 * as j*32+i*8+p
 */
union bdk_tns_se_lde_srch_cmdx_w0
{
    uint32_t u;
    struct bdk_tns_se_lde_srch_cmdx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key_byte_bmp          : 11; /**< [ 31: 21](R/W) bitmap for forming search key out of the 384-bit (48-Byte) input key.
                                                                 Supported LPM key sizes are 6, 8 or 18 bytes only,
                                                                 if key_size is less than this value, LPM key is MSB aligned,
                                                                 for all other requests, keys are LSB aligned if key specified in
                                                                 search command is
                                                                 less than what specified in the table. */
        uint32_t key_size              : 6;  /**< [ 20: 15](R/W) LPM: supported value are 4, 8, 18
                                                                 Hash: supported value are 4, 8, 9, 16, 32
                                                                 TCAM: supported value are: 8, 16, 24, 48 */
        uint32_t ecmp_en               : 1;  /**< [ 14: 14](R/W) Enable ECMP, applicable only for LPM search command. */
        uint32_t ecmp_hash_byte_start  : 6;  /**< [ 13:  8](R/W) ecmp_hash is always 10-bit, occupying 2-byte in the master key,
                                                                 and it is applicable only for LPM search command. */
        uint32_t hash_way_cnt          : 4;  /**< [  7:  4](R/W) Applicable only for hash search command. */
        uint32_t adm_id                : 4;  /**< [  3:  0](R/W) Each hash engine admits two command in a cycle, i.e. input port 0 and 1. And
                                                                 each command
                                                                 can potentially go to muliptle engines, so adm_id needs to be
                                                                 eng_id * 2 + input_id
                                                                 For hash command, each search command of each LDE is connected
                                                                 to 4 hash engines
                                                                 Since XPT has only 2 LDEs, to improve BW for average case, map
                                                                 LDE0 to input 0, LDE1 to input 1
                                                                 and map the LDE1 command backwards. Example: LDE0.CMD0 to
                                                                 ENG0.INP0; LDE0.CMD1 to ENG1.INP0,....
                                                                 LDE1.CMD0 to ENG3.INP1, LDE1.CMD1 to ENG2.INP1,....
                                                                 For LPM/direct/TCAM engines, each engine admits one command each
                                                                 cycle only,
                                                                 so adm_id is eng_id *2 (i.e. input_id is always 0)
                                                                 For direct-access table, search command i of each LDE is connected
                                                                 to 1 engine (CMD0 to ENG0, CMD1 to ENG1, etc...),
                                                                 which access SRAM pool.
                                                                 For LPM, all search commands connects to 1 LPM engine only (so
                                                                 adm_id always 0 since only 1 LPM engine).
                                                                 For TCAM, each search command connects to 4 TCAM engines. */
#else /* Word 0 - Little Endian */
        uint32_t adm_id                : 4;  /**< [  3:  0](R/W) Each hash engine admits two command in a cycle, i.e. input port 0 and 1. And
                                                                 each command
                                                                 can potentially go to muliptle engines, so adm_id needs to be
                                                                 eng_id * 2 + input_id
                                                                 For hash command, each search command of each LDE is connected
                                                                 to 4 hash engines
                                                                 Since XPT has only 2 LDEs, to improve BW for average case, map
                                                                 LDE0 to input 0, LDE1 to input 1
                                                                 and map the LDE1 command backwards. Example: LDE0.CMD0 to
                                                                 ENG0.INP0; LDE0.CMD1 to ENG1.INP0,....
                                                                 LDE1.CMD0 to ENG3.INP1, LDE1.CMD1 to ENG2.INP1,....
                                                                 For LPM/direct/TCAM engines, each engine admits one command each
                                                                 cycle only,
                                                                 so adm_id is eng_id *2 (i.e. input_id is always 0)
                                                                 For direct-access table, search command i of each LDE is connected
                                                                 to 1 engine (CMD0 to ENG0, CMD1 to ENG1, etc...),
                                                                 which access SRAM pool.
                                                                 For LPM, all search commands connects to 1 LPM engine only (so
                                                                 adm_id always 0 since only 1 LPM engine).
                                                                 For TCAM, each search command connects to 4 TCAM engines. */
        uint32_t hash_way_cnt          : 4;  /**< [  7:  4](R/W) Applicable only for hash search command. */
        uint32_t ecmp_hash_byte_start  : 6;  /**< [ 13:  8](R/W) ecmp_hash is always 10-bit, occupying 2-byte in the master key,
                                                                 and it is applicable only for LPM search command. */
        uint32_t ecmp_en               : 1;  /**< [ 14: 14](R/W) Enable ECMP, applicable only for LPM search command. */
        uint32_t key_size              : 6;  /**< [ 20: 15](R/W) LPM: supported value are 4, 8, 18
                                                                 Hash: supported value are 4, 8, 9, 16, 32
                                                                 TCAM: supported value are: 8, 16, 24, 48 */
        uint32_t key_byte_bmp          : 11; /**< [ 31: 21](R/W) bitmap for forming search key out of the 384-bit (48-Byte) input key.
                                                                 Supported LPM key sizes are 6, 8 or 18 bytes only,
                                                                 if key_size is less than this value, LPM key is MSB aligned,
                                                                 for all other requests, keys are LSB aligned if key specified in
                                                                 search command is
                                                                 less than what specified in the table. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lde_srch_cmdx_w0_s cn; */
};
typedef union bdk_tns_se_lde_srch_cmdx_w0 bdk_tns_se_lde_srch_cmdx_w0_t;

static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842056104000ll + 0xcll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SE_LDE_SRCH_CMDX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDE_SRCH_CMDX_W0(a) bdk_tns_se_lde_srch_cmdx_w0_t
#define bustype_BDK_TNS_SE_LDE_SRCH_CMDX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDE_SRCH_CMDX_W0(a) "TNS_SE_LDE_SRCH_CMDX_W0"
#define device_bar_BDK_TNS_SE_LDE_SRCH_CMDX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDE_SRCH_CMDX_W0(a) (a)
#define arguments_BDK_TNS_SE_LDE_SRCH_CMDX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lde_srch_cmd#_w1
 *
 * TNS Search LDE Search Command Word 1 Registers
 * Continuation of structure defined in TNS_SE_LDE_SRCH_CMD(0..63)_W0
 */
union bdk_tns_se_lde_srch_cmdx_w1
{
    uint32_t u;
    struct bdk_tns_se_lde_srch_cmdx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key_byte_bmp          : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key_byte_bmp          : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lde_srch_cmdx_w1_s cn; */
};
typedef union bdk_tns_se_lde_srch_cmdx_w1 bdk_tns_se_lde_srch_cmdx_w1_t;

static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842056104004ll + 0xcll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SE_LDE_SRCH_CMDX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDE_SRCH_CMDX_W1(a) bdk_tns_se_lde_srch_cmdx_w1_t
#define bustype_BDK_TNS_SE_LDE_SRCH_CMDX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDE_SRCH_CMDX_W1(a) "TNS_SE_LDE_SRCH_CMDX_W1"
#define device_bar_BDK_TNS_SE_LDE_SRCH_CMDX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDE_SRCH_CMDX_W1(a) (a)
#define arguments_BDK_TNS_SE_LDE_SRCH_CMDX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lde_srch_cmd#_w2
 *
 * TNS Search LDE Search Command Word 2 Registers
 * Continuation of structure defined in TNS_SE_LDE_SRCH_CMD(0..63)_W0
 */
union bdk_tns_se_lde_srch_cmdx_w2
{
    uint32_t u;
    struct bdk_tns_se_lde_srch_cmdx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t lpm_load_balance      : 1;  /**< [ 24: 24](R/W) XPT has only 1 LPM engine. This should be set to 0 for XPT
                                                                 LPM engines process even numbered prefix tables and odd numbered
                                                                 prefix tables in
                                                                 two consecutive cycles. Set this field SE will automatically
                                                                 admits the LPM
                                                                 command into alternative LPM engines for load balancing. */
        uint32_t table_id              : 8;  /**< [ 23: 16](R/W) Table ID determines search command type as well as the exact table
                                                                 configuration
                                                                 [0,63] for dire-access table.
                                                                 [64,95] for hash table
                                                                 [96,127] for TCAM table
                                                                 [128,135] for LPM table */
        uint32_t rslt_qw_start         : 5;  /**< [ 15: 11](R/W) The total result of a profile is maximum 512-bit, divided into 8 64-bit quad-
                                                                 word
                                                                 The result for this search command is quad-word qw_start to
                                                                 qw_start+qw_inc, inclusive */
        uint32_t rslt_qw_inc           : 4;  /**< [ 10:  7](R/W) -- */
        uint32_t regrettable           : 1;  /**< [  6:  6](R/W) a regrettable search command may return sorry only if SE experiences
                                                                 congestions. */
        uint32_t age_en                : 1;  /**< [  5:  5](R/W) enable age marking of the entry if hit. */
        uint32_t key_byte_bmp          : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key_byte_bmp          : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
        uint32_t age_en                : 1;  /**< [  5:  5](R/W) enable age marking of the entry if hit. */
        uint32_t regrettable           : 1;  /**< [  6:  6](R/W) a regrettable search command may return sorry only if SE experiences
                                                                 congestions. */
        uint32_t rslt_qw_inc           : 4;  /**< [ 10:  7](R/W) -- */
        uint32_t rslt_qw_start         : 5;  /**< [ 15: 11](R/W) The total result of a profile is maximum 512-bit, divided into 8 64-bit quad-
                                                                 word
                                                                 The result for this search command is quad-word qw_start to
                                                                 qw_start+qw_inc, inclusive */
        uint32_t table_id              : 8;  /**< [ 23: 16](R/W) Table ID determines search command type as well as the exact table
                                                                 configuration
                                                                 [0,63] for dire-access table.
                                                                 [64,95] for hash table
                                                                 [96,127] for TCAM table
                                                                 [128,135] for LPM table */
        uint32_t lpm_load_balance      : 1;  /**< [ 24: 24](R/W) XPT has only 1 LPM engine. This should be set to 0 for XPT
                                                                 LPM engines process even numbered prefix tables and odd numbered
                                                                 prefix tables in
                                                                 two consecutive cycles. Set this field SE will automatically
                                                                 admits the LPM
                                                                 command into alternative LPM engines for load balancing. */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lde_srch_cmdx_w2_s cn; */
};
typedef union bdk_tns_se_lde_srch_cmdx_w2 bdk_tns_se_lde_srch_cmdx_w2_t;

static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842056104008ll + 0xcll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_SE_LDE_SRCH_CMDX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDE_SRCH_CMDX_W2(a) bdk_tns_se_lde_srch_cmdx_w2_t
#define bustype_BDK_TNS_SE_LDE_SRCH_CMDX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDE_SRCH_CMDX_W2(a) "TNS_SE_LDE_SRCH_CMDX_W2"
#define device_bar_BDK_TNS_SE_LDE_SRCH_CMDX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDE_SRCH_CMDX_W2(a) (a)
#define arguments_BDK_TNS_SE_LDE_SRCH_CMDX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldecmd_lock
 *
 * TNS Search LDE Command Lock Register
 * Lock Register
 */
union bdk_tns_se_ldecmd_lock
{
    uint32_t u;
    struct bdk_tns_se_ldecmd_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldecmd_lock_s cn; */
};
typedef union bdk_tns_se_ldecmd_lock bdk_tns_se_ldecmd_lock_t;

#define BDK_TNS_SE_LDECMD_LOCK BDK_TNS_SE_LDECMD_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_LDECMD_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDECMD_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056104300ll;
    __bdk_csr_fatal("TNS_SE_LDECMD_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDECMD_LOCK bdk_tns_se_ldecmd_lock_t
#define bustype_BDK_TNS_SE_LDECMD_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDECMD_LOCK "TNS_SE_LDECMD_LOCK"
#define device_bar_BDK_TNS_SE_LDECMD_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDECMD_LOCK 0
#define arguments_BDK_TNS_SE_LDECMD_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldecmd_spad
 *
 * TNS Search LDE Command ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_ldecmd_spad
{
    uint32_t u;
    struct bdk_tns_se_ldecmd_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldecmd_spad_s cn; */
};
typedef union bdk_tns_se_ldecmd_spad bdk_tns_se_ldecmd_spad_t;

#define BDK_TNS_SE_LDECMD_SPAD BDK_TNS_SE_LDECMD_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_LDECMD_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDECMD_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056104304ll;
    __bdk_csr_fatal("TNS_SE_LDECMD_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDECMD_SPAD bdk_tns_se_ldecmd_spad_t
#define bustype_BDK_TNS_SE_LDECMD_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDECMD_SPAD "TNS_SE_LDECMD_SPAD"
#define device_bar_BDK_TNS_SE_LDECMD_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDECMD_SPAD 0
#define arguments_BDK_TNS_SE_LDECMD_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_rsl_ln#_w0
 *
 * TNS Search LDE Interface CPU Result LANE Word 0 Registers
 * A CPU search result can return upto 256-bit of data (for a single search
 * command).
 * The whole CPU search profile can return upto 512-bit of control data
 */
union bdk_tns_se_ldei_cpu_rsl_lnx_w0
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_rsl_lnx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) Each rslt_lane contains 64-bit control data */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) Each rslt_lane contains 64-bit control data */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_rsl_lnx_w0_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_rsl_lnx_w0 bdk_tns_se_ldei_cpu_rsl_lnx_w0_t;

static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205610906cll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_RSL_LNX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(a) bdk_tns_se_ldei_cpu_rsl_lnx_w0_t
#define bustype_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(a) "TNS_SE_LDEI_CPU_RSL_LNX_W0"
#define device_bar_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(a) (a)
#define arguments_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_rsl_ln#_w1
 *
 * TNS Search LDE Interface CPU Result LANE Word 1 Registers
 * Continuation of structure defined in TNS_SE_LDEI_CPU_RSL_LN(0..7)_W0
 */
union bdk_tns_se_ldei_cpu_rsl_lnx_w1
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_rsl_lnx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_rsl_lnx_w1_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_rsl_lnx_w1 bdk_tns_se_ldei_cpu_rsl_lnx_w1_t;

static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056109070ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_RSL_LNX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(a) bdk_tns_se_ldei_cpu_rsl_lnx_w1_t
#define bustype_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(a) "TNS_SE_LDEI_CPU_RSL_LNX_W1"
#define device_bar_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(a) (a)
#define arguments_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_rsl_ln#_w2
 *
 * TNS Search LDE Interface CPU Result LANE Word 2 Registers
 * Continuation of structure defined in TNS_SE_LDEI_CPU_RSL_LN(0..7)_W0
 */
union bdk_tns_se_ldei_cpu_rsl_lnx_w2
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_rsl_lnx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t req_id                : 6;  /**< [ 29: 24](RO/H) pass-through of req_id */
        uint32_t sorry                 : 1;  /**< [ 23: 23](RO/H) a regrettable search command may return sorry only. */
        uint32_t hit                   : 1;  /**< [ 22: 22](RO/H) search command has a hit when set */
        uint32_t hit_addr              : 22; /**< [ 21:  0](RO/H) logic table address of the control data. for hash, it is {pool_ID, key_ID,
                                                                 bucket_idx}.
                                                                 where pool_ID is 3-bit, key_ID is up to 3-bit, and bucket_idx is
                                                                 16-bit
                                                                 for LPM/direct-access, it is {pool_ID, address}, where pool_ID is
                                                                 3-bit and address
                                                                 is 19-bit. */
#else /* Word 0 - Little Endian */
        uint32_t hit_addr              : 22; /**< [ 21:  0](RO/H) logic table address of the control data. for hash, it is {pool_ID, key_ID,
                                                                 bucket_idx}.
                                                                 where pool_ID is 3-bit, key_ID is up to 3-bit, and bucket_idx is
                                                                 16-bit
                                                                 for LPM/direct-access, it is {pool_ID, address}, where pool_ID is
                                                                 3-bit and address
                                                                 is 19-bit. */
        uint32_t hit                   : 1;  /**< [ 22: 22](RO/H) search command has a hit when set */
        uint32_t sorry                 : 1;  /**< [ 23: 23](RO/H) a regrettable search command may return sorry only. */
        uint32_t req_id                : 6;  /**< [ 29: 24](RO/H) pass-through of req_id */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_rsl_lnx_w2_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_rsl_lnx_w2 bdk_tns_se_ldei_cpu_rsl_lnx_w2_t;

static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056109074ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_RSL_LNX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(a) bdk_tns_se_ldei_cpu_rsl_lnx_w2_t
#define bustype_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(a) "TNS_SE_LDEI_CPU_RSL_LNX_W2"
#define device_bar_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(a) (a)
#define arguments_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w0
 *
 * TNS Search LDE Interface CPU Search Request Word 0 Register
 * CPU initiated search, it is muxed with LDE0, and result goes to
 * xp_se_cpu_search_rslt_lane's
 * Note that CPU request can only access control data up to 256-bit.
 */
union bdk_tns_se_ldei_cpu_srch_req_w0
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 22; /**< [ 31: 10](R/W) Each of the 4 search command use part or all of the 384-bit input key. */
        uint32_t req_id                : 6;  /**< [  9:  4](R/W) Each request is accompanied with a unique req_id. */
        uint32_t cmd_en                : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t cmd_en                : 4;  /**< [  3:  0](R/W) -- */
        uint32_t req_id                : 6;  /**< [  9:  4](R/W) Each request is accompanied with a unique req_id. */
        uint32_t key                   : 22; /**< [ 31: 10](R/W) Each of the 4 search command use part or all of the 384-bit input key. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w0_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w0 bdk_tns_se_ldei_cpu_srch_req_w0_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109038ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 bdk_tns_se_ldei_cpu_srch_req_w0_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 "TNS_SE_LDEI_CPU_SRCH_REQ_W0"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w1
 *
 * TNS Search LDE Interface CPU Search Request Word 1 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w1
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w1_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w1 bdk_tns_se_ldei_cpu_srch_req_w1_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205610903cll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 bdk_tns_se_ldei_cpu_srch_req_w1_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 "TNS_SE_LDEI_CPU_SRCH_REQ_W1"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w10
 *
 * TNS Search LDE Interface CPU Search Request Word 10 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w10
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w10_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w10 bdk_tns_se_ldei_cpu_srch_req_w10_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109060ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W10", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 bdk_tns_se_ldei_cpu_srch_req_w10_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 "TNS_SE_LDEI_CPU_SRCH_REQ_W10"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w11
 *
 * TNS Search LDE Interface CPU Search Request Word 11 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w11
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w11_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w11 bdk_tns_se_ldei_cpu_srch_req_w11_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109064ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W11", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 bdk_tns_se_ldei_cpu_srch_req_w11_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 "TNS_SE_LDEI_CPU_SRCH_REQ_W11"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w12
 *
 * TNS Search LDE Interface CPU Search Request Word 12 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w12
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_17_31        : 15;
        uint32_t vld                   : 1;  /**< [ 16: 16](R/W) Rising edge of vld initiates a cpu seach request */
        uint32_t profile_id            : 6;  /**< [ 15: 10](R/W) each profile contains upto 4 search commands. */
        uint32_t key                   : 10; /**< [  9:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 10; /**< [  9:  0](R/W) Continuation of MSBs of field KEY from previous word. */
        uint32_t profile_id            : 6;  /**< [ 15: 10](R/W) each profile contains upto 4 search commands. */
        uint32_t vld                   : 1;  /**< [ 16: 16](R/W) Rising edge of vld initiates a cpu seach request */
        uint32_t reserved_17_31        : 15;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w12_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w12 bdk_tns_se_ldei_cpu_srch_req_w12_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109068ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W12", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 bdk_tns_se_ldei_cpu_srch_req_w12_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 "TNS_SE_LDEI_CPU_SRCH_REQ_W12"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w2
 *
 * TNS Search LDE Interface CPU Search Request Word 2 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w2
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w2_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w2 bdk_tns_se_ldei_cpu_srch_req_w2_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109040ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 bdk_tns_se_ldei_cpu_srch_req_w2_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 "TNS_SE_LDEI_CPU_SRCH_REQ_W2"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w3
 *
 * TNS Search LDE Interface CPU Search Request Word 3 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w3
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w3_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w3 bdk_tns_se_ldei_cpu_srch_req_w3_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109044ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 bdk_tns_se_ldei_cpu_srch_req_w3_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 "TNS_SE_LDEI_CPU_SRCH_REQ_W3"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w4
 *
 * TNS Search LDE Interface CPU Search Request Word 4 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w4
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w4_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w4 bdk_tns_se_ldei_cpu_srch_req_w4_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109048ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 bdk_tns_se_ldei_cpu_srch_req_w4_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 "TNS_SE_LDEI_CPU_SRCH_REQ_W4"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w5
 *
 * TNS Search LDE Interface CPU Search Request Word 5 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w5
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w5_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w5 bdk_tns_se_ldei_cpu_srch_req_w5_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205610904cll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W5", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 bdk_tns_se_ldei_cpu_srch_req_w5_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 "TNS_SE_LDEI_CPU_SRCH_REQ_W5"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w6
 *
 * TNS Search LDE Interface CPU Search Request Word 6 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w6
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w6_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w6 bdk_tns_se_ldei_cpu_srch_req_w6_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109050ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W6", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 bdk_tns_se_ldei_cpu_srch_req_w6_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 "TNS_SE_LDEI_CPU_SRCH_REQ_W6"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w7
 *
 * TNS Search LDE Interface CPU Search Request Word 7 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w7
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w7_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w7 bdk_tns_se_ldei_cpu_srch_req_w7_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109054ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W7", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 bdk_tns_se_ldei_cpu_srch_req_w7_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 "TNS_SE_LDEI_CPU_SRCH_REQ_W7"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w8
 *
 * TNS Search LDE Interface CPU Search Request Word 8 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w8
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w8_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w8 bdk_tns_se_ldei_cpu_srch_req_w8_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109058ll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W8", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 bdk_tns_se_ldei_cpu_srch_req_w8_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 "TNS_SE_LDEI_CPU_SRCH_REQ_W8"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_cpu_srch_req_w9
 *
 * TNS Search LDE Interface CPU Search Request Word 9 Register
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 */
union bdk_tns_se_ldei_cpu_srch_req_w9
{
    uint32_t u;
    struct bdk_tns_se_ldei_cpu_srch_req_w9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_cpu_srch_req_w9_s cn; */
};
typedef union bdk_tns_se_ldei_cpu_srch_req_w9 bdk_tns_se_ldei_cpu_srch_req_w9_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205610905cll;
    __bdk_csr_fatal("TNS_SE_LDEI_CPU_SRCH_REQ_W9", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 bdk_tns_se_ldei_cpu_srch_req_w9_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 "TNS_SE_LDEI_CPU_SRCH_REQ_W9"
#define device_bar_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_dbg_sel
 *
 * TNS Search LDE Interface Debug Selector Register
 * --
 */
union bdk_tns_se_ldei_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_ldei_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t ldeif_dbg_sel         : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else /* Word 0 - Little Endian */
        uint32_t ldeif_dbg_sel         : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_dbg_sel_s cn; */
};
typedef union bdk_tns_se_ldei_dbg_sel bdk_tns_se_ldei_dbg_sel_t;

#define BDK_TNS_SE_LDEI_DBG_SEL BDK_TNS_SE_LDEI_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109004ll;
    __bdk_csr_fatal("TNS_SE_LDEI_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_DBG_SEL bdk_tns_se_ldei_dbg_sel_t
#define bustype_BDK_TNS_SE_LDEI_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_DBG_SEL "TNS_SE_LDEI_DBG_SEL"
#define device_bar_BDK_TNS_SE_LDEI_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_DBG_SEL 0
#define arguments_BDK_TNS_SE_LDEI_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_hash_buf#
 *
 * TNS Search LDE Interface Hash Buffer Registers
 * SE start popping sorry fore regurettable commands once fill level of buffer
 * before
 * an engine excceds thd. There are 16 hash engines, the 4 engines
 * corresponding to
 * cmd_0 are engine 0-3, those 4 for cmd_1 are 4-7, etc.
 */
union bdk_tns_se_ldei_hash_bufx
{
    uint32_t u;
    struct bdk_tns_se_ldei_hash_bufx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t read_ptr              : 4;  /**< [  7:  4](R/W) -- */
        uint32_t sorry_thd             : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sorry_thd             : 4;  /**< [  3:  0](R/W) -- */
        uint32_t read_ptr              : 4;  /**< [  7:  4](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_hash_bufx_s cn; */
};
typedef union bdk_tns_se_ldei_hash_bufx bdk_tns_se_ldei_hash_bufx_t;

static inline uint64_t BDK_TNS_SE_LDEI_HASH_BUFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_HASH_BUFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x842056109008ll + 4ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SE_LDEI_HASH_BUFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_HASH_BUFX(a) bdk_tns_se_ldei_hash_bufx_t
#define bustype_BDK_TNS_SE_LDEI_HASH_BUFX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_HASH_BUFX(a) "TNS_SE_LDEI_HASH_BUFX"
#define device_bar_BDK_TNS_SE_LDEI_HASH_BUFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_HASH_BUFX(a) (a)
#define arguments_BDK_TNS_SE_LDEI_HASH_BUFX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_ldeif_dbg
 *
 * TNS Search LDE Interface LDE Interface Debug Register
 * --
 */
union bdk_tns_se_ldei_ldeif_dbg
{
    uint32_t u;
    struct bdk_tns_se_ldei_ldeif_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t intf_bypass           : 9;  /**< [ 25: 17](R/W) if set, the corresponding interface immediately return miss for all commands */
        uint32_t intf_disable          : 9;  /**< [ 16:  8](R/W) if set, the corresponding interface desert req_fc_n and rejecting all future
                                                                 requests */
        uint32_t req_log               : 4;  /**< [  7:  4](R/W) Status register to log last search reuqest from that interface
                                                                 0-11 for LDE 0-11 */
        uint32_t rslt_log              : 4;  /**< [  3:  0](R/W) Status register to log last returned search result from that interface
                                                                 Status can be read from register xp_se_lde_cpu_search_rslt_lane if
                                                                 xp_se_lde_cpu_search_req.vld field s not set */
#else /* Word 0 - Little Endian */
        uint32_t rslt_log              : 4;  /**< [  3:  0](R/W) Status register to log last returned search result from that interface
                                                                 Status can be read from register xp_se_lde_cpu_search_rslt_lane if
                                                                 xp_se_lde_cpu_search_req.vld field s not set */
        uint32_t req_log               : 4;  /**< [  7:  4](R/W) Status register to log last search reuqest from that interface
                                                                 0-11 for LDE 0-11 */
        uint32_t intf_disable          : 9;  /**< [ 16:  8](R/W) if set, the corresponding interface desert req_fc_n and rejecting all future
                                                                 requests */
        uint32_t intf_bypass           : 9;  /**< [ 25: 17](R/W) if set, the corresponding interface immediately return miss for all commands */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_ldeif_dbg_s cn; */
};
typedef union bdk_tns_se_ldei_ldeif_dbg bdk_tns_se_ldei_ldeif_dbg_t;

#define BDK_TNS_SE_LDEI_LDEIF_DBG BDK_TNS_SE_LDEI_LDEIF_DBG_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_LDEIF_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_LDEIF_DBG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109000ll;
    __bdk_csr_fatal("TNS_SE_LDEI_LDEIF_DBG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_LDEIF_DBG bdk_tns_se_ldei_ldeif_dbg_t
#define bustype_BDK_TNS_SE_LDEI_LDEIF_DBG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_LDEIF_DBG "TNS_SE_LDEI_LDEIF_DBG"
#define device_bar_BDK_TNS_SE_LDEI_LDEIF_DBG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_LDEIF_DBG 0
#define arguments_BDK_TNS_SE_LDEI_LDEIF_DBG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_lock
 *
 * TNS Search LDE Interface Lock Register
 * Lock Register
 */
union bdk_tns_se_ldei_lock
{
    uint32_t u;
    struct bdk_tns_se_ldei_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_lock_s cn; */
};
typedef union bdk_tns_se_ldei_lock bdk_tns_se_ldei_lock_t;

#define BDK_TNS_SE_LDEI_LOCK BDK_TNS_SE_LDEI_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109100ll;
    __bdk_csr_fatal("TNS_SE_LDEI_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_LOCK bdk_tns_se_ldei_lock_t
#define bustype_BDK_TNS_SE_LDEI_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_LOCK "TNS_SE_LDEI_LOCK"
#define device_bar_BDK_TNS_SE_LDEI_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_LOCK 0
#define arguments_BDK_TNS_SE_LDEI_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_spad
 *
 * TNS Search LDE Interface ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_ldei_spad
{
    uint32_t u;
    struct bdk_tns_se_ldei_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_spad_s cn; */
};
typedef union bdk_tns_se_ldei_spad bdk_tns_se_ldei_spad_t;

#define BDK_TNS_SE_LDEI_SPAD BDK_TNS_SE_LDEI_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109104ll;
    __bdk_csr_fatal("TNS_SE_LDEI_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_SPAD bdk_tns_se_ldei_spad_t
#define bustype_BDK_TNS_SE_LDEI_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_SPAD "TNS_SE_LDEI_SPAD"
#define device_bar_BDK_TNS_SE_LDEI_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_SPAD 0
#define arguments_BDK_TNS_SE_LDEI_SPAD -1,-1,-1,-1

/**
 * Register (NCB) tns_se_ldei_sta_hash_buf#
 *
 * TNS Search LDE Interface Status Hash Buffer Registers
 * --
 */
union bdk_tns_se_ldei_sta_hash_bufx
{
    uint64_t u;
    struct bdk_tns_se_ldei_sta_hash_bufx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_37_63        : 27;
        uint64_t intf_id               : 6;  /**< [ 36: 31](RO/H) -- */
        uint64_t req_id                : 6;  /**< [ 30: 25](RO/H) -- */
        uint64_t cmd_id                : 2;  /**< [ 24: 23](RO/H) -- */
        uint64_t rslt_qw_start         : 5;  /**< [ 22: 18](RO/H) -- */
        uint64_t rslt_qw_inc           : 4;  /**< [ 17: 14](RO/H) -- */
        uint64_t table_id              : 8;  /**< [ 13:  6](RO/H) -- */
        uint64_t age_en                : 1;  /**< [  5:  5](RO/H) -- */
        uint64_t regrettable           : 1;  /**< [  4:  4](RO/H) -- */
        uint64_t usage                 : 4;  /**< [  3:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t usage                 : 4;  /**< [  3:  0](RO/H) -- */
        uint64_t regrettable           : 1;  /**< [  4:  4](RO/H) -- */
        uint64_t age_en                : 1;  /**< [  5:  5](RO/H) -- */
        uint64_t table_id              : 8;  /**< [ 13:  6](RO/H) -- */
        uint64_t rslt_qw_inc           : 4;  /**< [ 17: 14](RO/H) -- */
        uint64_t rslt_qw_start         : 5;  /**< [ 22: 18](RO/H) -- */
        uint64_t cmd_id                : 2;  /**< [ 24: 23](RO/H) -- */
        uint64_t req_id                : 6;  /**< [ 30: 25](RO/H) -- */
        uint64_t intf_id               : 6;  /**< [ 36: 31](RO/H) -- */
        uint64_t reserved_37_63        : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_hash_bufx_s cn; */
};
typedef union bdk_tns_se_ldei_sta_hash_bufx bdk_tns_se_ldei_sta_hash_bufx_t;

static inline uint64_t BDK_TNS_SE_LDEI_STA_HASH_BUFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_HASH_BUFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x842056109018ll + 8ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_SE_LDEI_STA_HASH_BUFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_HASH_BUFX(a) bdk_tns_se_ldei_sta_hash_bufx_t
#define bustype_BDK_TNS_SE_LDEI_STA_HASH_BUFX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_LDEI_STA_HASH_BUFX(a) "TNS_SE_LDEI_STA_HASH_BUFX"
#define device_bar_BDK_TNS_SE_LDEI_STA_HASH_BUFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_HASH_BUFX(a) (a)
#define arguments_BDK_TNS_SE_LDEI_STA_HASH_BUFX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w0
 *
 * TNS Search LDE Interface Status Request Debug Word 0 Register
 * --
 */
union bdk_tns_se_ldei_sta_req_dbg_w0
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 7;  /**< [ 31: 25](RO/H) -- */
        uint32_t req_id                : 6;  /**< [ 24: 19](RO/H) -- */
        uint32_t unused_tmp            : 19; /**< [ 18:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t unused_tmp            : 19; /**< [ 18:  0](RO/H) -- */
        uint32_t req_id                : 6;  /**< [ 24: 19](RO/H) -- */
        uint32_t key                   : 7;  /**< [ 31: 25](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w0_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w0 bdk_tns_se_ldei_sta_req_dbg_w0_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 BDK_TNS_SE_LDEI_STA_REQ_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090ccll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 bdk_tns_se_ldei_sta_req_dbg_w0_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 "TNS_SE_LDEI_STA_REQ_DBG_W0"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w1
 *
 * TNS Search LDE Interface Status Request Debug Word 1 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w1
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w1_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w1 bdk_tns_se_ldei_sta_req_dbg_w1_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 BDK_TNS_SE_LDEI_STA_REQ_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090d0ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 bdk_tns_se_ldei_sta_req_dbg_w1_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 "TNS_SE_LDEI_STA_REQ_DBG_W1"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w10
 *
 * TNS Search LDE Interface Status Request Debug Word 10 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w10
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w10_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w10 bdk_tns_se_ldei_sta_req_dbg_w10_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 BDK_TNS_SE_LDEI_STA_REQ_DBG_W10_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W10_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W10_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090f4ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W10", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 bdk_tns_se_ldei_sta_req_dbg_w10_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 "TNS_SE_LDEI_STA_REQ_DBG_W10"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w11
 *
 * TNS Search LDE Interface Status Request Debug Word 11 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w11
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w11_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w11 bdk_tns_se_ldei_sta_req_dbg_w11_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 BDK_TNS_SE_LDEI_STA_REQ_DBG_W11_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W11_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W11_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090f8ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W11", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 bdk_tns_se_ldei_sta_req_dbg_w11_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 "TNS_SE_LDEI_STA_REQ_DBG_W11"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w12
 *
 * TNS Search LDE Interface Status Request Debug Word 12 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w12
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t profile_id            : 7;  /**< [ 31: 25](RO/H) -- */
        uint32_t key                   : 25; /**< [ 24:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 25; /**< [ 24:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
        uint32_t profile_id            : 7;  /**< [ 31: 25](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w12_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w12 bdk_tns_se_ldei_sta_req_dbg_w12_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 BDK_TNS_SE_LDEI_STA_REQ_DBG_W12_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W12_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W12_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090fcll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W12", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 bdk_tns_se_ldei_sta_req_dbg_w12_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 "TNS_SE_LDEI_STA_REQ_DBG_W12"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w2
 *
 * TNS Search LDE Interface Status Request Debug Word 2 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w2
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w2_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w2 bdk_tns_se_ldei_sta_req_dbg_w2_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 BDK_TNS_SE_LDEI_STA_REQ_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090d4ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 bdk_tns_se_ldei_sta_req_dbg_w2_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 "TNS_SE_LDEI_STA_REQ_DBG_W2"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w3
 *
 * TNS Search LDE Interface Status Request Debug Word 3 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w3
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w3_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w3 bdk_tns_se_ldei_sta_req_dbg_w3_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 BDK_TNS_SE_LDEI_STA_REQ_DBG_W3_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090d8ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 bdk_tns_se_ldei_sta_req_dbg_w3_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 "TNS_SE_LDEI_STA_REQ_DBG_W3"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w4
 *
 * TNS Search LDE Interface Status Request Debug Word 4 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w4
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w4_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w4 bdk_tns_se_ldei_sta_req_dbg_w4_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 BDK_TNS_SE_LDEI_STA_REQ_DBG_W4_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090dcll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 bdk_tns_se_ldei_sta_req_dbg_w4_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 "TNS_SE_LDEI_STA_REQ_DBG_W4"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w5
 *
 * TNS Search LDE Interface Status Request Debug Word 5 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w5
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w5_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w5 bdk_tns_se_ldei_sta_req_dbg_w5_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 BDK_TNS_SE_LDEI_STA_REQ_DBG_W5_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W5_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090e0ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W5", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 bdk_tns_se_ldei_sta_req_dbg_w5_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 "TNS_SE_LDEI_STA_REQ_DBG_W5"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w6
 *
 * TNS Search LDE Interface Status Request Debug Word 6 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w6
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w6_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w6 bdk_tns_se_ldei_sta_req_dbg_w6_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 BDK_TNS_SE_LDEI_STA_REQ_DBG_W6_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W6_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090e4ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W6", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 bdk_tns_se_ldei_sta_req_dbg_w6_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 "TNS_SE_LDEI_STA_REQ_DBG_W6"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w7
 *
 * TNS Search LDE Interface Status Request Debug Word 7 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w7
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w7_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w7 bdk_tns_se_ldei_sta_req_dbg_w7_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 BDK_TNS_SE_LDEI_STA_REQ_DBG_W7_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W7_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090e8ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W7", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 bdk_tns_se_ldei_sta_req_dbg_w7_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 "TNS_SE_LDEI_STA_REQ_DBG_W7"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w8
 *
 * TNS Search LDE Interface Status Request Debug Word 8 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w8
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w8_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w8 bdk_tns_se_ldei_sta_req_dbg_w8_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 BDK_TNS_SE_LDEI_STA_REQ_DBG_W8_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W8_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W8_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090ecll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W8", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 bdk_tns_se_ldei_sta_req_dbg_w8_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 "TNS_SE_LDEI_STA_REQ_DBG_W8"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_ldei_sta_req_dbg_w9
 *
 * TNS Search LDE Interface Status Request Debug Word 9 Register
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 */
union bdk_tns_se_ldei_sta_req_dbg_w9
{
    uint32_t u;
    struct bdk_tns_se_ldei_sta_req_dbg_w9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_ldei_sta_req_dbg_w9_s cn; */
};
typedef union bdk_tns_se_ldei_sta_req_dbg_w9 bdk_tns_se_ldei_sta_req_dbg_w9_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 BDK_TNS_SE_LDEI_STA_REQ_DBG_W9_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W9_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W9_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561090f0ll;
    __bdk_csr_fatal("TNS_SE_LDEI_STA_REQ_DBG_W9", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 bdk_tns_se_ldei_sta_req_dbg_w9_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 "TNS_SE_LDEI_STA_REQ_DBG_W9"
#define device_bar_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_lock
 *
 * TNS Search LPM Lock Register
 * Lock Register
 */
union bdk_tns_se_lpm_lock
{
    uint32_t u;
    struct bdk_tns_se_lpm_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_lock_s cn; */
};
typedef union bdk_tns_se_lpm_lock bdk_tns_se_lpm_lock_t;

#define BDK_TNS_SE_LPM_LOCK BDK_TNS_SE_LPM_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_LPM_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561070e4ll;
    __bdk_csr_fatal("TNS_SE_LPM_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_LOCK bdk_tns_se_lpm_lock_t
#define bustype_BDK_TNS_SE_LPM_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_LOCK "TNS_SE_LPM_LOCK"
#define device_bar_BDK_TNS_SE_LPM_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_LOCK 0
#define arguments_BDK_TNS_SE_LPM_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_lpm_dbg_sel
 *
 * TNS Search LPM LPM Debug Selector Register
 * --
 */
union bdk_tns_se_lpm_lpm_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_lpm_lpm_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lpm_dbg_sel           : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else /* Word 0 - Little Endian */
        uint32_t lpm_dbg_sel           : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_lpm_dbg_sel_s cn; */
};
typedef union bdk_tns_se_lpm_lpm_dbg_sel bdk_tns_se_lpm_lpm_dbg_sel_t;

#define BDK_TNS_SE_LPM_LPM_DBG_SEL BDK_TNS_SE_LPM_LPM_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_LPM_LPM_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_LPM_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561070e0ll;
    __bdk_csr_fatal("TNS_SE_LPM_LPM_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_LPM_DBG_SEL bdk_tns_se_lpm_lpm_dbg_sel_t
#define bustype_BDK_TNS_SE_LPM_LPM_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_LPM_DBG_SEL "TNS_SE_LPM_LPM_DBG_SEL"
#define device_bar_BDK_TNS_SE_LPM_LPM_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_LPM_DBG_SEL 0
#define arguments_BDK_TNS_SE_LPM_LPM_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_spad
 *
 * TNS Search LPM ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_lpm_spad
{
    uint32_t u;
    struct bdk_tns_se_lpm_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_spad_s cn; */
};
typedef union bdk_tns_se_lpm_spad bdk_tns_se_lpm_spad_t;

#define BDK_TNS_SE_LPM_SPAD BDK_TNS_SE_LPM_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_LPM_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420561070e8ll;
    __bdk_csr_fatal("TNS_SE_LPM_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_SPAD bdk_tns_se_lpm_spad_t
#define bustype_BDK_TNS_SE_LPM_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_SPAD "TNS_SE_LPM_SPAD"
#define device_bar_BDK_TNS_SE_LPM_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_SPAD 0
#define arguments_BDK_TNS_SE_LPM_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_lpm#
 *
 * TNS Search LPM Table LPM Registers
 * One LPM table can host a mixture of IPv4 (48-bit key) and IPv6 (144-bit key)
 * addresses.
 * 64-bit keys are also supported.
 */
union bdk_tns_se_lpm_tbl_lpmx
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_lpmx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t prefix_bmp            : 32; /**< [ 31:  0](R/W) Which prefix table to use, prefix table 0..31 always resides in pool 0 (only 1
                                                                 pool), */
#else /* Word 0 - Little Endian */
        uint32_t prefix_bmp            : 32; /**< [ 31:  0](R/W) Which prefix table to use, prefix table 0..31 always resides in pool 0 (only 1
                                                                 pool), */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_lpmx_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_lpmx bdk_tns_se_lpm_tbl_lpmx_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_LPMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_LPMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107000ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_LPMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_LPMX(a) bdk_tns_se_lpm_tbl_lpmx_t
#define bustype_BDK_TNS_SE_LPM_TBL_LPMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_LPMX(a) "TNS_SE_LPM_TBL_LPMX"
#define device_bar_BDK_TNS_SE_LPM_TBL_LPMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_LPMX(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_LPMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_nh#_w0
 *
 * TNS Search LPM Table NH Word 0 Registers
 * NH table i is associated with LPM table i.
 */
union bdk_tns_se_lpm_tbl_nhx_w0
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_nhx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_blk_start_2       : 1;  /**< [ 31: 31](R/W) -- */
        uint32_t row_blk_start_3       : 6;  /**< [ 30: 25](R/W) -- */
        uint32_t row_blk_start_4       : 6;  /**< [ 24: 19](R/W) -- */
        uint32_t row_blk_start_5       : 6;  /**< [ 18: 13](R/W) -- */
        uint32_t row_blk_start_6       : 6;  /**< [ 12:  7](R/W) -- */
        uint32_t row_blk_start_7       : 6;  /**< [  6:  1](R/W) -- */
        uint32_t return_nh_addr        : 1;  /**< [  0:  0](R/W) If set, use NH_addr as hit_addr return
                                                                 Otherwise, use NHI_addr as hit_addr return */
#else /* Word 0 - Little Endian */
        uint32_t return_nh_addr        : 1;  /**< [  0:  0](R/W) If set, use NH_addr as hit_addr return
                                                                 Otherwise, use NHI_addr as hit_addr return */
        uint32_t row_blk_start_7       : 6;  /**< [  6:  1](R/W) -- */
        uint32_t row_blk_start_6       : 6;  /**< [ 12:  7](R/W) -- */
        uint32_t row_blk_start_5       : 6;  /**< [ 18: 13](R/W) -- */
        uint32_t row_blk_start_4       : 6;  /**< [ 24: 19](R/W) -- */
        uint32_t row_blk_start_3       : 6;  /**< [ 30: 25](R/W) -- */
        uint32_t row_blk_start_2       : 1;  /**< [ 31: 31](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_nhx_w0_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_nhx_w0 bdk_tns_se_lpm_tbl_nhx_w0_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107080ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_NHX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_NHX_W0(a) bdk_tns_se_lpm_tbl_nhx_w0_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_NHX_W0(a) "TNS_SE_LPM_TBL_NHX_W0"
#define device_bar_BDK_TNS_SE_LPM_TBL_NHX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_NHX_W0(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_NHX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_nh#_w1
 *
 * TNS Search LPM Table NH Word 1 Registers
 * Continuation of structure defined in TNS_SE_LPM_TBL_NH(0..7)_W0
 */
union bdk_tns_se_lpm_tbl_nhx_w1
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_nhx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data_size             : 1;  /**< [ 31: 31](R/W) in unit of 32-bit double word. */
        uint32_t pool_bmp              : 8;  /**< [ 30: 23](R/W) NH table spreads across multiple SRAM pools */
        uint32_t row_blk_inc           : 6;  /**< [ 22: 17](R/W) The entire NHI table can be equally divided among multiple pools.
                                                                 row_blk_inc can only be 2**i-1, i.e 0, 1, 3, 7, 15, 31, 63, */
        uint32_t row_blk_start_0       : 6;  /**< [ 16: 11](R/W) Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
        uint32_t row_blk_start_1       : 6;  /**< [ 10:  5](R/W) -- */
        uint32_t row_blk_start_2       : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field ROW_BLK_START_2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start_2       : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field ROW_BLK_START_2 from previous word. */
        uint32_t row_blk_start_1       : 6;  /**< [ 10:  5](R/W) -- */
        uint32_t row_blk_start_0       : 6;  /**< [ 16: 11](R/W) Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
        uint32_t row_blk_inc           : 6;  /**< [ 22: 17](R/W) The entire NHI table can be equally divided among multiple pools.
                                                                 row_blk_inc can only be 2**i-1, i.e 0, 1, 3, 7, 15, 31, 63, */
        uint32_t pool_bmp              : 8;  /**< [ 30: 23](R/W) NH table spreads across multiple SRAM pools */
        uint32_t data_size             : 1;  /**< [ 31: 31](R/W) in unit of 32-bit double word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_nhx_w1_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_nhx_w1 bdk_tns_se_lpm_tbl_nhx_w1_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107084ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_NHX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_NHX_W1(a) bdk_tns_se_lpm_tbl_nhx_w1_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_NHX_W1(a) "TNS_SE_LPM_TBL_NHX_W1"
#define device_bar_BDK_TNS_SE_LPM_TBL_NHX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_NHX_W1(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_NHX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_nh#_w2
 *
 * TNS Search LPM Table NH Word 2 Registers
 * Continuation of structure defined in TNS_SE_LPM_TBL_NH(0..7)_W0
 */
union bdk_tns_se_lpm_tbl_nhx_w2
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_nhx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data_size             : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field DATA_SIZE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data_size             : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field DATA_SIZE from previous word. */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_nhx_w2_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_nhx_w2 bdk_tns_se_lpm_tbl_nhx_w2_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107088ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_NHX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_NHX_W2(a) bdk_tns_se_lpm_tbl_nhx_w2_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_NHX_W2(a) "TNS_SE_LPM_TBL_NHX_W2"
#define device_bar_BDK_TNS_SE_LPM_TBL_NHX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_NHX_W2(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_NHX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_nhi#_w0
 *
 * TNS Search LPM Table NHI Table Word 0 Registers
 * NHI table i is associated with LPM table i, nhi table is alwasy 128-bit wide
 */
union bdk_tns_se_lpm_tbl_nhix_w0
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_nhix_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_blk_start_2       : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t row_blk_start_3       : 6;  /**< [ 29: 24](R/W) -- */
        uint32_t row_blk_start_4       : 6;  /**< [ 23: 18](R/W) -- */
        uint32_t row_blk_start_5       : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t row_blk_start_6       : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t row_blk_start_7       : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start_7       : 6;  /**< [  5:  0](R/W) -- */
        uint32_t row_blk_start_6       : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t row_blk_start_5       : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t row_blk_start_4       : 6;  /**< [ 23: 18](R/W) -- */
        uint32_t row_blk_start_3       : 6;  /**< [ 29: 24](R/W) -- */
        uint32_t row_blk_start_2       : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_nhix_w0_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_nhix_w0 bdk_tns_se_lpm_tbl_nhix_w0_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107020ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_NHIX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_NHIX_W0(a) bdk_tns_se_lpm_tbl_nhix_w0_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHIX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_NHIX_W0(a) "TNS_SE_LPM_TBL_NHIX_W0"
#define device_bar_BDK_TNS_SE_LPM_TBL_NHIX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_NHIX_W0(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_NHIX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_nhi#_w1
 *
 * TNS Search LPM Table NHI Table Word 1 Registers
 * Continuation of structure defined in TNS_SE_LPM_TBL_NHI(0..7)_W0
 */
union bdk_tns_se_lpm_tbl_nhix_w1
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_nhix_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t nhi_size              : 2;  /**< [ 31: 30](R/W) Width of NH_blk_base, allowable: 10, 12, 14, 16, 18, 20 */
        uint32_t pool_bmp              : 8;  /**< [ 29: 22](R/W) NHI table spreads across multiple SRAM pools */
        uint32_t row_blk_inc           : 6;  /**< [ 21: 16](R/W) The entire NHI table can be equally divided among multiple pools, each pool
                                                                 with number
                                                                 of row blocks begin power of 2, i.e.  row_blk_inc can only be 0, 1,
                                                                 3, 7, 15, 31, 63. */
        uint32_t row_blk_start_0       : 6;  /**< [ 15: 10](R/W) row_blk_start point for SRAM pool 0 */
        uint32_t row_blk_start_1       : 6;  /**< [  9:  4](R/W) -- */
        uint32_t row_blk_start_2       : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field ROW_BLK_START_2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start_2       : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field ROW_BLK_START_2 from previous word. */
        uint32_t row_blk_start_1       : 6;  /**< [  9:  4](R/W) -- */
        uint32_t row_blk_start_0       : 6;  /**< [ 15: 10](R/W) row_blk_start point for SRAM pool 0 */
        uint32_t row_blk_inc           : 6;  /**< [ 21: 16](R/W) The entire NHI table can be equally divided among multiple pools, each pool
                                                                 with number
                                                                 of row blocks begin power of 2, i.e.  row_blk_inc can only be 0, 1,
                                                                 3, 7, 15, 31, 63. */
        uint32_t pool_bmp              : 8;  /**< [ 29: 22](R/W) NHI table spreads across multiple SRAM pools */
        uint32_t nhi_size              : 2;  /**< [ 31: 30](R/W) Width of NH_blk_base, allowable: 10, 12, 14, 16, 18, 20 */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_nhix_w1_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_nhix_w1 bdk_tns_se_lpm_tbl_nhix_w1_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107024ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_NHIX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_NHIX_W1(a) bdk_tns_se_lpm_tbl_nhix_w1_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHIX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_NHIX_W1(a) "TNS_SE_LPM_TBL_NHIX_W1"
#define device_bar_BDK_TNS_SE_LPM_TBL_NHIX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_NHIX_W1(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_NHIX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_lpm_tbl_nhi#_w2
 *
 * TNS Search LPM Table NHI Table Word 2 Registers
 * Continuation of structure defined in TNS_SE_LPM_TBL_NHI(0..7)_W0
 */
union bdk_tns_se_lpm_tbl_nhix_w2
{
    uint32_t u;
    struct bdk_tns_se_lpm_tbl_nhix_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t pair_per_entry        : 4;  /**< [  6:  3](R/W) A NHI table is always 128-bit wide, each entry contains multple pairs of
                                                                 {NH_blk_size,NH_blk_base}
                                                                 allowed value: 10, 8, 7, 6, correspondingly, a NHI pair is 12-bit,
                                                                 16-bit, 18-bit or 21-bit
                                                                 maximum allowed path for ECMP is 512, i.e. only 8 LSB of
                                                                 NH_blk_size is valid. */
        uint32_t nhi_size              : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field NHI_SIZE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t nhi_size              : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field NHI_SIZE from previous word. */
        uint32_t pair_per_entry        : 4;  /**< [  6:  3](R/W) A NHI table is always 128-bit wide, each entry contains multple pairs of
                                                                 {NH_blk_size,NH_blk_base}
                                                                 allowed value: 10, 8, 7, 6, correspondingly, a NHI pair is 12-bit,
                                                                 16-bit, 18-bit or 21-bit
                                                                 maximum allowed path for ECMP is 512, i.e. only 8 LSB of
                                                                 NH_blk_size is valid. */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_lpm_tbl_nhix_w2_s cn; */
};
typedef union bdk_tns_se_lpm_tbl_nhix_w2 bdk_tns_se_lpm_tbl_nhix_w2_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056107028ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_LPM_TBL_NHIX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_LPM_TBL_NHIX_W2(a) bdk_tns_se_lpm_tbl_nhix_w2_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHIX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_LPM_TBL_NHIX_W2(a) "TNS_SE_LPM_TBL_NHIX_W2"
#define device_bar_BDK_TNS_SE_LPM_TBL_NHIX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_LPM_TBL_NHIX_W2(a) (a)
#define arguments_BDK_TNS_SE_LPM_TBL_NHIX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_prfx_lock
 *
 * TNS Search Prefix Lock Register
 * Lock Register
 */
union bdk_tns_se_prfx_lock
{
    uint32_t u;
    struct bdk_tns_se_prfx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_prfx_lock_s cn; */
};
typedef union bdk_tns_se_prfx_lock bdk_tns_se_prfx_lock_t;

#define BDK_TNS_SE_PRFX_LOCK BDK_TNS_SE_PRFX_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_PRFX_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_PRFX_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056108200ll;
    __bdk_csr_fatal("TNS_SE_PRFX_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_PRFX_LOCK bdk_tns_se_prfx_lock_t
#define bustype_BDK_TNS_SE_PRFX_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_PRFX_LOCK "TNS_SE_PRFX_LOCK"
#define device_bar_BDK_TNS_SE_PRFX_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_PRFX_LOCK 0
#define arguments_BDK_TNS_SE_PRFX_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_prfx_spad
 *
 * TNS Search Prefix ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_prfx_spad
{
    uint32_t u;
    struct bdk_tns_se_prfx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_prfx_spad_s cn; */
};
typedef union bdk_tns_se_prfx_spad bdk_tns_se_prfx_spad_t;

#define BDK_TNS_SE_PRFX_SPAD BDK_TNS_SE_PRFX_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_PRFX_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_PRFX_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056108204ll;
    __bdk_csr_fatal("TNS_SE_PRFX_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_PRFX_SPAD bdk_tns_se_prfx_spad_t
#define bustype_BDK_TNS_SE_PRFX_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_PRFX_SPAD "TNS_SE_PRFX_SPAD"
#define device_bar_BDK_TNS_SE_PRFX_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_PRFX_SPAD 0
#define arguments_BDK_TNS_SE_PRFX_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_prfx_tbl_prefix#
 *
 * TNS Search Prefix Table Prefix Registers
 * prefix table 32*i through 32*i+31 are associated with LPM table i.
 * Within the 32 prefix tables, all go to SRAM pool 0 (only one pool)
 */
union bdk_tns_se_prfx_tbl_prefixx
{
    uint32_t u;
    struct bdk_tns_se_prfx_tbl_prefixx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_23_31        : 9;
        uint32_t entry_size            : 4;  /**< [ 22: 19](R/W) 0x4: 128-bit
                                                                 0x8: 256-bit */
        uint32_t tread                 : 8;  /**< [ 18: 11](R/W) Number of MSB bits to hash from */
        uint32_t way_depth             : 3;  /**< [ 10:  8](R/W) prefix bucket depths is 2^(10+way_depth), up to 32K-entries,
                                                                 so way_depth is ceiled at 3'd5. */
        uint32_t hash_func             : 2;  /**< [  7:  6](R/W) Each prefix table has a different set of 4 hash functions,
                                                                 choose one of them as hash function of this prefix table. */
        uint32_t row_blk_start         : 6;  /**< [  5:  0](R/W) row_blk_start of prefix table. Each prefix table is either 128-bit or 256-bit
                                                                 wide */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start         : 6;  /**< [  5:  0](R/W) row_blk_start of prefix table. Each prefix table is either 128-bit or 256-bit
                                                                 wide */
        uint32_t hash_func             : 2;  /**< [  7:  6](R/W) Each prefix table has a different set of 4 hash functions,
                                                                 choose one of them as hash function of this prefix table. */
        uint32_t way_depth             : 3;  /**< [ 10:  8](R/W) prefix bucket depths is 2^(10+way_depth), up to 32K-entries,
                                                                 so way_depth is ceiled at 3'd5. */
        uint32_t tread                 : 8;  /**< [ 18: 11](R/W) Number of MSB bits to hash from */
        uint32_t entry_size            : 4;  /**< [ 22: 19](R/W) 0x4: 128-bit
                                                                 0x8: 256-bit */
        uint32_t reserved_23_31        : 9;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_prfx_tbl_prefixx_s cn; */
};
typedef union bdk_tns_se_prfx_tbl_prefixx bdk_tns_se_prfx_tbl_prefixx_t;

static inline uint64_t BDK_TNS_SE_PRFX_TBL_PREFIXX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_PRFX_TBL_PREFIXX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842056108000ll + 4ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_SE_PRFX_TBL_PREFIXX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_PRFX_TBL_PREFIXX(a) bdk_tns_se_prfx_tbl_prefixx_t
#define bustype_BDK_TNS_SE_PRFX_TBL_PREFIXX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_PRFX_TBL_PREFIXX(a) "TNS_SE_PRFX_TBL_PREFIXX"
#define device_bar_BDK_TNS_SE_PRFX_TBL_PREFIXX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_PRFX_TBL_PREFIXX(a) (a)
#define arguments_BDK_TNS_SE_PRFX_TBL_PREFIXX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_bist_stdn
 *
 * TNS Search Sram Pair Bist Status Done Registers
 * --
 */
union bdk_tns_se_sram_pairx_bist_stdn
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bist_status           : 4;  /**< [  7:  4](RO/H) -- */
        uint32_t bist_done             : 4;  /**< [  3:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t bist_done             : 4;  /**< [  3:  0](RO/H) -- */
        uint32_t bist_status           : 4;  /**< [  7:  4](RO/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_bist_stdn_s cn; */
};
typedef union bdk_tns_se_sram_pairx_bist_stdn bdk_tns_se_sram_pairx_bist_stdn_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x8420540200f8ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_BIST_STDN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(a) bdk_tns_se_sram_pairx_bist_stdn_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(a) "TNS_SE_SRAM_PAIRX_BIST_STDN"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_dbg_sel
 *
 * TNS Search Sram Pair Debug Selector Registers
 * Debug select
 */
union bdk_tns_se_sram_pairx_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t sram_pair_dbg_sel     : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sram_pair_dbg_sel     : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_dbg_sel_s cn; */
};
typedef union bdk_tns_se_sram_pairx_dbg_sel bdk_tns_se_sram_pairx_dbg_sel_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842054020054ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_DBG_SEL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(a) bdk_tns_se_sram_pairx_dbg_sel_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(a) "TNS_SE_SRAM_PAIRX_DBG_SEL"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_dhsh#_w0
 *
 * TNS Search Sram Pair Duo Hash Word 0 Registers
 * --
 */
union bdk_tns_se_sram_pairx_dhshx_w0
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_dhshx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hash_err_cmd_id_0     : 2;  /**< [ 31: 30](RO/H) -- */
        uint32_t hash_err_table_id_0   : 8;  /**< [ 29: 22](RO/H) -- */
        uint32_t hash_err_intf_id_1    : 6;  /**< [ 21: 16](RO/H) -- */
        uint32_t hash_err_req_id_1     : 6;  /**< [ 15: 10](RO/H) -- */
        uint32_t hash_err_cmd_id_1     : 2;  /**< [  9:  8](RO/H) -- */
        uint32_t hash_err_table_id_1   : 8;  /**< [  7:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hash_err_table_id_1   : 8;  /**< [  7:  0](RO/H) -- */
        uint32_t hash_err_cmd_id_1     : 2;  /**< [  9:  8](RO/H) -- */
        uint32_t hash_err_req_id_1     : 6;  /**< [ 15: 10](RO/H) -- */
        uint32_t hash_err_intf_id_1    : 6;  /**< [ 21: 16](RO/H) -- */
        uint32_t hash_err_table_id_0   : 8;  /**< [ 29: 22](RO/H) -- */
        uint32_t hash_err_cmd_id_0     : 2;  /**< [ 31: 30](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_dhshx_w0_s cn; */
};
typedef union bdk_tns_se_sram_pairx_dhshx_w0 bdk_tns_se_sram_pairx_dhshx_w0_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x842054020020ll + 0x400000ll * ((a) & 0x7) + 0xcll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_DHSHX_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(a,b) bdk_tns_se_sram_pairx_dhshx_w0_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(a,b) "TNS_SE_SRAM_PAIRX_DHSHX_W0"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_dhsh#_w1
 *
 * TNS Search Sram Pair Duo Hash Word 1 Registers
 * Continuation of structure defined in TNS_SE_SRAM_PAIR(0..7)_DHSH(0..1)_W0
 */
union bdk_tns_se_sram_pairx_dhshx_w1
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_dhshx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t hash_hang_intf_id     : 3;  /**< [ 31: 29](RO/H) -- */
        uint32_t hash_hang_req_id      : 6;  /**< [ 28: 23](RO/H) -- */
        uint32_t hash_hang_cmd_id      : 2;  /**< [ 22: 21](RO/H) -- */
        uint32_t hash_hang_table_id    : 8;  /**< [ 20: 13](RO/H) -- */
        uint32_t dual_tile_hash_err    : 1;  /**< [ 12: 12](RO/H) same as interrupt register definition, and it is sticky status as well */
        uint32_t hash_err_intf_id_0    : 6;  /**< [ 11:  6](RO/H) -- */
        uint32_t hash_err_req_id_0     : 6;  /**< [  5:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hash_err_req_id_0     : 6;  /**< [  5:  0](RO/H) -- */
        uint32_t hash_err_intf_id_0    : 6;  /**< [ 11:  6](RO/H) -- */
        uint32_t dual_tile_hash_err    : 1;  /**< [ 12: 12](RO/H) same as interrupt register definition, and it is sticky status as well */
        uint32_t hash_hang_table_id    : 8;  /**< [ 20: 13](RO/H) -- */
        uint32_t hash_hang_cmd_id      : 2;  /**< [ 22: 21](RO/H) -- */
        uint32_t hash_hang_req_id      : 6;  /**< [ 28: 23](RO/H) -- */
        uint32_t hash_hang_intf_id     : 3;  /**< [ 31: 29](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_dhshx_w1_s cn; */
};
typedef union bdk_tns_se_sram_pairx_dhshx_w1 bdk_tns_se_sram_pairx_dhshx_w1_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x842054020024ll + 0x400000ll * ((a) & 0x7) + 0xcll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_DHSHX_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(a,b) bdk_tns_se_sram_pairx_dhshx_w1_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(a,b) "TNS_SE_SRAM_PAIRX_DHSHX_W1"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_dhsh#_w2
 *
 * TNS Search Sram Pair Duo Hash Word 2 Registers
 * Continuation of structure defined in TNS_SE_SRAM_PAIR(0..7)_DHSH(0..1)_W0
 */
union bdk_tns_se_sram_pairx_dhshx_w2
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_dhshx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t dual_tile_hash_hang   : 2;  /**< [  4:  3](RO/H) same as interrupt register definition, just it is non-sticky status */
        uint32_t hash_hang_intf_id     : 3;  /**< [  2:  0](RO/H) Continuation of MSBs of field HASH_HANG_INTF_ID from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t hash_hang_intf_id     : 3;  /**< [  2:  0](RO/H) Continuation of MSBs of field HASH_HANG_INTF_ID from previous word. */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  4:  3](RO/H) same as interrupt register definition, just it is non-sticky status */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_dhshx_w2_s cn; */
};
typedef union bdk_tns_se_sram_pairx_dhshx_w2 bdk_tns_se_sram_pairx_dhshx_w2_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x842054020028ll + 0x400000ll * ((a) & 0x7) + 0xcll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_DHSHX_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(a,b) bdk_tns_se_sram_pairx_dhshx_w2_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(a,b) "TNS_SE_SRAM_PAIRX_DHSHX_W2"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_done
 *
 * TNS Search Sram Pair Done Registers
 * --
 */
union bdk_tns_se_sram_pairx_done
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_done_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t flush_done            : 1;  /**< [  4:  4](RO/H) -- */
        uint32_t tile_rst_done         : 2;  /**< [  3:  2](RO/H) -- */
        uint32_t mem_ready             : 2;  /**< [  1:  0](RO/H) memory ready, per tile */
#else /* Word 0 - Little Endian */
        uint32_t mem_ready             : 2;  /**< [  1:  0](RO/H) memory ready, per tile */
        uint32_t tile_rst_done         : 2;  /**< [  3:  2](RO/H) -- */
        uint32_t flush_done            : 1;  /**< [  4:  4](RO/H) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_done_s cn; */
};
typedef union bdk_tns_se_sram_pairx_done bdk_tns_se_sram_pairx_done_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DONE(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DONE(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842054020038ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_DONE", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_DONE(a) bdk_tns_se_sram_pairx_done_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DONE(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_DONE(a) "TNS_SE_SRAM_PAIRX_DONE"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_DONE(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DONE(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DONE(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_dyn_dbg_w#
 *
 * TNS Search Sram Pair DYN Debug Registers
 * No memoir memory in XPT. This register will return 0x0
 * Bits 31..8 of registers ending in _W2 are unused.
 */
union bdk_tns_se_sram_pairx_dyn_dbg_wx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_dyn_dbg_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_dyn_dbg_wx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_dyn_dbg_wx bdk_tns_se_sram_pairx_dyn_dbg_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=2)))
        return 0x84205402005cll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_DYN_DBG_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(a,b) bdk_tns_se_sram_pairx_dyn_dbg_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(a,b) "TNS_SE_SRAM_PAIRX_DYN_DBG_WX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_ecc_ctl#
 *
 * TNS Search Sram Pair ECC Control Registers
 * --
 */
union bdk_tns_se_sram_pairx_ecc_ctlx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_ecc_ctlx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t flip_db_ecc           : 2;  /**< [  4:  3](R/W) Flip 2 bits of ECC syndrome in SRAM memory pair tiles. It's built out of 2
                                                                 memory tiles of 138 bits wide */
        uint32_t flip_sb_ecc           : 2;  /**< [  2:  1](R/W) Flip 1 bit  of ECC syndrome in SRAM memory pair tiles. It's built out of 2
                                                                 memory tiles of 138 bits wide */
        uint32_t cor_dis               : 1;  /**< [  0:  0](R/W) Disable ECC correction for TCAM SRAM memory */
#else /* Word 0 - Little Endian */
        uint32_t cor_dis               : 1;  /**< [  0:  0](R/W) Disable ECC correction for TCAM SRAM memory */
        uint32_t flip_sb_ecc           : 2;  /**< [  2:  1](R/W) Flip 1 bit  of ECC syndrome in SRAM memory pair tiles. It's built out of 2
                                                                 memory tiles of 138 bits wide */
        uint32_t flip_db_ecc           : 2;  /**< [  4:  3](R/W) Flip 2 bits of ECC syndrome in SRAM memory pair tiles. It's built out of 2
                                                                 memory tiles of 138 bits wide */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_ecc_ctlx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_ecc_ctlx bdk_tns_se_sram_pairx_ecc_ctlx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x84205402004cll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_ECC_CTLX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(a,b) bdk_tns_se_sram_pairx_ecc_ctlx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(a,b) "TNS_SE_SRAM_PAIRX_ECC_CTLX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_ecc_err#
 *
 * TNS Search Sram Pair ECC Error Registers
 * These are read only
 * Address is sticky on first error.  Re-armed after reading (of 4 registers
 * 1 and 3 not used. 0 is for sram_tile0, 2 is sram_tile1)
 */
union bdk_tns_se_sram_pairx_ecc_errx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_ecc_errx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t sb_err                : 2;  /**< [ 18: 17](R/W/H) single-bit memory error (logical tile = 2 physical tiles) */
        uint32_t db_err                : 2;  /**< [ 16: 15](R/W/H) -- */
        uint32_t paddr                 : 15; /**< [ 14:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t paddr                 : 15; /**< [ 14:  0](R/W/H) -- */
        uint32_t db_err                : 2;  /**< [ 16: 15](R/W/H) -- */
        uint32_t sb_err                : 2;  /**< [ 18: 17](R/W/H) single-bit memory error (logical tile = 2 physical tiles) */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_ecc_errx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_ecc_errx bdk_tns_se_sram_pairx_ecc_errx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=3)))
        return 0x84205402003cll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x3);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_ECC_ERRX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(a,b) bdk_tns_se_sram_pairx_ecc_errx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(a,b) "TNS_SE_SRAM_PAIRX_ECC_ERRX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_flsh_mm_w#
 *
 * TNS Search Sram Pair Flush Match Mask Registers
 * --
 */
union bdk_tns_se_sram_pairx_flsh_mm_wx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_flsh_mm_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t val                   : 32; /**< [ 31:  0](R/W) if (entry & match_mask == match_pattern) then:
                                                                 entry = (entry & subst_mask) | (entry_pattern & ~subst_mask) */
#else /* Word 0 - Little Endian */
        uint32_t val                   : 32; /**< [ 31:  0](R/W) if (entry & match_mask == match_pattern) then:
                                                                 entry = (entry & subst_mask) | (entry_pattern & ~subst_mask) */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_flsh_mm_wx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_flsh_mm_wx bdk_tns_se_sram_pairx_flsh_mm_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=7)))
        return 0x842054020074ll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_FLSH_MM_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(a,b) bdk_tns_se_sram_pairx_flsh_mm_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(a,b) "TNS_SE_SRAM_PAIRX_FLSH_MM_WX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_flsh_mp_w#
 *
 * TNS Search Sram Pair Flush Match Pattern Registers
 * --
 */
union bdk_tns_se_sram_pairx_flsh_mp_wx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_flsh_mp_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t val                   : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t val                   : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_flsh_mp_wx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_flsh_mp_wx bdk_tns_se_sram_pairx_flsh_mp_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=7)))
        return 0x842054020094ll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_FLSH_MP_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(a,b) bdk_tns_se_sram_pairx_flsh_mp_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(a,b) "TNS_SE_SRAM_PAIRX_FLSH_MP_WX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_flsh_sm_w#
 *
 * TNS Search Sram Pair Flush SUBST Mask Registers
 * --
 */
union bdk_tns_se_sram_pairx_flsh_sm_wx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_flsh_sm_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t subst_mask            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t subst_mask            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_flsh_sm_wx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_flsh_sm_wx bdk_tns_se_sram_pairx_flsh_sm_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=7)))
        return 0x8420540200b4ll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_FLSH_SM_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(a,b) bdk_tns_se_sram_pairx_flsh_sm_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(a,b) "TNS_SE_SRAM_PAIRX_FLSH_SM_WX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_flsh_sp_w#
 *
 * TNS Search Sram Pair Flush SUBST Pattern Registers
 * --
 */
union bdk_tns_se_sram_pairx_flsh_sp_wx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_flsh_sp_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t subst_pattern         : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t subst_pattern         : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_flsh_sp_wx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_flsh_sp_wx bdk_tns_se_sram_pairx_flsh_sp_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=7)))
        return 0x8420540200d4ll + 0x400000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_FLSH_SP_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(a,b) bdk_tns_se_sram_pairx_flsh_sp_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(a,b) "TNS_SE_SRAM_PAIRX_FLSH_SP_WX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_flsh_w0
 *
 * TNS Search Sram Pair Flush Word 0 Registers
 * --
 */
union bdk_tns_se_sram_pairx_flsh_w0
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_flsh_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t prio                  : 1;  /**< [ 31: 31](R/W) If set, flush is higher priority than traffic */
        uint32_t start_tile_id         : 4;  /**< [ 30: 27](R/W) -- */
        uint32_t start_tile_addr       : 11; /**< [ 26: 16](R/W) -- */
        uint32_t end_tile_id           : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t end_tile_addr         : 11; /**< [ 11:  1](R/W) -- */
        uint32_t subst_tile_offset     : 1;  /**< [  0:  0](R/W) If not set, the same SRAM data is matched, substituted and written back, one
                                                                 example
                                                                 usage case is entry removal of hash table whose key and data
                                                                 are both 256-bit wide.
                                                                 If set, SRAM data from the even numbered tile is read first, if
                                                                 matching, then read
                                                                 data of the same address from the immediate next odd numbered
                                                                 tile, substitued
                                                                 and write back, the usage case is a control data substitution
                                                                 for a hash table
                                                                 where both data and key are 256-bit wide, upon key match, the
                                                                 control data should
                                                                 be replaced.  Furthermore, in this mode, hardware only search
                                                                 in even numbered
                                                                 tiles for matching data. */
#else /* Word 0 - Little Endian */
        uint32_t subst_tile_offset     : 1;  /**< [  0:  0](R/W) If not set, the same SRAM data is matched, substituted and written back, one
                                                                 example
                                                                 usage case is entry removal of hash table whose key and data
                                                                 are both 256-bit wide.
                                                                 If set, SRAM data from the even numbered tile is read first, if
                                                                 matching, then read
                                                                 data of the same address from the immediate next odd numbered
                                                                 tile, substitued
                                                                 and write back, the usage case is a control data substitution
                                                                 for a hash table
                                                                 where both data and key are 256-bit wide, upon key match, the
                                                                 control data should
                                                                 be replaced.  Furthermore, in this mode, hardware only search
                                                                 in even numbered
                                                                 tiles for matching data. */
        uint32_t end_tile_addr         : 11; /**< [ 11:  1](R/W) -- */
        uint32_t end_tile_id           : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t start_tile_addr       : 11; /**< [ 26: 16](R/W) -- */
        uint32_t start_tile_id         : 4;  /**< [ 30: 27](R/W) -- */
        uint32_t prio                  : 1;  /**< [ 31: 31](R/W) If set, flush is higher priority than traffic */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_flsh_w0_s cn; */
};
typedef union bdk_tns_se_sram_pairx_flsh_w0 bdk_tns_se_sram_pairx_flsh_w0_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205402006cll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_FLSH_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(a) bdk_tns_se_sram_pairx_flsh_w0_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(a) "TNS_SE_SRAM_PAIRX_FLSH_W0"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_flsh_w1
 *
 * TNS Search Sram Pair Flush Word 1 Registers
 * Continuation of structure defined in TNS_SE_SRAM_PAIR(0..7)_FLSH_W0
 */
union bdk_tns_se_sram_pairx_flsh_w1
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_flsh_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t en                    : 1;  /**< [  0:  0](R/W) Rising edge triggered. */
#else /* Word 0 - Little Endian */
        uint32_t en                    : 1;  /**< [  0:  0](R/W) Rising edge triggered. */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_flsh_w1_s cn; */
};
typedef union bdk_tns_se_sram_pairx_flsh_w1 bdk_tns_se_sram_pairx_flsh_w1_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842054020070ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_FLSH_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(a) bdk_tns_se_sram_pairx_flsh_w1_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(a) "TNS_SE_SRAM_PAIRX_FLSH_W1"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_inf_frc
 *
 * TNS Search Sram Pair Interface Force Registers
 * --
 */
union bdk_tns_se_sram_pairx_inf_frc
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_inf_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t rx_force_stop_b       : 2;  /**< [  7:  6](R/W) -- */
        uint32_t rx_force_stop_a       : 2;  /**< [  5:  4](R/W) -- */
        uint32_t tx_force_stop_b       : 2;  /**< [  3:  2](R/W) -- */
        uint32_t tx_force_stop_a       : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tx_force_stop_a       : 2;  /**< [  1:  0](R/W) -- */
        uint32_t tx_force_stop_b       : 2;  /**< [  3:  2](R/W) -- */
        uint32_t rx_force_stop_a       : 2;  /**< [  5:  4](R/W) -- */
        uint32_t rx_force_stop_b       : 2;  /**< [  7:  6](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_inf_frc_s cn; */
};
typedef union bdk_tns_se_sram_pairx_inf_frc bdk_tns_se_sram_pairx_inf_frc_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INF_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INF_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842054020068ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_INF_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(a) bdk_tns_se_sram_pairx_inf_frc_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(a) "TNS_SE_SRAM_PAIRX_INF_FRC"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_int_en_hi#
 *
 * TNS Search Sram Pair Interrrupt Enable High Registers
 * register 0 for port-A, 1 for port-B
 */
union bdk_tns_se_sram_pairx_int_en_hix
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_int_en_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](R/W) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](R/W) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](R/W) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](R/W) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t sb_err                : 2;  /**< [  3:  2](R/W) single-bit memory error (logical tile = two physical tiles) */
        uint32_t db_err                : 2;  /**< [  1:  0](R/W) single-bit memory error (logical tile = two physical tiles) */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 2;  /**< [  1:  0](R/W) single-bit memory error (logical tile = two physical tiles) */
        uint32_t sb_err                : 2;  /**< [  3:  2](R/W) single-bit memory error (logical tile = two physical tiles) */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](R/W) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](R/W) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](R/W) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](R/W) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_int_en_hix_s cn; */
};
typedef union bdk_tns_se_sram_pairx_int_en_hix bdk_tns_se_sram_pairx_int_en_hix_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x842054020004ll + 0x400000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_INT_EN_HIX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(a,b) bdk_tns_se_sram_pairx_int_en_hix_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(a,b) "TNS_SE_SRAM_PAIRX_INT_EN_HIX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_int_en_lo#
 *
 * TNS Search Sram Pair Interrrupt Enable Low Registers
 * register 0 for port-A, 1 for port-B
 */
union bdk_tns_se_sram_pairx_int_en_lox
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_int_en_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](R/W) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](R/W) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](R/W) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](R/W) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t sb_err                : 2;  /**< [  3:  2](R/W) single-bit memory error (logical tile = two physical tiles) */
        uint32_t db_err                : 2;  /**< [  1:  0](R/W) single-bit memory error (logical tile = two physical tiles) */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 2;  /**< [  1:  0](R/W) single-bit memory error (logical tile = two physical tiles) */
        uint32_t sb_err                : 2;  /**< [  3:  2](R/W) single-bit memory error (logical tile = two physical tiles) */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](R/W) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](R/W) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](R/W) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](R/W) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_int_en_lox_s cn; */
};
typedef union bdk_tns_se_sram_pairx_int_en_lox bdk_tns_se_sram_pairx_int_en_lox_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x842054020008ll + 0x400000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_INT_EN_LOX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(a,b) bdk_tns_se_sram_pairx_int_en_lox_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(a,b) "TNS_SE_SRAM_PAIRX_INT_EN_LOX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_int_frc#
 *
 * TNS Search Sram Pair Interrrupt Force Registers
 * register 0 for port-A, 1 for port-B
 */
union bdk_tns_se_sram_pairx_int_frcx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_int_frcx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](WO) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](WO) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](WO) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](WO) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t sb_err                : 2;  /**< [  3:  2](WO) single-bit memory error (logical tile = two physical tiles) */
        uint32_t db_err                : 2;  /**< [  1:  0](WO) single-bit memory error (logical tile = two physical tiles) */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 2;  /**< [  1:  0](WO) single-bit memory error (logical tile = two physical tiles) */
        uint32_t sb_err                : 2;  /**< [  3:  2](WO) single-bit memory error (logical tile = two physical tiles) */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](WO) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](WO) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](WO) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](WO) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_int_frcx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_int_frcx bdk_tns_se_sram_pairx_int_frcx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x84205402000cll + 0x400000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_INT_FRCX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(a,b) bdk_tns_se_sram_pairx_int_frcx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(a,b) "TNS_SE_SRAM_PAIRX_INT_FRCX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_int_w1c#
 *
 * TNS Search Sram Pair Interrrupt W1C Registers
 * register 0 for port-A, 1 for port-B
 */
union bdk_tns_se_sram_pairx_int_w1cx
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_int_w1cx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](R/W1C/H) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](R/W1C/H) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](R/W1C/H) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](R/W1C/H) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t sb_err                : 2;  /**< [  3:  2](R/W1C/H) single-bit memory error (logical tile = two physical tiles) */
        uint32_t db_err                : 2;  /**< [  1:  0](R/W1C/H) single-bit memory error (logical tile = two physical tiles) */
#else /* Word 0 - Little Endian */
        uint32_t db_err                : 2;  /**< [  1:  0](R/W1C/H) single-bit memory error (logical tile = two physical tiles) */
        uint32_t sb_err                : 2;  /**< [  3:  2](R/W1C/H) single-bit memory error (logical tile = two physical tiles) */
        uint32_t dual_tile_hash_err    : 1;  /**< [  4:  4](R/W1C/H) when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
        uint32_t dual_tile_hash_hang   : 2;  /**< [  6:  5](R/W1C/H) 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
        uint32_t odd_tile_prfx         : 1;  /**< [  7:  7](R/W1C/H) Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
        uint32_t dfc_rx_ovfl           : 2;  /**< [  9:  8](R/W1C/H) bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_int_w1cx_s cn; */
};
typedef union bdk_tns_se_sram_pairx_int_w1cx bdk_tns_se_sram_pairx_int_w1cx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1)))
        return 0x842054020000ll + 0x400000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_INT_W1CX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(a,b) bdk_tns_se_sram_pairx_int_w1cx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(a,b) "TNS_SE_SRAM_PAIRX_INT_W1CX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(a,b) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_lock
 *
 * TNS Search Sram Pair Lock Registers
 * Lock Register
 */
union bdk_tns_se_sram_pairx_lock
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_lock_s cn; */
};
typedef union bdk_tns_se_sram_pairx_lock bdk_tns_se_sram_pairx_lock_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x8420540200fcll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_LOCK(a) bdk_tns_se_sram_pairx_lock_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_LOCK(a) "TNS_SE_SRAM_PAIRX_LOCK"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_LOCK(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_spad
 *
 * TNS Search Sram Pair ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_sram_pairx_spad
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_spad_s cn; */
};
typedef union bdk_tns_se_sram_pairx_spad bdk_tns_se_sram_pairx_spad_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842054020100ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_SPAD(a) bdk_tns_se_sram_pairx_spad_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_SPAD(a) "TNS_SE_SRAM_PAIRX_SPAD"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_SPAD(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_sram_dbg
 *
 * TNS Search Sram Pair Sram Debug Registers
 * debugging of memoir memory
 */
union bdk_tns_se_sram_pairx_sram_dbg
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_sram_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t en                    : 2;  /**< [ 18: 17](R/W) one bit per tile , when debug enabled, there should be NO functional requests
                                                                 to SRAM,
                                                                 i.e., all traffic needs to be stopped! */
        uint32_t tile_sel              : 1;  /**< [ 16: 16](R/W) choose which tile to read/write */
        uint32_t bank                  : 5;  /**< [ 15: 11](R/W) -- */
        uint32_t addr                  : 11; /**< [ 10:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t addr                  : 11; /**< [ 10:  0](R/W) -- */
        uint32_t bank                  : 5;  /**< [ 15: 11](R/W) -- */
        uint32_t tile_sel              : 1;  /**< [ 16: 16](R/W) choose which tile to read/write */
        uint32_t en                    : 2;  /**< [ 18: 17](R/W) one bit per tile , when debug enabled, there should be NO functional requests
                                                                 to SRAM,
                                                                 i.e., all traffic needs to be stopped! */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_sram_dbg_s cn; */
};
typedef union bdk_tns_se_sram_pairx_sram_dbg bdk_tns_se_sram_pairx_sram_dbg_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842054020058ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_SRAM_DBG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(a) bdk_tns_se_sram_pairx_sram_dbg_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(a) "TNS_SE_SRAM_PAIRX_SRAM_DBG"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_sram_pair#_tile_rst
 *
 * TNS Search Sram Pair Tile Reset Registers
 * --
 */
union bdk_tns_se_sram_pairx_tile_rst
{
    uint32_t u;
    struct bdk_tns_se_sram_pairx_tile_rst_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tile_rst_bmp          : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tile_rst_bmp          : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairx_tile_rst_s cn; */
};
typedef union bdk_tns_se_sram_pairx_tile_rst bdk_tns_se_sram_pairx_tile_rst_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_TILE_RST(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_TILE_RST(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x8420540200f4ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRX_TILE_RST", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(a) bdk_tns_se_sram_pairx_tile_rst_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(a) "TNS_SE_SRAM_PAIRX_TILE_RST"
#define device_bar_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(a) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_se_sram_pair#tile#d#_w#
 *
 * TNS Search Sram Pair Tile Registers
 * 8K-row memory tiles, numbered 0-1
 * When writing, the MSBs (word 3) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_se_sram_pairxtilexdx_wx
{
    uint64_t u;
    struct bdk_tns_se_sram_pairxtilexdx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_sram_pairxtilexdx_wx_s cn; */
};
typedef union bdk_tns_se_sram_pairxtilexdx_wx bdk_tns_se_sram_pairxtilexdx_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=1) && (c<=2047) && (d<=3)))
        return 0x842054000000ll + 0x400000ll * ((a) & 0x7) + 0x10000ll * ((b) & 0x1) + 0x20ll * ((c) & 0x7ff) + 8ll * ((d) & 0x3);
    __bdk_csr_fatal("TNS_SE_SRAM_PAIRXTILEXDX_WX", 4, a, b, c, d);
}

#define typedef_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(a,b,c,d) bdk_tns_se_sram_pairxtilexdx_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(a,b,c,d) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(a,b,c,d) "TNS_SE_SRAM_PAIRXTILEXDX_WX"
#define device_bar_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(a,b,c,d) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(a,b,c,d) (a)
#define arguments_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) tns_se_tcam#_dbg_sel
 *
 * TNS Search TCAM Debug Selector Registers
 * Debug select
 */
union bdk_tns_se_tcamx_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_tcamx_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tcam_sram_dbg_sel     : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tcam_sram_dbg_sel     : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_dbg_sel_s cn; */
};
typedef union bdk_tns_se_tcamx_dbg_sel bdk_tns_se_tcamx_dbg_sel_t;

static inline uint64_t BDK_TNS_SE_TCAMX_DBG_SEL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_DBG_SEL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008018ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_DBG_SEL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_DBG_SEL(a) bdk_tns_se_tcamx_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAMX_DBG_SEL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_DBG_SEL(a) "TNS_SE_TCAMX_DBG_SEL"
#define device_bar_BDK_TNS_SE_TCAMX_DBG_SEL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_DBG_SEL(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_DBG_SEL(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam#_ecc_ctl
 *
 * TNS Search TCAM ECC Control Registers
 * ECC configuration for TCAM SRAM memories
 */
union bdk_tns_se_tcamx_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_se_tcamx_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t flip_db_ecc           : 2;  /**< [  4:  3](R/W) Flip 2 bits of ECC syndrome in TCAM SRAM memory. It's built out of 2 logical
                                                                 memory tiles of 138 bits wide */
        uint32_t flip_sb_ecc           : 2;  /**< [  2:  1](R/W) Flip 1 bit of ECC syndrome in TCAM SRAM memory. It's built out of 2 logical
                                                                 memory tiles of 138 bits wide */
        uint32_t cor_dis               : 1;  /**< [  0:  0](R/W) Disable ECC correction for TCAM SRAM memory */
#else /* Word 0 - Little Endian */
        uint32_t cor_dis               : 1;  /**< [  0:  0](R/W) Disable ECC correction for TCAM SRAM memory */
        uint32_t flip_sb_ecc           : 2;  /**< [  2:  1](R/W) Flip 1 bit of ECC syndrome in TCAM SRAM memory. It's built out of 2 logical
                                                                 memory tiles of 138 bits wide */
        uint32_t flip_db_ecc           : 2;  /**< [  4:  3](R/W) Flip 2 bits of ECC syndrome in TCAM SRAM memory. It's built out of 2 logical
                                                                 memory tiles of 138 bits wide */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_ecc_ctl_s cn; */
};
typedef union bdk_tns_se_tcamx_ecc_ctl bdk_tns_se_tcamx_ecc_ctl_t;

static inline uint64_t BDK_TNS_SE_TCAMX_ECC_CTL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_ECC_CTL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008010ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_ECC_CTL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_ECC_CTL(a) bdk_tns_se_tcamx_ecc_ctl_t
#define bustype_BDK_TNS_SE_TCAMX_ECC_CTL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_ECC_CTL(a) "TNS_SE_TCAMX_ECC_CTL"
#define device_bar_BDK_TNS_SE_TCAMX_ECC_CTL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_ECC_CTL(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_ECC_CTL(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_se_tcam#_sram#_w#
 *
 * TNS Search TCAM Sram Registers
 * --
 * When writing, the MSBs (word 3) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_se_tcamx_sramx_wx
{
    uint64_t u;
    struct bdk_tns_se_tcamx_sramx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_sramx_wx_s cn; */
};
typedef union bdk_tns_se_tcamx_sramx_wx bdk_tns_se_tcamx_sramx_wx_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAMX_WX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAMX_WX(unsigned long a, unsigned long b, unsigned long c)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=767) && (c<=3)))
        return 0x842050000000ll + 0x400000ll * ((a) & 0x7) + 0x20ll * ((b) & 0x3ff) + 8ll * ((c) & 0x3);
    __bdk_csr_fatal("TNS_SE_TCAMX_SRAMX_WX", 3, a, b, c, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_SRAMX_WX(a,b,c) bdk_tns_se_tcamx_sramx_wx_t
#define bustype_BDK_TNS_SE_TCAMX_SRAMX_WX(a,b,c) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_SE_TCAMX_SRAMX_WX(a,b,c) "TNS_SE_TCAMX_SRAMX_WX"
#define device_bar_BDK_TNS_SE_TCAMX_SRAMX_WX(a,b,c) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_SRAMX_WX(a,b,c) (a)
#define arguments_BDK_TNS_SE_TCAMX_SRAMX_WX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) tns_se_tcam#_sram_ecc_log
 *
 * TNS Search TCAM Sram ECC Log Registers
 * These are read only
 */
union bdk_tns_se_tcamx_sram_ecc_log
{
    uint32_t u;
    struct bdk_tns_se_tcamx_sram_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t ecc_err_addr          : 10; /**< [  9:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 10; /**< [  9:  0](R/W/H) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_sram_ecc_log_s cn; */
};
typedef union bdk_tns_se_tcamx_sram_ecc_log bdk_tns_se_tcamx_sram_ecc_log_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008014ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_SRAM_ECC_LOG", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(a) bdk_tns_se_tcamx_sram_ecc_log_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(a) "TNS_SE_TCAMX_SRAM_ECC_LOG"
#define device_bar_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam#_sram_int_en_hi
 *
 * TNS Search TCAM Sram Interrrupt Enable High Registers
 * TCAM SRAM interrupt register
 */
union bdk_tns_se_tcamx_sram_int_en_hi
{
    uint32_t u;
    struct bdk_tns_se_tcamx_sram_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](R/W) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](R/W) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else /* Word 0 - Little Endian */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](R/W) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](R/W) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_sram_int_en_hi_s cn; */
};
typedef union bdk_tns_se_tcamx_sram_int_en_hi bdk_tns_se_tcamx_sram_int_en_hi_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008004ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_SRAM_INT_EN_HI", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(a) bdk_tns_se_tcamx_sram_int_en_hi_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(a) "TNS_SE_TCAMX_SRAM_INT_EN_HI"
#define device_bar_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam#_sram_int_en_lo
 *
 * TNS Search TCAM Sram Interrrupt Enable Low Registers
 * TCAM SRAM interrupt register
 */
union bdk_tns_se_tcamx_sram_int_en_lo
{
    uint32_t u;
    struct bdk_tns_se_tcamx_sram_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](R/W) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](R/W) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else /* Word 0 - Little Endian */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](R/W) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](R/W) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_sram_int_en_lo_s cn; */
};
typedef union bdk_tns_se_tcamx_sram_int_en_lo bdk_tns_se_tcamx_sram_int_en_lo_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008008ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_SRAM_INT_EN_LO", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(a) bdk_tns_se_tcamx_sram_int_en_lo_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(a) "TNS_SE_TCAMX_SRAM_INT_EN_LO"
#define device_bar_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam#_sram_int_frc
 *
 * TNS Search TCAM Sram Interrrupt Force Registers
 * TCAM SRAM interrupt register
 */
union bdk_tns_se_tcamx_sram_int_frc
{
    uint32_t u;
    struct bdk_tns_se_tcamx_sram_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](WO) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](WO) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else /* Word 0 - Little Endian */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](WO) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](WO) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_sram_int_frc_s cn; */
};
typedef union bdk_tns_se_tcamx_sram_int_frc bdk_tns_se_tcamx_sram_int_frc_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_FRC(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_FRC(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205000800cll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_SRAM_INT_FRC", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(a) bdk_tns_se_tcamx_sram_int_frc_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(a) "TNS_SE_TCAMX_SRAM_INT_FRC"
#define device_bar_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam#_sram_int_w1c
 *
 * TNS Search TCAM Sram Interrrupt W1C Registers
 * TCAM SRAM interrupt register
 */
union bdk_tns_se_tcamx_sram_int_w1c
{
    uint32_t u;
    struct bdk_tns_se_tcamx_sram_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](R/W1C/H) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](R/W1C/H) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else /* Word 0 - Little Endian */
        uint32_t tcam_sram_sb_err      : 2;  /**< [  1:  0](R/W1C/H) TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t tcam_sram_db_err      : 2;  /**< [  3:  2](R/W1C/H) TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcamx_sram_int_w1c_s cn; */
};
typedef union bdk_tns_se_tcamx_sram_int_w1c bdk_tns_se_tcamx_sram_int_w1c_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_W1C(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_W1C(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008000ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAMX_SRAM_INT_W1C", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(a) bdk_tns_se_tcamx_sram_int_w1c_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(a) "TNS_SE_TCAMX_SRAM_INT_W1C"
#define device_bar_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(a) (a)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_bist_stdn
 *
 * TNS Search TCAM Database Bist Status Done Registers
 * --
 */
union bdk_tns_se_tcam_dbx_bist_stdn
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t bist_status           : 6;  /**< [ 23: 18](RO/H) -- */
        uint32_t bist_done             : 6;  /**< [ 17: 12](RO/H) -- */
        uint32_t cam_bist_status       : 6;  /**< [ 11:  6](RO/H) -- */
        uint32_t cam_bist_done         : 6;  /**< [  5:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t cam_bist_done         : 6;  /**< [  5:  0](RO/H) -- */
        uint32_t cam_bist_status       : 6;  /**< [ 11:  6](RO/H) -- */
        uint32_t bist_done             : 6;  /**< [ 17: 12](RO/H) -- */
        uint32_t bist_status           : 6;  /**< [ 23: 18](RO/H) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_bist_stdn_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_bist_stdn bdk_tns_se_tcam_dbx_bist_stdn_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_BIST_STDN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_BIST_STDN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c028ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_BIST_STDN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_BIST_STDN(a) bdk_tns_se_tcam_dbx_bist_stdn_t
#define bustype_BDK_TNS_SE_TCAM_DBX_BIST_STDN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_BIST_STDN(a) "TNS_SE_TCAM_DBX_BIST_STDN"
#define device_bar_BDK_TNS_SE_TCAM_DBX_BIST_STDN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_BIST_STDN(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_BIST_STDN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_clk_en_bmap
 *
 * TNS Search TCAM Database Clock Enable Bit Map Registers
 * TCAM tile clk_en bit map
 */
union bdk_tns_se_tcam_dbx_clk_en_bmap
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_clk_en_bmap_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t clk_en_bmap           : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t clk_en_bmap           : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_clk_en_bmap_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_clk_en_bmap bdk_tns_se_tcam_dbx_clk_en_bmap_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c020ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_CLK_EN_BMAP", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(a) bdk_tns_se_tcam_dbx_clk_en_bmap_t
#define bustype_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(a) "TNS_SE_TCAM_DBX_CLK_EN_BMAP"
#define device_bar_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_db_dbg_sel
 *
 * TNS Search TCAM Database Database Debug Selector Registers
 * Debug select
 */
union bdk_tns_se_tcam_dbx_db_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_db_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t tcam_db_dbg_sel       : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tcam_db_dbg_sel       : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_db_dbg_sel_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_db_dbg_sel bdk_tns_se_tcam_dbx_db_dbg_sel_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c024ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_DB_DBG_SEL", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(a) bdk_tns_se_tcam_dbx_db_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(a) "TNS_SE_TCAM_DBX_DB_DBG_SEL"
#define device_bar_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_lock
 *
 * TNS Search TCAM Database Lock Registers
 * Lock Register
 */
union bdk_tns_se_tcam_dbx_lock
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_lock_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_lock bdk_tns_se_tcam_dbx_lock_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c02cll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_LOCK(a) bdk_tns_se_tcam_dbx_lock_t
#define bustype_BDK_TNS_SE_TCAM_DBX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_LOCK(a) "TNS_SE_TCAM_DBX_LOCK"
#define device_bar_BDK_TNS_SE_TCAM_DBX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_LOCK(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_spad
 *
 * TNS Search TCAM Database ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_tcam_dbx_spad
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_spad_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_spad bdk_tns_se_tcam_dbx_spad_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c030ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_SPAD(a) bdk_tns_se_tcam_dbx_spad_t
#define bustype_BDK_TNS_SE_TCAM_DBX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_SPAD(a) "TNS_SE_TCAM_DBX_SPAD"
#define device_bar_BDK_TNS_SE_TCAM_DBX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_SPAD(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_tdb_rvld_w#
 *
 * TNS Search TCAM Database TDB Row Valid Registers
 * Power optoin, each row_vld control 16 lines in a TCAM tile. Feature NOT
 * available in CN88XX custom TCAM
 */
union bdk_tns_se_tcam_dbx_tdb_rvld_wx
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_tdb_rvld_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t row_vld               : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t row_vld               : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_tdb_rvld_wx_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_tdb_rvld_wx bdk_tns_se_tcam_dbx_tdb_rvld_wx_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x84205200c004ll + 0x20000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_TDB_RVLD_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(a,b) bdk_tns_se_tcam_dbx_tdb_rvld_wx_t
#define bustype_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(a,b) "TNS_SE_TCAM_DBX_TDB_RVLD_WX"
#define device_bar_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_tile_rst
 *
 * TNS Search TCAM Database Tile Reset Registers
 * reset TCAM tile, rising edge trigger
 */
union bdk_tns_se_tcam_dbx_tile_rst
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_tile_rst_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t tile_rst              : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tile_rst              : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_tile_rst_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_tile_rst bdk_tns_se_tcam_dbx_tile_rst_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_TILE_RST(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_TILE_RST(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c000ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_TILE_RST", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_TILE_RST(a) bdk_tns_se_tcam_dbx_tile_rst_t
#define bustype_BDK_TNS_SE_TCAM_DBX_TILE_RST(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_TILE_RST(a) "TNS_SE_TCAM_DBX_TILE_RST"
#define device_bar_BDK_TNS_SE_TCAM_DBX_TILE_RST(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_TILE_RST(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_TILE_RST(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#_tpool_db
 *
 * TNS Search TCAM Database TPOOL Database Registers
 * configuration within a TCAM database, it has to be consistent with the
 * corresponding TCAM table definition.
 */
union bdk_tns_se_tcam_dbx_tpool_db
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbx_tpool_db_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t mode                  : 4;  /**< [ 11:  8](R/W) 0x1: 64-bit  X 1.5K-entry
                                                                 0x2: 128-bit X 768-entry
                                                                 0x3: 192-bit X 512-entry
                                                                 0x6: 384-bit X 256-entry */
        uint32_t db_addr_base          : 8;  /**< [  7:  0](R/W) starting table address for this database, in unit of 256-entry */
#else /* Word 0 - Little Endian */
        uint32_t db_addr_base          : 8;  /**< [  7:  0](R/W) starting table address for this database, in unit of 256-entry */
        uint32_t mode                  : 4;  /**< [ 11:  8](R/W) 0x1: 64-bit  X 1.5K-entry
                                                                 0x2: 128-bit X 768-entry
                                                                 0x3: 192-bit X 512-entry
                                                                 0x6: 384-bit X 256-entry */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbx_tpool_db_s cn; */
};
typedef union bdk_tns_se_tcam_dbx_tpool_db bdk_tns_se_tcam_dbx_tpool_db_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_TPOOL_DB(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_TPOOL_DB(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205200c01cll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBX_TPOOL_DB", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(a) bdk_tns_se_tcam_dbx_tpool_db_t
#define bustype_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(a) "TNS_SE_TCAM_DBX_TPOOL_DB"
#define device_bar_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(a) (a)
#define arguments_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_db#cn_vdm#d#_w#
 *
 * TNS Search TCAM Database CN Valid Data Mask Registers
 * TCAM tile, {CN88XX cn_vld_data_mask[129:0]}
 * Bits[31:2] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_se_tcam_dbxcn_vdmxdx_wx
{
    uint32_t u;
    struct bdk_tns_se_tcam_dbxcn_vdmxdx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t cn_vld_data_mask      : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t cn_vld_data_mask      : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_dbxcn_vdmxdx_wx_s cn; */
};
typedef union bdk_tns_se_tcam_dbxcn_vdmxdx_wx bdk_tns_se_tcam_dbxcn_vdmxdx_wx_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(unsigned long a, unsigned long b, unsigned long c, unsigned long d) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(unsigned long a, unsigned long b, unsigned long c, unsigned long d)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5) && (c<=255) && (d<=4)))
        return 0x842052000000ll + 0x20000ll * ((a) & 0x7) + 0x2000ll * ((b) & 0x7) + 0x20ll * ((c) & 0xff) + 4ll * ((d) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_DBXCN_VDMXDX_WX", 4, a, b, c, d);
}

#define typedef_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(a,b,c,d) bdk_tns_se_tcam_dbxcn_vdmxdx_wx_t
#define bustype_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(a,b,c,d) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(a,b,c,d) "TNS_SE_TCAM_DBXCN_VDMXDX_WX"
#define device_bar_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(a,b,c,d) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(a,b,c,d) (a)
#define arguments_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(a,b,c,d) (a),(b),(c),(d)

/**
 * Register (NCB32b) tns_se_tcam_eng_dbg_sel
 *
 * TNS Search TCAM Engine Debug Selector Register
 * --
 */
union bdk_tns_se_tcam_eng_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_tcam_eng_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t age_dbg_sel           : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t age_dbg_sel           : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_eng_dbg_sel_s cn; */
};
typedef union bdk_tns_se_tcam_eng_dbg_sel bdk_tns_se_tcam_eng_dbg_sel_t;

#define BDK_TNS_SE_TCAM_ENG_DBG_SEL BDK_TNS_SE_TCAM_ENG_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205220104cll;
    __bdk_csr_fatal("TNS_SE_TCAM_ENG_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_ENG_DBG_SEL bdk_tns_se_tcam_eng_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAM_ENG_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_ENG_DBG_SEL "TNS_SE_TCAM_ENG_DBG_SEL"
#define device_bar_BDK_TNS_SE_TCAM_ENG_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_ENG_DBG_SEL 0
#define arguments_BDK_TNS_SE_TCAM_ENG_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_eng_lock
 *
 * TNS Search TCAM Engine Lock Register
 * Lock Register
 */
union bdk_tns_se_tcam_eng_lock
{
    uint32_t u;
    struct bdk_tns_se_tcam_eng_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_eng_lock_s cn; */
};
typedef union bdk_tns_se_tcam_eng_lock bdk_tns_se_tcam_eng_lock_t;

#define BDK_TNS_SE_TCAM_ENG_LOCK BDK_TNS_SE_TCAM_ENG_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052201054ll;
    __bdk_csr_fatal("TNS_SE_TCAM_ENG_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_ENG_LOCK bdk_tns_se_tcam_eng_lock_t
#define bustype_BDK_TNS_SE_TCAM_ENG_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_ENG_LOCK "TNS_SE_TCAM_ENG_LOCK"
#define device_bar_BDK_TNS_SE_TCAM_ENG_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_ENG_LOCK 0
#define arguments_BDK_TNS_SE_TCAM_ENG_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_eng_rslt_dbg_sel
 *
 * TNS Search TCAM Engine Result Debug Selector Register
 * --
 */
union bdk_tns_se_tcam_eng_rslt_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_tcam_eng_rslt_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t age_dbg_sel           : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t age_dbg_sel           : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_eng_rslt_dbg_sel_s cn; */
};
typedef union bdk_tns_se_tcam_eng_rslt_dbg_sel bdk_tns_se_tcam_eng_rslt_dbg_sel_t;

#define BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052201050ll;
    __bdk_csr_fatal("TNS_SE_TCAM_ENG_RSLT_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL bdk_tns_se_tcam_eng_rslt_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL "TNS_SE_TCAM_ENG_RSLT_DBG_SEL"
#define device_bar_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL 0
#define arguments_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_eng_spad
 *
 * TNS Search TCAM Engine ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_tcam_eng_spad
{
    uint32_t u;
    struct bdk_tns_se_tcam_eng_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_eng_spad_s cn; */
};
typedef union bdk_tns_se_tcam_eng_spad bdk_tns_se_tcam_eng_spad_t;

#define BDK_TNS_SE_TCAM_ENG_SPAD BDK_TNS_SE_TCAM_ENG_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052201058ll;
    __bdk_csr_fatal("TNS_SE_TCAM_ENG_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_ENG_SPAD bdk_tns_se_tcam_eng_spad_t
#define bustype_BDK_TNS_SE_TCAM_ENG_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_ENG_SPAD "TNS_SE_TCAM_ENG_SPAD"
#define device_bar_BDK_TNS_SE_TCAM_ENG_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_ENG_SPAD 0
#define arguments_BDK_TNS_SE_TCAM_ENG_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_eng_tcam_dbbuf#
 *
 * TNS Search TCAM Engine TCAM Database Buffer Registers
 * --
 */
union bdk_tns_se_tcam_eng_tcam_dbbufx
{
    uint32_t u;
    struct bdk_tns_se_tcam_eng_tcam_dbbufx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t dbbuf_fc_thd          : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t dbbuf_fc_thd          : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_eng_tcam_dbbufx_s cn; */
};
typedef union bdk_tns_se_tcam_eng_tcam_dbbufx bdk_tns_se_tcam_eng_tcam_dbbufx_t;

static inline uint64_t BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842052201020ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_ENG_TCAM_DBBUFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(a) bdk_tns_se_tcam_eng_tcam_dbbufx_t
#define bustype_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(a) "TNS_SE_TCAM_ENG_TCAM_DBBUFX"
#define device_bar_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(a) (a)
#define arguments_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_eng_tpool_vcod#
 *
 * TNS Search TCAM Engine TPOOL VENCODER Registers
 * configuration across TCAM databases, it has to be consistent with the
 * corresponding TCAM table definition.
 */
union bdk_tns_se_tcam_eng_tpool_vcodx
{
    uint32_t u;
    struct bdk_tns_se_tcam_eng_tpool_vcodx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t db_bmp                : 8;  /**< [ 11:  4](R/W) bitmap for all databases in the table, they have to be a contiguous set of
                                                                 DB's. */
        uint32_t data_size             : 4;  /**< [  3:  0](R/W) In unit of 32-bit, max 256-bit return control data. Allowed data size: 64, 128,
                                                                 256-bit */
#else /* Word 0 - Little Endian */
        uint32_t data_size             : 4;  /**< [  3:  0](R/W) In unit of 32-bit, max 256-bit return control data. Allowed data size: 64, 128,
                                                                 256-bit */
        uint32_t db_bmp                : 8;  /**< [ 11:  4](R/W) bitmap for all databases in the table, they have to be a contiguous set of
                                                                 DB's. */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_eng_tpool_vcodx_s cn; */
};
typedef union bdk_tns_se_tcam_eng_tpool_vcodx bdk_tns_se_tcam_eng_tpool_vcodx_t;

static inline uint64_t BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842052201000ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_ENG_TPOOL_VCODX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(a) bdk_tns_se_tcam_eng_tpool_vcodx_t
#define bustype_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(a) "TNS_SE_TCAM_ENG_TPOOL_VCODX"
#define device_bar_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(a) (a)
#define arguments_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_ecc#d#
 *
 * TNS Search TCAM Scrub ECC Registers
 * --
 */
union bdk_tns_se_tcam_scrbx_eccxdx
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_eccxdx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t ecc_data              : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_data              : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_eccxdx_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_eccxdx bdk_tns_se_tcam_scrbx_eccxdx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECCXDX(unsigned long a, unsigned long b, unsigned long c) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECCXDX(unsigned long a, unsigned long b, unsigned long c)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5) && (c<=255)))
        return 0x842052100000ll + 0x20000ll * ((a) & 0x7) + 0x400ll * ((b) & 0x7) + 4ll * ((c) & 0xff);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_ECCXDX", 3, a, b, c, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(a,b,c) bdk_tns_se_tcam_scrbx_eccxdx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(a,b,c) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(a,b,c) "TNS_SE_TCAM_SCRBX_ECCXDX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(a,b,c) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(a,b,c) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(a,b,c) (a),(b),(c),-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_ecc_log#
 *
 * TNS Search TCAM Scrub ECC Log Registers
 * These are read only
 */
union bdk_tns_se_tcam_scrbx_ecc_logx
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_ecc_logx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_ecc_logx_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_ecc_logx bdk_tns_se_tcam_scrbx_ecc_logx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x842052101878ll + 0x20000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_ECC_LOGX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(a,b) bdk_tns_se_tcam_scrbx_ecc_logx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(a,b) "TNS_SE_TCAM_SCRBX_ECC_LOGX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_int_en_hi#
 *
 * TNS Search TCAM Scrub Interrrupt Enable High Registers
 * TCAM scrub interrupt register
 */
union bdk_tns_se_tcam_scrbx_int_en_hix
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_int_en_hix_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](R/W) TCAM scrub has double bit ECC interrupt */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](R/W) TCAM scrub has single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](R/W) TCAM scrub has single bit ECC interrupt */
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](R/W) TCAM scrub has double bit ECC interrupt */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_int_en_hix_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_int_en_hix bdk_tns_se_tcam_scrbx_int_en_hix_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x84205210181cll + 0x20000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_INT_EN_HIX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(a,b) bdk_tns_se_tcam_scrbx_int_en_hix_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(a,b) "TNS_SE_TCAM_SCRBX_INT_EN_HIX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_int_en_lo#
 *
 * TNS Search TCAM Scrub Interrrupt Enable Low Registers
 * TCAM scrub interrupt register
 */
union bdk_tns_se_tcam_scrbx_int_en_lox
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_int_en_lox_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](R/W) TCAM scrub has double bit ECC interrupt */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](R/W) TCAM scrub has single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](R/W) TCAM scrub has single bit ECC interrupt */
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](R/W) TCAM scrub has double bit ECC interrupt */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_int_en_lox_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_int_en_lox bdk_tns_se_tcam_scrbx_int_en_lox_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x842052101820ll + 0x20000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_INT_EN_LOX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(a,b) bdk_tns_se_tcam_scrbx_int_en_lox_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(a,b) "TNS_SE_TCAM_SCRBX_INT_EN_LOX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_int_frc#
 *
 * TNS Search TCAM Scrub Interrrupt Force Registers
 * TCAM scrub interrupt register
 */
union bdk_tns_se_tcam_scrbx_int_frcx
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_int_frcx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](WO) TCAM scrub has double bit ECC interrupt */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](WO) TCAM scrub has single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](WO) TCAM scrub has single bit ECC interrupt */
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](WO) TCAM scrub has double bit ECC interrupt */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_int_frcx_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_int_frcx bdk_tns_se_tcam_scrbx_int_frcx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x842052101824ll + 0x20000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_INT_FRCX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(a,b) bdk_tns_se_tcam_scrbx_int_frcx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(a,b) "TNS_SE_TCAM_SCRBX_INT_FRCX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_int_w1c#
 *
 * TNS Search TCAM Scrub Interrrupt W1C Registers
 * TCAM scrub interrupt register
 */
union bdk_tns_se_tcam_scrbx_int_w1cx
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_int_w1cx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](R/W1C/H) TCAM scrub has double bit ECC interrupt */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](R/W1C/H) TCAM scrub has single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tcam_scrb_sb_err      : 1;  /**< [  0:  0](R/W1C/H) TCAM scrub has single bit ECC interrupt */
        uint32_t tcam_scrb_db_err      : 1;  /**< [  1:  1](R/W1C/H) TCAM scrub has double bit ECC interrupt */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_int_w1cx_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_int_w1cx bdk_tns_se_tcam_scrbx_int_w1cx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x842052101818ll + 0x20000ll * ((a) & 0x7) + 0x10ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_INT_W1CX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(a,b) bdk_tns_se_tcam_scrbx_int_w1cx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(a,b) "TNS_SE_TCAM_SCRBX_INT_W1CX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_lock
 *
 * TNS Search TCAM Scrub Lock Registers
 * Lock Register
 */
union bdk_tns_se_tcam_scrbx_lock
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_lock_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_lock bdk_tns_se_tcam_scrbx_lock_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842052101890ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_LOCK(a) bdk_tns_se_tcam_scrbx_lock_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_LOCK(a) "TNS_SE_TCAM_SCRBX_LOCK"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_LOCK(a) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_scrb#
 *
 * TNS Search TCAM Scrub Scrub Registers
 * Hardware scrubbing of TCAMs
 */
union bdk_tns_se_tcam_scrbx_scrbx
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_scrbx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scrub_row_intvl       : 10; /**< [ 31: 22](R/W) When set to 0 scrubbing is disabled. When nonzero it is the interval in
                                                                 switch-clock cycles
                                                                 between scrubbing adjacent rows */
        uint32_t scrub_last_to_1st_row_intvl : 16;/**< [ 21:  6](R/W) When set to 0 this interval is disabled. When nonzero it is the interval in
                                                                 switch-clock cycles
                                                                 between scrubbing last row and first row (i.e. new scrub cycle)
                                                                 gives granularity upto 0.1ms with 600MHz switch-clock
                                                                 Not implemented in Pass1 */
        uint32_t unused                : 1;  /**< [  5:  5](R/W) -- */
        uint32_t flip_sb_ecc           : 1;  /**< [  4:  4](R/W) -- */
        uint32_t flip_db_ecc           : 1;  /**< [  3:  3](R/W) -- */
        uint32_t cor_dis               : 1;  /**< [  2:  2](R/W) -- */
        uint32_t sw_scrb_wr            : 1;  /**< [  1:  1](R/W) When set to 1, HW will indicate the SBE erred address, SW will scrub that
                                                                 address by doing a CPU write to TCAM
                                                                 When set to 0 (default), HW will do the scrubbing */
        uint32_t use_ecc_rams          : 1;  /**< [  0:  0](R/W) Hack to make Test bench work.
                                                                 This bit needs to be set by software before this feature can be
                                                                 used */
#else /* Word 0 - Little Endian */
        uint32_t use_ecc_rams          : 1;  /**< [  0:  0](R/W) Hack to make Test bench work.
                                                                 This bit needs to be set by software before this feature can be
                                                                 used */
        uint32_t sw_scrb_wr            : 1;  /**< [  1:  1](R/W) When set to 1, HW will indicate the SBE erred address, SW will scrub that
                                                                 address by doing a CPU write to TCAM
                                                                 When set to 0 (default), HW will do the scrubbing */
        uint32_t cor_dis               : 1;  /**< [  2:  2](R/W) -- */
        uint32_t flip_db_ecc           : 1;  /**< [  3:  3](R/W) -- */
        uint32_t flip_sb_ecc           : 1;  /**< [  4:  4](R/W) -- */
        uint32_t unused                : 1;  /**< [  5:  5](R/W) -- */
        uint32_t scrub_last_to_1st_row_intvl : 16;/**< [ 21:  6](R/W) When set to 0 this interval is disabled. When nonzero it is the interval in
                                                                 switch-clock cycles
                                                                 between scrubbing last row and first row (i.e. new scrub cycle)
                                                                 gives granularity upto 0.1ms with 600MHz switch-clock
                                                                 Not implemented in Pass1 */
        uint32_t scrub_row_intvl       : 10; /**< [ 31: 22](R/W) When set to 0 scrubbing is disabled. When nonzero it is the interval in
                                                                 switch-clock cycles
                                                                 between scrubbing adjacent rows */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_scrbx_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_scrbx bdk_tns_se_tcam_scrbx_scrbx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SCRBX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SCRBX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=7) && (b<=5)))
        return 0x842052101800ll + 0x20000ll * ((a) & 0x7) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_SCRBX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_SCRBX(a,b) bdk_tns_se_tcam_scrbx_scrbx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_SCRBX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_SCRBX(a,b) "TNS_SE_TCAM_SCRBX_SCRBX"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_SCRBX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_SCRBX(a,b) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_SCRBX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_tcam_scrb#_spad
 *
 * TNS Search TCAM Scrub ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_tcam_scrbx_spad
{
    uint32_t u;
    struct bdk_tns_se_tcam_scrbx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_scrbx_spad_s cn; */
};
typedef union bdk_tns_se_tcam_scrbx_spad bdk_tns_se_tcam_scrbx_spad_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842052101894ll + 0x20000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SCRBX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SCRBX_SPAD(a) bdk_tns_se_tcam_scrbx_spad_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SCRBX_SPAD(a) "TNS_SE_TCAM_SCRBX_SPAD"
#define device_bar_BDK_TNS_SE_TCAM_SCRBX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SCRBX_SPAD(a) (a)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_sram#_bist_stdn
 *
 * TNS Search TCAM Sram Bist Status Done Registers
 * --
 */
union bdk_tns_se_tcam_sramx_bist_stdn
{
    uint32_t u;
    struct bdk_tns_se_tcam_sramx_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t bist_status           : 2;  /**< [  3:  2](RO/H) -- */
        uint32_t bist_done             : 2;  /**< [  1:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t bist_done             : 2;  /**< [  1:  0](RO/H) -- */
        uint32_t bist_status           : 2;  /**< [  3:  2](RO/H) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_sramx_bist_stdn_s cn; */
};
typedef union bdk_tns_se_tcam_sramx_bist_stdn bdk_tns_se_tcam_sramx_bist_stdn_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008020ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SRAMX_BIST_STDN", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(a) bdk_tns_se_tcam_sramx_bist_stdn_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(a) "TNS_SE_TCAM_SRAMX_BIST_STDN"
#define device_bar_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(a) (a)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_sram#_lock
 *
 * TNS Search TCAM Sram Lock Registers
 * Lock Register
 */
union bdk_tns_se_tcam_sramx_lock
{
    uint32_t u;
    struct bdk_tns_se_tcam_sramx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_sramx_lock_s cn; */
};
typedef union bdk_tns_se_tcam_sramx_lock bdk_tns_se_tcam_sramx_lock_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008024ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SRAMX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SRAMX_LOCK(a) bdk_tns_se_tcam_sramx_lock_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SRAMX_LOCK(a) "TNS_SE_TCAM_SRAMX_LOCK"
#define device_bar_BDK_TNS_SE_TCAM_SRAMX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SRAMX_LOCK(a) (a)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_sram#_spad
 *
 * TNS Search TCAM Sram ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_tcam_sramx_spad
{
    uint32_t u;
    struct bdk_tns_se_tcam_sramx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_sramx_spad_s cn; */
};
typedef union bdk_tns_se_tcam_sramx_spad bdk_tns_se_tcam_sramx_spad_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842050008028ll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SRAMX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SRAMX_SPAD(a) bdk_tns_se_tcam_sramx_spad_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SRAMX_SPAD(a) "TNS_SE_TCAM_SRAMX_SPAD"
#define device_bar_BDK_TNS_SE_TCAM_SRAMX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SRAMX_SPAD(a) (a)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_sram#_tcam_rdbuf
 *
 * TNS Search TCAM Sram TCAM Read Buffer Registers
 * --
 */
union bdk_tns_se_tcam_sramx_tcam_rdbuf
{
    uint32_t u;
    struct bdk_tns_se_tcam_sramx_tcam_rdbuf_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t rdbuf_fc_thd          : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t rdbuf_fc_thd          : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_sramx_tcam_rdbuf_s cn; */
};
typedef union bdk_tns_se_tcam_sramx_tcam_rdbuf bdk_tns_se_tcam_sramx_tcam_rdbuf_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205000801cll + 0x400000ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_TCAM_SRAMX_TCAM_RDBUF", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(a) bdk_tns_se_tcam_sramx_tcam_rdbuf_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(a) "TNS_SE_TCAM_SRAMX_TCAM_RDBUF"
#define device_bar_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(a) (a)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_tbl#
 *
 * TNS Search TCAM Table Registers
 * --
 */
union bdk_tns_se_tcam_tblx
{
    uint32_t u;
    struct bdk_tns_se_tcam_tblx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t key_size              : 4;  /**< [ 13: 10](R/W) In unit of 32-bit, allowed values 64-bit, 128-bit, 192-bit, or 384-bit
                                                                 Note that control data size is configured in
                                                                 xp_se_config_tpool_vencoder. */
        uint32_t db_start              : 5;  /**< [  9:  5](R/W) The tcam pool has 8 databases. */
        uint32_t db_end                : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t db_end                : 5;  /**< [  4:  0](R/W) -- */
        uint32_t db_start              : 5;  /**< [  9:  5](R/W) The tcam pool has 8 databases. */
        uint32_t key_size              : 4;  /**< [ 13: 10](R/W) In unit of 32-bit, allowed values 64-bit, 128-bit, 192-bit, or 384-bit
                                                                 Note that control data size is configured in
                                                                 xp_se_config_tpool_vencoder. */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_tblx_s cn; */
};
typedef union bdk_tns_se_tcam_tblx bdk_tns_se_tcam_tblx_t;

static inline uint64_t BDK_TNS_SE_TCAM_TBLX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_TBLX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842052200000ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_SE_TCAM_TBLX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_TBLX(a) bdk_tns_se_tcam_tblx_t
#define bustype_BDK_TNS_SE_TCAM_TBLX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_TBLX(a) "TNS_SE_TCAM_TBLX"
#define device_bar_BDK_TNS_SE_TCAM_TBLX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_TBLX(a) (a)
#define arguments_BDK_TNS_SE_TCAM_TBLX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_tbl_lock
 *
 * TNS Search TCAM Table Lock Register
 * Lock Register
 */
union bdk_tns_se_tcam_tbl_lock
{
    uint32_t u;
    struct bdk_tns_se_tcam_tbl_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_tbl_lock_s cn; */
};
typedef union bdk_tns_se_tcam_tbl_lock bdk_tns_se_tcam_tbl_lock_t;

#define BDK_TNS_SE_TCAM_TBL_LOCK BDK_TNS_SE_TCAM_TBL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_TBL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_TBL_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842052200048ll;
    __bdk_csr_fatal("TNS_SE_TCAM_TBL_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_TBL_LOCK bdk_tns_se_tcam_tbl_lock_t
#define bustype_BDK_TNS_SE_TCAM_TBL_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_TBL_LOCK "TNS_SE_TCAM_TBL_LOCK"
#define device_bar_BDK_TNS_SE_TCAM_TBL_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_TBL_LOCK 0
#define arguments_BDK_TNS_SE_TCAM_TBL_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_tcam_tbl_spad
 *
 * TNS Search TCAM Table ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_tcam_tbl_spad
{
    uint32_t u;
    struct bdk_tns_se_tcam_tbl_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_tcam_tbl_spad_s cn; */
};
typedef union bdk_tns_se_tcam_tbl_spad bdk_tns_se_tcam_tbl_spad_t;

#define BDK_TNS_SE_TCAM_TBL_SPAD BDK_TNS_SE_TCAM_TBL_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_TBL_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_TBL_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205220004cll;
    __bdk_csr_fatal("TNS_SE_TCAM_TBL_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_TCAM_TBL_SPAD bdk_tns_se_tcam_tbl_spad_t
#define bustype_BDK_TNS_SE_TCAM_TBL_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_TCAM_TBL_SPAD "TNS_SE_TCAM_TBL_SPAD"
#define device_bar_BDK_TNS_SE_TCAM_TBL_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_TCAM_TBL_SPAD 0
#define arguments_BDK_TNS_SE_TCAM_TBL_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urw_tbl_lock
 *
 * TNS Search URW Table Lock Register
 * Lock Register
 */
union bdk_tns_se_urw_tbl_lock
{
    uint32_t u;
    struct bdk_tns_se_urw_tbl_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urw_tbl_lock_s cn; */
};
typedef union bdk_tns_se_urw_tbl_lock bdk_tns_se_urw_tbl_lock_t;

#define BDK_TNS_SE_URW_TBL_LOCK BDK_TNS_SE_URW_TBL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_URW_TBL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URW_TBL_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109880ll;
    __bdk_csr_fatal("TNS_SE_URW_TBL_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URW_TBL_LOCK bdk_tns_se_urw_tbl_lock_t
#define bustype_BDK_TNS_SE_URW_TBL_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URW_TBL_LOCK "TNS_SE_URW_TBL_LOCK"
#define device_bar_BDK_TNS_SE_URW_TBL_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URW_TBL_LOCK 0
#define arguments_BDK_TNS_SE_URW_TBL_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urw_tbl_spad
 *
 * TNS Search URW Table ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_urw_tbl_spad
{
    uint32_t u;
    struct bdk_tns_se_urw_tbl_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urw_tbl_spad_s cn; */
};
typedef union bdk_tns_se_urw_tbl_spad bdk_tns_se_urw_tbl_spad_t;

#define BDK_TNS_SE_URW_TBL_SPAD BDK_TNS_SE_URW_TBL_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_URW_TBL_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URW_TBL_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056109884ll;
    __bdk_csr_fatal("TNS_SE_URW_TBL_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URW_TBL_SPAD bdk_tns_se_urw_tbl_spad_t
#define bustype_BDK_TNS_SE_URW_TBL_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URW_TBL_SPAD "TNS_SE_URW_TBL_SPAD"
#define device_bar_BDK_TNS_SE_URW_TBL_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URW_TBL_SPAD 0
#define arguments_BDK_TNS_SE_URW_TBL_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urw_tbl_urw#
 *
 * TNS Search URW Table URW Registers
 * Same as xp_se_config_table_direct
 */
union bdk_tns_se_urw_tbl_urwx
{
    uint32_t u;
    struct bdk_tns_se_urw_tbl_urwx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t data_size             : 4;  /**< [ 18: 15](R/W) 0x2:     64-bit
                                                                 0x4:     128-bit
                                                                 0x8:     256-bit
                                                                 0x9(\>8): 512-bit */
        uint32_t pool                  : 3;  /**< [ 14: 12](R/W) Pool ID out of the 8 pools, which this table resides. */
        uint32_t row_blk_inc           : 6;  /**< [ 11:  6](R/W) Each table occupies row blocks [row_blk_start, row_blk_start + row_blk_inc],
                                                                 inclusive */
        uint32_t row_blk_start         : 6;  /**< [  5:  0](R/W) Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
#else /* Word 0 - Little Endian */
        uint32_t row_blk_start         : 6;  /**< [  5:  0](R/W) Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
        uint32_t row_blk_inc           : 6;  /**< [ 11:  6](R/W) Each table occupies row blocks [row_blk_start, row_blk_start + row_blk_inc],
                                                                 inclusive */
        uint32_t pool                  : 3;  /**< [ 14: 12](R/W) Pool ID out of the 8 pools, which this table resides. */
        uint32_t data_size             : 4;  /**< [ 18: 15](R/W) 0x2:     64-bit
                                                                 0x4:     128-bit
                                                                 0x8:     256-bit
                                                                 0x9(\>8): 512-bit */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urw_tbl_urwx_s cn; */
};
typedef union bdk_tns_se_urw_tbl_urwx bdk_tns_se_urw_tbl_urwx_t;

static inline uint64_t BDK_TNS_SE_URW_TBL_URWX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URW_TBL_URWX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=31))
        return 0x842056109800ll + 4ll * ((a) & 0x1f);
    __bdk_csr_fatal("TNS_SE_URW_TBL_URWX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URW_TBL_URWX(a) bdk_tns_se_urw_tbl_urwx_t
#define bustype_BDK_TNS_SE_URW_TBL_URWX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URW_TBL_URWX(a) "TNS_SE_URW_TBL_URWX"
#define device_bar_BDK_TNS_SE_URW_TBL_URWX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URW_TBL_URWX(a) (a)
#define arguments_BDK_TNS_SE_URW_TBL_URWX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwcmd#_lock
 *
 * TNS Search URW Command Lock Registers
 * Lock Register
 */
union bdk_tns_se_urwcmdx_lock
{
    uint32_t u;
    struct bdk_tns_se_urwcmdx_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwcmdx_lock_s cn; */
};
typedef union bdk_tns_se_urwcmdx_lock bdk_tns_se_urwcmdx_lock_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_LOCK(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_LOCK(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842056105300ll + 0x1000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SE_URWCMDX_LOCK", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWCMDX_LOCK(a) bdk_tns_se_urwcmdx_lock_t
#define bustype_BDK_TNS_SE_URWCMDX_LOCK(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWCMDX_LOCK(a) "TNS_SE_URWCMDX_LOCK"
#define device_bar_BDK_TNS_SE_URWCMDX_LOCK(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWCMDX_LOCK(a) (a)
#define arguments_BDK_TNS_SE_URWCMDX_LOCK(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwcmd#_spad
 *
 * TNS Search URW Command ScratchPad Registers
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_urwcmdx_spad
{
    uint32_t u;
    struct bdk_tns_se_urwcmdx_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwcmdx_spad_s cn; */
};
typedef union bdk_tns_se_urwcmdx_spad bdk_tns_se_urwcmdx_spad_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SPAD(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SPAD(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x842056105304ll + 0x1000ll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_SE_URWCMDX_SPAD", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWCMDX_SPAD(a) bdk_tns_se_urwcmdx_spad_t
#define bustype_BDK_TNS_SE_URWCMDX_SPAD(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWCMDX_SPAD(a) "TNS_SE_URWCMDX_SPAD"
#define device_bar_BDK_TNS_SE_URWCMDX_SPAD(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWCMDX_SPAD(a) (a)
#define arguments_BDK_TNS_SE_URWCMDX_SPAD(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwcmd#_srch_cmd#_w0
 *
 * TNS Search URW Command Search Command Word 0 Registers
 * Search command configuration, command 4*i through 4*i+3 constitute search
 * profile i.
 * URW j in [0..1] can request for search profiel j*8 through j*8+7.
 * MRE can request for search profile 16 through 23
 * More Explanation (Let's use URW/MRE as example. LDE is similar):
 * Each instantiated block in this XML has 64 commands and we instantiate
 * two blocks for a total of 128 cmd registers.
 * Of these 128 registers:
 * - 32 are for URWVIF (00 to 31)
 * - 32 are for URWINS (32 to 63)
 * - 32 are for MRE (64 to 95)
 * - 32 are unused
 * Each incoming request can have upto 8 profiles and 4 commands. So that's
 * why 32 (i.e. 8x4).
 * So the mapping is
 * {..........P1C3,P1C2,P1C1,P1C0,P0C3,P0C2,P0C1,P0C0} where Px = Profile X, and
 * Cy = Command Y.
 * So for example URWINS starts at 32 and if it's command 3 of profile 0
 * then it has to be urw_cmd = 35.
 */
union bdk_tns_se_urwcmdx_srch_cmdx_w0
{
    uint32_t u;
    struct bdk_tns_se_urwcmdx_srch_cmdx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key_byte_bmp          : 11; /**< [ 31: 21](R/W) bitmap for forming search key out of the 384-bit (48-Byte) input key.
                                                                 bit 0-15: mask for byte selection
                                                                 bit 16-47: reserved, i.e. only lower 16-bytes of input master key
                                                                 are used to form search key. */
        uint32_t key_size              : 6;  /**< [ 20: 15](R/W) in unit of byte */
        uint32_t ecmp_en               : 1;  /**< [ 14: 14](R/W) Enable ECMP, applicable only for LPM search command. */
        uint32_t ecmp_hash_byte_start  : 6;  /**< [ 13:  8](R/W) rout_idx is always 2-byte long, and it is applicable only for LPM search
                                                                 command. */
        uint32_t hash_way_cnt          : 4;  /**< [  7:  4](R/W) Applicable only for hash search command. */
        uint32_t adm_id                : 4;  /**< [  3:  0](R/W) see same field of xp_se_lde_search_command register (URW/MRE only do direct
                                                                 lookups). */
#else /* Word 0 - Little Endian */
        uint32_t adm_id                : 4;  /**< [  3:  0](R/W) see same field of xp_se_lde_search_command register (URW/MRE only do direct
                                                                 lookups). */
        uint32_t hash_way_cnt          : 4;  /**< [  7:  4](R/W) Applicable only for hash search command. */
        uint32_t ecmp_hash_byte_start  : 6;  /**< [ 13:  8](R/W) rout_idx is always 2-byte long, and it is applicable only for LPM search
                                                                 command. */
        uint32_t ecmp_en               : 1;  /**< [ 14: 14](R/W) Enable ECMP, applicable only for LPM search command. */
        uint32_t key_size              : 6;  /**< [ 20: 15](R/W) in unit of byte */
        uint32_t key_byte_bmp          : 11; /**< [ 31: 21](R/W) bitmap for forming search key out of the 384-bit (48-Byte) input key.
                                                                 bit 0-15: mask for byte selection
                                                                 bit 16-47: reserved, i.e. only lower 16-bytes of input master key
                                                                 are used to form search key. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwcmdx_srch_cmdx_w0_s cn; */
};
typedef union bdk_tns_se_urwcmdx_srch_cmdx_w0 bdk_tns_se_urwcmdx_srch_cmdx_w0_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=63)))
        return 0x842056105000ll + 0x1000ll * ((a) & 0x1) + 0xcll * ((b) & 0x3f);
    __bdk_csr_fatal("TNS_SE_URWCMDX_SRCH_CMDX_W0", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(a,b) bdk_tns_se_urwcmdx_srch_cmdx_w0_t
#define bustype_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(a,b) "TNS_SE_URWCMDX_SRCH_CMDX_W0"
#define device_bar_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(a,b) (a)
#define arguments_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_urwcmd#_srch_cmd#_w1
 *
 * TNS Search URW Command Search Command Word 1 Registers
 * Continuation of structure defined in TNS_SE_URWCMD(0..1)_SRCH_CMD(0..63)_W0
 */
union bdk_tns_se_urwcmdx_srch_cmdx_w1
{
    uint32_t u;
    struct bdk_tns_se_urwcmdx_srch_cmdx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key_byte_bmp          : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key_byte_bmp          : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwcmdx_srch_cmdx_w1_s cn; */
};
typedef union bdk_tns_se_urwcmdx_srch_cmdx_w1 bdk_tns_se_urwcmdx_srch_cmdx_w1_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=63)))
        return 0x842056105004ll + 0x1000ll * ((a) & 0x1) + 0xcll * ((b) & 0x3f);
    __bdk_csr_fatal("TNS_SE_URWCMDX_SRCH_CMDX_W1", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(a,b) bdk_tns_se_urwcmdx_srch_cmdx_w1_t
#define bustype_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(a,b) "TNS_SE_URWCMDX_SRCH_CMDX_W1"
#define device_bar_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(a,b) (a)
#define arguments_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_urwcmd#_srch_cmd#_w2
 *
 * TNS Search URW Command Search Command Word 2 Registers
 * Continuation of structure defined in TNS_SE_URWCMD(0..1)_SRCH_CMD(0..63)_W0
 */
union bdk_tns_se_urwcmdx_srch_cmdx_w2
{
    uint32_t u;
    struct bdk_tns_se_urwcmdx_srch_cmdx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t lpm_load_balance      : 1;  /**< [ 24: 24](R/W) Not used for URW command, retained to be format compatible with
                                                                 xp_se_lde_search_command */
        uint32_t table_id              : 8;  /**< [ 23: 16](R/W) Allowed value: 128-159, direct access only
                                                                 Table ID determines search command type as well as the exact table
                                                                 configuration
                                                                 There are only 32 table defined for URW and MRE, the higher-bits of
                                                                 table_id are used to identify */
        uint32_t rslt_qw_start         : 5;  /**< [ 15: 11](R/W) The total result of a profile is maximum 512-bit, divided into 8 64-bit quad-
                                                                 word
                                                                 The result for this search command is quad-word qw_start to
                                                                 qw_start+qw_inc, inclusive
                                                                 For URWVIF, there are 8 physical result lanes, maximum 16 QW, the
                                                                 restrictions are:
                                                                 1. for 512-bit result, rslt_qw_start can only be 0 or 8.
                                                                 2. for 256-bit result, rslt_qw_start can only be 0, 4, 8 or 12.
                                                                 3. for 128-bit result, rslt_qw_start can NOT be 3, 7 or 11.
                                                                 4. No restriction for 64 or 32-bit return data. */
        uint32_t rslt_qw_inc           : 4;  /**< [ 10:  7](R/W) -- */
        uint32_t regrettable           : 1;  /**< [  6:  6](R/W) a regrettable search command may return sorry only if SE experiences
                                                                 congestions. */
        uint32_t age_en                : 1;  /**< [  5:  5](R/W) enable age marking of the entry if hit */
        uint32_t key_byte_bmp          : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key_byte_bmp          : 5;  /**< [  4:  0](R/W) Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
        uint32_t age_en                : 1;  /**< [  5:  5](R/W) enable age marking of the entry if hit */
        uint32_t regrettable           : 1;  /**< [  6:  6](R/W) a regrettable search command may return sorry only if SE experiences
                                                                 congestions. */
        uint32_t rslt_qw_inc           : 4;  /**< [ 10:  7](R/W) -- */
        uint32_t rslt_qw_start         : 5;  /**< [ 15: 11](R/W) The total result of a profile is maximum 512-bit, divided into 8 64-bit quad-
                                                                 word
                                                                 The result for this search command is quad-word qw_start to
                                                                 qw_start+qw_inc, inclusive
                                                                 For URWVIF, there are 8 physical result lanes, maximum 16 QW, the
                                                                 restrictions are:
                                                                 1. for 512-bit result, rslt_qw_start can only be 0 or 8.
                                                                 2. for 256-bit result, rslt_qw_start can only be 0, 4, 8 or 12.
                                                                 3. for 128-bit result, rslt_qw_start can NOT be 3, 7 or 11.
                                                                 4. No restriction for 64 or 32-bit return data. */
        uint32_t table_id              : 8;  /**< [ 23: 16](R/W) Allowed value: 128-159, direct access only
                                                                 Table ID determines search command type as well as the exact table
                                                                 configuration
                                                                 There are only 32 table defined for URW and MRE, the higher-bits of
                                                                 table_id are used to identify */
        uint32_t lpm_load_balance      : 1;  /**< [ 24: 24](R/W) Not used for URW command, retained to be format compatible with
                                                                 xp_se_lde_search_command */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwcmdx_srch_cmdx_w2_s cn; */
};
typedef union bdk_tns_se_urwcmdx_srch_cmdx_w2 bdk_tns_se_urwcmdx_srch_cmdx_w2_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1) && (b<=63)))
        return 0x842056105008ll + 0x1000ll * ((a) & 0x1) + 0xcll * ((b) & 0x3f);
    __bdk_csr_fatal("TNS_SE_URWCMDX_SRCH_CMDX_W2", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(a,b) bdk_tns_se_urwcmdx_srch_cmdx_w2_t
#define bustype_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(a,b) "TNS_SE_URWCMDX_SRCH_CMDX_W2"
#define device_bar_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(a,b) (a)
#define arguments_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_se_urwif_dbg
 *
 * TNS Search URW Interface Debug Register
 * --
 */
union bdk_tns_se_urwif_dbg
{
    uint32_t u;
    struct bdk_tns_se_urwif_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t intf_bypass           : 9;  /**< [ 25: 17](R/W) if set, the corresponding interface immediately return miss for all commands */
        uint32_t intf_disable          : 9;  /**< [ 16:  8](R/W) if set, the corresponding interface desert req_fc_n and rejecting all future
                                                                 requests */
        uint32_t req_log               : 4;  /**< [  7:  4](R/W) Status register to log last search reuqest from that interface
                                                                 0-3 for URW INS interface
                                                                 4-7 for URW VIF interface
                                                                 8 for MRE interface */
        uint32_t rslt_log              : 4;  /**< [  3:  0](R/W) Status register to log last returned search result from that interface
                                                                 0-3 for URW INS interface
                                                                 4-7 for URW VIF interface
                                                                 8 for MRE interface */
#else /* Word 0 - Little Endian */
        uint32_t rslt_log              : 4;  /**< [  3:  0](R/W) Status register to log last returned search result from that interface
                                                                 0-3 for URW INS interface
                                                                 4-7 for URW VIF interface
                                                                 8 for MRE interface */
        uint32_t req_log               : 4;  /**< [  7:  4](R/W) Status register to log last search reuqest from that interface
                                                                 0-3 for URW INS interface
                                                                 4-7 for URW VIF interface
                                                                 8 for MRE interface */
        uint32_t intf_disable          : 9;  /**< [ 16:  8](R/W) if set, the corresponding interface desert req_fc_n and rejecting all future
                                                                 requests */
        uint32_t intf_bypass           : 9;  /**< [ 25: 17](R/W) if set, the corresponding interface immediately return miss for all commands */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_dbg_s cn; */
};
typedef union bdk_tns_se_urwif_dbg bdk_tns_se_urwif_dbg_t;

#define BDK_TNS_SE_URWIF_DBG BDK_TNS_SE_URWIF_DBG_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_DBG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056100000ll;
    __bdk_csr_fatal("TNS_SE_URWIF_DBG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_DBG bdk_tns_se_urwif_dbg_t
#define bustype_BDK_TNS_SE_URWIF_DBG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_DBG "TNS_SE_URWIF_DBG"
#define device_bar_BDK_TNS_SE_URWIF_DBG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_DBG 0
#define arguments_BDK_TNS_SE_URWIF_DBG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_dbg_sel
 *
 * TNS Search URW Interface Debug Selector Register
 * --
 */
union bdk_tns_se_urwif_dbg_sel
{
    uint32_t u;
    struct bdk_tns_se_urwif_dbg_sel_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t urwif_dbg_sel         : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else /* Word 0 - Little Endian */
        uint32_t urwif_dbg_sel         : 32; /**< [ 31:  0](R/W) SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_dbg_sel_s cn; */
};
typedef union bdk_tns_se_urwif_dbg_sel bdk_tns_se_urwif_dbg_sel_t;

#define BDK_TNS_SE_URWIF_DBG_SEL BDK_TNS_SE_URWIF_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_DBG_SEL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056100074ll;
    __bdk_csr_fatal("TNS_SE_URWIF_DBG_SEL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_DBG_SEL bdk_tns_se_urwif_dbg_sel_t
#define bustype_BDK_TNS_SE_URWIF_DBG_SEL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_DBG_SEL "TNS_SE_URWIF_DBG_SEL"
#define device_bar_BDK_TNS_SE_URWIF_DBG_SEL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_DBG_SEL 0
#define arguments_BDK_TNS_SE_URWIF_DBG_SEL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_lock
 *
 * TNS Search URW Interface Lock Register
 * Lock Register
 */
union bdk_tns_se_urwif_lock
{
    uint32_t u;
    struct bdk_tns_se_urwif_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_lock_s cn; */
};
typedef union bdk_tns_se_urwif_lock bdk_tns_se_urwif_lock_t;

#define BDK_TNS_SE_URWIF_LOCK BDK_TNS_SE_URWIF_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056100078ll;
    __bdk_csr_fatal("TNS_SE_URWIF_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_LOCK bdk_tns_se_urwif_lock_t
#define bustype_BDK_TNS_SE_URWIF_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_LOCK "TNS_SE_URWIF_LOCK"
#define device_bar_BDK_TNS_SE_URWIF_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_LOCK 0
#define arguments_BDK_TNS_SE_URWIF_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_req_dbg_w0
 *
 * TNS Search URW Interface Request Debug Word 0 Register
 * --
 */
union bdk_tns_se_urwif_req_dbg_w0
{
    uint32_t u;
    struct bdk_tns_se_urwif_req_dbg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 7;  /**< [ 31: 25](RO/H) -- */
        uint32_t req_id                : 6;  /**< [ 24: 19](RO/H) -- */
        uint32_t unused_tmp            : 19; /**< [ 18:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t unused_tmp            : 19; /**< [ 18:  0](RO/H) -- */
        uint32_t req_id                : 6;  /**< [ 24: 19](RO/H) -- */
        uint32_t key                   : 7;  /**< [ 31: 25](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_req_dbg_w0_s cn; */
};
typedef union bdk_tns_se_urwif_req_dbg_w0 bdk_tns_se_urwif_req_dbg_w0_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W0 BDK_TNS_SE_URWIF_REQ_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056100004ll;
    __bdk_csr_fatal("TNS_SE_URWIF_REQ_DBG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W0 bdk_tns_se_urwif_req_dbg_w0_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W0 "TNS_SE_URWIF_REQ_DBG_W0"
#define device_bar_BDK_TNS_SE_URWIF_REQ_DBG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W0 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_req_dbg_w1
 *
 * TNS Search URW Interface Request Debug Word 1 Register
 * Continuation of structure defined in TNS_SE_URWIF_REQ_DBG_W0
 */
union bdk_tns_se_urwif_req_dbg_w1
{
    uint32_t u;
    struct bdk_tns_se_urwif_req_dbg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_req_dbg_w1_s cn; */
};
typedef union bdk_tns_se_urwif_req_dbg_w1 bdk_tns_se_urwif_req_dbg_w1_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W1 BDK_TNS_SE_URWIF_REQ_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056100008ll;
    __bdk_csr_fatal("TNS_SE_URWIF_REQ_DBG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W1 bdk_tns_se_urwif_req_dbg_w1_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W1 "TNS_SE_URWIF_REQ_DBG_W1"
#define device_bar_BDK_TNS_SE_URWIF_REQ_DBG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W1 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_req_dbg_w2
 *
 * TNS Search URW Interface Request Debug Word 2 Register
 * Continuation of structure defined in TNS_SE_URWIF_REQ_DBG_W0
 */
union bdk_tns_se_urwif_req_dbg_w2
{
    uint32_t u;
    struct bdk_tns_se_urwif_req_dbg_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_req_dbg_w2_s cn; */
};
typedef union bdk_tns_se_urwif_req_dbg_w2 bdk_tns_se_urwif_req_dbg_w2_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W2 BDK_TNS_SE_URWIF_REQ_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205610000cll;
    __bdk_csr_fatal("TNS_SE_URWIF_REQ_DBG_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W2 bdk_tns_se_urwif_req_dbg_w2_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W2 "TNS_SE_URWIF_REQ_DBG_W2"
#define device_bar_BDK_TNS_SE_URWIF_REQ_DBG_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W2 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_req_dbg_w3
 *
 * TNS Search URW Interface Request Debug Word 3 Register
 * Continuation of structure defined in TNS_SE_URWIF_REQ_DBG_W0
 */
union bdk_tns_se_urwif_req_dbg_w3
{
    uint32_t u;
    struct bdk_tns_se_urwif_req_dbg_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t profile_id            : 7;  /**< [ 31: 25](RO/H) -- */
        uint32_t key                   : 25; /**< [ 24:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t key                   : 25; /**< [ 24:  0](RO/H) Continuation of MSBs of field KEY from previous word. */
        uint32_t profile_id            : 7;  /**< [ 31: 25](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_req_dbg_w3_s cn; */
};
typedef union bdk_tns_se_urwif_req_dbg_w3 bdk_tns_se_urwif_req_dbg_w3_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W3 BDK_TNS_SE_URWIF_REQ_DBG_W3_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842056100010ll;
    __bdk_csr_fatal("TNS_SE_URWIF_REQ_DBG_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W3 bdk_tns_se_urwif_req_dbg_w3_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W3 "TNS_SE_URWIF_REQ_DBG_W3"
#define device_bar_BDK_TNS_SE_URWIF_REQ_DBG_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W3 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_rslt_dbg#_w0
 *
 * TNS Search URW Interface Result Debug Word 0 Registers
 * --
 */
union bdk_tns_se_urwif_rslt_dbgx_w0
{
    uint32_t u;
    struct bdk_tns_se_urwif_rslt_dbgx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_rslt_dbgx_w0_s cn; */
};
typedef union bdk_tns_se_urwif_rslt_dbgx_w0 bdk_tns_se_urwif_rslt_dbgx_w0_t;

static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056100014ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_URWIF_RSLT_DBGX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(a) bdk_tns_se_urwif_rslt_dbgx_w0_t
#define bustype_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(a) "TNS_SE_URWIF_RSLT_DBGX_W0"
#define device_bar_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(a) (a)
#define arguments_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_rslt_dbg#_w1
 *
 * TNS Search URW Interface Result Debug Word 1 Registers
 * Continuation of structure defined in TNS_SE_URWIF_RSLT_DBG(0..7)_W0
 */
union bdk_tns_se_urwif_rslt_dbgx_w1
{
    uint32_t u;
    struct bdk_tns_se_urwif_rslt_dbgx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field DATA from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](RO/H) Continuation of MSBs of field DATA from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_rslt_dbgx_w1_s cn; */
};
typedef union bdk_tns_se_urwif_rslt_dbgx_w1 bdk_tns_se_urwif_rslt_dbgx_w1_t;

static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x842056100018ll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_URWIF_RSLT_DBGX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(a) bdk_tns_se_urwif_rslt_dbgx_w1_t
#define bustype_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(a) "TNS_SE_URWIF_RSLT_DBGX_W1"
#define device_bar_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(a) (a)
#define arguments_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_rslt_dbg#_w2
 *
 * TNS Search URW Interface Result Debug Word 2 Registers
 * Continuation of structure defined in TNS_SE_URWIF_RSLT_DBG(0..7)_W0
 */
union bdk_tns_se_urwif_rslt_dbgx_w2
{
    uint32_t u;
    struct bdk_tns_se_urwif_rslt_dbgx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t req_id                : 6;  /**< [ 31: 26](RO/H) -- */
        uint32_t sorry                 : 1;  /**< [ 25: 25](RO/H) -- */
        uint32_t hit                   : 1;  /**< [ 24: 24](RO/H) -- */
        uint32_t hit_addr              : 24; /**< [ 23:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t hit_addr              : 24; /**< [ 23:  0](RO/H) -- */
        uint32_t hit                   : 1;  /**< [ 24: 24](RO/H) -- */
        uint32_t sorry                 : 1;  /**< [ 25: 25](RO/H) -- */
        uint32_t req_id                : 6;  /**< [ 31: 26](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_rslt_dbgx_w2_s cn; */
};
typedef union bdk_tns_se_urwif_rslt_dbgx_w2 bdk_tns_se_urwif_rslt_dbgx_w2_t;

static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x84205610001cll + 0xcll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_SE_URWIF_RSLT_DBGX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(a) bdk_tns_se_urwif_rslt_dbgx_w2_t
#define bustype_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(a) "TNS_SE_URWIF_RSLT_DBGX_W2"
#define device_bar_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(a) (a)
#define arguments_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_se_urwif_spad
 *
 * TNS Search URW Interface ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_se_urwif_spad
{
    uint32_t u;
    struct bdk_tns_se_urwif_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_se_urwif_spad_s cn; */
};
typedef union bdk_tns_se_urwif_spad bdk_tns_se_urwif_spad_t;

#define BDK_TNS_SE_URWIF_SPAD BDK_TNS_SE_URWIF_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84205610007cll;
    __bdk_csr_fatal("TNS_SE_URWIF_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_SE_URWIF_SPAD bdk_tns_se_urwif_spad_t
#define bustype_BDK_TNS_SE_URWIF_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_SE_URWIF_SPAD "TNS_SE_URWIF_SPAD"
#define device_bar_BDK_TNS_SE_URWIF_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_SE_URWIF_SPAD 0
#define arguments_BDK_TNS_SE_URWIF_SPAD -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cfg_spare
 *
 * TNS TxQ Configuration Spare Register
 * Spare register with default signature value 0x210FEDCBA9876543 after reset.
 */
union bdk_tns_txq_cfg_spare
{
    uint64_t u;
    struct bdk_tns_txq_cfg_spare_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t spare                 : 64; /**< [ 63:  0](R/W) Spare field. */
#else /* Word 0 - Little Endian */
        uint64_t spare                 : 64; /**< [ 63:  0](R/W) Spare field. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cfg_spare_s cn; */
};
typedef union bdk_tns_txq_cfg_spare bdk_tns_txq_cfg_spare_t;

#define BDK_TNS_TXQ_CFG_SPARE BDK_TNS_TXQ_CFG_SPARE_FUNC()
static inline uint64_t BDK_TNS_TXQ_CFG_SPARE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CFG_SPARE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684910ll;
    __bdk_csr_fatal("TNS_TXQ_CFG_SPARE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CFG_SPARE bdk_tns_txq_cfg_spare_t
#define bustype_BDK_TNS_TXQ_CFG_SPARE BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CFG_SPARE "TNS_TXQ_CFG_SPARE"
#define device_bar_BDK_TNS_TXQ_CFG_SPARE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CFG_SPARE 0
#define arguments_BDK_TNS_TXQ_CFG_SPARE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_ct_go_neg_cfg
 *
 * TNS TxQ CNT Count Go Negative Configuration Register
 * Configuration to allow counters to go negative or saturate at 0 in RTL.
 * Setting to '1' allows the counter to go negative
 */
union bdk_tns_txq_cnt_ct_go_neg_cfg
{
    uint32_t u;
    struct bdk_tns_txq_cnt_ct_go_neg_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t q_length_negative     : 1;  /**< [  6:  6](R/W) -- */
        uint32_t h1_length_negative    : 1;  /**< [  5:  5](R/W) -- */
        uint32_t pt_length_negative    : 1;  /**< [  4:  4](R/W) -- */
        uint32_t pfc_mc_ct_negative    : 1;  /**< [  3:  3](R/W) -- */
        uint32_t pfc_cluster_ct_negative : 1;/**< [  2:  2](R/W) -- */
        uint32_t pfc_tc_ct_negative    : 1;  /**< [  1:  1](R/W) -- */
        uint32_t pfc_ct_negative       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pfc_ct_negative       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t pfc_tc_ct_negative    : 1;  /**< [  1:  1](R/W) -- */
        uint32_t pfc_cluster_ct_negative : 1;/**< [  2:  2](R/W) -- */
        uint32_t pfc_mc_ct_negative    : 1;  /**< [  3:  3](R/W) -- */
        uint32_t pt_length_negative    : 1;  /**< [  4:  4](R/W) -- */
        uint32_t h1_length_negative    : 1;  /**< [  5:  5](R/W) -- */
        uint32_t q_length_negative     : 1;  /**< [  6:  6](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_ct_go_neg_cfg_s cn; */
};
typedef union bdk_tns_txq_cnt_ct_go_neg_cfg bdk_tns_txq_cnt_ct_go_neg_cfg_t;

#define BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cb4ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_CT_GO_NEG_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG bdk_tns_txq_cnt_ct_go_neg_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG "TNS_TXQ_CNT_CT_GO_NEG_CFG"
#define device_bar_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_ecc_ctl
 *
 * TNS TxQ CNT ECC Control Register
 * ECC configuration of TxQ Counters memories
 */
union bdk_tns_txq_cnt_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_cnt_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t h1_drop_len_db_ecc    : 1;  /**< [ 29: 29](R/W) Flip 2 bits of ECC syndrome in H1 drop length memory */
        uint32_t h1_drop_len_sb_ecc    : 1;  /**< [ 28: 28](R/W) Flip 1 bit of ECC syndrome in H1 drop length memory */
        uint32_t h1_drop_len_ecc_dis   : 1;  /**< [ 27: 27](R/W) Disable ECC for H1 drop length memory */
        uint32_t h1_drop_pkt_db_ecc    : 1;  /**< [ 26: 26](R/W) Flip 2 bits of ECC syndrome in H1 drop packet memory */
        uint32_t h1_drop_pkt_sb_ecc    : 1;  /**< [ 25: 25](R/W) Flip 1 bit of ECC syndrome in H1 drop packet memory */
        uint32_t h1_drop_pkt_ecc_dis   : 1;  /**< [ 24: 24](R/W) Disable ECC for H1 drop packet memory */
        uint32_t h1_fwd_len_db_ecc     : 1;  /**< [ 23: 23](R/W) Flip 2 bits of ECC syndrome in H1 forward length memory */
        uint32_t h1_fwd_len_sb_ecc     : 1;  /**< [ 22: 22](R/W) Flip 1 bit of ECC syndrome in H1 forward length memory */
        uint32_t h1_fwd_len_ecc_dis    : 1;  /**< [ 21: 21](R/W) Disable ECC for H1 forward length memory */
        uint32_t h1_fwd_pkt_db_ecc     : 1;  /**< [ 20: 20](R/W) Flip 2 bits of ECC syndrome in H1 forward packet memory */
        uint32_t h1_fwd_pkt_sb_ecc     : 1;  /**< [ 19: 19](R/W) Flip 1 bit of ECC syndrome in H1 forward packet memory */
        uint32_t h1_fwd_pkt_ecc_dis    : 1;  /**< [ 18: 18](R/W) Disable ECC for H1 forward packet memory */
        uint32_t q_drop_len_db_ecc     : 1;  /**< [ 17: 17](R/W) Flip 2 bits of ECC syndrome in Q drop length memory */
        uint32_t q_drop_len_sb_ecc     : 1;  /**< [ 16: 16](R/W) Flip 1 bit of ECC syndrome in Q drop length memory */
        uint32_t q_drop_len_ecc_dis    : 1;  /**< [ 15: 15](R/W) Disable ECC for Q drop length memory */
        uint32_t q_drop_pkt_db_ecc     : 1;  /**< [ 14: 14](R/W) Flip 2 bits of ECC syndrome in Q drop packet memory */
        uint32_t q_drop_pkt_sb_ecc     : 1;  /**< [ 13: 13](R/W) Flip 1 bit of ECC syndrome in Q drop packet memory */
        uint32_t q_drop_pkt_ecc_dis    : 1;  /**< [ 12: 12](R/W) Disable ECC for Q drop packet memory */
        uint32_t q_fwd_len_db_ecc      : 1;  /**< [ 11: 11](R/W) Flip 2 bits of ECC syndrome in Q forward length memory */
        uint32_t q_fwd_len_sb_ecc      : 1;  /**< [ 10: 10](R/W) Flip 1 bit of ECC syndrome in Q forward length memory */
        uint32_t q_fwd_len_ecc_dis     : 1;  /**< [  9:  9](R/W) Disable ECC for Q forward length memory */
        uint32_t q_fwd_pkt_db_ecc      : 1;  /**< [  8:  8](R/W) Flip 2 bits of ECC syndrome in Q forward packet memory */
        uint32_t q_fwd_pkt_sb_ecc      : 1;  /**< [  7:  7](R/W) Flip 1 bit of ECC syndrome in Q forward packet memory */
        uint32_t q_fwd_pkt_ecc_dis     : 1;  /**< [  6:  6](R/W) Disable ECC for Q forward packet memory */
        uint32_t q_old_len_db_ecc      : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in Q old length memory */
        uint32_t q_old_len_sb_ecc      : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in Q old length memory */
        uint32_t q_old_len_ecc_dis     : 1;  /**< [  3:  3](R/W) Disable ECC for Q old length memory */
        uint32_t q_avg_len_db_ecc      : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in Q average length memory */
        uint32_t q_avg_len_sb_ecc      : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in Q average length memory */
        uint32_t q_avg_len_ecc_dis     : 1;  /**< [  0:  0](R/W) Disable ECC for Q average length memory */
#else /* Word 0 - Little Endian */
        uint32_t q_avg_len_ecc_dis     : 1;  /**< [  0:  0](R/W) Disable ECC for Q average length memory */
        uint32_t q_avg_len_sb_ecc      : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in Q average length memory */
        uint32_t q_avg_len_db_ecc      : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in Q average length memory */
        uint32_t q_old_len_ecc_dis     : 1;  /**< [  3:  3](R/W) Disable ECC for Q old length memory */
        uint32_t q_old_len_sb_ecc      : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in Q old length memory */
        uint32_t q_old_len_db_ecc      : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in Q old length memory */
        uint32_t q_fwd_pkt_ecc_dis     : 1;  /**< [  6:  6](R/W) Disable ECC for Q forward packet memory */
        uint32_t q_fwd_pkt_sb_ecc      : 1;  /**< [  7:  7](R/W) Flip 1 bit of ECC syndrome in Q forward packet memory */
        uint32_t q_fwd_pkt_db_ecc      : 1;  /**< [  8:  8](R/W) Flip 2 bits of ECC syndrome in Q forward packet memory */
        uint32_t q_fwd_len_ecc_dis     : 1;  /**< [  9:  9](R/W) Disable ECC for Q forward length memory */
        uint32_t q_fwd_len_sb_ecc      : 1;  /**< [ 10: 10](R/W) Flip 1 bit of ECC syndrome in Q forward length memory */
        uint32_t q_fwd_len_db_ecc      : 1;  /**< [ 11: 11](R/W) Flip 2 bits of ECC syndrome in Q forward length memory */
        uint32_t q_drop_pkt_ecc_dis    : 1;  /**< [ 12: 12](R/W) Disable ECC for Q drop packet memory */
        uint32_t q_drop_pkt_sb_ecc     : 1;  /**< [ 13: 13](R/W) Flip 1 bit of ECC syndrome in Q drop packet memory */
        uint32_t q_drop_pkt_db_ecc     : 1;  /**< [ 14: 14](R/W) Flip 2 bits of ECC syndrome in Q drop packet memory */
        uint32_t q_drop_len_ecc_dis    : 1;  /**< [ 15: 15](R/W) Disable ECC for Q drop length memory */
        uint32_t q_drop_len_sb_ecc     : 1;  /**< [ 16: 16](R/W) Flip 1 bit of ECC syndrome in Q drop length memory */
        uint32_t q_drop_len_db_ecc     : 1;  /**< [ 17: 17](R/W) Flip 2 bits of ECC syndrome in Q drop length memory */
        uint32_t h1_fwd_pkt_ecc_dis    : 1;  /**< [ 18: 18](R/W) Disable ECC for H1 forward packet memory */
        uint32_t h1_fwd_pkt_sb_ecc     : 1;  /**< [ 19: 19](R/W) Flip 1 bit of ECC syndrome in H1 forward packet memory */
        uint32_t h1_fwd_pkt_db_ecc     : 1;  /**< [ 20: 20](R/W) Flip 2 bits of ECC syndrome in H1 forward packet memory */
        uint32_t h1_fwd_len_ecc_dis    : 1;  /**< [ 21: 21](R/W) Disable ECC for H1 forward length memory */
        uint32_t h1_fwd_len_sb_ecc     : 1;  /**< [ 22: 22](R/W) Flip 1 bit of ECC syndrome in H1 forward length memory */
        uint32_t h1_fwd_len_db_ecc     : 1;  /**< [ 23: 23](R/W) Flip 2 bits of ECC syndrome in H1 forward length memory */
        uint32_t h1_drop_pkt_ecc_dis   : 1;  /**< [ 24: 24](R/W) Disable ECC for H1 drop packet memory */
        uint32_t h1_drop_pkt_sb_ecc    : 1;  /**< [ 25: 25](R/W) Flip 1 bit of ECC syndrome in H1 drop packet memory */
        uint32_t h1_drop_pkt_db_ecc    : 1;  /**< [ 26: 26](R/W) Flip 2 bits of ECC syndrome in H1 drop packet memory */
        uint32_t h1_drop_len_ecc_dis   : 1;  /**< [ 27: 27](R/W) Disable ECC for H1 drop length memory */
        uint32_t h1_drop_len_sb_ecc    : 1;  /**< [ 28: 28](R/W) Flip 1 bit of ECC syndrome in H1 drop length memory */
        uint32_t h1_drop_len_db_ecc    : 1;  /**< [ 29: 29](R/W) Flip 2 bits of ECC syndrome in H1 drop length memory */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_cnt_ecc_ctl bdk_tns_txq_cnt_ecc_ctl_t;

#define BDK_TNS_TXQ_CNT_ECC_CTL BDK_TNS_TXQ_CNT_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c60ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_ECC_CTL bdk_tns_txq_cnt_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_CNT_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_ECC_CTL "TNS_TXQ_CNT_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_CNT_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_CNT_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_gbl_mcfc_off
 *
 * TNS TxQ CNT Force Global Multi-cast Flow Control Off Register
 * Configuration to force global Multiple copy flow control off
 */
union bdk_tns_txq_cnt_frc_gbl_mcfc_off
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_gbl_mcfc_off_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_gbl_mcfc_off_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_gbl_mcfc_off bdk_tns_txq_cnt_frc_gbl_mcfc_off_t;

#define BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9dd8ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_GBL_MCFC_OFF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF bdk_tns_txq_cnt_frc_gbl_mcfc_off_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF "TNS_TXQ_CNT_FRC_GBL_MCFC_OFF"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_gbl_mcfc_on
 *
 * TNS TxQ CNT Force Global Multi-cast Flow Control On Register
 * Configuration to force global Multiple copy flow control on
 */
union bdk_tns_txq_cnt_frc_gbl_mcfc_on
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_gbl_mcfc_on_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_gbl_mcfc_on_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_gbl_mcfc_on bdk_tns_txq_cnt_frc_gbl_mcfc_on_t;

#define BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9dd4ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_GBL_MCFC_ON", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON bdk_tns_txq_cnt_frc_gbl_mcfc_on_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON "TNS_TXQ_CNT_FRC_GBL_MCFC_ON"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_pc_pfc_off
 *
 * TNS TxQ CNT Force Port Cluster PFC Off Register
 * Configuration to force PFC off per port cluster.  One bit per port
 */
union bdk_tns_txq_cnt_frc_pc_pfc_off
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_pc_pfc_off_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t data                  : 11; /**< [ 10:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 11; /**< [ 10:  0](R/W) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_pc_pfc_off_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_pc_pfc_off bdk_tns_txq_cnt_frc_pc_pfc_off_t;

#define BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9dc8ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_PC_PFC_OFF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF bdk_tns_txq_cnt_frc_pc_pfc_off_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF "TNS_TXQ_CNT_FRC_PC_PFC_OFF"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_pc_pfc_on
 *
 * TNS TxQ CNT Force Port Cluster PFC On Register
 * Configuration to force PFC on per port cluster. One bit per port
 */
union bdk_tns_txq_cnt_frc_pc_pfc_on
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_pc_pfc_on_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t data                  : 11; /**< [ 10:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 11; /**< [ 10:  0](R/W) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_pc_pfc_on_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_pc_pfc_on bdk_tns_txq_cnt_frc_pc_pfc_on_t;

#define BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9dc4ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_PC_PFC_ON", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON bdk_tns_txq_cnt_frc_pc_pfc_on_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON "TNS_TXQ_CNT_FRC_PC_PFC_ON"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_pfc_off_w#
 *
 * TNS TxQ CNT Force PFC Off Registers
 * Configuration to force PFC off per flow control channel. One bit per FC channel
 * Bits 31..16 of registers ending in _W12 are unused.
 */
union bdk_tns_txq_cnt_frc_pfc_off_wx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_pfc_off_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_pfc_off_wx_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_pfc_off_wx bdk_tns_txq_cnt_frc_pfc_off_wx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=12))
        return 0x8420706d9d90ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_PFC_OFF_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(a) bdk_tns_txq_cnt_frc_pfc_off_wx_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(a) "TNS_TXQ_CNT_FRC_PFC_OFF_WX"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_pfc_on_w#
 *
 * TNS TxQ CNT Force PFC On Registers
 * Configuration to force PFC on per flow control channel.  One bit per FC channel
 * Bits 31..16 of registers ending in _W12 are unused.
 */
union bdk_tns_txq_cnt_frc_pfc_on_wx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_pfc_on_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_pfc_on_wx_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_pfc_on_wx bdk_tns_txq_cnt_frc_pfc_on_wx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=12))
        return 0x8420706d9d5cll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_PFC_ON_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(a) bdk_tns_txq_cnt_frc_pfc_on_wx_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(a) "TNS_TXQ_CNT_FRC_PFC_ON_WX"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_tc_pfc_off
 *
 * TNS TxQ CNT Force Traffic Class PFC Off Register
 * Configuration to force PFC off per traffic class. One bit per TC
 */
union bdk_tns_txq_cnt_frc_tc_pfc_off
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_tc_pfc_off_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_tc_pfc_off_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_tc_pfc_off bdk_tns_txq_cnt_frc_tc_pfc_off_t;

#define BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9dd0ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_TC_PFC_OFF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF bdk_tns_txq_cnt_frc_tc_pfc_off_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF "TNS_TXQ_CNT_FRC_TC_PFC_OFF"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_frc_tc_pfc_on
 *
 * TNS TxQ CNT Force Traffic Class PFC On Register
 * Configuration to force PFC on per traffic class.  One bit per TC
 */
union bdk_tns_txq_cnt_frc_tc_pfc_on
{
    uint32_t u;
    struct bdk_tns_txq_cnt_frc_tc_pfc_on_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t data                  : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_frc_tc_pfc_on_s cn; */
};
typedef union bdk_tns_txq_cnt_frc_tc_pfc_on bdk_tns_txq_cnt_frc_tc_pfc_on_t;

#define BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9dccll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FRC_TC_PFC_ON", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON bdk_tns_txq_cnt_frc_tc_pfc_on_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON "TNS_TXQ_CNT_FRC_TC_PFC_ON"
#define device_bar_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_fw_drp_rdclr_cfg
 *
 * TNS TxQ CNT Forward Drop Read Clear Configuration Register
 * Configuration indicating clear on read functionality for packet and packet
 * length forward and drop counters
 */
union bdk_tns_txq_cnt_fw_drp_rdclr_cfg
{
    uint32_t u;
    struct bdk_tns_txq_cnt_fw_drp_rdclr_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t fwd_pkt_cnt           : 1;  /**< [  3:  3](R/W) -- */
        uint32_t drop_pkt_cnt          : 1;  /**< [  2:  2](R/W) -- */
        uint32_t fwd_len_cnt           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t drop_len_cnt          : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t drop_len_cnt          : 1;  /**< [  0:  0](R/W) -- */
        uint32_t fwd_len_cnt           : 1;  /**< [  1:  1](R/W) -- */
        uint32_t drop_pkt_cnt          : 1;  /**< [  2:  2](R/W) -- */
        uint32_t fwd_pkt_cnt           : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_fw_drp_rdclr_cfg_s cn; */
};
typedef union bdk_tns_txq_cnt_fw_drp_rdclr_cfg bdk_tns_txq_cnt_fw_drp_rdclr_cfg_t;

#define BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cb0ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_FW_DRP_RDCLR_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG bdk_tns_txq_cnt_fw_drp_rdclr_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG "TNS_TXQ_CNT_FW_DRP_RDCLR_CFG"
#define device_bar_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_gbl_mc_ct
 *
 * TNS TxQ CNT Global Multip-cast Count Register
 * Read/write access to global multi-cast count.
 */
union bdk_tns_txq_cnt_gbl_mc_ct
{
    uint32_t u;
    struct bdk_tns_txq_cnt_gbl_mc_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](R/W/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_gbl_mc_ct_s cn; */
};
typedef union bdk_tns_txq_cnt_gbl_mc_ct bdk_tns_txq_cnt_gbl_mc_ct_t;

#define BDK_TNS_TXQ_CNT_GBL_MC_CT BDK_TNS_TXQ_CNT_GBL_MC_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9d58ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_GBL_MC_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_GBL_MC_CT bdk_tns_txq_cnt_gbl_mc_ct_t
#define bustype_BDK_TNS_TXQ_CNT_GBL_MC_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_GBL_MC_CT "TNS_TXQ_CNT_GBL_MC_CT"
#define device_bar_BDK_TNS_TXQ_CNT_GBL_MC_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_GBL_MC_CT 0
#define arguments_BDK_TNS_TXQ_CNT_GBL_MC_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_gbl_mc_thr
 *
 * TNS TxQ CNT Global Multip-cast Threshold Register
 * Provide Xon/Xoff profiles for the global MC count.
 */
union bdk_tns_txq_cnt_gbl_mc_thr
{
    uint32_t u;
    struct bdk_tns_txq_cnt_gbl_mc_thr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t xoff                  : 15; /**< [ 29: 15](R/W) -- */
        uint32_t xon                   : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t xon                   : 15; /**< [ 14:  0](R/W) -- */
        uint32_t xoff                  : 15; /**< [ 29: 15](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_gbl_mc_thr_s cn; */
};
typedef union bdk_tns_txq_cnt_gbl_mc_thr bdk_tns_txq_cnt_gbl_mc_thr_t;

#define BDK_TNS_TXQ_CNT_GBL_MC_THR BDK_TNS_TXQ_CNT_GBL_MC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_THR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9d54ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_GBL_MC_THR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_GBL_MC_THR bdk_tns_txq_cnt_gbl_mc_thr_t
#define bustype_BDK_TNS_TXQ_CNT_GBL_MC_THR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_GBL_MC_THR "TNS_TXQ_CNT_GBL_MC_THR"
#define device_bar_BDK_TNS_TXQ_CNT_GBL_MC_THR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_GBL_MC_THR 0
#define arguments_BDK_TNS_TXQ_CNT_GBL_MC_THR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_h1_dlcm_ecc_log
 *
 * TNS TxQ CNT H1 Dropped Length Counter Memory ECC Log Register
 * H1 dropped length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_h1_dlcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_h1_dlcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_dlcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_dlcm_ecc_log bdk_tns_txq_cnt_h1_dlcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c6cll;
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_DLCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG bdk_tns_txq_cnt_h1_dlcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG "TNS_TXQ_CNT_H1_DLCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_h1_dpcm_ecc_log
 *
 * TNS TxQ CNT H1 Dropped Packet Counter Memory ECC Log Register
 * H1 dropped packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_h1_dpcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_h1_dpcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_dpcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_dpcm_ecc_log bdk_tns_txq_cnt_h1_dpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c68ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_DPCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG bdk_tns_txq_cnt_h1_dpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG "TNS_TXQ_CNT_H1_DPCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_h1_drp_len_ct#
 *
 * TNS TxQ CNT H1 Drop Length Count Registers
 * CPU access to H1 dropped packet byte count memory
 */
union bdk_tns_txq_cnt_h1_drp_len_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_h1_drp_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_drp_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_drp_len_ctx bdk_tns_txq_cnt_h1_drp_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x8420706d7800ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_DRP_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(a) bdk_tns_txq_cnt_h1_drp_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(a) "TNS_TXQ_CNT_H1_DRP_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_h1_drp_pkt_ct#
 *
 * TNS TxQ CNT H1 Drop Packet Count Registers
 * CPU access to H1 dropped packet count memory
 */
union bdk_tns_txq_cnt_h1_drp_pkt_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_h1_drp_pkt_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_drp_pkt_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_drp_pkt_ctx bdk_tns_txq_cnt_h1_drp_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x8420706d6800ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_DRP_PKT_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(a) bdk_tns_txq_cnt_h1_drp_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(a) "TNS_TXQ_CNT_H1_DRP_PKT_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_h1_flcm_ecc_log
 *
 * TNS TxQ CNT H1 Forwarded Length Counter Memory ECC Log Register
 * H1 forwarded length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_h1_flcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_h1_flcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_flcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_flcm_ecc_log bdk_tns_txq_cnt_h1_flcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c74ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_FLCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG bdk_tns_txq_cnt_h1_flcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG "TNS_TXQ_CNT_H1_FLCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_h1_fpcm_ecc_log
 *
 * TNS TxQ CNT H1 Forwarded Packet Counter Memory ECC Log Register
 * H1 forwarded packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_h1_fpcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_h1_fpcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_fpcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_fpcm_ecc_log bdk_tns_txq_cnt_h1_fpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c70ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_FPCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG bdk_tns_txq_cnt_h1_fpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG "TNS_TXQ_CNT_H1_FPCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_h1_fw_len_ct#
 *
 * TNS TxQ CNT H1 Forward Length Count Registers
 * CPU access to H1 forwarded packet byte count memory
 */
union bdk_tns_txq_cnt_h1_fw_len_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_h1_fw_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_fw_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_fw_len_ctx bdk_tns_txq_cnt_h1_fw_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x8420706d7000ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_FW_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(a) bdk_tns_txq_cnt_h1_fw_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(a) "TNS_TXQ_CNT_H1_FW_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_h1_fw_pkt_ct#
 *
 * TNS TxQ CNT H1 Forward Packet Count Registers
 * CPU access to H1 forwarded packet count memory
 */
union bdk_tns_txq_cnt_h1_fw_pkt_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_h1_fw_pkt_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_fw_pkt_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_fw_pkt_ctx bdk_tns_txq_cnt_h1_fw_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x8420706d6000ll + 8ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_FW_PKT_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(a) bdk_tns_txq_cnt_h1_fw_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(a) "TNS_TXQ_CNT_H1_FW_PKT_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_h1_len_ct#
 *
 * TNS TxQ CNT H1 Length Count Registers
 * CPU access to H1 length counters memory
 */
union bdk_tns_txq_cnt_h1_len_ctx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_h1_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_h1_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_h1_len_ctx bdk_tns_txq_cnt_h1_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x8420706d8800ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_CNT_H1_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_H1_LEN_CTX(a) bdk_tns_txq_cnt_h1_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_LEN_CTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_H1_LEN_CTX(a) "TNS_TXQ_CNT_H1_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_H1_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_H1_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_H1_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_int_en_hi
 *
 * TNS TxQ CNT Interrrupt Enable High Register
 * CNT interrupt register
 */
union bdk_tns_txq_cnt_int_en_hi
{
    uint64_t u;
    struct bdk_tns_txq_cnt_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](R/W) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](R/W) Cluster PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](R/W) Traffic class PFC counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](R/W) Per-priority PFC counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](R/W) Q page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](R/W) H1 page length counter rolled over */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](R/W) Port page length counter rolled over */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](R/W) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](R/W) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](R/W) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](R/W) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](R/W) Q page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](R/W) H1 page length counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](R/W) Port page length counter tried to decrement pages to a negative value */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](R/W) CNT configuration input DFC Rx overflow */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](R/W) H1 drop length memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](R/W) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](R/W) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](R/W) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](R/W) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](R/W) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](R/W) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](R/W) H1 forward packet memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](R/W) Q drop length memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](R/W) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](R/W) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](R/W) Q drop packet memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](R/W) Q forward length memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](R/W) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](R/W) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](R/W) Q forward packet memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](R/W) Q old length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](R/W) Q old length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](R/W) Q average length memory double bit ECC interrupt */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](R/W) Q average length memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](R/W) Q average length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](R/W) Q average length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](R/W) Q old length memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](R/W) Q old length memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](R/W) Q forward packet memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](R/W) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](R/W) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](R/W) Q forward length memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](R/W) Q drop packet memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](R/W) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](R/W) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](R/W) Q drop length memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](R/W) H1 forward packet memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](R/W) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](R/W) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](R/W) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](R/W) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](R/W) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](R/W) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](R/W) H1 drop length memory double bit ECC interrupt */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](R/W) CNT configuration input DFC Rx overflow */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](R/W) Port page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](R/W) H1 page length counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](R/W) Q page length counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](R/W) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](R/W) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](R/W) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](R/W) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](R/W) Port page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](R/W) H1 page length counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](R/W) Q page length counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](R/W) Per-priority PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](R/W) Traffic class PFC counter rolled over */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](R/W) Cluster PFC counter rolled over */
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](R/W) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_cnt_int_en_hi bdk_tns_txq_cnt_int_en_hi_t;

#define BDK_TNS_TXQ_CNT_INT_EN_HI BDK_TNS_TXQ_CNT_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c48ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_INT_EN_HI bdk_tns_txq_cnt_int_en_hi_t
#define bustype_BDK_TNS_TXQ_CNT_INT_EN_HI BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_INT_EN_HI "TNS_TXQ_CNT_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_CNT_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_CNT_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_int_en_lo
 *
 * TNS TxQ CNT Interrrupt Enable Low Register
 * CNT interrupt register
 */
union bdk_tns_txq_cnt_int_en_lo
{
    uint64_t u;
    struct bdk_tns_txq_cnt_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](R/W) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](R/W) Cluster PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](R/W) Traffic class PFC counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](R/W) Per-priority PFC counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](R/W) Q page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](R/W) H1 page length counter rolled over */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](R/W) Port page length counter rolled over */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](R/W) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](R/W) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](R/W) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](R/W) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](R/W) Q page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](R/W) H1 page length counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](R/W) Port page length counter tried to decrement pages to a negative value */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](R/W) CNT configuration input DFC Rx overflow */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](R/W) H1 drop length memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](R/W) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](R/W) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](R/W) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](R/W) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](R/W) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](R/W) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](R/W) H1 forward packet memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](R/W) Q drop length memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](R/W) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](R/W) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](R/W) Q drop packet memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](R/W) Q forward length memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](R/W) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](R/W) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](R/W) Q forward packet memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](R/W) Q old length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](R/W) Q old length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](R/W) Q average length memory double bit ECC interrupt */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](R/W) Q average length memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](R/W) Q average length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](R/W) Q average length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](R/W) Q old length memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](R/W) Q old length memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](R/W) Q forward packet memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](R/W) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](R/W) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](R/W) Q forward length memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](R/W) Q drop packet memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](R/W) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](R/W) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](R/W) Q drop length memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](R/W) H1 forward packet memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](R/W) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](R/W) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](R/W) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](R/W) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](R/W) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](R/W) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](R/W) H1 drop length memory double bit ECC interrupt */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](R/W) CNT configuration input DFC Rx overflow */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](R/W) Port page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](R/W) H1 page length counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](R/W) Q page length counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](R/W) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](R/W) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](R/W) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](R/W) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](R/W) Port page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](R/W) H1 page length counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](R/W) Q page length counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](R/W) Per-priority PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](R/W) Traffic class PFC counter rolled over */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](R/W) Cluster PFC counter rolled over */
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](R/W) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_cnt_int_en_lo bdk_tns_txq_cnt_int_en_lo_t;

#define BDK_TNS_TXQ_CNT_INT_EN_LO BDK_TNS_TXQ_CNT_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c50ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_INT_EN_LO bdk_tns_txq_cnt_int_en_lo_t
#define bustype_BDK_TNS_TXQ_CNT_INT_EN_LO BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_INT_EN_LO "TNS_TXQ_CNT_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_CNT_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_CNT_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_int_frc
 *
 * TNS TxQ CNT Interrrupt Force Register
 * CNT interrupt register
 */
union bdk_tns_txq_cnt_int_frc
{
    uint64_t u;
    struct bdk_tns_txq_cnt_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](WO) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](WO) Cluster PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](WO) Traffic class PFC counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](WO) Per-priority PFC counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](WO) Q page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](WO) H1 page length counter rolled over */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](WO) Port page length counter rolled over */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](WO) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](WO) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](WO) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](WO) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](WO) Q page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](WO) H1 page length counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](WO) Port page length counter tried to decrement pages to a negative value */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](WO) CNT configuration input DFC Rx overflow */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](WO) H1 drop length memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](WO) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](WO) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](WO) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](WO) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](WO) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](WO) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](WO) H1 forward packet memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](WO) Q drop length memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](WO) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](WO) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](WO) Q drop packet memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](WO) Q forward length memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](WO) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](WO) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](WO) Q forward packet memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](WO) Q old length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](WO) Q old length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](WO) Q average length memory double bit ECC interrupt */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](WO) Q average length memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](WO) Q average length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](WO) Q average length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](WO) Q old length memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](WO) Q old length memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](WO) Q forward packet memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](WO) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](WO) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](WO) Q forward length memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](WO) Q drop packet memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](WO) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](WO) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](WO) Q drop length memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](WO) H1 forward packet memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](WO) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](WO) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](WO) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](WO) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](WO) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](WO) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](WO) H1 drop length memory double bit ECC interrupt */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](WO) CNT configuration input DFC Rx overflow */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](WO) Port page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](WO) H1 page length counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](WO) Q page length counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](WO) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](WO) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](WO) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](WO) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](WO) Port page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](WO) H1 page length counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](WO) Q page length counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](WO) Per-priority PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](WO) Traffic class PFC counter rolled over */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](WO) Cluster PFC counter rolled over */
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](WO) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_int_frc_s cn; */
};
typedef union bdk_tns_txq_cnt_int_frc bdk_tns_txq_cnt_int_frc_t;

#define BDK_TNS_TXQ_CNT_INT_FRC BDK_TNS_TXQ_CNT_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c58ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_INT_FRC bdk_tns_txq_cnt_int_frc_t
#define bustype_BDK_TNS_TXQ_CNT_INT_FRC BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_INT_FRC "TNS_TXQ_CNT_INT_FRC"
#define device_bar_BDK_TNS_TXQ_CNT_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_INT_FRC 0
#define arguments_BDK_TNS_TXQ_CNT_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_int_w1c
 *
 * TNS TxQ CNT Interrrupt W1C Register
 * CNT interrupt register
 */
union bdk_tns_txq_cnt_int_w1c
{
    uint64_t u;
    struct bdk_tns_txq_cnt_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_35_63        : 29;
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](R/W1C/H) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](R/W1C/H) Cluster PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](R/W1C/H) Traffic class PFC counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](R/W1C/H) Per-priority PFC counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](R/W1C/H) Q page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](R/W1C/H) H1 page length counter rolled over */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](R/W1C/H) Port page length counter rolled over */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](R/W1C/H) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](R/W1C/H) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](R/W1C/H) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](R/W1C/H) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](R/W1C/H) Q page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](R/W1C/H) H1 page length counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](R/W1C/H) Port page length counter tried to decrement pages to a negative value */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](R/W1C/H) CNT configuration input DFC Rx overflow */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](R/W1C/H) H1 drop length memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](R/W1C/H) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](R/W1C/H) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](R/W1C/H) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](R/W1C/H) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](R/W1C/H) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](R/W1C/H) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](R/W1C/H) H1 forward packet memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](R/W1C/H) Q drop length memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](R/W1C/H) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](R/W1C/H) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](R/W1C/H) Q drop packet memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](R/W1C/H) Q forward length memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](R/W1C/H) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](R/W1C/H) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](R/W1C/H) Q forward packet memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](R/W1C/H) Q old length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](R/W1C/H) Q old length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](R/W1C/H) Q average length memory double bit ECC interrupt */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](R/W1C/H) Q average length memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint64_t q_avg_len_sb_err      : 1;  /**< [  0:  0](R/W1C/H) Q average length memory single bit ECC interrupt */
        uint64_t q_avg_len_db_err      : 1;  /**< [  1:  1](R/W1C/H) Q average length memory double bit ECC interrupt */
        uint64_t q_old_len_sb_err      : 1;  /**< [  2:  2](R/W1C/H) Q old length memory single bit ECC interrupt */
        uint64_t q_old_len_db_err      : 1;  /**< [  3:  3](R/W1C/H) Q old length memory double bit ECC interrupt */
        uint64_t q_fwd_pkt_sb_err      : 1;  /**< [  4:  4](R/W1C/H) Q forward packet memory single bit ECC interrupt */
        uint64_t q_fwd_pkt_db_err      : 1;  /**< [  5:  5](R/W1C/H) Q forward packet memory double bit ECC interrupt */
        uint64_t q_fwd_len_sb_err      : 1;  /**< [  6:  6](R/W1C/H) Q forward length memory single bit ECC interrupt */
        uint64_t q_fwd_len_db_err      : 1;  /**< [  7:  7](R/W1C/H) Q forward length memory double bit ECC interrupt */
        uint64_t q_drop_pkt_sb_err     : 1;  /**< [  8:  8](R/W1C/H) Q drop packet memory single bit ECC interrupt */
        uint64_t q_drop_pkt_db_err     : 1;  /**< [  9:  9](R/W1C/H) Q drop packet memory double bit ECC interrupt */
        uint64_t q_drop_len_sb_err     : 1;  /**< [ 10: 10](R/W1C/H) Q drop length memory single bit ECC interrupt */
        uint64_t q_drop_len_db_err     : 1;  /**< [ 11: 11](R/W1C/H) Q drop length memory double bit ECC interrupt */
        uint64_t h1_fwd_pkt_sb_err     : 1;  /**< [ 12: 12](R/W1C/H) H1 forward packet memory single bit ECC interrupt */
        uint64_t h1_fwd_pkt_db_err     : 1;  /**< [ 13: 13](R/W1C/H) H1 forward packet memory double bit ECC interrupt */
        uint64_t h1_fwd_len_sb_err     : 1;  /**< [ 14: 14](R/W1C/H) H1 forward length memory single bit ECC interrupt */
        uint64_t h1_fwd_len_db_err     : 1;  /**< [ 15: 15](R/W1C/H) H1 forward length memory double bit ECC interrupt */
        uint64_t h1_drop_pkt_sb_err    : 1;  /**< [ 16: 16](R/W1C/H) H1 drop packet memory single bit ECC interrupt */
        uint64_t h1_drop_pkt_db_err    : 1;  /**< [ 17: 17](R/W1C/H) H1 drop packet memory double bit ECC interrupt */
        uint64_t h1_drop_len_sb_err    : 1;  /**< [ 18: 18](R/W1C/H) H1 drop length memory single bit ECC interrupt */
        uint64_t h1_drop_len_db_err    : 1;  /**< [ 19: 19](R/W1C/H) H1 drop length memory double bit ECC interrupt */
        uint64_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [ 20: 20](R/W1C/H) CNT configuration input DFC Rx overflow */
        uint64_t pt_length_ct_neg_err  : 1;  /**< [ 21: 21](R/W1C/H) Port page length counter tried to decrement pages to a negative value */
        uint64_t h1_length_ct_neg_err  : 1;  /**< [ 22: 22](R/W1C/H) H1 page length counter tried to decrement pages to a negative value */
        uint64_t q_length_ct_neg_err   : 1;  /**< [ 23: 23](R/W1C/H) Q page length counter tried to decrement pages to a negative value */
        uint64_t pfc_ct_neg_err        : 1;  /**< [ 24: 24](R/W1C/H) Per-priority PFC counter tried to decrement pages to a negative value */
        uint64_t tc_ct_neg_err         : 1;  /**< [ 25: 25](R/W1C/H) Traffic class PFC counter tried to decrement pages to a negative value */
        uint64_t cluster_ct_neg_err    : 1;  /**< [ 26: 26](R/W1C/H) Cluster PFC counter tried to decrement pages to a negative value */
        uint64_t global_mc_ct_neg_err  : 1;  /**< [ 27: 27](R/W1C/H) Global MC PFC counter tried to decrement pages to a negative value */
        uint64_t pt_length_ct_rollover_err : 1;/**< [ 28: 28](R/W1C/H) Port page length counter rolled over */
        uint64_t h1_length_ct_rollover_err : 1;/**< [ 29: 29](R/W1C/H) H1 page length counter rolled over */
        uint64_t q_length_ct_rollover_err : 1;/**< [ 30: 30](R/W1C/H) Q page length counter rolled over */
        uint64_t pfc_ct_rollover_err   : 1;  /**< [ 31: 31](R/W1C/H) Per-priority PFC counter rolled over */
        uint64_t tc_ct_rollover_err    : 1;  /**< [ 32: 32](R/W1C/H) Traffic class PFC counter rolled over */
        uint64_t cluster_ct_rollover_err : 1;/**< [ 33: 33](R/W1C/H) Cluster PFC counter rolled over */
        uint64_t nic_crd_over_thr_err  : 1;  /**< [ 34: 34](R/W1C/H) NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
        uint64_t reserved_35_63        : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_int_w1c_s cn; */
};
typedef union bdk_tns_txq_cnt_int_w1c bdk_tns_txq_cnt_int_w1c_t;

#define BDK_TNS_TXQ_CNT_INT_W1C BDK_TNS_TXQ_CNT_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c40ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_INT_W1C bdk_tns_txq_cnt_int_w1c_t
#define bustype_BDK_TNS_TXQ_CNT_INT_W1C BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_INT_W1C "TNS_TXQ_CNT_INT_W1C"
#define device_bar_BDK_TNS_TXQ_CNT_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_INT_W1C 0
#define arguments_BDK_TNS_TXQ_CNT_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_lock
 *
 * TNS TxQ CNT Lock Register
 * Lock Register
 */
union bdk_tns_txq_cnt_lock
{
    uint32_t u;
    struct bdk_tns_txq_cnt_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_lock_s cn; */
};
typedef union bdk_tns_txq_cnt_lock bdk_tns_txq_cnt_lock_t;

#define BDK_TNS_TXQ_CNT_LOCK BDK_TNS_TXQ_CNT_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9ddcll;
    __bdk_csr_fatal("TNS_TXQ_CNT_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_LOCK bdk_tns_txq_cnt_lock_t
#define bustype_BDK_TNS_TXQ_CNT_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_LOCK "TNS_TXQ_CNT_LOCK"
#define device_bar_BDK_TNS_TXQ_CNT_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_LOCK 0
#define arguments_BDK_TNS_TXQ_CNT_LOCK -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_nic_crd_ov_thr_w#
 *
 * TNS TxQ CNT NIC Credit Over Threshold Registers
 * Log the status of flow control channels when any channel goes over the flow
 * control threshold.  The log only occurs when NIC credits are enabled in TNS PFC
 * mode.   In normal operation, the threshold should never be reached, as the NIC
 * flow controls itself with credits.  Log is sticky on first error.  Re-armed
 * after reading.
 */
union bdk_tns_txq_cnt_nic_crd_ov_thr_wx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_nic_crd_ov_thr_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t over_threshold        : 64; /**< [ 63:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint64_t over_threshold        : 64; /**< [ 63:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_nic_crd_ov_thr_wx_s cn; */
};
typedef union bdk_tns_txq_cnt_nic_crd_ov_thr_wx bdk_tns_txq_cnt_nic_crd_ov_thr_wx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x8420706d9c90ll + 8ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_TXQ_CNT_NIC_CRD_OV_THR_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(a) bdk_tns_txq_cnt_nic_crd_ov_thr_wx_t
#define bustype_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(a) "TNS_TXQ_CNT_NIC_CRD_OV_THR_WX"
#define device_bar_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_onthefly_pkt_ct
 *
 * TNS TxQ CNT On The Fly Packet Count Register
 * Count of the total number of packets currently in the pipeline between the txq
 * reply to enqueuing operation
 */
union bdk_tns_txq_cnt_onthefly_pkt_ct
{
    uint32_t u;
    struct bdk_tns_txq_cnt_onthefly_pkt_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_onthefly_pkt_ct_s cn; */
};
typedef union bdk_tns_txq_cnt_onthefly_pkt_ct bdk_tns_txq_cnt_onthefly_pkt_ct_t;

#define BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cf0ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_ONTHEFLY_PKT_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT bdk_tns_txq_cnt_onthefly_pkt_ct_t
#define bustype_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT "TNS_TXQ_CNT_ONTHEFLY_PKT_CT"
#define device_bar_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT 0
#define arguments_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pc_cnt_mem#
 *
 * TNS TxQ CNT Port Cluster CNT Memory Registers
 * CPU access to per-port cluster count
 */
union bdk_tns_txq_cnt_pc_cnt_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pc_cnt_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t pc_cnt                : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pc_cnt                : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pc_cnt_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_pc_cnt_memx bdk_tns_txq_cnt_pc_cnt_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PC_CNT_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PC_CNT_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=10))
        return 0x8420706d9c00ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PC_CNT_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(a) bdk_tns_txq_cnt_pc_cnt_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(a) "TNS_TXQ_CNT_PC_CNT_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pc_pfl_mem#
 *
 * TNS TxQ CNT Port Cluster Profile Memory Registers
 * CPU access to port cluster profile memory. Provide Xon/Xoff profiles for each
 * of the 11 port clusters.  address 0 corresponds to port cluster 0
 */
union bdk_tns_txq_cnt_pc_pfl_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pc_pfl_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t xon                   : 15; /**< [ 29: 15](R/W) -- */
        uint32_t xoff                  : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t xoff                  : 15; /**< [ 14:  0](R/W) -- */
        uint32_t xon                   : 15; /**< [ 29: 15](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pc_pfl_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_pc_pfl_memx bdk_tns_txq_cnt_pc_pfl_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PC_PFL_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PC_PFL_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=10))
        return 0x8420706d9b40ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PC_PFL_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(a) bdk_tns_txq_cnt_pc_pfl_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(a) "TNS_TXQ_CNT_PC_PFL_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_cfg
 *
 * TNS TxQ CNT PFC Configuration Register
 * PFC mode and NIC Credit Enable Configuration.
 */
union bdk_tns_txq_cnt_pfc_cfg
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pfc_mode_cfg          : 1;  /**< [  1:  1](R/W) -- */
        uint32_t pfc_nic_credits_cfg   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pfc_nic_credits_cfg   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t pfc_mode_cfg          : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_cfg_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_cfg bdk_tns_txq_cnt_pfc_cfg_t;

#define BDK_TNS_TXQ_CNT_PFC_CFG BDK_TNS_TXQ_CNT_PFC_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9d24ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_CFG bdk_tns_txq_cnt_pfc_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_CFG "TNS_TXQ_CNT_PFC_CFG"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_PFC_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_cnt_mem#
 *
 * TNS TxQ CNT PFC CNT Memory Registers
 * CPU access to PFC counters 400 channels (256 for NIC, 128 for BGX, 16 for CPU)
 */
union bdk_tns_txq_cnt_pfc_cnt_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_cnt_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t pfc_counter           : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pfc_counter           : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_cnt_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_cnt_memx bdk_tns_txq_cnt_pfc_cnt_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=399))
        return 0x8420706d8000ll + 4ll * ((a) & 0x1ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_CNT_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(a) bdk_tns_txq_cnt_pfc_cnt_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(a) "TNS_TXQ_CNT_PFC_CNT_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_hw_init_sta
 *
 * TNS TxQ CNT PFC Hardware Init Status Register
 * Per memory HW init.  Read for status.  '1' indicates that HW init is completed
 */
union bdk_tns_txq_cnt_pfc_hw_init_sta
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_hw_init_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pfc_cnt_mem_init_done : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t pc_cnt_mem_init_done  : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t tc_cnt_mem_init_done  : 1;  /**< [  0:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t tc_cnt_mem_init_done  : 1;  /**< [  0:  0](RO/H) -- */
        uint32_t pc_cnt_mem_init_done  : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t pfc_cnt_mem_init_done : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_hw_init_sta_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_hw_init_sta bdk_tns_txq_cnt_pfc_hw_init_sta_t;

#define BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cbcll;
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_HW_INIT_STA", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA bdk_tns_txq_cnt_pfc_hw_init_sta_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA "TNS_TXQ_CNT_PFC_HW_INIT_STA"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA 0
#define arguments_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_pfl_map_mem#
 *
 * TNS TxQ CNT PFC Profile Map Memory Registers
 * CPU access to PFC profile map memory. Maps a PFC profile to each of the 400
 * flow control channels
 */
union bdk_tns_txq_cnt_pfc_pfl_map_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_pfl_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t pfc_profile           : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pfc_profile           : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_pfl_map_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_pfl_map_memx bdk_tns_txq_cnt_pfc_pfl_map_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=399))
        return 0x8420706d9000ll + 4ll * ((a) & 0x1ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_PFL_MAP_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(a) bdk_tns_txq_cnt_pfc_pfl_map_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(a) "TNS_TXQ_CNT_PFC_PFL_MAP_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_pfl_mem#
 *
 * TNS TxQ CNT PFC Profile Memory Registers
 * CPU access to PFC profile memory. Provide Xon/Xoff profiles for the PFC
 * channels.  Each channel is assigned one of the 64 profiles to determine its
 * xon/xoff thresholds.
 */
union bdk_tns_txq_cnt_pfc_pfl_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_pfl_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t xon                   : 15; /**< [ 29: 15](R/W) -- */
        uint32_t xoff                  : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t xoff                  : 15; /**< [ 14:  0](R/W) -- */
        uint32_t xon                   : 15; /**< [ 29: 15](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_pfl_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_pfl_memx bdk_tns_txq_cnt_pfc_pfl_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x8420706d9800ll + 4ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_PFL_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(a) bdk_tns_txq_cnt_pfc_pfl_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(a) "TNS_TXQ_CNT_PFC_PFL_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_pt_clus_cfg#
 *
 * TNS TxQ CNT PFC PORT Cluster Configuration Registers
 * Configuration to assign port to a port cluster.  A registers exists for each
 * port to assign to a port cluster.  Port cluster values 0-10 are valid.
 */
union bdk_tns_txq_cnt_pfc_pt_clus_cfgx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_pt_clus_cfgx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t pt_cluster            : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_cluster            : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_pt_clus_cfgx_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_pt_clus_cfgx bdk_tns_txq_cnt_pfc_pt_clus_cfgx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=10))
        return 0x8420706d9d28ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_PT_CLUS_CFGX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(a) bdk_tns_txq_cnt_pfc_pt_clus_cfgx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(a) "TNS_TXQ_CNT_PFC_PT_CLUS_CFGX"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pfc_rst_cfg
 *
 * TNS TxQ CNT PFC Reset Configuration Register
 * Reset configuration to auto-initialize counters in PFC block and start various
 * modules within TBM
 */
union bdk_tns_txq_cnt_pfc_rst_cfg
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pfc_rst_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pfc_hw_auto_init      : 1;  /**< [  2:  2](R/W) -- */
        uint32_t pc_hw_auto_init       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t tc_hw_auto_init       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tc_hw_auto_init       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t pc_hw_auto_init       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t pfc_hw_auto_init      : 1;  /**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pfc_rst_cfg_s cn; */
};
typedef union bdk_tns_txq_cnt_pfc_rst_cfg bdk_tns_txq_cnt_pfc_rst_cfg_t;

#define BDK_TNS_TXQ_CNT_PFC_RST_CFG BDK_TNS_TXQ_CNT_PFC_RST_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_RST_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_RST_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cb8ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_PFC_RST_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PFC_RST_CFG bdk_tns_txq_cnt_pfc_rst_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_RST_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PFC_RST_CFG "TNS_TXQ_CNT_PFC_RST_CFG"
#define device_bar_BDK_TNS_TXQ_CNT_PFC_RST_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PFC_RST_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_PFC_RST_CFG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_pt_drp_len_ct#
 *
 * TNS TxQ CNT PORT Drop Length Count Registers
 * CPU access to port dropped packet byte count memory
 */
union bdk_tns_txq_cnt_pt_drp_len_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_pt_drp_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pt_drp_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_pt_drp_len_ctx bdk_tns_txq_cnt_pt_drp_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9a80ll + 8ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PT_DRP_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(a) bdk_tns_txq_cnt_pt_drp_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(a) "TNS_TXQ_CNT_PT_DRP_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_pt_drp_pkt_ct#
 *
 * TNS TxQ CNT PORT Drop Packet Count Registers
 * CPU access to port dropped packet count memory
 */
union bdk_tns_txq_cnt_pt_drp_pkt_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_pt_drp_pkt_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pt_drp_pkt_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_pt_drp_pkt_ctx bdk_tns_txq_cnt_pt_drp_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9980ll + 8ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PT_DRP_PKT_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(a) bdk_tns_txq_cnt_pt_drp_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(a) "TNS_TXQ_CNT_PT_DRP_PKT_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_pt_fw_len_ct#
 *
 * TNS TxQ CNT PORT Forward Length Count Registers
 * CPU access to port forwarded packet byte count memory
 */
union bdk_tns_txq_cnt_pt_fw_len_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_pt_fw_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pt_fw_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_pt_fw_len_ctx bdk_tns_txq_cnt_pt_fw_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9a00ll + 8ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PT_FW_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(a) bdk_tns_txq_cnt_pt_fw_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(a) "TNS_TXQ_CNT_PT_FW_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_pt_fw_pkt_ct#
 *
 * TNS TxQ CNT PORT Forward Packet Count Registers
 * CPU access to port forwarded packet count memory
 */
union bdk_tns_txq_cnt_pt_fw_pkt_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_pt_fw_pkt_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pt_fw_pkt_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_pt_fw_pkt_ctx bdk_tns_txq_cnt_pt_fw_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9900ll + 8ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PT_FW_PKT_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(a) bdk_tns_txq_cnt_pt_fw_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(a) "TNS_TXQ_CNT_PT_FW_PKT_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_pt_len_ct#
 *
 * TNS TxQ CNT PORT Length Count Registers
 * CPU access to PORT length counters memory
 */
union bdk_tns_txq_cnt_pt_len_ctx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_pt_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_pt_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_pt_len_ctx bdk_tns_txq_cnt_pt_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9b80ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_PT_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_PT_LEN_CTX(a) bdk_tns_txq_cnt_pt_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_LEN_CTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_PT_LEN_CTX(a) "TNS_TXQ_CNT_PT_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_PT_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_PT_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_PT_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_alcm_ecc_log
 *
 * TNS TxQ CNT Queue Average Length Counters Memory ECC Log Register
 * Q average length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_q_alcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_alcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_alcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_q_alcm_ecc_log bdk_tns_txq_cnt_q_alcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c88ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_ALCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG bdk_tns_txq_cnt_q_alcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG "TNS_TXQ_CNT_Q_ALCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_avg_len_ct#
 *
 * TNS TxQ CNT Queue Avergage Length Count Registers
 * CPU access to Q avg_length counters memory
 */
union bdk_tns_txq_cnt_q_avg_len_ctx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_avg_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_avg_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_avg_len_ctx bdk_tns_txq_cnt_q_avg_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706d2000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_AVG_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(a) bdk_tns_txq_cnt_q_avg_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(a) "TNS_TXQ_CNT_Q_AVG_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_dlcm_ecc_log
 *
 * TNS TxQ CNT Queue Dropped Length Counter Memory ECC Log Register
 * Q dropped length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_q_dlcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_dlcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_dlcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_q_dlcm_ecc_log bdk_tns_txq_cnt_q_dlcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c7cll;
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_DLCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG bdk_tns_txq_cnt_q_dlcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG "TNS_TXQ_CNT_Q_DLCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_dpcm_ecc_log
 *
 * TNS TxQ CNT Queue Dropped Packet Counter Memory ECC Log Register
 * Q dropped packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_q_dpcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_dpcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_dpcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_q_dpcm_ecc_log bdk_tns_txq_cnt_q_dpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c78ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_DPCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG bdk_tns_txq_cnt_q_dpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG "TNS_TXQ_CNT_Q_DPCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_q_drp_len_ct#
 *
 * TNS TxQ CNT Queue Drop Length Count Registers
 * CPU access to Q dropped packet byte count memory
 */
union bdk_tns_txq_cnt_q_drp_len_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_q_drp_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_drp_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_drp_len_ctx bdk_tns_txq_cnt_q_drp_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706cc000ll + 8ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_DRP_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(a) bdk_tns_txq_cnt_q_drp_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(a) "TNS_TXQ_CNT_Q_DRP_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_q_drp_pkt_ct#
 *
 * TNS TxQ CNT Queue Drop Packet Count Registers
 * CPU access to Q dropped packet count memory
 */
union bdk_tns_txq_cnt_q_drp_pkt_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_q_drp_pkt_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_drp_pkt_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_drp_pkt_ctx bdk_tns_txq_cnt_q_drp_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706c4000ll + 8ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_DRP_PKT_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(a) bdk_tns_txq_cnt_q_drp_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(a) "TNS_TXQ_CNT_Q_DRP_PKT_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_flcm_ecc_log
 *
 * TNS TxQ CNT Queue Forwarded Length Counter Memory ECC Log Register
 * Q forwarded length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_q_flcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_flcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_flcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_q_flcm_ecc_log bdk_tns_txq_cnt_q_flcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c84ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_FLCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG bdk_tns_txq_cnt_q_flcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG "TNS_TXQ_CNT_Q_FLCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_fpcm_ecc_log
 *
 * TNS TxQ CNT Queue Forwarded Packet Counter Memory ECC Log Register
 * Q forwarded packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_cnt_q_fpcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_fpcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_fpcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_q_fpcm_ecc_log bdk_tns_txq_cnt_q_fpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c80ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_FPCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG bdk_tns_txq_cnt_q_fpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG "TNS_TXQ_CNT_Q_FPCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_q_fw_len_ct#
 *
 * TNS TxQ CNT Queue Forward Length Count Registers
 * CPU access to Q forwarded packet byte count memory
 */
union bdk_tns_txq_cnt_q_fw_len_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_q_fw_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_fw_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_fw_len_ctx bdk_tns_txq_cnt_q_fw_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706c8000ll + 8ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_FW_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(a) bdk_tns_txq_cnt_q_fw_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(a) "TNS_TXQ_CNT_Q_FW_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_cnt_q_fw_pkt_ct#
 *
 * TNS TxQ CNT Queue Forward Packet Count Registers
 * CPU access to Q forwarded packet count memory
 */
union bdk_tns_txq_cnt_q_fw_pkt_ctx
{
    uint64_t u;
    struct bdk_tns_txq_cnt_q_fw_pkt_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_41_63        : 23;
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t count                 : 40; /**< [ 39:  0](R/W) -- */
        uint64_t saturate              : 1;  /**< [ 40: 40](R/W) -- */
        uint64_t reserved_41_63        : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_fw_pkt_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_fw_pkt_ctx bdk_tns_txq_cnt_q_fw_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706c0000ll + 8ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_FW_PKT_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(a) bdk_tns_txq_cnt_q_fw_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(a) "TNS_TXQ_CNT_Q_FW_PKT_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_len_ct#
 *
 * TNS TxQ CNT Queue Length Count Registers
 * CPU access to Q length counters memory
 */
union bdk_tns_txq_cnt_q_len_ctx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_len_ctx bdk_tns_txq_cnt_q_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706d0000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_LEN_CTX(a) bdk_tns_txq_cnt_q_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_LEN_CTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_LEN_CTX(a) "TNS_TXQ_CNT_Q_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_olcm_ecc_log
 *
 * TNS TxQ CNT Queue Old Length Counters Memory ECC Log Register
 * Q old length ECC error log.  Address is sticky on first error.  Re-armed after
 * reading
 */
union bdk_tns_txq_cnt_q_olcm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_olcm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_olcm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_cnt_q_olcm_ecc_log bdk_tns_txq_cnt_q_olcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c8cll;
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_OLCM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG bdk_tns_txq_cnt_q_olcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG "TNS_TXQ_CNT_Q_OLCM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_q_old_len_ct#
 *
 * TNS TxQ CNT Queue Old Length Count Registers
 * CPU access to Q old_length counters memory
 */
union bdk_tns_txq_cnt_q_old_len_ctx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_q_old_len_ctx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t length_count          : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_q_old_len_ctx_s cn; */
};
typedef union bdk_tns_txq_cnt_q_old_len_ctx bdk_tns_txq_cnt_q_old_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x8420706d4000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_CNT_Q_OLD_LEN_CTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(a) bdk_tns_txq_cnt_q_old_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(a) "TNS_TXQ_CNT_Q_OLD_LEN_CTX"
#define device_bar_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_qac_bist_stdn
 *
 * TNS TxQ CNT QAC Bist Status Done Register
 * TxQ QAC bist status and bist_done
 */
union bdk_tns_txq_cnt_qac_bist_stdn
{
    uint32_t u;
    struct bdk_tns_txq_cnt_qac_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t q_old_len_mem_status  : 1;  /**< [ 23: 23](RO/H) -- */
        uint32_t q_avg_len_mem_status  : 1;  /**< [ 22: 22](RO/H) -- */
        uint32_t q_fwd_pkt_mem_status  : 1;  /**< [ 21: 21](RO/H) -- */
        uint32_t q_fwd_len_mem_status  : 1;  /**< [ 20: 20](RO/H) -- */
        uint32_t q_drop_pkt_mem_status : 1;  /**< [ 19: 19](RO/H) -- */
        uint32_t q_drop_len_mem_status : 1;  /**< [ 18: 18](RO/H) -- */
        uint32_t h1_fwd_pkt_mem_status : 1;  /**< [ 17: 17](RO/H) -- */
        uint32_t h1_fwd_len_mem_status : 1;  /**< [ 16: 16](RO/H) -- */
        uint32_t h1_drop_pkt_mem_status : 1; /**< [ 15: 15](RO/H) -- */
        uint32_t h1_drop_len_mem_status : 1; /**< [ 14: 14](RO/H) -- */
        uint32_t eq_cfg_mem_status     : 1;  /**< [ 13: 13](RO/H) -- */
        uint32_t qmap_table_mem_status : 1;  /**< [ 12: 12](RO/H) -- */
        uint32_t q_old_len_mem_done    : 1;  /**< [ 11: 11](RO/H) -- */
        uint32_t q_avg_len_mem_done    : 1;  /**< [ 10: 10](RO/H) -- */
        uint32_t q_fwd_pkt_mem_done    : 1;  /**< [  9:  9](RO/H) -- */
        uint32_t q_fwd_len_mem_done    : 1;  /**< [  8:  8](RO/H) -- */
        uint32_t q_drop_pkt_mem_done   : 1;  /**< [  7:  7](RO/H) -- */
        uint32_t q_drop_len_mem_done   : 1;  /**< [  6:  6](RO/H) -- */
        uint32_t h1_fwd_pkt_mem_done   : 1;  /**< [  5:  5](RO/H) -- */
        uint32_t h1_fwd_len_mem_done   : 1;  /**< [  4:  4](RO/H) -- */
        uint32_t h1_drop_pkt_mem_done  : 1;  /**< [  3:  3](RO/H) -- */
        uint32_t h1_drop_len_mem_done  : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t eq_cfg_mem_done       : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t qmap_table_mem_done   : 1;  /**< [  0:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t qmap_table_mem_done   : 1;  /**< [  0:  0](RO/H) -- */
        uint32_t eq_cfg_mem_done       : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t h1_drop_len_mem_done  : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t h1_drop_pkt_mem_done  : 1;  /**< [  3:  3](RO/H) -- */
        uint32_t h1_fwd_len_mem_done   : 1;  /**< [  4:  4](RO/H) -- */
        uint32_t h1_fwd_pkt_mem_done   : 1;  /**< [  5:  5](RO/H) -- */
        uint32_t q_drop_len_mem_done   : 1;  /**< [  6:  6](RO/H) -- */
        uint32_t q_drop_pkt_mem_done   : 1;  /**< [  7:  7](RO/H) -- */
        uint32_t q_fwd_len_mem_done    : 1;  /**< [  8:  8](RO/H) -- */
        uint32_t q_fwd_pkt_mem_done    : 1;  /**< [  9:  9](RO/H) -- */
        uint32_t q_avg_len_mem_done    : 1;  /**< [ 10: 10](RO/H) -- */
        uint32_t q_old_len_mem_done    : 1;  /**< [ 11: 11](RO/H) -- */
        uint32_t qmap_table_mem_status : 1;  /**< [ 12: 12](RO/H) -- */
        uint32_t eq_cfg_mem_status     : 1;  /**< [ 13: 13](RO/H) -- */
        uint32_t h1_drop_len_mem_status : 1; /**< [ 14: 14](RO/H) -- */
        uint32_t h1_drop_pkt_mem_status : 1; /**< [ 15: 15](RO/H) -- */
        uint32_t h1_fwd_len_mem_status : 1;  /**< [ 16: 16](RO/H) -- */
        uint32_t h1_fwd_pkt_mem_status : 1;  /**< [ 17: 17](RO/H) -- */
        uint32_t q_drop_len_mem_status : 1;  /**< [ 18: 18](RO/H) -- */
        uint32_t q_drop_pkt_mem_status : 1;  /**< [ 19: 19](RO/H) -- */
        uint32_t q_fwd_len_mem_status  : 1;  /**< [ 20: 20](RO/H) -- */
        uint32_t q_fwd_pkt_mem_status  : 1;  /**< [ 21: 21](RO/H) -- */
        uint32_t q_avg_len_mem_status  : 1;  /**< [ 22: 22](RO/H) -- */
        uint32_t q_old_len_mem_status  : 1;  /**< [ 23: 23](RO/H) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_qac_bist_stdn_s cn; */
};
typedef union bdk_tns_txq_cnt_qac_bist_stdn bdk_tns_txq_cnt_qac_bist_stdn_t;

#define BDK_TNS_TXQ_CNT_QAC_BIST_STDN BDK_TNS_TXQ_CNT_QAC_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_QAC_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_QAC_BIST_STDN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9c64ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_QAC_BIST_STDN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_QAC_BIST_STDN bdk_tns_txq_cnt_qac_bist_stdn_t
#define bustype_BDK_TNS_TXQ_CNT_QAC_BIST_STDN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_QAC_BIST_STDN "TNS_TXQ_CNT_QAC_BIST_STDN"
#define device_bar_BDK_TNS_TXQ_CNT_QAC_BIST_STDN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_QAC_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_CNT_QAC_BIST_STDN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_shrd_pkt_len#
 *
 * TNS TxQ CNT Shared Packet Length Registers
 * Count of the total number of pages currently in use by packets stored in the
 * token buffer shared pools
 */
union bdk_tns_txq_cnt_shrd_pkt_lenx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_shrd_pkt_lenx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_shrd_pkt_lenx_s cn; */
};
typedef union bdk_tns_txq_cnt_shrd_pkt_lenx bdk_tns_txq_cnt_shrd_pkt_lenx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x8420706d9cd0ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_CNT_SHRD_PKT_LENX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(a) bdk_tns_txq_cnt_shrd_pkt_lenx_t
#define bustype_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(a) "TNS_TXQ_CNT_SHRD_PKT_LENX"
#define device_bar_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_shrd_pkt_len_max#
 *
 * TNS TxQ CNT Shared Packet Length Maximum Registers
 * Limit for the number of pages consumed by each shared pool before full is
 * asserted to AQM
 */
union bdk_tns_txq_cnt_shrd_pkt_len_maxx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_shrd_pkt_len_maxx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_shrd_pkt_len_maxx_s cn; */
};
typedef union bdk_tns_txq_cnt_shrd_pkt_len_maxx bdk_tns_txq_cnt_shrd_pkt_len_maxx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=7))
        return 0x8420706d9d04ll + 4ll * ((a) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(a) bdk_tns_txq_cnt_shrd_pkt_len_maxx_t
#define bustype_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(a) "TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX"
#define device_bar_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_spad
 *
 * TNS TxQ CNT ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_cnt_spad
{
    uint32_t u;
    struct bdk_tns_txq_cnt_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_spad_s cn; */
};
typedef union bdk_tns_txq_cnt_spad bdk_tns_txq_cnt_spad_t;

#define BDK_TNS_TXQ_CNT_SPAD BDK_TNS_TXQ_CNT_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9de0ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_SPAD bdk_tns_txq_cnt_spad_t
#define bustype_BDK_TNS_TXQ_CNT_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_SPAD "TNS_TXQ_CNT_SPAD"
#define device_bar_BDK_TNS_TXQ_CNT_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_SPAD 0
#define arguments_BDK_TNS_TXQ_CNT_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tc_cnt_mem#
 *
 * TNS TxQ CNT Traffic Class CNT Memory Registers
 * CPU access to global per-TC count
 */
union bdk_tns_txq_cnt_tc_cnt_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tc_cnt_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t tc_global_cnt         : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tc_global_cnt         : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tc_cnt_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_tc_cnt_memx bdk_tns_txq_cnt_tc_cnt_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_TC_CNT_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TC_CNT_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9bc0ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_TC_CNT_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(a) bdk_tns_txq_cnt_tc_cnt_memx_t
#define bustype_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(a) "TNS_TXQ_CNT_TC_CNT_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tc_pfl_mem#
 *
 * TNS TxQ CNT Traffic Class Profile Memory Registers
 * CPU access to traffic class  profile memory. Provide Xon/Xoff profiles for each
 * of the 16 PFC  channels.  address 0 corresponds to TC 0
 */
union bdk_tns_txq_cnt_tc_pfl_memx
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tc_pfl_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t xon                   : 15; /**< [ 29: 15](R/W) -- */
        uint32_t xoff                  : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t xoff                  : 15; /**< [ 14:  0](R/W) -- */
        uint32_t xon                   : 15; /**< [ 29: 15](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tc_pfl_memx_s cn; */
};
typedef union bdk_tns_txq_cnt_tc_pfl_memx bdk_tns_txq_cnt_tc_pfl_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_TC_PFL_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TC_PFL_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420706d9b00ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_CNT_TC_PFL_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(a) bdk_tns_txq_cnt_tc_pfl_memx_t
#define bustype_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(a) "TNS_TXQ_CNT_TC_PFL_MEMX"
#define device_bar_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_mc_pkt_ct
 *
 * TNS TxQ CNT Total Multip-cast Packet Count Register
 * Count of the total number of multi-copy packets currently stored by the switch
 */
union bdk_tns_txq_cnt_tl_mc_pkt_ct
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_mc_pkt_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_mc_pkt_ct_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_mc_pkt_ct bdk_tns_txq_cnt_tl_mc_pkt_ct_t;

#define BDK_TNS_TXQ_CNT_TL_MC_PKT_CT BDK_TNS_TXQ_CNT_TL_MC_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cc8ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_MC_PKT_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT bdk_tns_txq_cnt_tl_mc_pkt_ct_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT "TNS_TXQ_CNT_TL_MC_PKT_CT"
#define device_bar_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_mc_pkt_len
 *
 * TNS TxQ CNT Total Multip-cast Packet Length Register
 * Count of the total number of pages currently in use by multi-copy packet
 */
union bdk_tns_txq_cnt_tl_mc_pkt_len
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_mc_pkt_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_mc_pkt_len_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_mc_pkt_len bdk_tns_txq_cnt_tl_mc_pkt_len_t;

#define BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cccll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_MC_PKT_LEN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN bdk_tns_txq_cnt_tl_mc_pkt_len_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN "TNS_TXQ_CNT_TL_MC_PKT_LEN"
#define device_bar_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_mcpkt_ct_max
 *
 * TNS TxQ CNT Total Multi-cast Packet Count Maximum Register
 * Limit for the number of MC packet before full is asserted to AQM
 */
union bdk_tns_txq_cnt_tl_mcpkt_ct_max
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_mcpkt_ct_max_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_mcpkt_ct_max_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_mcpkt_ct_max bdk_tns_txq_cnt_tl_mcpkt_ct_max_t;

#define BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cfcll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_MCPKT_CT_MAX", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX bdk_tns_txq_cnt_tl_mcpkt_ct_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX "TNS_TXQ_CNT_TL_MCPKT_CT_MAX"
#define device_bar_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_mcpkt_len_max
 *
 * TNS TxQ CNT Total Multi-cast Packet Length Maximum Register
 * Limit for the number of pages consumed by MC packets before full is asserted to
 * AQM
 */
union bdk_tns_txq_cnt_tl_mcpkt_len_max
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_mcpkt_len_max_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_mcpkt_len_max_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_mcpkt_len_max bdk_tns_txq_cnt_tl_mcpkt_len_max_t;

#define BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9d00ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_MCPKT_LEN_MAX", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX bdk_tns_txq_cnt_tl_mcpkt_len_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX "TNS_TXQ_CNT_TL_MCPKT_LEN_MAX"
#define device_bar_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_pkt_ct
 *
 * TNS TxQ CNT Total Packet Count Register
 * Count of the total number of packets currently stored by the switch
 */
union bdk_tns_txq_cnt_tl_pkt_ct
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_pkt_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_pkt_ct_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_pkt_ct bdk_tns_txq_cnt_tl_pkt_ct_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_CT BDK_TNS_TXQ_CNT_TL_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cc0ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_PKT_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_CT bdk_tns_txq_cnt_tl_pkt_ct_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_CT "TNS_TXQ_CNT_TL_PKT_CT"
#define device_bar_BDK_TNS_TXQ_CNT_TL_PKT_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_CT 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_pkt_ct_max
 *
 * TNS TxQ CNT Total Packet Count Maximum Register
 * Limit for the number of packets stored before full is asserted to AQM
 */
union bdk_tns_txq_cnt_tl_pkt_ct_max
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_pkt_ct_max_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_pkt_ct_max_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_pkt_ct_max bdk_tns_txq_cnt_tl_pkt_ct_max_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cf4ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_PKT_CT_MAX", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX bdk_tns_txq_cnt_tl_pkt_ct_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX "TNS_TXQ_CNT_TL_PKT_CT_MAX"
#define device_bar_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_pkt_len
 *
 * TNS TxQ CNT Total Packet Length Register
 * Count of the total number of pages currently in use by the switch
 */
union bdk_tns_txq_cnt_tl_pkt_len
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_pkt_len_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](RO/H) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_pkt_len_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_pkt_len bdk_tns_txq_cnt_tl_pkt_len_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_LEN BDK_TNS_TXQ_CNT_TL_PKT_LEN_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cc4ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_PKT_LEN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_LEN bdk_tns_txq_cnt_tl_pkt_len_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_LEN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_LEN "TNS_TXQ_CNT_TL_PKT_LEN"
#define device_bar_BDK_TNS_TXQ_CNT_TL_PKT_LEN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_LEN 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_LEN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_cnt_tl_pkt_len_max
 *
 * TNS TxQ CNT Total Packet Length Maximum Register
 * Limit for the number of pages consumed by all packets before full is asserted
 * to AQM
 */
union bdk_tns_txq_cnt_tl_pkt_len_max
{
    uint32_t u;
    struct bdk_tns_txq_cnt_tl_pkt_len_max_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_cnt_tl_pkt_len_max_s cn; */
};
typedef union bdk_tns_txq_cnt_tl_pkt_len_max bdk_tns_txq_cnt_tl_pkt_len_max_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706d9cf8ll;
    __bdk_csr_fatal("TNS_TXQ_CNT_TL_PKT_LEN_MAX", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX bdk_tns_txq_cnt_tl_pkt_len_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX "TNS_TXQ_CNT_TL_PKT_LEN_MAX"
#define device_bar_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_bist_stdn
 *
 * TNS TxQ Deque Bist Status Done Register
 * TxQ DQ bist status and bist_done
 */
union bdk_tns_txq_dq_bist_stdn
{
    uint32_t u;
    struct bdk_tns_txq_dq_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t tb_access_mem_status  : 1;  /**< [ 27: 27](RO/H) -- */
        uint32_t qcn_qmap_mem_status   : 1;  /**< [ 26: 26](RO/H) -- */
        uint32_t qcn_mem_status        : 1;  /**< [ 25: 25](RO/H) -- */
        uint32_t h1_tm_mem_status      : 7;  /**< [ 24: 18](RO/H) -- */
        uint32_t q_slow_shp_mem_status : 1;  /**< [ 17: 17](RO/H) -- */
        uint32_t h1_dwrr_mem_status    : 1;  /**< [ 16: 16](RO/H) -- */
        uint32_t h1_slow_shp_mem_status : 1; /**< [ 15: 15](RO/H) -- */
        uint32_t pt_dwrr_mem_status    : 1;  /**< [ 14: 14](RO/H) -- */
        uint32_t tb_access_mem_done    : 1;  /**< [ 13: 13](RO/H) -- */
        uint32_t qcn_qmap_mem_done     : 1;  /**< [ 12: 12](RO/H) -- */
        uint32_t qcn_mem_done          : 1;  /**< [ 11: 11](RO/H) -- */
        uint32_t h1_tm_mem_done        : 7;  /**< [ 10:  4](RO/H) -- */
        uint32_t q_slow_shp_mem_done   : 1;  /**< [  3:  3](RO/H) -- */
        uint32_t h1_dwrr_mem_done      : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t h1_slow_shp_mem_done  : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t pt_dwrr_mem_done      : 1;  /**< [  0:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_dwrr_mem_done      : 1;  /**< [  0:  0](RO/H) -- */
        uint32_t h1_slow_shp_mem_done  : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t h1_dwrr_mem_done      : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t q_slow_shp_mem_done   : 1;  /**< [  3:  3](RO/H) -- */
        uint32_t h1_tm_mem_done        : 7;  /**< [ 10:  4](RO/H) -- */
        uint32_t qcn_mem_done          : 1;  /**< [ 11: 11](RO/H) -- */
        uint32_t qcn_qmap_mem_done     : 1;  /**< [ 12: 12](RO/H) -- */
        uint32_t tb_access_mem_done    : 1;  /**< [ 13: 13](RO/H) -- */
        uint32_t pt_dwrr_mem_status    : 1;  /**< [ 14: 14](RO/H) -- */
        uint32_t h1_slow_shp_mem_status : 1; /**< [ 15: 15](RO/H) -- */
        uint32_t h1_dwrr_mem_status    : 1;  /**< [ 16: 16](RO/H) -- */
        uint32_t q_slow_shp_mem_status : 1;  /**< [ 17: 17](RO/H) -- */
        uint32_t h1_tm_mem_status      : 7;  /**< [ 24: 18](RO/H) -- */
        uint32_t qcn_mem_status        : 1;  /**< [ 25: 25](RO/H) -- */
        uint32_t qcn_qmap_mem_status   : 1;  /**< [ 26: 26](RO/H) -- */
        uint32_t tb_access_mem_status  : 1;  /**< [ 27: 27](RO/H) -- */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_bist_stdn_s cn; */
};
typedef union bdk_tns_txq_dq_bist_stdn bdk_tns_txq_dq_bist_stdn_t;

#define BDK_TNS_TXQ_DQ_BIST_STDN BDK_TNS_TXQ_DQ_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BIST_STDN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488114ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_BIST_STDN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_BIST_STDN bdk_tns_txq_dq_bist_stdn_t
#define bustype_BDK_TNS_TXQ_DQ_BIST_STDN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_BIST_STDN "TNS_TXQ_DQ_BIST_STDN"
#define device_bar_BDK_TNS_TXQ_DQ_BIST_STDN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_DQ_BIST_STDN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_byte_ct_off_w0
 *
 * TNS TxQ Deque Byte Count Off Word 0 Register
 * Byte count offset for port/H1/Q DWRR and SHAPERS.  This byte count is
 * added/subtracted to every packet to account for CRC and IPG (XPH).  We use a
 * per port byte count offset because each port may have a different confguration
 * (e.g. XPH).  Bit 0-7 indicate number of bytes.  Bit 8 indicates positive or
 * negative (1=negative, 0=positive).
 */
union bdk_tns_txq_dq_byte_ct_off_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_byte_ct_off_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t port3_bytes           : 5;  /**< [ 31: 27](R/W) -- */
        uint32_t port2_bytes           : 9;  /**< [ 26: 18](R/W) -- */
        uint32_t port1_bytes           : 9;  /**< [ 17:  9](R/W) -- */
        uint32_t port0_bytes           : 9;  /**< [  8:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t port0_bytes           : 9;  /**< [  8:  0](R/W) -- */
        uint32_t port1_bytes           : 9;  /**< [ 17:  9](R/W) -- */
        uint32_t port2_bytes           : 9;  /**< [ 26: 18](R/W) -- */
        uint32_t port3_bytes           : 5;  /**< [ 31: 27](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_byte_ct_off_w0_s cn; */
};
typedef union bdk_tns_txq_dq_byte_ct_off_w0 bdk_tns_txq_dq_byte_ct_off_w0_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048811cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_BYTE_CT_OFF_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 bdk_tns_txq_dq_byte_ct_off_w0_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 "TNS_TXQ_DQ_BYTE_CT_OFF_W0"
#define device_bar_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_byte_ct_off_w1
 *
 * TNS TxQ Deque Byte Count Off Word 1 Register
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 */
union bdk_tns_txq_dq_byte_ct_off_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_byte_ct_off_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t port7_bytes           : 1;  /**< [ 31: 31](R/W) -- */
        uint32_t port6_bytes           : 9;  /**< [ 30: 22](R/W) -- */
        uint32_t port5_bytes           : 9;  /**< [ 21: 13](R/W) -- */
        uint32_t port4_bytes           : 9;  /**< [ 12:  4](R/W) -- */
        uint32_t port3_bytes           : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field PORT3_BYTES from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t port3_bytes           : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field PORT3_BYTES from previous word. */
        uint32_t port4_bytes           : 9;  /**< [ 12:  4](R/W) -- */
        uint32_t port5_bytes           : 9;  /**< [ 21: 13](R/W) -- */
        uint32_t port6_bytes           : 9;  /**< [ 30: 22](R/W) -- */
        uint32_t port7_bytes           : 1;  /**< [ 31: 31](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_byte_ct_off_w1_s cn; */
};
typedef union bdk_tns_txq_dq_byte_ct_off_w1 bdk_tns_txq_dq_byte_ct_off_w1_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488120ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_BYTE_CT_OFF_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 bdk_tns_txq_dq_byte_ct_off_w1_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 "TNS_TXQ_DQ_BYTE_CT_OFF_W1"
#define device_bar_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_byte_ct_off_w2
 *
 * TNS TxQ Deque Byte Count Off Word 2 Register
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 */
union bdk_tns_txq_dq_byte_ct_off_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_byte_ct_off_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t port10_bytes          : 6;  /**< [ 31: 26](R/W) -- */
        uint32_t port9_bytes           : 9;  /**< [ 25: 17](R/W) -- */
        uint32_t port8_bytes           : 9;  /**< [ 16:  8](R/W) -- */
        uint32_t port7_bytes           : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field PORT7_BYTES from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t port7_bytes           : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field PORT7_BYTES from previous word. */
        uint32_t port8_bytes           : 9;  /**< [ 16:  8](R/W) -- */
        uint32_t port9_bytes           : 9;  /**< [ 25: 17](R/W) -- */
        uint32_t port10_bytes          : 6;  /**< [ 31: 26](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_byte_ct_off_w2_s cn; */
};
typedef union bdk_tns_txq_dq_byte_ct_off_w2 bdk_tns_txq_dq_byte_ct_off_w2_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488124ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_BYTE_CT_OFF_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 bdk_tns_txq_dq_byte_ct_off_w2_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 "TNS_TXQ_DQ_BYTE_CT_OFF_W2"
#define device_bar_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_byte_ct_off_w3
 *
 * TNS TxQ Deque Byte Count Off Word 3 Register
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 */
union bdk_tns_txq_dq_byte_ct_off_w3
{
    uint32_t u;
    struct bdk_tns_txq_dq_byte_ct_off_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t port14_bytes          : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t port13_bytes          : 9;  /**< [ 29: 21](R/W) -- */
        uint32_t port12_bytes          : 9;  /**< [ 20: 12](R/W) -- */
        uint32_t port11_bytes          : 9;  /**< [ 11:  3](R/W) -- */
        uint32_t port10_bytes          : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field PORT10_BYTES from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t port10_bytes          : 3;  /**< [  2:  0](R/W) Continuation of MSBs of field PORT10_BYTES from previous word. */
        uint32_t port11_bytes          : 9;  /**< [ 11:  3](R/W) -- */
        uint32_t port12_bytes          : 9;  /**< [ 20: 12](R/W) -- */
        uint32_t port13_bytes          : 9;  /**< [ 29: 21](R/W) -- */
        uint32_t port14_bytes          : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_byte_ct_off_w3_s cn; */
};
typedef union bdk_tns_txq_dq_byte_ct_off_w3 bdk_tns_txq_dq_byte_ct_off_w3_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488128ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_BYTE_CT_OFF_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 bdk_tns_txq_dq_byte_ct_off_w3_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 "TNS_TXQ_DQ_BYTE_CT_OFF_W3"
#define device_bar_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_byte_ct_off_w4
 *
 * TNS TxQ Deque Byte Count Off Word 4 Register
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 */
union bdk_tns_txq_dq_byte_ct_off_w4
{
    uint32_t u;
    struct bdk_tns_txq_dq_byte_ct_off_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t port15_bytes          : 9;  /**< [ 15:  7](R/W) -- */
        uint32_t port14_bytes          : 7;  /**< [  6:  0](R/W) Continuation of MSBs of field PORT14_BYTES from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t port14_bytes          : 7;  /**< [  6:  0](R/W) Continuation of MSBs of field PORT14_BYTES from previous word. */
        uint32_t port15_bytes          : 9;  /**< [ 15:  7](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_byte_ct_off_w4_s cn; */
};
typedef union bdk_tns_txq_dq_byte_ct_off_w4 bdk_tns_txq_dq_byte_ct_off_w4_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048812cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_BYTE_CT_OFF_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 bdk_tns_txq_dq_byte_ct_off_w4_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 "TNS_TXQ_DQ_BYTE_CT_OFF_W4"
#define device_bar_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_drtbaf_int_en_hi
 *
 * TNS TxQ Deque DRC Rx and Token Buffer Access FIFO Interrrupt Enable High Register
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 */
union bdk_tns_txq_dq_drtbaf_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_dq_drtbaf_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](R/W) DQ configuration input DFC Rx overflow */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](R/W) Token Buffer access fifo full error.  Should never happen */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](R/W) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](R/W) Token Buffer access fifo memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](R/W) Token Buffer access fifo memory single bit ECC interrupt */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](R/W) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](R/W) Token Buffer access fifo full error.  Should never happen */
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](R/W) DQ configuration input DFC Rx overflow */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_drtbaf_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_dq_drtbaf_int_en_hi bdk_tns_txq_dq_drtbaf_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488108ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_DRTBAF_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI bdk_tns_txq_dq_drtbaf_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI "TNS_TXQ_DQ_DRTBAF_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_drtbaf_int_en_lo
 *
 * TNS TxQ Deque DRC Rx and Token Buffer Access FIFO Interrrupt Enable Low Register
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 */
union bdk_tns_txq_dq_drtbaf_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_dq_drtbaf_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](R/W) DQ configuration input DFC Rx overflow */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](R/W) Token Buffer access fifo full error.  Should never happen */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](R/W) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](R/W) Token Buffer access fifo memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](R/W) Token Buffer access fifo memory single bit ECC interrupt */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](R/W) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](R/W) Token Buffer access fifo full error.  Should never happen */
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](R/W) DQ configuration input DFC Rx overflow */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_drtbaf_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_dq_drtbaf_int_en_lo bdk_tns_txq_dq_drtbaf_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048810cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_DRTBAF_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO bdk_tns_txq_dq_drtbaf_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO "TNS_TXQ_DQ_DRTBAF_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_drtbaf_int_frc
 *
 * TNS TxQ Deque DRC Rx and Token Buffer Access FIFO Interrrupt Force Register
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 */
union bdk_tns_txq_dq_drtbaf_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_dq_drtbaf_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](WO) DQ configuration input DFC Rx overflow */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](WO) Token Buffer access fifo full error.  Should never happen */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](WO) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](WO) Token Buffer access fifo memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](WO) Token Buffer access fifo memory single bit ECC interrupt */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](WO) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](WO) Token Buffer access fifo full error.  Should never happen */
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](WO) DQ configuration input DFC Rx overflow */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_drtbaf_int_frc_s cn; */
};
typedef union bdk_tns_txq_dq_drtbaf_int_frc bdk_tns_txq_dq_drtbaf_int_frc_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488110ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_DRTBAF_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC bdk_tns_txq_dq_drtbaf_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC "TNS_TXQ_DQ_DRTBAF_INT_FRC"
#define device_bar_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_drtbaf_int_w1c
 *
 * TNS TxQ Deque DRC Rx and Token Buffer Access FIFO Interrrupt W1C Register
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 */
union bdk_tns_txq_dq_drtbaf_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_dq_drtbaf_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](R/W1C/H) DQ configuration input DFC Rx overflow */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](R/W1C/H) Token Buffer access fifo full error.  Should never happen */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](R/W1C/H) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](R/W1C/H) Token Buffer access fifo memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tbaf_sbe              : 1;  /**< [  0:  0](R/W1C/H) Token Buffer access fifo memory single bit ECC interrupt */
        uint32_t tbaf_dbe              : 1;  /**< [  1:  1](R/W1C/H) Token Buffer access fifo memory double bit ECC interrupt */
        uint32_t tbaf_full             : 1;  /**< [  2:  2](R/W1C/H) Token Buffer access fifo full error.  Should never happen */
        uint32_t dfcr_ovfl             : 1;  /**< [  3:  3](R/W1C/H) DQ configuration input DFC Rx overflow */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_drtbaf_int_w1c_s cn; */
};
typedef union bdk_tns_txq_dq_drtbaf_int_w1c bdk_tns_txq_dq_drtbaf_int_w1c_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488104ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_DRTBAF_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C bdk_tns_txq_dq_drtbaf_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C "TNS_TXQ_DQ_DRTBAF_INT_W1C"
#define device_bar_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_ecc_ctl
 *
 * TNS TxQ Deque ECC Control Register
 * ECC configuration of DQ token buffer access memory
 */
union bdk_tns_txq_dq_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_dq_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t tb_access_fifo_db_ecc : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in TB access FIFO memory */
        uint32_t tb_access_fifo_sb_ecc : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in TB access FIFO  memory */
        uint32_t tb_access_fifo_ecc_dis : 1; /**< [  0:  0](R/W) Disable ECC for TB access FIFO memory */
#else /* Word 0 - Little Endian */
        uint32_t tb_access_fifo_ecc_dis : 1; /**< [  0:  0](R/W) Disable ECC for TB access FIFO memory */
        uint32_t tb_access_fifo_sb_ecc : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in TB access FIFO  memory */
        uint32_t tb_access_fifo_db_ecc : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in TB access FIFO memory */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_dq_ecc_ctl bdk_tns_txq_dq_ecc_ctl_t;

#define BDK_TNS_TXQ_DQ_ECC_CTL BDK_TNS_TXQ_DQ_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488118ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_ECC_CTL bdk_tns_txq_dq_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_DQ_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_ECC_CTL "TNS_TXQ_DQ_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_DQ_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_DQ_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_dwrr_cst_mem#
 *
 * TNS TxQ Deque H1 Scheduler DWRR Configuration Status Table Memory Registers
 * Q DWRR weights and counters memory
 */
union bdk_tns_txq_dq_h1s_dwrr_cst_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_dwrr_cst_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 24; /**< [ 31:  8](R/W) -- */
        uint32_t weight                : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t weight                : 8;  /**< [  7:  0](R/W) -- */
        uint32_t count                 : 24; /**< [ 31:  8](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_dwrr_cst_memx_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_dwrr_cst_memx bdk_tns_txq_dq_h1s_dwrr_cst_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070412000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_DWRR_CST_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(a) bdk_tns_txq_dq_h1s_dwrr_cst_memx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(a) "TNS_TXQ_DQ_H1S_DWRR_CST_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_dwrr_ecc_log
 *
 * TNS TxQ Deque H1 Scheduler DWRR ECC Log Register
 * H1 scheduler DWRR configuration and state memory ECC error log.  Address is
 * sticky on first error.  Re-armed after reading
 */
union bdk_tns_txq_dq_h1s_dwrr_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_dwrr_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_dwrr_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_dwrr_ecc_log bdk_tns_txq_dq_h1s_dwrr_ecc_log_t;

#define BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c064ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_DWRR_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG bdk_tns_txq_dq_h1s_dwrr_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG "TNS_TXQ_DQ_H1S_DWRR_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_ecc_ctl
 *
 * TNS TxQ Deque H1 Scheduler ECC Control Register
 * ECC configuration of DQ H1 scheduler memories
 */
union bdk_tns_txq_dq_h1s_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_27_31        : 5;
        uint32_t qcn_db_ecc            : 1;  /**< [ 26: 26](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 2 bits of ECC syndrome in QCN (defeatured)
                                                                 configuration and state memory */
        uint32_t qcn_sb_ecc            : 1;  /**< [ 25: 25](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 1 bit of ECC syndrome in QCN (defeatured)
                                                                 configuration and state  memory */
        uint32_t qcn_ecc_dis           : 1;  /**< [ 24: 24](R/W) Reserved.
                                                                 Internal:
                                                                 Disable ECC for QCN (defeatured) configuration and state
                                                                 memory */
        uint32_t qcn_qmap_db_ecc       : 1;  /**< [ 23: 23](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 2 bits of ECC syndrome in QCN (defeatured) Q mapping
                                                                 memory */
        uint32_t qcn_qmap_sb_ecc       : 1;  /**< [ 22: 22](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 1 bit of ECC syndrome in QCN (defeatured) Q mapping
                                                                 memory */
        uint32_t qcn_qmap_ecc_dis      : 1;  /**< [ 21: 21](R/W) Reserved.
                                                                 Internal:
                                                                 Disable ECC for QCN (defeatured) Q mapping memory */
        uint32_t h1_sch_tm_db_ecc      : 7;  /**< [ 20: 14](R/W) Flip 2 bits of ECC syndrome in H1 scheduler TM config and state memory */
        uint32_t h1_sch_tm_sb_ecc      : 7;  /**< [ 13:  7](R/W) Flip 1 bit of ECC syndrome in H1 scheduler TM config and state  memory */
        uint32_t h1_sch_tm_ecc_dis     : 1;  /**< [  6:  6](R/W) Disable ECC for H1 scheduler TM config and state memory */
        uint32_t q_slow_shp_db_ecc     : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in Q slow shaper memory */
        uint32_t q_slow_shp_sb_ecc     : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in Q slow shaper  memory */
        uint32_t q_slow_shp_ecc_dis    : 1;  /**< [  3:  3](R/W) Disable ECC for Q slow shaper memory */
        uint32_t h1_sch_dwrr_db_ecc    : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in H1 scheduler DWRR memory */
        uint32_t h1_sch_dwrr_sb_ecc    : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in H1 scheduler DWRR memory */
        uint32_t h1_sch_dwrr_ecc_dis   : 1;  /**< [  0:  0](R/W) Disable ECC for H1 scheduler DWRR memory */
#else /* Word 0 - Little Endian */
        uint32_t h1_sch_dwrr_ecc_dis   : 1;  /**< [  0:  0](R/W) Disable ECC for H1 scheduler DWRR memory */
        uint32_t h1_sch_dwrr_sb_ecc    : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in H1 scheduler DWRR memory */
        uint32_t h1_sch_dwrr_db_ecc    : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in H1 scheduler DWRR memory */
        uint32_t q_slow_shp_ecc_dis    : 1;  /**< [  3:  3](R/W) Disable ECC for Q slow shaper memory */
        uint32_t q_slow_shp_sb_ecc     : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in Q slow shaper  memory */
        uint32_t q_slow_shp_db_ecc     : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in Q slow shaper memory */
        uint32_t h1_sch_tm_ecc_dis     : 1;  /**< [  6:  6](R/W) Disable ECC for H1 scheduler TM config and state memory */
        uint32_t h1_sch_tm_sb_ecc      : 7;  /**< [ 13:  7](R/W) Flip 1 bit of ECC syndrome in H1 scheduler TM config and state  memory */
        uint32_t h1_sch_tm_db_ecc      : 7;  /**< [ 20: 14](R/W) Flip 2 bits of ECC syndrome in H1 scheduler TM config and state memory */
        uint32_t qcn_qmap_ecc_dis      : 1;  /**< [ 21: 21](R/W) Reserved.
                                                                 Internal:
                                                                 Disable ECC for QCN (defeatured) Q mapping memory */
        uint32_t qcn_qmap_sb_ecc       : 1;  /**< [ 22: 22](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 1 bit of ECC syndrome in QCN (defeatured) Q mapping
                                                                 memory */
        uint32_t qcn_qmap_db_ecc       : 1;  /**< [ 23: 23](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 2 bits of ECC syndrome in QCN (defeatured) Q mapping
                                                                 memory */
        uint32_t qcn_ecc_dis           : 1;  /**< [ 24: 24](R/W) Reserved.
                                                                 Internal:
                                                                 Disable ECC for QCN (defeatured) configuration and state
                                                                 memory */
        uint32_t qcn_sb_ecc            : 1;  /**< [ 25: 25](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 1 bit of ECC syndrome in QCN (defeatured)
                                                                 configuration and state  memory */
        uint32_t qcn_db_ecc            : 1;  /**< [ 26: 26](R/W) Reserved.
                                                                 Internal:
                                                                 Flip 2 bits of ECC syndrome in QCN (defeatured)
                                                                 configuration and state memory */
        uint32_t reserved_27_31        : 5;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_ecc_ctl bdk_tns_txq_dq_h1s_ecc_ctl_t;

#define BDK_TNS_TXQ_DQ_H1S_ECC_CTL BDK_TNS_TXQ_DQ_H1S_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c050ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_ECC_CTL bdk_tns_txq_dq_h1s_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_ECC_CTL "TNS_TXQ_DQ_H1S_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_fshp_i2q#
 *
 * TNS TxQ Deque H1 Scheduler CB Fast Update Shapper Index To Queue Registers
 * "Q CB shapers fast_update Q # mapping memory. Maps the index of the fast shaper
 * to the associated Queue"
 */
union bdk_tns_txq_dq_h1s_fshp_i2qx
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_fshp_i2qx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t q_node                : 11; /**< [ 10:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t q_node                : 11; /**< [ 10:  0](R/W) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_fshp_i2qx_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_fshp_i2qx bdk_tns_txq_dq_h1s_fshp_i2qx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=159))
        return 0x842070419000ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_FSHP_I2QX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(a) bdk_tns_txq_dq_h1s_fshp_i2qx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(a) "TNS_TXQ_DQ_H1S_FSHP_I2QX"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_fshp_mem#_w0
 *
 * TNS TxQ Deque H1 Scheduler CB Fast Update Shapper Memory Word 0 Registers
 * Q CB shapers fast_update memory
 * Bits[31:19] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_h1s_fshp_memx_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_fshp_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
#else /* Word 0 - Little Endian */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_fshp_memx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_fshp_memx_w0 bdk_tns_txq_dq_h1s_fshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=159))
        return 0x842070418000ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_FSHP_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(a) bdk_tns_txq_dq_h1s_fshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(a) "TNS_TXQ_DQ_H1S_FSHP_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_fshp_mem#_w1
 *
 * TNS TxQ Deque H1 Scheduler CB Fast Update Shapper Memory Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_FSHP_MEM(0..159)_W0
 */
union bdk_tns_txq_dq_h1s_fshp_memx_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_fshp_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_fshp_memx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_fshp_memx_w1 bdk_tns_txq_dq_h1s_fshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=159))
        return 0x842070418004ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_FSHP_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(a) bdk_tns_txq_dq_h1s_fshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(a) "TNS_TXQ_DQ_H1S_FSHP_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_fshp_mem#_w2
 *
 * TNS TxQ Deque H1 Scheduler CB Fast Update Shapper Memory Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_FSHP_MEM(0..159)_W0
 */
union bdk_tns_txq_dq_h1s_fshp_memx_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_fshp_memx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t comp_count            : 19; /**< [ 18:  0](R/W) current shaper pending compensation count */
#else /* Word 0 - Little Endian */
        uint32_t comp_count            : 19; /**< [ 18:  0](R/W) current shaper pending compensation count */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_fshp_memx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_fshp_memx_w2 bdk_tns_txq_dq_h1s_fshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=159))
        return 0x842070418008ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_FSHP_MEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(a) bdk_tns_txq_dq_h1s_fshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(a) "TNS_TXQ_DQ_H1S_FSHP_MEMX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_int_en_hi
 *
 * TNS TxQ Deque H1 Scheduler Interrrupt Enable High Register
 * H1 scheduler interrupt register
 */
union bdk_tns_txq_dq_h1s_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](R/W) Q packet count rolled over */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](R/W) Q packet count tried to decrement when count was zero */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](R/W) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](R/W) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](R/W) Q slow shaper memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](R/W) Q slow shaper memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) H1 scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) H1 scheduler DWRR memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](R/W) Q slow shaper memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](R/W) Q slow shaper memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](R/W) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](R/W) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](R/W) Q packet count tried to decrement when count was zero */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](R/W) Q packet count rolled over */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_int_en_hi bdk_tns_txq_dq_h1s_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_EN_HI BDK_TNS_TXQ_DQ_H1S_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c044ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI bdk_tns_txq_dq_h1s_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI "TNS_TXQ_DQ_H1S_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_int_en_lo
 *
 * TNS TxQ Deque H1 Scheduler Interrrupt Enable Low Register
 * H1 scheduler interrupt register
 */
union bdk_tns_txq_dq_h1s_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](R/W) Q packet count rolled over */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](R/W) Q packet count tried to decrement when count was zero */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](R/W) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](R/W) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](R/W) Q slow shaper memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](R/W) Q slow shaper memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) H1 scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) H1 scheduler DWRR memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](R/W) Q slow shaper memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](R/W) Q slow shaper memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](R/W) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](R/W) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](R/W) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](R/W) Q packet count tried to decrement when count was zero */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](R/W) Q packet count rolled over */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](R/W) Q shaper credits wrapped from negative to positive */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_int_en_lo bdk_tns_txq_dq_h1s_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_EN_LO BDK_TNS_TXQ_DQ_H1S_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c048ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO bdk_tns_txq_dq_h1s_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO "TNS_TXQ_DQ_H1S_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_int_frc
 *
 * TNS TxQ Deque H1 Scheduler Interrrupt Force Register
 * H1 scheduler interrupt register
 */
union bdk_tns_txq_dq_h1s_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](WO) Q shaper credits wrapped from negative to positive */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](WO) Q shaper credits wrapped from negative to positive */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](WO) Q packet count rolled over */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](WO) Q packet count tried to decrement when count was zero */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](WO) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](WO) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](WO) Q slow shaper memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](WO) Q slow shaper memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](WO) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](WO) H1 scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](WO) H1 scheduler DWRR memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](WO) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](WO) Q slow shaper memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](WO) Q slow shaper memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](WO) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](WO) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](WO) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](WO) Q packet count tried to decrement when count was zero */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](WO) Q packet count rolled over */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](WO) Q shaper credits wrapped from negative to positive */
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](WO) Q shaper credits wrapped from negative to positive */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_int_frc_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_int_frc bdk_tns_txq_dq_h1s_int_frc_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_FRC BDK_TNS_TXQ_DQ_H1S_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c04cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_FRC bdk_tns_txq_dq_h1s_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_FRC "TNS_TXQ_DQ_H1S_INT_FRC"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_int_w1c
 *
 * TNS TxQ Deque H1 Scheduler Interrrupt W1C Register
 * H1 scheduler interrupt register
 */
union bdk_tns_txq_dq_h1s_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_26_31        : 6;
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](R/W1C/H) Q shaper credits wrapped from negative to positive */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](R/W1C/H) Q shaper credits wrapped from negative to positive */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](R/W1C/H) Q packet count rolled over */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](R/W1C/H) Q packet count tried to decrement when count was zero */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](R/W1C/H) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](R/W1C/H) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](R/W1C/H) Q slow shaper memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](R/W1C/H) Q slow shaper memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W1C/H) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W1C/H) H1 scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t h1_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W1C/H) H1 scheduler DWRR memory single bit ECC interrupt */
        uint32_t h1_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W1C/H) H1 scheduler DWRR memory double bit ECC interrupt */
        uint32_t q_slow_shp_mem_sb_err : 1;  /**< [  2:  2](R/W1C/H) Q slow shaper memory single bit ECC interrupt */
        uint32_t q_slow_shp_mem_db_err : 1;  /**< [  3:  3](R/W1C/H) Q slow shaper memory double bit ECC interrupt */
        uint32_t h1_sch_tm_mem_sb_err  : 7;  /**< [ 10:  4](R/W1C/H) H1 scheduler TM config and state memory single bit ECC interrupt */
        uint32_t h1_sch_tm_mem_db_err  : 7;  /**< [ 17: 11](R/W1C/H) H1 scheduler TM config and state memory double bit ECC interrupt */
        uint32_t qcn_qmap_mem_sb_err   : 1;  /**< [ 18: 18](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory single bit ECC interrupt */
        uint32_t qcn_qmap_mem_db_err   : 1;  /**< [ 19: 19](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) Q mapping memory double bit ECC interrupt */
        uint32_t qcn_mem_sb_err        : 1;  /**< [ 20: 20](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory single bit
                                                                 ECC interrupt */
        uint32_t qcn_mem_db_err        : 1;  /**< [ 21: 21](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 QCN (defeatured) configuration and state memory double bit
                                                                 ECC interrupt */
        uint32_t q_pkt_ct_neg_err      : 1;  /**< [ 22: 22](R/W1C/H) Q packet count tried to decrement when count was zero */
        uint32_t q_pkt_ct_rollover_err : 1;  /**< [ 23: 23](R/W1C/H) Q packet count rolled over */
        uint32_t q_slow_shp_neg_wrap_err : 1;/**< [ 24: 24](R/W1C/H) Q shaper credits wrapped from negative to positive */
        uint32_t q_fast_shp_neg_wrap_err : 1;/**< [ 25: 25](R/W1C/H) Q shaper credits wrapped from negative to positive */
        uint32_t reserved_26_31        : 6;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_int_w1c_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_int_w1c bdk_tns_txq_dq_h1s_int_w1c_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_W1C BDK_TNS_TXQ_DQ_H1S_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c040ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_W1C bdk_tns_txq_dq_h1s_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_W1C "TNS_TXQ_DQ_H1S_INT_W1C"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_lock
 *
 * TNS TxQ Deque H1 Scheduler Lock Register
 * Lock Register
 */
union bdk_tns_txq_dq_h1s_lock
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_lock_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_lock bdk_tns_txq_dq_h1s_lock_t;

#define BDK_TNS_TXQ_DQ_H1S_LOCK BDK_TNS_TXQ_DQ_H1S_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c0a0ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_LOCK bdk_tns_txq_dq_h1s_lock_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_LOCK "TNS_TXQ_DQ_H1S_LOCK"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_q_gen_cfg
 *
 * TNS TxQ Deque H1 Scheduler Queue General Configuration Register
 * Enable for shapers, DWRR, and slow compensation
 */
union bdk_tns_txq_dq_h1s_q_gen_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_q_gen_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t q_pkt_ct_neg_en       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t shapers_en            : 1;  /**< [  2:  2](R/W) -- */
        uint32_t dwrr_en               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t slow_compensation_en  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t slow_compensation_en  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t dwrr_en               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t shapers_en            : 1;  /**< [  2:  2](R/W) -- */
        uint32_t q_pkt_ct_neg_en       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_q_gen_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_q_gen_cfg bdk_tns_txq_dq_h1s_q_gen_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c068ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_Q_GEN_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG bdk_tns_txq_dq_h1s_q_gen_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG "TNS_TXQ_DQ_H1S_Q_GEN_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qdwrr_mtu_cfg
 *
 * TNS TxQ Deque H1 Scheduler Queue DWRR MTU Configuration Register
 * MTU configuration for H1 arbiter (MTU in bytes = 2^q_dwrr_mtu_cfg).
 */
union bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t data                  : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c06cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG "TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qfshp_adr_map
 *
 * TNS TxQ Deque H1 Scheduler Queue Fast CB Shapper Address Map Register
 * Configuration to map bits in Q array to FAST_UPD CB shapers list index
 */
union bdk_tns_txq_dq_h1s_qfshp_adr_map
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qfshp_adr_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t index_7               : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t index_6               : 4;  /**< [ 27: 24](R/W) -- */
        uint32_t index_5               : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t index_4               : 4;  /**< [ 19: 16](R/W) -- */
        uint32_t index_3               : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t index_2               : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t index_1               : 4;  /**< [  7:  4](R/W) -- */
        uint32_t index_0               : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t index_0               : 4;  /**< [  3:  0](R/W) -- */
        uint32_t index_1               : 4;  /**< [  7:  4](R/W) -- */
        uint32_t index_2               : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t index_3               : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t index_4               : 4;  /**< [ 19: 16](R/W) -- */
        uint32_t index_5               : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t index_6               : 4;  /**< [ 27: 24](R/W) -- */
        uint32_t index_7               : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qfshp_adr_map_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qfshp_adr_map bdk_tns_txq_dq_h1s_qfshp_adr_map_t;

#define BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c070ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP bdk_tns_txq_dq_h1s_qfshp_adr_map_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP "TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qfshp_chk_cfg
 *
 * TNS TxQ Deque H1 Scheduler Queue Fast CB Shapper Check Configuration Register
 * Bitmap used to validate entry in FAST_UPD list
 */
union bdk_tns_txq_dq_h1s_qfshp_chk_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qfshp_chk_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t bitmap                : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t bitmap                : 3;  /**< [  2:  0](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qfshp_chk_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qfshp_chk_cfg bdk_tns_txq_dq_h1s_qfshp_chk_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c078ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG bdk_tns_txq_dq_h1s_qfshp_chk_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG "TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qfshp_map_cfg
 *
 * TNS TxQ Deque H1 Scheduler Queue Fast CB Shapper Map Configuration Register
 * Configuration to map bits in Q array used to validate entry in FAST_UPD list
 */
union bdk_tns_txq_dq_h1s_qfshp_map_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qfshp_map_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t index_2               : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t index_1               : 4;  /**< [  7:  4](R/W) -- */
        uint32_t index_0               : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t index_0               : 4;  /**< [  3:  0](R/W) -- */
        uint32_t index_1               : 4;  /**< [  7:  4](R/W) -- */
        uint32_t index_2               : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qfshp_map_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qfshp_map_cfg bdk_tns_txq_dq_h1s_qfshp_map_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c074ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG bdk_tns_txq_dq_h1s_qfshp_map_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG "TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qpkt_ct_lmt#
 *
 * TNS TxQ Deque H1 Scheduler Queue Packet Count Limit Registers
 * Q packet count limits
 */
union bdk_tns_txq_dq_h1s_qpkt_ct_lmtx
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qpkt_ct_lmtx bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070419400ll + 4ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QPKT_CT_LMTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(a) bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(a) "TNS_TXQ_DQ_H1S_QPKT_CT_LMTX"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qpkt_ct_mem#
 *
 * TNS TxQ Deque H1 Scheduler Queue Packet Count Memory Registers
 * Q packet count memory
 */
union bdk_tns_txq_dq_h1s_qpkt_ct_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qpkt_ct_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qpkt_ct_memx_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qpkt_ct_memx bdk_tns_txq_dq_h1s_qpkt_ct_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070416000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QPKT_CT_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(a) bdk_tns_txq_dq_h1s_qpkt_ct_memx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(a) "TNS_TXQ_DQ_H1S_QPKT_CT_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qpkt_ct_nz#
 *
 * TNS TxQ Deque H1 Scheduler Queue Packet Count Not Zero Registers
 * Use this to set Q nodes to have packet_count_not_zero to 0 or 1 for scheduling
 * purposes.  Useful for clearing a Q in case it has not flushed out properly
 */
union bdk_tns_txq_dq_h1s_qpkt_ct_nzx
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qpkt_ct_nzx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qpkt_ct_nzx_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qpkt_ct_nzx bdk_tns_txq_dq_h1s_qpkt_ct_nzx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x84207041a000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QPKT_CT_NZX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(a) bdk_tns_txq_dq_h1s_qpkt_ct_nzx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(a) "TNS_TXQ_DQ_H1S_QPKT_CT_NZX"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qpkt_fprf_map
 *
 * TNS TxQ Deque H1 Scheduler Queue Packet Full Profile Map Register
 * Map Q address bits to a packet count limit profile
 */
union bdk_tns_txq_dq_h1s_qpkt_fprf_map
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qpkt_fprf_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t q_bit_to_limit_addr6  : 4;  /**< [ 27: 24](R/W) -- */
        uint32_t q_bit_to_limit_addr5  : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t q_bit_to_limit_addr4  : 4;  /**< [ 19: 16](R/W) -- */
        uint32_t q_bit_to_limit_addr3  : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t q_bit_to_limit_addr2  : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t q_bit_to_limit_addr1  : 4;  /**< [  7:  4](R/W) -- */
        uint32_t q_bit_to_limit_addr0  : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t q_bit_to_limit_addr0  : 4;  /**< [  3:  0](R/W) -- */
        uint32_t q_bit_to_limit_addr1  : 4;  /**< [  7:  4](R/W) -- */
        uint32_t q_bit_to_limit_addr2  : 4;  /**< [ 11:  8](R/W) -- */
        uint32_t q_bit_to_limit_addr3  : 4;  /**< [ 15: 12](R/W) -- */
        uint32_t q_bit_to_limit_addr4  : 4;  /**< [ 19: 16](R/W) -- */
        uint32_t q_bit_to_limit_addr5  : 4;  /**< [ 23: 20](R/W) -- */
        uint32_t q_bit_to_limit_addr6  : 4;  /**< [ 27: 24](R/W) -- */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qpkt_fprf_map_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qpkt_fprf_map bdk_tns_txq_dq_h1s_qpkt_fprf_map_t;

#define BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c080ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP bdk_tns_txq_dq_h1s_qpkt_fprf_map_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP "TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qshp_mtu_cfg
 *
 * TNS TxQ Deque H1 Scheduler Queue Shapper MTU Configuration Register
 * MTU configuration register (MTU in BYTES = 2^h2_cb_shapers_mtu_cfg)
 */
union bdk_tns_txq_dq_h1s_qshp_mtu_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qshp_mtu_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qshp_mtu_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qshp_mtu_cfg bdk_tns_txq_dq_h1s_qshp_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c07cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QSHP_MTU_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG bdk_tns_txq_dq_h1s_qshp_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG "TNS_TXQ_DQ_H1S_QSHP_MTU_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_qsshp_ecc_log
 *
 * TNS TxQ Deque H1 Scheduler Queue Slow CB Shaper ECC Log Register
 * Q slow shaper memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_dq_h1s_qsshp_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_qsshp_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_qsshp_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_qsshp_ecc_log bdk_tns_txq_dq_h1s_qsshp_ecc_log_t;

#define BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c060ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG bdk_tns_txq_dq_h1s_qsshp_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG "TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_spad
 *
 * TNS TxQ Deque H1 Scheduler ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_dq_h1s_spad
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_spad_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_spad bdk_tns_txq_dq_h1s_spad_t;

#define BDK_TNS_TXQ_DQ_H1S_SPAD BDK_TNS_TXQ_DQ_H1S_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c0a4ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_SPAD bdk_tns_txq_dq_h1s_spad_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_SPAD "TNS_TXQ_DQ_H1S_SPAD"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_sshp_mem#_w0
 *
 * TNS TxQ Deque H1 Scheduler Slow Shapper Memory Word 0 Registers
 * Q CB shapers fast_update memory
 * Bits[31:19] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_h1s_sshp_memx_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_sshp_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
#else /* Word 0 - Little Endian */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_sshp_memx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_sshp_memx_w0 bdk_tns_txq_dq_h1s_sshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070408000ll + 0x10ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_SSHP_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(a) bdk_tns_txq_dq_h1s_sshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(a) "TNS_TXQ_DQ_H1S_SSHP_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_sshp_mem#_w1
 *
 * TNS TxQ Deque H1 Scheduler Slow Shapper Memory Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_SSHP_MEM(0..2047)_W0
 */
union bdk_tns_txq_dq_h1s_sshp_memx_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_sshp_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_sshp_memx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_sshp_memx_w1 bdk_tns_txq_dq_h1s_sshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070408004ll + 0x10ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_SSHP_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(a) bdk_tns_txq_dq_h1s_sshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(a) "TNS_TXQ_DQ_H1S_SSHP_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_sshp_mem#_w2
 *
 * TNS TxQ Deque H1 Scheduler Slow Shapper Memory Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_SSHP_MEM(0..2047)_W0
 */
union bdk_tns_txq_dq_h1s_sshp_memx_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_sshp_memx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t comp_count            : 19; /**< [ 18:  0](R/W) current shaper pending compensation count */
#else /* Word 0 - Little Endian */
        uint32_t comp_count            : 19; /**< [ 18:  0](R/W) current shaper pending compensation count */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_sshp_memx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_sshp_memx_w2 bdk_tns_txq_dq_h1s_sshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070408008ll + 0x10ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_SSHP_MEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(a) bdk_tns_txq_dq_h1s_sshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(a) "TNS_TXQ_DQ_H1S_SSHP_MEMX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w0
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 0 Registers
 * H1 scheduler TM config table
 * Bits[31:14] in _W[28] are unused.
 * When writing, the MSBs (word 28) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t strict_en             : 32; /**< [ 31:  0](R/W) Strict priority enable for each of the 64 Queues assigned to this port */
#else /* Word 0 - Little Endian */
        uint32_t strict_en             : 32; /**< [ 31:  0](R/W) Strict priority enable for each of the 64 Queues assigned to this port */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w0 bdk_tns_txq_dq_h1s_tm_cstx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400000ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(a) bdk_tns_txq_dq_h1s_tm_cstx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w1
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t strict_en             : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field STRICT_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t strict_en             : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field STRICT_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w1 bdk_tns_txq_dq_h1s_tm_cstx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400004ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(a) bdk_tns_txq_dq_h1s_tm_cstx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w10
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 10 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w10
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w10_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w10_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w10 bdk_tns_txq_dq_h1s_tm_cstx_w10_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400028ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W10", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(a) bdk_tns_txq_dq_h1s_tm_cstx_w10_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W10"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w11
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 11 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w11
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w11_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w11_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w11 bdk_tns_txq_dq_h1s_tm_cstx_w11_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040002cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W11", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(a) bdk_tns_txq_dq_h1s_tm_cstx_w11_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W11"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w12
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 12 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w12
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w12_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w12_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w12 bdk_tns_txq_dq_h1s_tm_cstx_w12_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400030ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W12", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(a) bdk_tns_txq_dq_h1s_tm_cstx_w12_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W12"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w13
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 13 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w13
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w13_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w13_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w13 bdk_tns_txq_dq_h1s_tm_cstx_w13_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400034ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W13", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(a) bdk_tns_txq_dq_h1s_tm_cstx_w13_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W13"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w14
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 14 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w14
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w14_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w14_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w14 bdk_tns_txq_dq_h1s_tm_cstx_w14_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400038ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W14", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(a) bdk_tns_txq_dq_h1s_tm_cstx_w14_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W14"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w15
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 15 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w15
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w15_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w15_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w15 bdk_tns_txq_dq_h1s_tm_cstx_w15_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040003cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W15", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(a) bdk_tns_txq_dq_h1s_tm_cstx_w15_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W15"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w16
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 16 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w16
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w16_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) TC array (4 bits each) for each of the 64 Queues assigned to this port.  This
                                                                 field is valid for all ports */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) TC array (4 bits each) for each of the 64 Queues assigned to this port.  This
                                                                 field is valid for all ports */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w16_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w16 bdk_tns_txq_dq_h1s_tm_cstx_w16_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400040ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W16", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(a) bdk_tns_txq_dq_h1s_tm_cstx_w16_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W16"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w17
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 17 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w17
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w17_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w17_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w17 bdk_tns_txq_dq_h1s_tm_cstx_w17_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400044ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W17", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(a) bdk_tns_txq_dq_h1s_tm_cstx_w17_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W17"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w18
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 18 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w18
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w18_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w18_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w18 bdk_tns_txq_dq_h1s_tm_cstx_w18_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400048ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W18", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(a) bdk_tns_txq_dq_h1s_tm_cstx_w18_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W18"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w19
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 19 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w19
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w19_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w19_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w19 bdk_tns_txq_dq_h1s_tm_cstx_w19_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040004cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W19", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(a) bdk_tns_txq_dq_h1s_tm_cstx_w19_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W19"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w2
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Channel array (7 bits each) for each of the 64 Queues assigned to this port.
                                                                 This field is only valid for H1 nodes associated with Ports 8 and 9 */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Channel array (7 bits each) for each of the 64 Queues assigned to this port.
                                                                 This field is only valid for H1 nodes associated with Ports 8 and 9 */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w2 bdk_tns_txq_dq_h1s_tm_cstx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400008ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(a) bdk_tns_txq_dq_h1s_tm_cstx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w20
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 20 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w20
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w20_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w20_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w20 bdk_tns_txq_dq_h1s_tm_cstx_w20_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400050ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W20", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(a) bdk_tns_txq_dq_h1s_tm_cstx_w20_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W20"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w21
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 21 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w21
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w21_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w21_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w21 bdk_tns_txq_dq_h1s_tm_cstx_w21_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400054ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W21", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(a) bdk_tns_txq_dq_h1s_tm_cstx_w21_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W21"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w22
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 22 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w22
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w22_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w22_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w22 bdk_tns_txq_dq_h1s_tm_cstx_w22_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400058ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W22", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(a) bdk_tns_txq_dq_h1s_tm_cstx_w22_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W22"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w23
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 23 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w23
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w23_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tc_array              : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w23_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w23 bdk_tns_txq_dq_h1s_tm_cstx_w23_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040005cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W23", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(a) bdk_tns_txq_dq_h1s_tm_cstx_w23_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W23"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w24
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 24 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w24
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w24_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dq_en                 : 32; /**< [ 31:  0](R/W) DQ enable for each of the 64 Queues assigned to this port */
#else /* Word 0 - Little Endian */
        uint32_t dq_en                 : 32; /**< [ 31:  0](R/W) DQ enable for each of the 64 Queues assigned to this port */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w24_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w24 bdk_tns_txq_dq_h1s_tm_cstx_w24_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400060ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W24", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(a) bdk_tns_txq_dq_h1s_tm_cstx_w24_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W24"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w25
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 25 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w25
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w25_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t dq_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DQ_EN from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t dq_en                 : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field DQ_EN from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w25_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w25 bdk_tns_txq_dq_h1s_tm_cstx_w25_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400064ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W25", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(a) bdk_tns_txq_dq_h1s_tm_cstx_w25_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W25"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w26
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 26 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w26
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w26_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t q_group2              : 8;  /**< [ 31: 24](R/W) Queue group 2 index */
        uint32_t q_group1              : 8;  /**< [ 23: 16](R/W) Queue group 1 index */
        uint32_t q_group0              : 8;  /**< [ 15:  8](R/W) Queue group 0 index */
        uint32_t q_groups_valid        : 8;  /**< [  7:  0](R/W) Queue groups valid vector, one bit for each of the 8 nodes */
#else /* Word 0 - Little Endian */
        uint32_t q_groups_valid        : 8;  /**< [  7:  0](R/W) Queue groups valid vector, one bit for each of the 8 nodes */
        uint32_t q_group0              : 8;  /**< [ 15:  8](R/W) Queue group 0 index */
        uint32_t q_group1              : 8;  /**< [ 23: 16](R/W) Queue group 1 index */
        uint32_t q_group2              : 8;  /**< [ 31: 24](R/W) Queue group 2 index */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w26_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w26 bdk_tns_txq_dq_h1s_tm_cstx_w26_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400068ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W26", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(a) bdk_tns_txq_dq_h1s_tm_cstx_w26_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W26"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w27
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 27 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w27
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w27_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t q_group6              : 8;  /**< [ 31: 24](R/W) Queue group 6 index */
        uint32_t q_group5              : 8;  /**< [ 23: 16](R/W) Queue group 5 index */
        uint32_t q_group4              : 8;  /**< [ 15:  8](R/W) Queue group 4 index */
        uint32_t q_group3              : 8;  /**< [  7:  0](R/W) Queue group 3 index */
#else /* Word 0 - Little Endian */
        uint32_t q_group3              : 8;  /**< [  7:  0](R/W) Queue group 3 index */
        uint32_t q_group4              : 8;  /**< [ 15:  8](R/W) Queue group 4 index */
        uint32_t q_group5              : 8;  /**< [ 23: 16](R/W) Queue group 5 index */
        uint32_t q_group6              : 8;  /**< [ 31: 24](R/W) Queue group 6 index */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w27_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w27 bdk_tns_txq_dq_h1s_tm_cstx_w27_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040006cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W27", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(a) bdk_tns_txq_dq_h1s_tm_cstx_w27_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W27"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w28
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 28 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w28
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w28_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t last_q_index          : 6;  /**< [ 13:  8](R/W) Last Q index chosen for this H1 node */
        uint32_t q_group7              : 8;  /**< [  7:  0](R/W) Queue group 7 index */
#else /* Word 0 - Little Endian */
        uint32_t q_group7              : 8;  /**< [  7:  0](R/W) Queue group 7 index */
        uint32_t last_q_index          : 6;  /**< [ 13:  8](R/W) Last Q index chosen for this H1 node */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w28_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w28 bdk_tns_txq_dq_h1s_tm_cstx_w28_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400070ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W28", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(a) bdk_tns_txq_dq_h1s_tm_cstx_w28_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W28"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w3
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 3 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w3
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w3_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w3 bdk_tns_txq_dq_h1s_tm_cstx_w3_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040000cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(a) bdk_tns_txq_dq_h1s_tm_cstx_w3_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W3"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w4
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 4 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w4
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w4_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w4 bdk_tns_txq_dq_h1s_tm_cstx_w4_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400010ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(a) bdk_tns_txq_dq_h1s_tm_cstx_w4_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W4"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w5
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 5 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w5
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w5_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w5 bdk_tns_txq_dq_h1s_tm_cstx_w5_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400014ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W5", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(a) bdk_tns_txq_dq_h1s_tm_cstx_w5_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W5"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w6
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 6 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w6
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w6_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w6 bdk_tns_txq_dq_h1s_tm_cstx_w6_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400018ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W6", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(a) bdk_tns_txq_dq_h1s_tm_cstx_w6_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W6"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w7
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 7 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w7
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w7_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w7_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w7 bdk_tns_txq_dq_h1s_tm_cstx_w7_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207040001cll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W7", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(a) bdk_tns_txq_dq_h1s_tm_cstx_w7_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W7"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w8
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 8 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w8
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w8_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w8_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w8 bdk_tns_txq_dq_h1s_tm_cstx_w8_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400020ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W8", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(a) bdk_tns_txq_dq_h1s_tm_cstx_w8_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W8"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_cst#_w9
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager Configuration Status Table Word 9 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 */
union bdk_tns_txq_dq_h1s_tm_cstx_w9
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_cstx_w9_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t channel_array         : 32; /**< [ 31:  0](R/W) Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_cstx_w9_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w9 bdk_tns_txq_dq_h1s_tm_cstx_w9_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070400024ll + 0x80ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_CSTX_W9", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(a) bdk_tns_txq_dq_h1s_tm_cstx_w9_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(a) "TNS_TXQ_DQ_H1S_TM_CSTX_W9"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_h1s_tm_ecc_log
 *
 * TNS TxQ Deque H1 Scheduler Traffic Manager ECC Log Register
 * H1 scheduler TM config and state memory ECC error log.  Address is sticky on
 * first error.  Re-armed after reading
 */
union bdk_tns_txq_dq_h1s_tm_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_h1s_tm_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_h1s_tm_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_h1s_tm_ecc_log bdk_tns_txq_dq_h1s_tm_ecc_log_t;

#define BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c05cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_H1S_TM_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG bdk_tns_txq_dq_h1s_tm_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG "TNS_TXQ_DQ_H1S_TM_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_int_ro
 *
 * TNS TxQ Deque Interrrupt Read Only Register
 * DQ top level interrupt status register
 */
union bdk_tns_txq_dq_int_ro
{
    uint32_t u;
    struct bdk_tns_txq_dq_int_ro_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t h1_sch                : 1;  /**< [  3:  3](RO/H) H1 scheduler high interrupt. */
        uint32_t pt_sch                : 1;  /**< [  2:  2](RO/H) Port schedulerinterrupt. */
        uint32_t pipe_sch              : 1;  /**< [  1:  1](RO/H) Pipe scheduler interrupt. */
        uint32_t dfcr_tbaf             : 1;  /**< [  0:  0](RO/H) DFC RX or Token Buffer access fifo interrupts. */
#else /* Word 0 - Little Endian */
        uint32_t dfcr_tbaf             : 1;  /**< [  0:  0](RO/H) DFC RX or Token Buffer access fifo interrupts. */
        uint32_t pipe_sch              : 1;  /**< [  1:  1](RO/H) Pipe scheduler interrupt. */
        uint32_t pt_sch                : 1;  /**< [  2:  2](RO/H) Port schedulerinterrupt. */
        uint32_t h1_sch                : 1;  /**< [  3:  3](RO/H) H1 scheduler high interrupt. */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_int_ro_s cn; */
};
typedef union bdk_tns_txq_dq_int_ro bdk_tns_txq_dq_int_ro_t;

#define BDK_TNS_TXQ_DQ_INT_RO BDK_TNS_TXQ_DQ_INT_RO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_INT_RO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_INT_RO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488100ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_INT_RO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_INT_RO bdk_tns_txq_dq_int_ro_t
#define bustype_BDK_TNS_TXQ_DQ_INT_RO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_INT_RO "TNS_TXQ_DQ_INT_RO"
#define device_bar_BDK_TNS_TXQ_DQ_INT_RO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_INT_RO 0
#define arguments_BDK_TNS_TXQ_DQ_INT_RO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_lock
 *
 * TNS TxQ Deque Lock Register
 * Lock Register
 */
union bdk_tns_txq_dq_lock
{
    uint32_t u;
    struct bdk_tns_txq_dq_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_lock_s cn; */
};
typedef union bdk_tns_txq_dq_lock bdk_tns_txq_dq_lock_t;

#define BDK_TNS_TXQ_DQ_LOCK BDK_TNS_TXQ_DQ_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488140ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_LOCK bdk_tns_txq_dq_lock_t
#define bustype_BDK_TNS_TXQ_DQ_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_LOCK "TNS_TXQ_DQ_LOCK"
#define device_bar_BDK_TNS_TXQ_DQ_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_dwrr_cst_mem#
 *
 * TNS TxQ Deque Pipe Scheduler DWRR Configuration Status Table Memory Registers
 * PORT DWRR weights and counters memory
 */
union bdk_tns_txq_dq_pps_dwrr_cst_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_dwrr_cst_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 24; /**< [ 31:  8](R/W) -- */
        uint32_t weight                : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t weight                : 8;  /**< [  7:  0](R/W) -- */
        uint32_t count                 : 24; /**< [ 31:  8](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_dwrr_cst_memx_s cn; */
};
typedef union bdk_tns_txq_dq_pps_dwrr_cst_memx bdk_tns_txq_dq_pps_dwrr_cst_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070489080ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_DWRR_CST_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(a) bdk_tns_txq_dq_pps_dwrr_cst_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(a) "TNS_TXQ_DQ_PPS_DWRR_CST_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_frc_ptp_mskof
 *
 * TNS TxQ Deque Pipe Scheduler Force Port Pacing Mask Off Register
 * Debug register to force port pacing mask on.  One bit for each port
 */
union bdk_tns_txq_dq_pps_frc_ptp_mskof
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_frc_ptp_mskof_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t force_port15_off      : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t force_port14_off      : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t force_port13_off      : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t force_port12_off      : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t force_port11_off      : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t force_port10_off      : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t force_port9_off       : 1;  /**< [  9:  9](R/W) -- */
        uint32_t force_port8_off       : 1;  /**< [  8:  8](R/W) -- */
        uint32_t force_port7_off       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t force_port6_off       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t force_port5_off       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t force_port4_off       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t force_port3_off       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t force_port2_off       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t force_port1_off       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t force_port0_off       : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t force_port0_off       : 1;  /**< [  0:  0](R/W) -- */
        uint32_t force_port1_off       : 1;  /**< [  1:  1](R/W) -- */
        uint32_t force_port2_off       : 1;  /**< [  2:  2](R/W) -- */
        uint32_t force_port3_off       : 1;  /**< [  3:  3](R/W) -- */
        uint32_t force_port4_off       : 1;  /**< [  4:  4](R/W) -- */
        uint32_t force_port5_off       : 1;  /**< [  5:  5](R/W) -- */
        uint32_t force_port6_off       : 1;  /**< [  6:  6](R/W) -- */
        uint32_t force_port7_off       : 1;  /**< [  7:  7](R/W) -- */
        uint32_t force_port8_off       : 1;  /**< [  8:  8](R/W) -- */
        uint32_t force_port9_off       : 1;  /**< [  9:  9](R/W) -- */
        uint32_t force_port10_off      : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t force_port11_off      : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t force_port12_off      : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t force_port13_off      : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t force_port14_off      : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t force_port15_off      : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_frc_ptp_mskof_s cn; */
};
typedef union bdk_tns_txq_dq_pps_frc_ptp_mskof bdk_tns_txq_dq_pps_frc_ptp_mskof_t;

#define BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891f0ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF bdk_tns_txq_dq_pps_frc_ptp_mskof_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF "TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_frc_ptp_mskon
 *
 * TNS TxQ Deque Pipe Scheduler Force Port Pacing Mask On Register
 * Debug register to force port pacing mask on.  One bit for each port
 */
union bdk_tns_txq_dq_pps_frc_ptp_mskon
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_frc_ptp_mskon_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t force_port15_on       : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t force_port14_on       : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t force_port13_on       : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t force_port12_on       : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t force_port11_on       : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t force_port10_on       : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t force_port9_on        : 1;  /**< [  9:  9](R/W) -- */
        uint32_t force_port8_on        : 1;  /**< [  8:  8](R/W) -- */
        uint32_t force_port7_on        : 1;  /**< [  7:  7](R/W) -- */
        uint32_t force_port6_on        : 1;  /**< [  6:  6](R/W) -- */
        uint32_t force_port5_on        : 1;  /**< [  5:  5](R/W) -- */
        uint32_t force_port4_on        : 1;  /**< [  4:  4](R/W) -- */
        uint32_t force_port3_on        : 1;  /**< [  3:  3](R/W) -- */
        uint32_t force_port2_on        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t force_port1_on        : 1;  /**< [  1:  1](R/W) -- */
        uint32_t force_port0_on        : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t force_port0_on        : 1;  /**< [  0:  0](R/W) -- */
        uint32_t force_port1_on        : 1;  /**< [  1:  1](R/W) -- */
        uint32_t force_port2_on        : 1;  /**< [  2:  2](R/W) -- */
        uint32_t force_port3_on        : 1;  /**< [  3:  3](R/W) -- */
        uint32_t force_port4_on        : 1;  /**< [  4:  4](R/W) -- */
        uint32_t force_port5_on        : 1;  /**< [  5:  5](R/W) -- */
        uint32_t force_port6_on        : 1;  /**< [  6:  6](R/W) -- */
        uint32_t force_port7_on        : 1;  /**< [  7:  7](R/W) -- */
        uint32_t force_port8_on        : 1;  /**< [  8:  8](R/W) -- */
        uint32_t force_port9_on        : 1;  /**< [  9:  9](R/W) -- */
        uint32_t force_port10_on       : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t force_port11_on       : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t force_port12_on       : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t force_port13_on       : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t force_port14_on       : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t force_port15_on       : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_frc_ptp_mskon_s cn; */
};
typedef union bdk_tns_txq_dq_pps_frc_ptp_mskon bdk_tns_txq_dq_pps_frc_ptp_mskon_t;

#define BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891ecll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_FRC_PTP_MSKON", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON bdk_tns_txq_dq_pps_frc_ptp_mskon_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON "TNS_TXQ_DQ_PPS_FRC_PTP_MSKON"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pps_fshp_mem#
 *
 * TNS TxQ Deque Pipe Scheduler CB Fast Update Shapper Memory Registers
 * PORT CB shapers fast_update memory
 */
union bdk_tns_txq_dq_pps_fshp_memx
{
    uint64_t u;
    struct bdk_tns_txq_dq_pps_fshp_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t enable                : 1;  /**< [ 63: 63](R/W) enable */
        uint64_t max_burst_size        : 8;  /**< [ 62: 55](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint64_t tokens_to_add         : 14; /**< [ 54: 41](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint64_t rate_divider          : 8;  /**< [ 40: 33](R/W) update rate divider for shaper time-wheel */
        uint64_t bucket_size           : 25; /**< [ 32:  8](R/W) current token bucket size (in bytes).  Signed two's complement number */
        uint64_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
#else /* Word 0 - Little Endian */
        uint64_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
        uint64_t bucket_size           : 25; /**< [ 32:  8](R/W) current token bucket size (in bytes).  Signed two's complement number */
        uint64_t rate_divider          : 8;  /**< [ 40: 33](R/W) update rate divider for shaper time-wheel */
        uint64_t tokens_to_add         : 14; /**< [ 54: 41](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint64_t max_burst_size        : 8;  /**< [ 62: 55](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint64_t enable                : 1;  /**< [ 63: 63](R/W) enable */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_fshp_memx_s cn; */
};
typedef union bdk_tns_txq_dq_pps_fshp_memx bdk_tns_txq_dq_pps_fshp_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070489000ll + 8ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_FSHP_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(a) bdk_tns_txq_dq_pps_fshp_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(a) "TNS_TXQ_DQ_PPS_FSHP_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_int_en_hi
 *
 * TNS TxQ Deque Pipe Scheduler Interrrupt Enable High Register
 * PIPE scheduler intr register
 */
union bdk_tns_txq_dq_pps_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](R/W) Port packet count rolled over */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](R/W) Port packet count tried to decrement when count was zero */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](R/W) Port shaper bucket count wrapped from negative to positive */
#else /* Word 0 - Little Endian */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](R/W) Port shaper bucket count wrapped from negative to positive */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](R/W) Port packet count tried to decrement when count was zero */
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](R/W) Port packet count rolled over */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_dq_pps_int_en_hi bdk_tns_txq_dq_pps_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_EN_HI BDK_TNS_TXQ_DQ_PPS_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891c4ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI bdk_tns_txq_dq_pps_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI "TNS_TXQ_DQ_PPS_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_int_en_lo
 *
 * TNS TxQ Deque Pipe Scheduler Interrrupt Enable Low Register
 * PIPE scheduler intr register
 */
union bdk_tns_txq_dq_pps_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](R/W) Port packet count rolled over */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](R/W) Port packet count tried to decrement when count was zero */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](R/W) Port shaper bucket count wrapped from negative to positive */
#else /* Word 0 - Little Endian */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](R/W) Port shaper bucket count wrapped from negative to positive */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](R/W) Port packet count tried to decrement when count was zero */
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](R/W) Port packet count rolled over */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_dq_pps_int_en_lo bdk_tns_txq_dq_pps_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_EN_LO BDK_TNS_TXQ_DQ_PPS_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891c8ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO bdk_tns_txq_dq_pps_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO "TNS_TXQ_DQ_PPS_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_int_frc
 *
 * TNS TxQ Deque Pipe Scheduler Interrrupt Force Register
 * PIPE scheduler intr register
 */
union bdk_tns_txq_dq_pps_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](WO) Port packet count rolled over */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](WO) Port packet count tried to decrement when count was zero */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](WO) Port shaper bucket count wrapped from negative to positive */
#else /* Word 0 - Little Endian */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](WO) Port shaper bucket count wrapped from negative to positive */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](WO) Port packet count tried to decrement when count was zero */
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](WO) Port packet count rolled over */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_int_frc_s cn; */
};
typedef union bdk_tns_txq_dq_pps_int_frc bdk_tns_txq_dq_pps_int_frc_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_FRC BDK_TNS_TXQ_DQ_PPS_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891ccll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_FRC bdk_tns_txq_dq_pps_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_FRC "TNS_TXQ_DQ_PPS_INT_FRC"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_int_w1c
 *
 * TNS TxQ Deque Pipe Scheduler Interrrupt W1C Register
 * PIPE scheduler intr register
 */
union bdk_tns_txq_dq_pps_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](R/W1C/H) Port packet count rolled over */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](R/W1C/H) Port packet count tried to decrement when count was zero */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](R/W1C/H) Port shaper bucket count wrapped from negative to positive */
#else /* Word 0 - Little Endian */
        uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;/**< [  0:  0](R/W1C/H) Port shaper bucket count wrapped from negative to positive */
        uint32_t pt_pkt_ct_neg_err     : 1;  /**< [  1:  1](R/W1C/H) Port packet count tried to decrement when count was zero */
        uint32_t pt_pkt_ct_rollover_err : 1; /**< [  2:  2](R/W1C/H) Port packet count rolled over */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_int_w1c_s cn; */
};
typedef union bdk_tns_txq_dq_pps_int_w1c bdk_tns_txq_dq_pps_int_w1c_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_W1C BDK_TNS_TXQ_DQ_PPS_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891c0ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_W1C bdk_tns_txq_dq_pps_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_W1C "TNS_TXQ_DQ_PPS_INT_W1C"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_lock
 *
 * TNS TxQ Deque Pipe Scheduler Lock Register
 * Lock Register
 */
union bdk_tns_txq_dq_pps_lock
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_lock_s cn; */
};
typedef union bdk_tns_txq_dq_pps_lock bdk_tns_txq_dq_pps_lock_t;

#define BDK_TNS_TXQ_DQ_PPS_LOCK BDK_TNS_TXQ_DQ_PPS_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070489200ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_LOCK bdk_tns_txq_dq_pps_lock_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_LOCK "TNS_TXQ_DQ_PPS_LOCK"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_pdwrr_mtu_cfg
 *
 * TNS TxQ Deque Pipe Scheduler Port DWRR MTU Configuration Register
 * MTU configuration for PIPE arbiter (MTU in bytes = 2^port_dwrr_mtu_cfg).
 */
union bdk_tns_txq_dq_pps_pdwrr_mtu_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pps_pdwrr_mtu_cfg bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891d4ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG "TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_port_spd_mem#
 *
 * TNS TxQ Deque Pipe Scheduler Port Speed Memory Registers
 * Port speed configuration used in computing the minimum number of cycles for
 * which a port is masked after scheduling. The assignment of speed values 0-7 is
 * based on the programming of the register port_pacing_mask_cycle
 */
union bdk_tns_txq_dq_pps_port_spd_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_port_spd_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t speed                 : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t speed                 : 3;  /**< [  2:  0](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_port_spd_memx_s cn; */
};
typedef union bdk_tns_txq_dq_pps_port_spd_memx bdk_tns_txq_dq_pps_port_spd_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070489140ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PORT_SPD_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(a) bdk_tns_txq_dq_pps_port_spd_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(a) "TNS_TXQ_DQ_PPS_PORT_SPD_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ppkt_ct_lmt#
 *
 * TNS TxQ Deque Pipe Scheduler Port Packet Count Limit Registers
 * per-port packet count limits
 */
union bdk_tns_txq_dq_pps_ppkt_ct_lmtx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ppkt_ct_lmtx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ppkt_ct_lmtx_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ppkt_ct_lmtx bdk_tns_txq_dq_pps_ppkt_ct_lmtx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x8420704890c0ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PPKT_CT_LMTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(a) bdk_tns_txq_dq_pps_ppkt_ct_lmtx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(a) "TNS_TXQ_DQ_PPS_PPKT_CT_LMTX"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ppkt_ct_mem#
 *
 * TNS TxQ Deque Pipe Scheduler Port Packet Count Memory Registers
 * per-port packet count memory
 */
union bdk_tns_txq_dq_pps_ppkt_ct_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ppkt_ct_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ppkt_ct_memx_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ppkt_ct_memx bdk_tns_txq_dq_pps_ppkt_ct_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070489100ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PPKT_CT_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(a) bdk_tns_txq_dq_pps_ppkt_ct_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(a) "TNS_TXQ_DQ_PPS_PPKT_CT_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ppkt_ct_nz#
 *
 * TNS TxQ Deque Pipe Scheduler Port Packet Count Not Zero Registers
 * Use this to set/unset ports to have packet_count_not_zero to 0 or 1 for
 * scheduling purposes.  Useful for clearing a port in case it has not flushed out
 * properly
 */
union bdk_tns_txq_dq_pps_ppkt_ct_nzx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ppkt_ct_nzx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ppkt_ct_nzx_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ppkt_ct_nzx bdk_tns_txq_dq_pps_ppkt_ct_nzx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070489180ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PPKT_CT_NZX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(a) bdk_tns_txq_dq_pps_ppkt_ct_nzx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(a) "TNS_TXQ_DQ_PPS_PPKT_CT_NZX"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_pshp_mtu_cfg
 *
 * TNS TxQ Deque Pipe Scheduler Port CB Shapper MTU Configuration Register
 * MTU configuration register (MTU in BYTES = 2^port_cb_shapers_mtu_cfg)
 */
union bdk_tns_txq_dq_pps_pshp_mtu_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_pshp_mtu_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_pshp_mtu_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pps_pshp_mtu_cfg bdk_tns_txq_dq_pps_pshp_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891d8ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PSHP_MTU_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG bdk_tns_txq_dq_pps_pshp_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG "TNS_TXQ_DQ_PPS_PSHP_MTU_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_pt_gen_cfg
 *
 * TNS TxQ Deque Pipe Scheduler PORT General Configuration Register
 * Enable for shapers and DWRR
 */
union bdk_tns_txq_dq_pps_pt_gen_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_pt_gen_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pt_pkt_ct_neg_en      : 1;  /**< [  2:  2](R/W) -- */
        uint32_t shapers_en            : 1;  /**< [  1:  1](R/W) -- */
        uint32_t dwrr_en               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t dwrr_en               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t shapers_en            : 1;  /**< [  1:  1](R/W) -- */
        uint32_t pt_pkt_ct_neg_en      : 1;  /**< [  2:  2](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_pt_gen_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pps_pt_gen_cfg bdk_tns_txq_dq_pps_pt_gen_cfg_t;

#define BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891d0ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PT_GEN_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG bdk_tns_txq_dq_pps_pt_gen_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG "TNS_TXQ_DQ_PPS_PT_GEN_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ptp_mskcy_w0
 *
 * TNS TxQ Deque Pipe Scheduler Port Pacing Mask Cycles Word 0 Register
 * "Indicates # of cycles between scheduling a particular port
 * {40G,10G,1G,100M, 10M} is the order.   The number of masking cycles one
 * more than the programmed value.  A value of 9 will ensure that a port only has
 * one packet scheduled every 10 cycles."
 */
union bdk_tns_txq_dq_pps_ptp_mskcy_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ptp_mskcy_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mask_other0_cycles    : 16; /**< [ 31: 16](R/W) -- */
        uint32_t mask_other1_cycles    : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mask_other1_cycles    : 16; /**< [ 15:  0](R/W) -- */
        uint32_t mask_other0_cycles    : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ptp_mskcy_w0_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w0 bdk_tns_txq_dq_pps_ptp_mskcy_w0_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891dcll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PTP_MSKCY_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 bdk_tns_txq_dq_pps_ptp_mskcy_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W0"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ptp_mskcy_w1
 *
 * TNS TxQ Deque Pipe Scheduler Port Pacing Mask Cycles Word 1 Register
 * Continuation of structure defined in TNS_TXQ_DQ_PPS_PTP_MSKCY_W0
 */
union bdk_tns_txq_dq_pps_ptp_mskcy_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ptp_mskcy_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mask_100m_cycles      : 16; /**< [ 31: 16](R/W) -- */
        uint32_t mask_10m_cycles       : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mask_10m_cycles       : 16; /**< [ 15:  0](R/W) -- */
        uint32_t mask_100m_cycles      : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ptp_mskcy_w1_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w1 bdk_tns_txq_dq_pps_ptp_mskcy_w1_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891e0ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PTP_MSKCY_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 bdk_tns_txq_dq_pps_ptp_mskcy_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W1"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ptp_mskcy_w2
 *
 * TNS TxQ Deque Pipe Scheduler Port Pacing Mask Cycles Word 2 Register
 * Continuation of structure defined in TNS_TXQ_DQ_PPS_PTP_MSKCY_W0
 */
union bdk_tns_txq_dq_pps_ptp_mskcy_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ptp_mskcy_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mask_10g_cycles       : 16; /**< [ 31: 16](R/W) -- */
        uint32_t mask_1g_cycles        : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mask_1g_cycles        : 16; /**< [ 15:  0](R/W) -- */
        uint32_t mask_10g_cycles       : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ptp_mskcy_w2_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w2 bdk_tns_txq_dq_pps_ptp_mskcy_w2_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891e4ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PTP_MSKCY_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 bdk_tns_txq_dq_pps_ptp_mskcy_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W2"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_ptp_mskcy_w3
 *
 * TNS TxQ Deque Pipe Scheduler Port Pacing Mask Cycles Word 3 Register
 * Continuation of structure defined in TNS_TXQ_DQ_PPS_PTP_MSKCY_W0
 */
union bdk_tns_txq_dq_pps_ptp_mskcy_w3
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_ptp_mskcy_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t mask_40g_cycles       : 16; /**< [ 31: 16](R/W) -- */
        uint32_t mask_20g_cycles       : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mask_20g_cycles       : 16; /**< [ 15:  0](R/W) -- */
        uint32_t mask_40g_cycles       : 16; /**< [ 31: 16](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_ptp_mskcy_w3_s cn; */
};
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w3 bdk_tns_txq_dq_pps_ptp_mskcy_w3_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891e8ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PTP_MSKCY_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 bdk_tns_txq_dq_pps_ptp_mskcy_w3_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W3"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_pus_4_cpu_acs
 *
 * TNS TxQ Deque Pipe Scheduler Pause For CPU Access Register
 * Bit to pause DQ pipe TM_CFG from issuing valid which would stop the entire Dq
 * process
 */
union bdk_tns_txq_dq_pps_pus_4_cpu_acs
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_pus_4_cpu_acs_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t pause                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pause                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_pus_4_cpu_acs_s cn; */
};
typedef union bdk_tns_txq_dq_pps_pus_4_cpu_acs bdk_tns_txq_dq_pps_pus_4_cpu_acs_t;

#define BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891f4ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS bdk_tns_txq_dq_pps_pus_4_cpu_acs_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS "TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pps_spad
 *
 * TNS TxQ Deque Pipe Scheduler ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_dq_pps_spad
{
    uint32_t u;
    struct bdk_tns_txq_dq_pps_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_spad_s cn; */
};
typedef union bdk_tns_txq_dq_pps_spad bdk_tns_txq_dq_pps_spad_t;

#define BDK_TNS_TXQ_DQ_PPS_SPAD BDK_TNS_TXQ_DQ_PPS_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070489204ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_SPAD bdk_tns_txq_dq_pps_spad_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PPS_SPAD "TNS_TXQ_DQ_PPS_SPAD"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_SPAD -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pps_tm_cfg_dat
 *
 * TNS TxQ Deque Pipe Scheduler Traffic Manager Configuration Data Register
 * TM config and state information for various ports tied to a pipe
 */
union bdk_tns_txq_dq_pps_tm_cfg_dat
{
    uint64_t u;
    struct bdk_tns_txq_dq_pps_tm_cfg_dat_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_52_63        : 12;
        uint64_t dq_en                 : 16; /**< [ 51: 36](R/W/H) DQ enable for each of the supported  16 ports */
        uint64_t strict_en             : 16; /**< [ 35: 20](R/W/H) Strict prioirty enable for each of the supported 16 ports */
        uint64_t pt_valid              : 16; /**< [ 19:  4](R/W/H) Port is valid for scheduling purposes */
        uint64_t last_port             : 4;  /**< [  3:  0](R/W/H) Last port scheduled by pipe scheduler */
#else /* Word 0 - Little Endian */
        uint64_t last_port             : 4;  /**< [  3:  0](R/W/H) Last port scheduled by pipe scheduler */
        uint64_t pt_valid              : 16; /**< [ 19:  4](R/W/H) Port is valid for scheduling purposes */
        uint64_t strict_en             : 16; /**< [ 35: 20](R/W/H) Strict prioirty enable for each of the supported 16 ports */
        uint64_t dq_en                 : 16; /**< [ 51: 36](R/W/H) DQ enable for each of the supported  16 ports */
        uint64_t reserved_52_63        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pps_tm_cfg_dat_s cn; */
};
typedef union bdk_tns_txq_dq_pps_tm_cfg_dat bdk_tns_txq_dq_pps_tm_cfg_dat_t;

#define BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420704891f8ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PPS_TM_CFG_DAT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT bdk_tns_txq_dq_pps_tm_cfg_dat_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT "TNS_TXQ_DQ_PPS_TM_CFG_DAT"
#define device_bar_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_dwrr_cst_mem#
 *
 * TNS TxQ Deque Port Scheduler DWRR Configuration Status Table Memory Registers
 * H1 DWRR weights and counters memory
 */
union bdk_tns_txq_dq_pts_dwrr_cst_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_dwrr_cst_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 24; /**< [ 31:  8](R/W) -- */
        uint32_t weight                : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t weight                : 8;  /**< [  7:  0](R/W) -- */
        uint32_t count                 : 24; /**< [ 31:  8](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_dwrr_cst_memx_s cn; */
};
typedef union bdk_tns_txq_dq_pts_dwrr_cst_memx bdk_tns_txq_dq_pts_dwrr_cst_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070481400ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_DWRR_CST_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(a) bdk_tns_txq_dq_pts_dwrr_cst_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(a) "TNS_TXQ_DQ_PTS_DWRR_CST_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_dwrr_ecc_log
 *
 * TNS TxQ Deque Port Scheduler DWRR ECC Log Register
 * Port scheduler DWRR configuration and state memory ECC error log.  Address is
 * sticky on first error.  Re-armed after reading
 */
union bdk_tns_txq_dq_pts_dwrr_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_dwrr_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_dwrr_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_pts_dwrr_ecc_log bdk_tns_txq_dq_pts_dwrr_ecc_log_t;

#define BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482858ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_DWRR_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG bdk_tns_txq_dq_pts_dwrr_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG "TNS_TXQ_DQ_PTS_DWRR_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_ecc_ctl
 *
 * TNS TxQ Deque Port Scheduler ECC Control Register
 * ECC configuration of DQ port scheduler memories
 */
union bdk_tns_txq_dq_pts_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t h1_slow_shp_db_ecc    : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in H1 slow shaper memory */
        uint32_t h1_slow_shp_sb_ecc    : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in H1 slow shaper  memory */
        uint32_t h1_slow_shp_ecc_dis   : 1;  /**< [  3:  3](R/W) Disable ECC for H1 slow shaper memory */
        uint32_t pt_sch_dwrr_db_ecc    : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in Port scheduler DWRR memory */
        uint32_t pt_sch_dwrr_sb_ecc    : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in Port scheduler DWRR memory */
        uint32_t pt_sch_dwrr_ecc_dis   : 1;  /**< [  0:  0](R/W) Disable ECC for Port scheduler DWRR memory */
#else /* Word 0 - Little Endian */
        uint32_t pt_sch_dwrr_ecc_dis   : 1;  /**< [  0:  0](R/W) Disable ECC for Port scheduler DWRR memory */
        uint32_t pt_sch_dwrr_sb_ecc    : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in Port scheduler DWRR memory */
        uint32_t pt_sch_dwrr_db_ecc    : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in Port scheduler DWRR memory */
        uint32_t h1_slow_shp_ecc_dis   : 1;  /**< [  3:  3](R/W) Disable ECC for H1 slow shaper memory */
        uint32_t h1_slow_shp_sb_ecc    : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in H1 slow shaper  memory */
        uint32_t h1_slow_shp_db_ecc    : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in H1 slow shaper memory */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_dq_pts_ecc_ctl bdk_tns_txq_dq_pts_ecc_ctl_t;

#define BDK_TNS_TXQ_DQ_PTS_ECC_CTL BDK_TNS_TXQ_DQ_PTS_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482850ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_ECC_CTL bdk_tns_txq_dq_pts_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_ECC_CTL "TNS_TXQ_DQ_PTS_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_fshp_i2h#
 *
 * TNS TxQ Deque Port Scheduler CB Fast Update Shapper Index To H1 Registers
 * "H1 CB shapers fast_update H1 # memory.  Maps the index of the fast shaper to
 * the associated H1 node"
 */
union bdk_tns_txq_dq_pts_fshp_i2hx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_fshp_i2hx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t h1_node               : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t h1_node               : 8;  /**< [  7:  0](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_fshp_i2hx_s cn; */
};
typedef union bdk_tns_txq_dq_pts_fshp_i2hx bdk_tns_txq_dq_pts_fshp_i2hx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842070482200ll + 4ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_FSHP_I2HX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(a) bdk_tns_txq_dq_pts_fshp_i2hx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(a) "TNS_TXQ_DQ_PTS_FSHP_I2HX"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_fshp_mem#_w0
 *
 * TNS TxQ Deque Port Scheduler CB Fast Update Shapper Memory Word 0 Registers
 * H1 CB shapers fast_update memory
 * Bits[31:16] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_pts_fshp_memx_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_fshp_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
#else /* Word 0 - Little Endian */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_fshp_memx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_pts_fshp_memx_w0 bdk_tns_txq_dq_pts_fshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842070481800ll + 0x10ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_FSHP_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(a) bdk_tns_txq_dq_pts_fshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(a) "TNS_TXQ_DQ_PTS_FSHP_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_fshp_mem#_w1
 *
 * TNS TxQ Deque Port Scheduler CB Fast Update Shapper Memory Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_FSHP_MEM(0..63)_W0
 */
union bdk_tns_txq_dq_pts_fshp_memx_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_fshp_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_fshp_memx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_pts_fshp_memx_w1 bdk_tns_txq_dq_pts_fshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842070481804ll + 0x10ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_FSHP_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(a) bdk_tns_txq_dq_pts_fshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(a) "TNS_TXQ_DQ_PTS_FSHP_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_fshp_mem#_w2
 *
 * TNS TxQ Deque Port Scheduler CB Fast Update Shapper Memory Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_FSHP_MEM(0..63)_W0
 */
union bdk_tns_txq_dq_pts_fshp_memx_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_fshp_memx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t comp_count            : 16; /**< [ 15:  0](R/W) current shaper pending compensation count */
#else /* Word 0 - Little Endian */
        uint32_t comp_count            : 16; /**< [ 15:  0](R/W) current shaper pending compensation count */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_fshp_memx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_pts_fshp_memx_w2 bdk_tns_txq_dq_pts_fshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842070481808ll + 0x10ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_FSHP_MEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(a) bdk_tns_txq_dq_pts_fshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(a) "TNS_TXQ_DQ_PTS_FSHP_MEMX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_h1_gen_cfg
 *
 * TNS TxQ Deque Port Scheduler H1 General Configuration Register
 * Enable for shapers, DWRR.
 */
union bdk_tns_txq_dq_pts_h1_gen_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_h1_gen_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t h1_pkt_ct_neg_en      : 1;  /**< [  4:  4](R/W) -- */
        uint32_t prop_prio_en          : 1;  /**< [  3:  3](R/W) Reserved. It must be set to 0 after reset.
                                                                 Internal:
                                                                 Propagated priority
                                                                 enable. Propagated priority is defeatured. */
        uint32_t shapers_en            : 1;  /**< [  2:  2](R/W) -- */
        uint32_t dwrr_en               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t slow_compensation_en  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t slow_compensation_en  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t dwrr_en               : 1;  /**< [  1:  1](R/W) -- */
        uint32_t shapers_en            : 1;  /**< [  2:  2](R/W) -- */
        uint32_t prop_prio_en          : 1;  /**< [  3:  3](R/W) Reserved. It must be set to 0 after reset.
                                                                 Internal:
                                                                 Propagated priority
                                                                 enable. Propagated priority is defeatured. */
        uint32_t h1_pkt_ct_neg_en      : 1;  /**< [  4:  4](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_h1_gen_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pts_h1_gen_cfg bdk_tns_txq_dq_pts_h1_gen_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048285cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_H1_GEN_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG bdk_tns_txq_dq_pts_h1_gen_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG "TNS_TXQ_DQ_PTS_H1_GEN_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hdwrr_mtu_cfg
 *
 * TNS TxQ Deque Port Scheduler H1 DWRR MTU Configuration Register
 * MTU configuration for PORT arbiter (MTU in bytes = 2^h1_dwrr_mtu_cfg).
 */
union bdk_tns_txq_dq_pts_hdwrr_mtu_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hdwrr_mtu_cfg bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482860ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG "TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hfshp_adr_map
 *
 * TNS TxQ Deque Port Scheduler H1 CB Fast Shapper Address Map Register
 * Configuration to map bits in H1 array to FAST_UPD CB shapers list index
 */
union bdk_tns_txq_dq_pts_hfshp_adr_map
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hfshp_adr_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_18_31        : 14;
        uint32_t index_5               : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t index_4               : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t index_3               : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t index_2               : 3;  /**< [  8:  6](R/W) -- */
        uint32_t index_1               : 3;  /**< [  5:  3](R/W) -- */
        uint32_t index_0               : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t index_0               : 3;  /**< [  2:  0](R/W) -- */
        uint32_t index_1               : 3;  /**< [  5:  3](R/W) -- */
        uint32_t index_2               : 3;  /**< [  8:  6](R/W) -- */
        uint32_t index_3               : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t index_4               : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t index_5               : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t reserved_18_31        : 14;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hfshp_adr_map_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hfshp_adr_map bdk_tns_txq_dq_pts_hfshp_adr_map_t;

#define BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482864ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP bdk_tns_txq_dq_pts_hfshp_adr_map_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP "TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hfshp_chk_cfg
 *
 * TNS TxQ Deque Port Scheduler H1 CB Fast Shapper Check Configuration Register
 * Bitmap used to validate entry in FAST_UPD list
 */
union bdk_tns_txq_dq_pts_hfshp_chk_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hfshp_chk_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t bitmap                : 2;  /**< [  1:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t bitmap                : 2;  /**< [  1:  0](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hfshp_chk_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hfshp_chk_cfg bdk_tns_txq_dq_pts_hfshp_chk_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048286cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG bdk_tns_txq_dq_pts_hfshp_chk_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG "TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hfshp_map_cfg
 *
 * TNS TxQ Deque Port Scheduler H1 CB Fast Shapper Map Configuration Register
 * Configuration to map bits in H1 array used to validate entry in FAST_UPD list
 */
union bdk_tns_txq_dq_pts_hfshp_map_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hfshp_map_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t index_1               : 3;  /**< [  5:  3](R/W) -- */
        uint32_t index_0               : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t index_0               : 3;  /**< [  2:  0](R/W) -- */
        uint32_t index_1               : 3;  /**< [  5:  3](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hfshp_map_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hfshp_map_cfg bdk_tns_txq_dq_pts_hfshp_map_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482868ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG bdk_tns_txq_dq_pts_hfshp_map_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG "TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hpkt_ct_lmt#
 *
 * TNS TxQ Deque Port Scheduler H1 Packet Count Limit Registers
 * H1 packet count limits
 */
union bdk_tns_txq_dq_pts_hpkt_ct_lmtx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hpkt_ct_lmtx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t limit                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hpkt_ct_lmtx_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hpkt_ct_lmtx bdk_tns_txq_dq_pts_hpkt_ct_lmtx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070482000ll + 4ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HPKT_CT_LMTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(a) bdk_tns_txq_dq_pts_hpkt_ct_lmtx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(a) "TNS_TXQ_DQ_PTS_HPKT_CT_LMTX"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hpkt_ct_mem#
 *
 * TNS TxQ Deque Port Scheduler H1 Packet Count Memory Registers
 * H1 packet count memory
 */
union bdk_tns_txq_dq_pts_hpkt_ct_memx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hpkt_ct_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_15_31        : 17;
        uint32_t count                 : 15; /**< [ 14:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 15; /**< [ 14:  0](R/W) -- */
        uint32_t reserved_15_31        : 17;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hpkt_ct_memx_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hpkt_ct_memx bdk_tns_txq_dq_pts_hpkt_ct_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070481c00ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HPKT_CT_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(a) bdk_tns_txq_dq_pts_hpkt_ct_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(a) "TNS_TXQ_DQ_PTS_HPKT_CT_MEMX"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hpkt_ct_nz#
 *
 * TNS TxQ Deque Port Scheduler H1 Packet Count Not Zero Registers
 * Use this to set H1 nodes to have packet_count_not_zero to 0 or 1 for scheduling
 * purposes.  Useful for clearing a H1 in case it has not flushed out properly
 */
union bdk_tns_txq_dq_pts_hpkt_ct_nzx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hpkt_ct_nzx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hpkt_ct_nzx_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hpkt_ct_nzx bdk_tns_txq_dq_pts_hpkt_ct_nzx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070482400ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HPKT_CT_NZX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(a) bdk_tns_txq_dq_pts_hpkt_ct_nzx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(a) "TNS_TXQ_DQ_PTS_HPKT_CT_NZX"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hpkt_fprf_map
 *
 * TNS TxQ Deque Port Scheduler H1 Packet Full Profile Map Register
 * Map H1 address bits to a packet count limit profile
 */
union bdk_tns_txq_dq_pts_hpkt_fprf_map
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hpkt_fprf_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_21_31        : 11;
        uint32_t h1_bit_to_limit_addr6 : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t h1_bit_to_limit_addr5 : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t h1_bit_to_limit_addr4 : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t h1_bit_to_limit_addr3 : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t h1_bit_to_limit_addr2 : 3;  /**< [  8:  6](R/W) -- */
        uint32_t h1_bit_to_limit_addr1 : 3;  /**< [  5:  3](R/W) -- */
        uint32_t h1_bit_to_limit_addr0 : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t h1_bit_to_limit_addr0 : 3;  /**< [  2:  0](R/W) -- */
        uint32_t h1_bit_to_limit_addr1 : 3;  /**< [  5:  3](R/W) -- */
        uint32_t h1_bit_to_limit_addr2 : 3;  /**< [  8:  6](R/W) -- */
        uint32_t h1_bit_to_limit_addr3 : 3;  /**< [ 11:  9](R/W) -- */
        uint32_t h1_bit_to_limit_addr4 : 3;  /**< [ 14: 12](R/W) -- */
        uint32_t h1_bit_to_limit_addr5 : 3;  /**< [ 17: 15](R/W) -- */
        uint32_t h1_bit_to_limit_addr6 : 3;  /**< [ 20: 18](R/W) -- */
        uint32_t reserved_21_31        : 11;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hpkt_fprf_map_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hpkt_fprf_map bdk_tns_txq_dq_pts_hpkt_fprf_map_t;

#define BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482874ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP bdk_tns_txq_dq_pts_hpkt_fprf_map_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP "TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hshp_mtu_cfg
 *
 * TNS TxQ Deque Port Scheduler H1 Shapper MTU Configuration Register
 * MTU configuration register (MTU in BYTES = 2^h2_cb_shapers_mtu_cfg)
 */
union bdk_tns_txq_dq_pts_hshp_mtu_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hshp_mtu_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mtu                   : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hshp_mtu_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hshp_mtu_cfg bdk_tns_txq_dq_pts_hshp_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482870ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HSHP_MTU_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG bdk_tns_txq_dq_pts_hshp_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG "TNS_TXQ_DQ_PTS_HSHP_MTU_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_hsshp_ecc_log
 *
 * TNS TxQ Deque Port Scheduler H1 Slow Shapper Memory ECC Log Register
 * H1 slow shaper memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_dq_pts_hsshp_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_hsshp_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_hsshp_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_pts_hsshp_ecc_log bdk_tns_txq_dq_pts_hsshp_ecc_log_t;

#define BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482854ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG bdk_tns_txq_dq_pts_hsshp_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG "TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_int_en_hi
 *
 * TNS TxQ Deque Port Scheduler Interrrupt Enable High Register
 * Port scheduler interrupt register
 */
union bdk_tns_txq_dq_pts_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](R/W) H1 packet count rolled over */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](R/W) H1 packet count tried to decrement when count was zero */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](R/W) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](R/W) H1 slow shaper memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) Port scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) Port scheduler DWRR memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](R/W) H1 slow shaper memory single bit ECC interrupt */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](R/W) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](R/W) H1 packet count tried to decrement when count was zero */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](R/W) H1 packet count rolled over */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_dq_pts_int_en_hi bdk_tns_txq_dq_pts_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_EN_HI BDK_TNS_TXQ_DQ_PTS_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482844ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI bdk_tns_txq_dq_pts_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI "TNS_TXQ_DQ_PTS_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_int_en_lo
 *
 * TNS TxQ Deque Port Scheduler Interrrupt Enable Low Register
 * Port scheduler interrupt register
 */
union bdk_tns_txq_dq_pts_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](R/W) H1 packet count rolled over */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](R/W) H1 packet count tried to decrement when count was zero */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](R/W) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](R/W) H1 slow shaper memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) Port scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W) Port scheduler DWRR memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](R/W) H1 slow shaper memory single bit ECC interrupt */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](R/W) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](R/W) H1 packet count tried to decrement when count was zero */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](R/W) H1 packet count rolled over */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](R/W) H1 shaper credits wrapped from negative to positive */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_dq_pts_int_en_lo bdk_tns_txq_dq_pts_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_EN_LO BDK_TNS_TXQ_DQ_PTS_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482848ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO bdk_tns_txq_dq_pts_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO "TNS_TXQ_DQ_PTS_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_int_frc
 *
 * TNS TxQ Deque Port Scheduler Interrrupt Force Register
 * Port scheduler interrupt register
 */
union bdk_tns_txq_dq_pts_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](WO) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](WO) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](WO) H1 packet count rolled over */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](WO) H1 packet count tried to decrement when count was zero */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](WO) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](WO) H1 slow shaper memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](WO) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](WO) Port scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](WO) Port scheduler DWRR memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](WO) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](WO) H1 slow shaper memory single bit ECC interrupt */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](WO) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](WO) H1 packet count tried to decrement when count was zero */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](WO) H1 packet count rolled over */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](WO) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](WO) H1 shaper credits wrapped from negative to positive */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_int_frc_s cn; */
};
typedef union bdk_tns_txq_dq_pts_int_frc bdk_tns_txq_dq_pts_int_frc_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_FRC BDK_TNS_TXQ_DQ_PTS_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048284cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_FRC bdk_tns_txq_dq_pts_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_FRC "TNS_TXQ_DQ_PTS_INT_FRC"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_int_w1c
 *
 * TNS TxQ Deque Port Scheduler Interrrupt W1C Register
 * Port scheduler interrupt register
 */
union bdk_tns_txq_dq_pts_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](R/W1C/H) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](R/W1C/H) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](R/W1C/H) H1 packet count rolled over */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](R/W1C/H) H1 packet count tried to decrement when count was zero */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](R/W1C/H) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](R/W1C/H) H1 slow shaper memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W1C/H) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W1C/H) Port scheduler DWRR memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pt_sch_dwrr_mem_sb_err : 1; /**< [  0:  0](R/W1C/H) Port scheduler DWRR memory single bit ECC interrupt */
        uint32_t pt_sch_dwrr_mem_db_err : 1; /**< [  1:  1](R/W1C/H) Port scheduler DWRR memory double bit ECC interrupt */
        uint32_t h1_slow_shp_mem_sb_err : 1; /**< [  2:  2](R/W1C/H) H1 slow shaper memory single bit ECC interrupt */
        uint32_t h1_slow_shp_mem_db_err : 1; /**< [  3:  3](R/W1C/H) H1 slow shaper memory double bit ECC interrupt */
        uint32_t h1_pkt_ct_neg_err     : 1;  /**< [  4:  4](R/W1C/H) H1 packet count tried to decrement when count was zero */
        uint32_t h1_pkt_ct_rollover_err : 1; /**< [  5:  5](R/W1C/H) H1 packet count rolled over */
        uint32_t h1_slow_shp_neg_wrap_err : 1;/**< [  6:  6](R/W1C/H) H1 shaper credits wrapped from negative to positive */
        uint32_t h1_fast_shp_neg_wrap_err : 1;/**< [  7:  7](R/W1C/H) H1 shaper credits wrapped from negative to positive */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_int_w1c_s cn; */
};
typedef union bdk_tns_txq_dq_pts_int_w1c bdk_tns_txq_dq_pts_int_w1c_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_W1C BDK_TNS_TXQ_DQ_PTS_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482840ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_W1C bdk_tns_txq_dq_pts_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_W1C "TNS_TXQ_DQ_PTS_INT_W1C"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_lock
 *
 * TNS TxQ Deque Port Scheduler Lock Register
 * Lock Register
 */
union bdk_tns_txq_dq_pts_lock
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_lock_s cn; */
};
typedef union bdk_tns_txq_dq_pts_lock bdk_tns_txq_dq_pts_lock_t;

#define BDK_TNS_TXQ_DQ_PTS_LOCK BDK_TNS_TXQ_DQ_PTS_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070482878ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_LOCK bdk_tns_txq_dq_pts_lock_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_LOCK "TNS_TXQ_DQ_PTS_LOCK"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_spad
 *
 * TNS TxQ Deque Port Scheduler ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_dq_pts_spad
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_spad_s cn; */
};
typedef union bdk_tns_txq_dq_pts_spad bdk_tns_txq_dq_pts_spad_t;

#define BDK_TNS_TXQ_DQ_PTS_SPAD BDK_TNS_TXQ_DQ_PTS_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048287cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_SPAD bdk_tns_txq_dq_pts_spad_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_SPAD "TNS_TXQ_DQ_PTS_SPAD"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_sshp_mem#_w0
 *
 * TNS TxQ Deque Port Scheduler Slow Shapper Memory Word 0 Registers
 * H1 CB shapers fast_update memory
 * Bits[31:16] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_pts_sshp_memx_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_sshp_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
#else /* Word 0 - Little Endian */
        uint32_t rate_count            : 8;  /**< [  7:  0](R/W) update rate divider count */
        uint32_t bucket_size           : 24; /**< [ 31:  8](R/W) current token bucket size (in bytes) */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_sshp_memx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_pts_sshp_memx_w0 bdk_tns_txq_dq_pts_sshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070480000ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_SSHP_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(a) bdk_tns_txq_dq_pts_sshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(a) "TNS_TXQ_DQ_PTS_SSHP_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_sshp_mem#_w1
 *
 * TNS TxQ Deque Port Scheduler Slow Shapper Memory Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_SSHP_MEM(0..255)_W0
 */
union bdk_tns_txq_dq_pts_sshp_memx_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_sshp_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t bucket_size           : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field BUCKET_SIZE from previous word. */
        uint32_t rate_divider          : 8;  /**< [  8:  1](R/W) update rate divider for shaper time-wheel */
        uint32_t tokens_to_add         : 14; /**< [ 22:  9](R/W) tokens to add per shaper time-wheel (in bytes) */
        uint32_t max_burst_size        : 8;  /**< [ 30: 23](R/W) shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
        uint32_t enable                : 1;  /**< [ 31: 31](R/W) enable */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_sshp_memx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_pts_sshp_memx_w1 bdk_tns_txq_dq_pts_sshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070480004ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_SSHP_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(a) bdk_tns_txq_dq_pts_sshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(a) "TNS_TXQ_DQ_PTS_SSHP_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_sshp_mem#_w2
 *
 * TNS TxQ Deque Port Scheduler Slow Shapper Memory Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_SSHP_MEM(0..255)_W0
 */
union bdk_tns_txq_dq_pts_sshp_memx_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_sshp_memx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t comp_count            : 16; /**< [ 15:  0](R/W) current shaper pending compensation count */
#else /* Word 0 - Little Endian */
        uint32_t comp_count            : 16; /**< [ 15:  0](R/W) current shaper pending compensation count */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_sshp_memx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_pts_sshp_memx_w2 bdk_tns_txq_dq_pts_sshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070480008ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_SSHP_MEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(a) bdk_tns_txq_dq_pts_sshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(a) "TNS_TXQ_DQ_PTS_SSHP_MEMX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w0
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 0 Registers
 * PORT scheduler TM config table
 * Bits[63:48] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w0
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t strict_en             : 64; /**< [ 63:  0](R/W) Strict priority enable for each of the 64 H1 nodes assigned to this port */
#else /* Word 0 - Little Endian */
        uint64_t strict_en             : 64; /**< [ 63:  0](R/W) Strict priority enable for each of the 64 H1 nodes assigned to this port */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w0 bdk_tns_txq_dq_pts_tm_cfgx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481000ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(a) bdk_tns_txq_dq_pts_tm_cfgx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w1
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w1
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) TC array (4 bits each) for each of the 64 H1 nodes assigned to this port */
#else /* Word 0 - Little Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) TC array (4 bits each) for each of the 64 H1 nodes assigned to this port */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w1 bdk_tns_txq_dq_pts_tm_cfgx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481008ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(a) bdk_tns_txq_dq_pts_tm_cfgx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w2
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w2
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w2 bdk_tns_txq_dq_pts_tm_cfgx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481010ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(a) bdk_tns_txq_dq_pts_tm_cfgx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w3
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 3 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w3
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w3_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w3 bdk_tns_txq_dq_pts_tm_cfgx_w3_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481018ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(a) bdk_tns_txq_dq_pts_tm_cfgx_w3_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W3"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w4
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 4 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w4
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t tc_array              : 64; /**< [ 63:  0](R/W) Continuation of MSBs of field TC_ARRAY from previous word. */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w4_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w4 bdk_tns_txq_dq_pts_tm_cfgx_w4_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481020ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(a) bdk_tns_txq_dq_pts_tm_cfgx_w4_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W4"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w5
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 5 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w5
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t dq_en                 : 64; /**< [ 63:  0](R/W) DQ enable for each of the 64 H1 nodes assigned to this port */
#else /* Word 0 - Little Endian */
        uint64_t dq_en                 : 64; /**< [ 63:  0](R/W) DQ enable for each of the 64 H1 nodes assigned to this port */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w5_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w5 bdk_tns_txq_dq_pts_tm_cfgx_w5_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481028ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W5", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(a) bdk_tns_txq_dq_pts_tm_cfgx_w5_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W5"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_pts_tm_cfg#_w6
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager Configuration Word 6 Registers
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 */
union bdk_tns_txq_dq_pts_tm_cfgx_w6
{
    uint64_t u;
    struct bdk_tns_txq_dq_pts_tm_cfgx_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t h1_group7             : 5;  /**< [ 47: 43](R/W) H1 group 7 index */
        uint64_t h1_group6             : 5;  /**< [ 42: 38](R/W) H1 group 6 index */
        uint64_t h1_group5             : 5;  /**< [ 37: 33](R/W) H1 group 5 index */
        uint64_t h1_group4             : 5;  /**< [ 32: 28](R/W) H1 group 4 index */
        uint64_t h1_group3             : 5;  /**< [ 27: 23](R/W) H1 group 3 index */
        uint64_t h1_group2             : 5;  /**< [ 22: 18](R/W) H1 group 2 index */
        uint64_t h1_group1             : 5;  /**< [ 17: 13](R/W) H1 group 1 index */
        uint64_t h1_group0             : 5;  /**< [ 12:  8](R/W) H1 group 0 index */
        uint64_t h1_groups_valid       : 8;  /**< [  7:  0](R/W) H1 groups valid vector, one bit for each of the 8 nodes */
#else /* Word 0 - Little Endian */
        uint64_t h1_groups_valid       : 8;  /**< [  7:  0](R/W) H1 groups valid vector, one bit for each of the 8 nodes */
        uint64_t h1_group0             : 5;  /**< [ 12:  8](R/W) H1 group 0 index */
        uint64_t h1_group1             : 5;  /**< [ 17: 13](R/W) H1 group 1 index */
        uint64_t h1_group2             : 5;  /**< [ 22: 18](R/W) H1 group 2 index */
        uint64_t h1_group3             : 5;  /**< [ 27: 23](R/W) H1 group 3 index */
        uint64_t h1_group4             : 5;  /**< [ 32: 28](R/W) H1 group 4 index */
        uint64_t h1_group5             : 5;  /**< [ 37: 33](R/W) H1 group 5 index */
        uint64_t h1_group6             : 5;  /**< [ 42: 38](R/W) H1 group 6 index */
        uint64_t h1_group7             : 5;  /**< [ 47: 43](R/W) H1 group 7 index */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_cfgx_w6_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w6 bdk_tns_txq_dq_pts_tm_cfgx_w6_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070481030ll + 0x40ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_CFGX_W6", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(a) bdk_tns_txq_dq_pts_tm_cfgx_w6_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(a) "TNS_TXQ_DQ_PTS_TM_CFGX_W6"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_pts_tm_stt#
 *
 * TNS TxQ Deque Port Scheduler Traffic Manager State Registers
 * PORT scheduler TM state table
 */
union bdk_tns_txq_dq_pts_tm_sttx
{
    uint32_t u;
    struct bdk_tns_txq_dq_pts_tm_sttx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t last_h1_index         : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t last_h1_index         : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_pts_tm_sttx_s cn; */
};
typedef union bdk_tns_txq_dq_pts_tm_sttx bdk_tns_txq_dq_pts_tm_sttx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_STTX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_STTX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070482800ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_PTS_TM_STTX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_STTX(a) bdk_tns_txq_dq_pts_tm_sttx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_STTX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_STTX(a) "TNS_TXQ_DQ_PTS_TM_STTX"
#define device_bar_BDK_TNS_TXQ_DQ_PTS_TM_STTX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_STTX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_STTX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_qcn_change
 *
 * INTERNAL: TNS TxQ Deque QCN Change Register
 *
 * This register is written when a QCN (defeatured) packet arrives and the shaper
 * rates need to be updated.  Software determines the new target rate and current
 * rate to use.
 */
union bdk_tns_txq_dq_qcn_change
{
    uint64_t u;
    struct bdk_tns_txq_dq_qcn_change_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_39_63        : 25;
        uint64_t rp                    : 9;  /**< [ 38: 30](R/W/H) Identify the QCN reaction point to update */
        uint64_t byte_en               : 1;  /**< [ 29: 29](R/W/H) Value with which to update the byte_upd_en field of qcn_mem_cfg */
        uint64_t timer_en              : 1;  /**< [ 28: 28](R/W/H) Value with which to update the timer_upd_en field of qcn_mem_cfg */
        uint64_t target_rate           : 14; /**< [ 27: 14](R/W/H) If nonzero, update the target rate of qcn_mem_cfg */
        uint64_t current_rate          : 14; /**< [ 13:  0](R/W/H) If nonzero, update the current rate of qcn_mem_cfg */
#else /* Word 0 - Little Endian */
        uint64_t current_rate          : 14; /**< [ 13:  0](R/W/H) If nonzero, update the current rate of qcn_mem_cfg */
        uint64_t target_rate           : 14; /**< [ 27: 14](R/W/H) If nonzero, update the target rate of qcn_mem_cfg */
        uint64_t timer_en              : 1;  /**< [ 28: 28](R/W/H) Value with which to update the timer_upd_en field of qcn_mem_cfg */
        uint64_t byte_en               : 1;  /**< [ 29: 29](R/W/H) Value with which to update the byte_upd_en field of qcn_mem_cfg */
        uint64_t rp                    : 9;  /**< [ 38: 30](R/W/H) Identify the QCN reaction point to update */
        uint64_t reserved_39_63        : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_change_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_change bdk_tns_txq_dq_qcn_change_t;

#define BDK_TNS_TXQ_DQ_QCN_CHANGE BDK_TNS_TXQ_DQ_QCN_CHANGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_CHANGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_CHANGE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c098ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_CHANGE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_CHANGE bdk_tns_txq_dq_qcn_change_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_CHANGE BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_QCN_CHANGE "TNS_TXQ_DQ_QCN_CHANGE"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_CHANGE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_CHANGE 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_CHANGE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_ecc_log
 *
 * INTERNAL: TNS TxQ Deque QCN ECC Log Register
 *
 * QCN (defeatured) configuration and state memory ECC error log.  Address is
 * sticky on first error.  Re-armed after reading
 */
union bdk_tns_txq_dq_qcn_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t ecc_err_addr          : 9;  /**< [  8:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 9;  /**< [  8:  0](R/W/H) -- */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_ecc_log bdk_tns_txq_dq_qcn_ecc_log_t;

#define BDK_TNS_TXQ_DQ_QCN_ECC_LOG BDK_TNS_TXQ_DQ_QCN_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c054ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_ECC_LOG bdk_tns_txq_dq_qcn_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_ECC_LOG "TNS_TXQ_DQ_QCN_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_gbl_cfg_w0
 *
 * INTERNAL: TNS TxQ Deque QCN Global Configuration Word 0 Register
 *
 * QCN (defeatured) global configuration registers.  These configuration
 * parameters apply to all QCN CCF Queues. QCN has been defeatured and software is
 * not allowed to enable and/or configure QCN in any circumstance.
 */
union bdk_tns_txq_dq_qcn_gbl_cfg_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_gbl_cfg_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t qcn_time_rate         : 27; /**< [ 31:  5](R/W) Number of switch-clock cycles between each QCN timer event.  Represents
                                                                 rpgTimeReset (15ms typical) */
        uint32_t qcn_time_rand         : 5;  /**< [  4:  0](R/W) QCN random time shift.  Bit 7 of the random number will indicate add/not-
                                                                 substract. qcn_rand[6:0] will be shifted by this amount and added/subtracted
                                                                 from qcn_time_rate for the next round's time base.  Set to represent the
                                                                 closest power of 2 that results in less htna 15% of cnm_time_rate being
                                                                 randomized
                                                                 0x0 - Randomization disabled
                                                                 0x1 - Time[0] is randomized
                                                                 0x2 - Time[1:0] is randomized
                                                                 0x3 - Time[2:0] is randomized
                                                                 0x4 - Time[3:0] is randomized
                                                                 0x5 - Time[4:0] is randomized
                                                                 0x6 - Time[5:0] is randomized
                                                                 0x7 - Time[6:0] is randomized
                                                                 0x8 - Time[7:0] is randomized
                                                                 0x9 - Time[8:1] is randomized
                                                                 0xa - Time[9:2] is randomized
                                                                 0xb - Time[10:3] is randomized
                                                                 0xc - Time[11:4] is randomized
                                                                 0xd - Time[12:5] is randomized
                                                                 0xe - Time[13:6] is randomized
                                                                 0xf - Time[14:7] is randomized
                                                                 0x10 - Time[15:8] is randomized
                                                                 0x11 - Time[16:9] is randomized
                                                                 0x12 - Time[17:10] is randomized
                                                                 0x13 - Time[18:11] is randomized
                                                                 0x14 - Time[19:12] is randomized
                                                                 0x15 - Time[20:13] is randomized
                                                                 0x16 - Time[21:14] is randomized
                                                                 0x17 - Time[22:15] is randomized
                                                                 0x18 - Time[23:16] is randomized
                                                                 0x19 - Time[24:17] is randomized
                                                                 0x1A - Time[25:18] is randomized
                                                                 0x1B - Time[26:19] is randomized */
#else /* Word 0 - Little Endian */
        uint32_t qcn_time_rand         : 5;  /**< [  4:  0](R/W) QCN random time shift.  Bit 7 of the random number will indicate add/not-
                                                                 substract. qcn_rand[6:0] will be shifted by this amount and added/subtracted
                                                                 from qcn_time_rate for the next round's time base.  Set to represent the
                                                                 closest power of 2 that results in less htna 15% of cnm_time_rate being
                                                                 randomized
                                                                 0x0 - Randomization disabled
                                                                 0x1 - Time[0] is randomized
                                                                 0x2 - Time[1:0] is randomized
                                                                 0x3 - Time[2:0] is randomized
                                                                 0x4 - Time[3:0] is randomized
                                                                 0x5 - Time[4:0] is randomized
                                                                 0x6 - Time[5:0] is randomized
                                                                 0x7 - Time[6:0] is randomized
                                                                 0x8 - Time[7:0] is randomized
                                                                 0x9 - Time[8:1] is randomized
                                                                 0xa - Time[9:2] is randomized
                                                                 0xb - Time[10:3] is randomized
                                                                 0xc - Time[11:4] is randomized
                                                                 0xd - Time[12:5] is randomized
                                                                 0xe - Time[13:6] is randomized
                                                                 0xf - Time[14:7] is randomized
                                                                 0x10 - Time[15:8] is randomized
                                                                 0x11 - Time[16:9] is randomized
                                                                 0x12 - Time[17:10] is randomized
                                                                 0x13 - Time[18:11] is randomized
                                                                 0x14 - Time[19:12] is randomized
                                                                 0x15 - Time[20:13] is randomized
                                                                 0x16 - Time[21:14] is randomized
                                                                 0x17 - Time[22:15] is randomized
                                                                 0x18 - Time[23:16] is randomized
                                                                 0x19 - Time[24:17] is randomized
                                                                 0x1A - Time[25:18] is randomized
                                                                 0x1B - Time[26:19] is randomized */
        uint32_t qcn_time_rate         : 27; /**< [ 31:  5](R/W) Number of switch-clock cycles between each QCN timer event.  Represents
                                                                 rpgTimeReset (15ms typical) */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_gbl_cfg_w0_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_gbl_cfg_w0 bdk_tns_txq_dq_qcn_gbl_cfg_w0_t;

#define BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c084ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_GBL_CFG_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 bdk_tns_txq_dq_qcn_gbl_cfg_w0_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 "TNS_TXQ_DQ_QCN_GBL_CFG_W0"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_gbl_cfg_w1
 *
 * INTERNAL: TNS TxQ Deque QCN Global Configuration Word 1 Register
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_GBL_CFG_W0
 */
union bdk_tns_txq_dq_qcn_gbl_cfg_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_gbl_cfg_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_29_31        : 3;
        uint32_t qcn_thresh            : 4;  /**< [ 28: 25](R/W) Number of fast recovery stages after which the RP state machine advances to AI
                                                                 or HAI. This applies to both byte and timer stages */
        uint32_t qcn_byte_reset        : 19; /**< [ 24:  6](R/W) Number of bytes in an CNM byte stage.  Represents rpgByteReset(150000 bytes
                                                                 typical) */
        uint32_t qcn_byte_rand         : 5;  /**< [  5:  1](R/W) QCN random byte shift.  Bit 7 of the random number will indicate add/not-
                                                                 substract. qcn_byte_rand[6:0] will be shifted by this amount and
                                                                 added/subtracted from qcn_byte_reset for the next round's time base.  Set to
                                                                 represent the closest power of 2 that results in less than 15% of cnm_byte_rate
                                                                 being randomized
                                                                 0x0 - Randomization disabled
                                                                 0x1 - Byte[0] is randomized
                                                                 0x2 - Byte[1:0] is randomized
                                                                 0x3 - Byte[2:0] is randomized
                                                                 0x4 - Byte[3:0] is randomized
                                                                 0x5 - Byte[4:0] is randomized
                                                                 0x6 - Byte[5:0] is randomized
                                                                 0x7 - Byte[6:0] is randomized
                                                                 0x8 - Byte[7:0] is randomized
                                                                 0x9 - Byte[8:1] is randomized
                                                                 0xa - Byte[9:2] is randomized
                                                                 0xb - Byte[10:3] is randomized
                                                                 0xc - Byte[11:4] is randomized
                                                                 0xd - Byte[12:5] is randomized
                                                                 0xe - Byte[13:6] is randomized
                                                                 0xf - Byte[14:7] is randomized
                                                                 0x10 - Byte[15:8] is randomized
                                                                 0x11 - Byte[16:9] is randomized
                                                                 0x12 - Byte[17:10] is randomized
                                                                 0x13 - Byte[18:11] is randomized */
        uint32_t qcn_time_rate         : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field QCN_TIME_RATE from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t qcn_time_rate         : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field QCN_TIME_RATE from previous word. */
        uint32_t qcn_byte_rand         : 5;  /**< [  5:  1](R/W) QCN random byte shift.  Bit 7 of the random number will indicate add/not-
                                                                 substract. qcn_byte_rand[6:0] will be shifted by this amount and
                                                                 added/subtracted from qcn_byte_reset for the next round's time base.  Set to
                                                                 represent the closest power of 2 that results in less than 15% of cnm_byte_rate
                                                                 being randomized
                                                                 0x0 - Randomization disabled
                                                                 0x1 - Byte[0] is randomized
                                                                 0x2 - Byte[1:0] is randomized
                                                                 0x3 - Byte[2:0] is randomized
                                                                 0x4 - Byte[3:0] is randomized
                                                                 0x5 - Byte[4:0] is randomized
                                                                 0x6 - Byte[5:0] is randomized
                                                                 0x7 - Byte[6:0] is randomized
                                                                 0x8 - Byte[7:0] is randomized
                                                                 0x9 - Byte[8:1] is randomized
                                                                 0xa - Byte[9:2] is randomized
                                                                 0xb - Byte[10:3] is randomized
                                                                 0xc - Byte[11:4] is randomized
                                                                 0xd - Byte[12:5] is randomized
                                                                 0xe - Byte[13:6] is randomized
                                                                 0xf - Byte[14:7] is randomized
                                                                 0x10 - Byte[15:8] is randomized
                                                                 0x11 - Byte[16:9] is randomized
                                                                 0x12 - Byte[17:10] is randomized
                                                                 0x13 - Byte[18:11] is randomized */
        uint32_t qcn_byte_reset        : 19; /**< [ 24:  6](R/W) Number of bytes in an CNM byte stage.  Represents rpgByteReset(150000 bytes
                                                                 typical) */
        uint32_t qcn_thresh            : 4;  /**< [ 28: 25](R/W) Number of fast recovery stages after which the RP state machine advances to AI
                                                                 or HAI. This applies to both byte and timer stages */
        uint32_t reserved_29_31        : 3;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_gbl_cfg_w1_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_gbl_cfg_w1 bdk_tns_txq_dq_qcn_gbl_cfg_w1_t;

#define BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c088ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_GBL_CFG_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 bdk_tns_txq_dq_qcn_gbl_cfg_w1_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 "TNS_TXQ_DQ_QCN_GBL_CFG_W1"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_qcn_mem#_w0
 *
 * INTERNAL: TNS TxQ Deque QCN Memory Word 0 Registers
 *
 * QCN (defeatured) configuration and state memory. QCN has been defeatured and
 * this memory must not be accessed by software in any circumstance.
 * Bits[63:48] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_qcn_memx_w0
{
    uint64_t u;
    struct bdk_tns_txq_dq_qcn_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t current_rate          : 10; /**< [ 63: 54](R/W) Current shaper rate in bytes to add to shaper per time-wheel turn.  Corresponds
                                                                 to rpCurrentRate */
        uint64_t hai_rate              : 14; /**< [ 53: 40](R/W) QCN hyper active increase rate in bytes to add to shaper per time-wheel turn.
                                                                 Corresponds to rpgHaiRate */
        uint64_t ai_rate               : 14; /**< [ 39: 26](R/W) QCN active increase rate in bytes to add to shaper per time-wheel turn.
                                                                 Corresponds to rpgAiRate */
        uint64_t peak_rate             : 14; /**< [ 25: 12](R/W) Peak shaper rate in bytes to add to shaper per time-wheel turn.  Note that the
                                                                 rate divider and burst sizes are set separately in the actual Q shapers */
        uint64_t queue                 : 11; /**< [ 11:  1](R/W) Queue associated with this QCN CCF */
        uint64_t fast_shaper           : 1;  /**< [  0:  0](R/W) This queue managed by the fast shaper.  Else it goes into the slow shaper.
                                                                 User must ensure that the this corresponds correctly to the way the shapers are
                                                                 configured */
#else /* Word 0 - Little Endian */
        uint64_t fast_shaper           : 1;  /**< [  0:  0](R/W) This queue managed by the fast shaper.  Else it goes into the slow shaper.
                                                                 User must ensure that the this corresponds correctly to the way the shapers are
                                                                 configured */
        uint64_t queue                 : 11; /**< [ 11:  1](R/W) Queue associated with this QCN CCF */
        uint64_t peak_rate             : 14; /**< [ 25: 12](R/W) Peak shaper rate in bytes to add to shaper per time-wheel turn.  Note that the
                                                                 rate divider and burst sizes are set separately in the actual Q shapers */
        uint64_t ai_rate               : 14; /**< [ 39: 26](R/W) QCN active increase rate in bytes to add to shaper per time-wheel turn.
                                                                 Corresponds to rpgAiRate */
        uint64_t hai_rate              : 14; /**< [ 53: 40](R/W) QCN hyper active increase rate in bytes to add to shaper per time-wheel turn.
                                                                 Corresponds to rpgHaiRate */
        uint64_t current_rate          : 10; /**< [ 63: 54](R/W) Current shaper rate in bytes to add to shaper per time-wheel turn.  Corresponds
                                                                 to rpCurrentRate */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_memx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_memx_w0 bdk_tns_txq_dq_qcn_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=511))
        return 0x842070410000ll + 0x10ll * ((a) & 0x1ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(a) bdk_tns_txq_dq_qcn_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(a) "TNS_TXQ_DQ_QCN_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_qcn_mem#_w1
 *
 * INTERNAL: TNS TxQ Deque QCN Memory Word 1 Registers
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_MEM(0..511)_W0
 */
union bdk_tns_txq_dq_qcn_memx_w1
{
    uint64_t u;
    struct bdk_tns_txq_dq_qcn_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_48_63        : 16;
        uint64_t time_stage            : 4;  /**< [ 47: 44](R/W) QCN time stage.  Corresponds to rpTimeStage */
        uint64_t byte_stage            : 4;  /**< [ 43: 40](R/W) QCN byte stage.  Corresponds to rpByteStage */
        uint64_t byte_upd_en           : 1;  /**< [ 39: 39](R/W) QCN byte update enable */
        uint64_t timer_upd_en          : 1;  /**< [ 38: 38](R/W) QCN timer update enable */
        uint64_t byte_cnt              : 20; /**< [ 37: 18](R/W) Number of bytes remaining in stage.  Signed integer */
        uint64_t target_rate           : 14; /**< [ 17:  4](R/W) Target shaper rate in bytes to add to shaper per time-wheel turn.  Corresponds
                                                                 to rpTargetRate */
        uint64_t current_rate          : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field CURRENT_RATE from previous word. */
#else /* Word 0 - Little Endian */
        uint64_t current_rate          : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field CURRENT_RATE from previous word. */
        uint64_t target_rate           : 14; /**< [ 17:  4](R/W) Target shaper rate in bytes to add to shaper per time-wheel turn.  Corresponds
                                                                 to rpTargetRate */
        uint64_t byte_cnt              : 20; /**< [ 37: 18](R/W) Number of bytes remaining in stage.  Signed integer */
        uint64_t timer_upd_en          : 1;  /**< [ 38: 38](R/W) QCN timer update enable */
        uint64_t byte_upd_en           : 1;  /**< [ 39: 39](R/W) QCN byte update enable */
        uint64_t byte_stage            : 4;  /**< [ 43: 40](R/W) QCN byte stage.  Corresponds to rpByteStage */
        uint64_t time_stage            : 4;  /**< [ 47: 44](R/W) QCN time stage.  Corresponds to rpTimeStage */
        uint64_t reserved_48_63        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_memx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_memx_w1 bdk_tns_txq_dq_qcn_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=511))
        return 0x842070410008ll + 0x10ll * ((a) & 0x1ff);
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(a) bdk_tns_txq_dq_qcn_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(a) "TNS_TXQ_DQ_QCN_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_qmap_ecc_log
 *
 * INTERNAL: TNS TxQ Deque QCN QMAP ECC Log Register
 *
 * QCN (defeatured) Q mapping memory ECC error log.  Address is sticky on first
 * error.  Re-armed after reading
 */
union bdk_tns_txq_dq_qcn_qmap_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_qmap_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 8;  /**< [  7:  0](R/W/H) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_qmap_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_qmap_ecc_log bdk_tns_txq_dq_qcn_qmap_ecc_log_t;

#define BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c058ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_QMAP_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG bdk_tns_txq_dq_qcn_qmap_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG "TNS_TXQ_DQ_QCN_QMAP_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_qmap_mem#_w0
 *
 * INTERNAL: TNS TxQ Deque QCN QMAP Memory Word 0 Registers
 *
 * Map Queue to a QCN (defeatured) RP.  8 queue mappings to the QCN RPs are stored
 * per line.  Software must ensure that only one queue is mapped to each reaction
 * point, and that only 512 of the possible 2048 queues are enabled.
 * Bits[31:16] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_dq_qcn_qmap_memx_w0
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_qmap_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reaction_point3       : 1;  /**< [ 31: 31](R/W) -- */
        uint32_t enable3               : 1;  /**< [ 30: 30](R/W) -- */
        uint32_t reaction_point2       : 9;  /**< [ 29: 21](R/W) -- */
        uint32_t enable2               : 1;  /**< [ 20: 20](R/W) -- */
        uint32_t reaction_point1       : 9;  /**< [ 19: 11](R/W) -- */
        uint32_t enable1               : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t reaction_point0       : 9;  /**< [  9:  1](R/W) -- */
        uint32_t enable0               : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t enable0               : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reaction_point0       : 9;  /**< [  9:  1](R/W) -- */
        uint32_t enable1               : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t reaction_point1       : 9;  /**< [ 19: 11](R/W) -- */
        uint32_t enable2               : 1;  /**< [ 20: 20](R/W) -- */
        uint32_t reaction_point2       : 9;  /**< [ 29: 21](R/W) -- */
        uint32_t enable3               : 1;  /**< [ 30: 30](R/W) -- */
        uint32_t reaction_point3       : 1;  /**< [ 31: 31](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_qmap_memx_w0_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_qmap_memx_w0 bdk_tns_txq_dq_qcn_qmap_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070414000ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_QMAP_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(a) bdk_tns_txq_dq_qcn_qmap_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(a) "TNS_TXQ_DQ_QCN_QMAP_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_qmap_mem#_w1
 *
 * INTERNAL: TNS TxQ Deque QCN QMAP Memory Word 1 Registers
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_QMAP_MEM(0..255)_W0
 */
union bdk_tns_txq_dq_qcn_qmap_memx_w1
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_qmap_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reaction_point6       : 3;  /**< [ 31: 29](R/W) -- */
        uint32_t enable6               : 1;  /**< [ 28: 28](R/W) -- */
        uint32_t reaction_point5       : 9;  /**< [ 27: 19](R/W) -- */
        uint32_t enable5               : 1;  /**< [ 18: 18](R/W) -- */
        uint32_t reaction_point4       : 9;  /**< [ 17:  9](R/W) -- */
        uint32_t enable4               : 1;  /**< [  8:  8](R/W) -- */
        uint32_t reaction_point3       : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field REACTION_POINT3 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t reaction_point3       : 8;  /**< [  7:  0](R/W) Continuation of MSBs of field REACTION_POINT3 from previous word. */
        uint32_t enable4               : 1;  /**< [  8:  8](R/W) -- */
        uint32_t reaction_point4       : 9;  /**< [ 17:  9](R/W) -- */
        uint32_t enable5               : 1;  /**< [ 18: 18](R/W) -- */
        uint32_t reaction_point5       : 9;  /**< [ 27: 19](R/W) -- */
        uint32_t enable6               : 1;  /**< [ 28: 28](R/W) -- */
        uint32_t reaction_point6       : 3;  /**< [ 31: 29](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_qmap_memx_w1_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_qmap_memx_w1 bdk_tns_txq_dq_qcn_qmap_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070414004ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_QMAP_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(a) bdk_tns_txq_dq_qcn_qmap_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(a) "TNS_TXQ_DQ_QCN_QMAP_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_qmap_mem#_w2
 *
 * INTERNAL: TNS TxQ Deque QCN QMAP Memory Word 2 Registers
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_QMAP_MEM(0..255)_W0
 */
union bdk_tns_txq_dq_qcn_qmap_memx_w2
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_qmap_memx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t reaction_point7       : 9;  /**< [ 15:  7](R/W) -- */
        uint32_t enable7               : 1;  /**< [  6:  6](R/W) -- */
        uint32_t reaction_point6       : 6;  /**< [  5:  0](R/W) Continuation of MSBs of field REACTION_POINT6 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t reaction_point6       : 6;  /**< [  5:  0](R/W) Continuation of MSBs of field REACTION_POINT6 from previous word. */
        uint32_t enable7               : 1;  /**< [  6:  6](R/W) -- */
        uint32_t reaction_point7       : 9;  /**< [ 15:  7](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_qmap_memx_w2_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_qmap_memx_w2 bdk_tns_txq_dq_qcn_qmap_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070414008ll + 0x10ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_QMAP_MEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(a) bdk_tns_txq_dq_qcn_qmap_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(a) "TNS_TXQ_DQ_QCN_QMAP_MEMX_W2"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_rng_cfg
 *
 * INTERNAL: TNS TxQ Deque QCN Random Number Generator Configuration Register
 *
 * QCN (defeatured) random number generator configuration
 */
union bdk_tns_txq_dq_qcn_rng_cfg
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_rng_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t qcn_byte_rng_seed     : 16; /**< [ 31: 16](R/W) Byte counter RNG seed value */
        uint32_t qcn_timer_rng_seed    : 16; /**< [ 15:  0](R/W) Timer RNG seed value */
#else /* Word 0 - Little Endian */
        uint32_t qcn_timer_rng_seed    : 16; /**< [ 15:  0](R/W) Timer RNG seed value */
        uint32_t qcn_byte_rng_seed     : 16; /**< [ 31: 16](R/W) Byte counter RNG seed value */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_rng_cfg_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_rng_cfg bdk_tns_txq_dq_qcn_rng_cfg_t;

#define BDK_TNS_TXQ_DQ_QCN_RNG_CFG BDK_TNS_TXQ_DQ_QCN_RNG_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_RNG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_RNG_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c08cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_RNG_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_RNG_CFG bdk_tns_txq_dq_qcn_rng_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_RNG_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_RNG_CFG "TNS_TXQ_DQ_QCN_RNG_CFG"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_RNG_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_RNG_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_RNG_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_qcn_supd_fif#
 *
 * INTERNAL: TNS TxQ Deque QCN Slow Update FIFO Registers
 *
 * QCN (defeatured) slow update FIFO data
 */
union bdk_tns_txq_dq_qcn_supd_fifx
{
    uint32_t u;
    struct bdk_tns_txq_dq_qcn_supd_fifx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_25_31        : 7;
        uint32_t tokens_to_add         : 14; /**< [ 24: 11](R/W) -- */
        uint32_t queue                 : 11; /**< [ 10:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t queue                 : 11; /**< [ 10:  0](R/W) -- */
        uint32_t tokens_to_add         : 14; /**< [ 24: 11](R/W) -- */
        uint32_t reserved_25_31        : 7;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_supd_fifx_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_supd_fifx bdk_tns_txq_dq_qcn_supd_fifx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x84207041c000ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_SUPD_FIFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(a) bdk_tns_txq_dq_qcn_supd_fifx_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(a) "TNS_TXQ_DQ_QCN_SUPD_FIFX"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_dq_qcn_time
 *
 * INTERNAL: TNS TxQ Deque QCN Time Register
 *
 * Status of QCN (defeatured) timer and RNG
 */
union bdk_tns_txq_dq_qcn_time
{
    uint64_t u;
    struct bdk_tns_txq_dq_qcn_time_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_60_63        : 4;
        uint64_t current_time          : 28; /**< [ 59: 32](RO/H) Current QCN time, counting down to zero */
        uint64_t time_random           : 16; /**< [ 31: 16](RO/H) Current random number used for QCN timer reset randomization.  Updated each
                                                                 time round */
        uint64_t byte_random           : 16; /**< [ 15:  0](RO/H) Current random number used for QCN byte reset randomization.  Updated each byte
                                                                 reset */
#else /* Word 0 - Little Endian */
        uint64_t byte_random           : 16; /**< [ 15:  0](RO/H) Current random number used for QCN byte reset randomization.  Updated each byte
                                                                 reset */
        uint64_t time_random           : 16; /**< [ 31: 16](RO/H) Current random number used for QCN timer reset randomization.  Updated each
                                                                 time round */
        uint64_t current_time          : 28; /**< [ 59: 32](RO/H) Current QCN time, counting down to zero */
        uint64_t reserved_60_63        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_qcn_time_s cn; */
};
typedef union bdk_tns_txq_dq_qcn_time bdk_tns_txq_dq_qcn_time_t;

#define BDK_TNS_TXQ_DQ_QCN_TIME BDK_TNS_TXQ_DQ_QCN_TIME_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_TIME_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_TIME_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207041c090ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_QCN_TIME", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_QCN_TIME bdk_tns_txq_dq_qcn_time_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_TIME BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_DQ_QCN_TIME "TNS_TXQ_DQ_QCN_TIME"
#define device_bar_BDK_TNS_TXQ_DQ_QCN_TIME 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_QCN_TIME 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_TIME -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_spad
 *
 * TNS TxQ Deque ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_dq_spad
{
    uint32_t u;
    struct bdk_tns_txq_dq_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_spad_s cn; */
};
typedef union bdk_tns_txq_dq_spad bdk_tns_txq_dq_spad_t;

#define BDK_TNS_TXQ_DQ_SPAD BDK_TNS_TXQ_DQ_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488144ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_SPAD bdk_tns_txq_dq_spad_t
#define bustype_BDK_TNS_TXQ_DQ_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_SPAD "TNS_TXQ_DQ_SPAD"
#define device_bar_BDK_TNS_TXQ_DQ_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_tb_afif#
 *
 * TNS TxQ Deque Token Buffer Access FIFO Registers
 * TB access fifo
 */
union bdk_tns_txq_dq_tb_afifx
{
    uint32_t u;
    struct bdk_tns_txq_dq_tb_afifx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_30_31        : 2;
        uint32_t data                  : 30; /**< [ 29:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 30; /**< [ 29:  0](R/W) -- */
        uint32_t reserved_30_31        : 2;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_tb_afifx_s cn; */
};
typedef union bdk_tns_txq_dq_tb_afifx bdk_tns_txq_dq_tb_afifx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIFX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIFX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=63))
        return 0x842070488000ll + 4ll * ((a) & 0x3f);
    __bdk_csr_fatal("TNS_TXQ_DQ_TB_AFIFX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_TB_AFIFX(a) bdk_tns_txq_dq_tb_afifx_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIFX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_TB_AFIFX(a) "TNS_TXQ_DQ_TB_AFIFX"
#define device_bar_BDK_TNS_TXQ_DQ_TB_AFIFX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIFX(a) (a)
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIFX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_tb_afif_ecc_log
 *
 * TNS TxQ Deque Token Buffer Access FIFO ECC Log Register
 * TB access FIFO memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_dq_tb_afif_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_dq_tb_afif_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t ecc_err_addr          : 6;  /**< [  5:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 6;  /**< [  5:  0](R/W/H) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_tb_afif_ecc_log_s cn; */
};
typedef union bdk_tns_txq_dq_tb_afif_ecc_log bdk_tns_txq_dq_tb_afif_ecc_log_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488134ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_TB_AFIF_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG bdk_tns_txq_dq_tb_afif_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG "TNS_TXQ_DQ_TB_AFIF_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_tb_afif_fc_thr
 *
 * TNS TxQ Deque Token Buffer Access FIFO Flow Control Threshold Register
 * TB access fifo flow control threshold
 */
union bdk_tns_txq_dq_tb_afif_fc_thr
{
    uint32_t u;
    struct bdk_tns_txq_dq_tb_afif_fc_thr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t threshold             : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t threshold             : 7;  /**< [  6:  0](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_tb_afif_fc_thr_s cn; */
};
typedef union bdk_tns_txq_dq_tb_afif_fc_thr bdk_tns_txq_dq_tb_afif_fc_thr_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488138ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_TB_AFIF_FC_THR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR bdk_tns_txq_dq_tb_afif_fc_thr_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR "TNS_TXQ_DQ_TB_AFIF_FC_THR"
#define device_bar_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_tb_afif_ptr
 *
 * TNS TxQ Deque Token Buffer Access FIFO Pointer Register
 * TB access fifo pointer debug register
 */
union bdk_tns_txq_dq_tb_afif_ptr
{
    uint32_t u;
    struct bdk_tns_txq_dq_tb_afif_ptr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t debug                 : 14; /**< [ 13:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t debug                 : 14; /**< [ 13:  0](R/W/H) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_tb_afif_ptr_s cn; */
};
typedef union bdk_tns_txq_dq_tb_afif_ptr bdk_tns_txq_dq_tb_afif_ptr_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_PTR BDK_TNS_TXQ_DQ_TB_AFIF_PTR_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_PTR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207048813cll;
    __bdk_csr_fatal("TNS_TXQ_DQ_TB_AFIF_PTR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_PTR bdk_tns_txq_dq_tb_afif_ptr_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_PTR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_PTR "TNS_TXQ_DQ_TB_AFIF_PTR"
#define device_bar_BDK_TNS_TXQ_DQ_TB_AFIF_PTR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_PTR 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_PTR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_dq_tb_afif_usage
 *
 * TNS TxQ Deque Token Buffer Access FIFO Usage Register
 * DQ read token buffer access FIFO usage
 */
union bdk_tns_txq_dq_tb_afif_usage
{
    uint32_t u;
    struct bdk_tns_txq_dq_tb_afif_usage_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t fifo_usage            : 7;  /**< [  6:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_usage            : 7;  /**< [  6:  0](RO/H) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_dq_tb_afif_usage_s cn; */
};
typedef union bdk_tns_txq_dq_tb_afif_usage bdk_tns_txq_dq_tb_afif_usage_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_USAGE BDK_TNS_TXQ_DQ_TB_AFIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_USAGE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070488130ll;
    __bdk_csr_fatal("TNS_TXQ_DQ_TB_AFIF_USAGE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE bdk_tns_txq_dq_tb_afif_usage_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE "TNS_TXQ_DQ_TB_AFIF_USAGE"
#define device_bar_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_3spd_wsarb_mode
 *
 * TNS TxQ Enque Multi-cse Three Speed FIFOs WRR/SP Arbiter Mode Register
 * Multi-cast Speed FIFOs arbiter '0' - WRR, '1' - SP for 40G
 */
union bdk_tns_txq_eq_3spd_wsarb_mode
{
    uint32_t u;
    struct bdk_tns_txq_eq_3spd_wsarb_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t mode                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_3spd_wsarb_mode_s cn; */
};
typedef union bdk_tns_txq_eq_3spd_wsarb_mode bdk_tns_txq_eq_3spd_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848f0ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_3SPD_WSARB_MODE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE bdk_tns_txq_eq_3spd_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE "TNS_TXQ_EQ_3SPD_WSARB_MODE"
#define device_bar_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_3spd_wsarb_wgt
 *
 * TNS TxQ Enque Multi-cse Three Speed FIFOs WRR/SP Arbiter Weight Register
 * Multi-cast Speed FIFOs arbiter weights for 40G/10G/misc
 */
union bdk_tns_txq_eq_3spd_wsarb_wgt
{
    uint32_t u;
    struct bdk_tns_txq_eq_3spd_wsarb_wgt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t weight_misc           : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t weight_10g            : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t weight_40g            : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t weight_40g            : 8;  /**< [  7:  0](R/W) -- */
        uint32_t weight_10g            : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t weight_misc           : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_3spd_wsarb_wgt_s cn; */
};
typedef union bdk_tns_txq_eq_3spd_wsarb_wgt bdk_tns_txq_eq_3spd_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848f4ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_3SPD_WSARB_WGT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT bdk_tns_txq_eq_3spd_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT "TNS_TXQ_EQ_3SPD_WSARB_WGT"
#define device_bar_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_aqm_lfif#_w#
 *
 * TNS TxQ Enque AQM Latency FIFO Registers
 * Target pipe based FIFOs used for latency matching during MC query-response
 * Bits[31:18] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_aqm_lfifx_wx
{
    uint32_t u;
    struct bdk_tns_txq_eq_aqm_lfifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_aqm_lfifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_aqm_lfifx_wx bdk_tns_txq_eq_aqm_lfifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=4)))
        return 0x842070684000ll + 0x20ll * ((a) & 0xf) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_AQM_LFIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(a,b) bdk_tns_txq_eq_aqm_lfifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(a,b) "TNS_TXQ_EQ_AQM_LFIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_aqmq_wsarb_mode
 *
 * TNS TxQ Enque AQM Query WRR/SP Arbiter Mode Register
 * AQM query pipeline arbiter '0' - WRR, '1' - SP for Multi-cast
 */
union bdk_tns_txq_eq_aqmq_wsarb_mode
{
    uint32_t u;
    struct bdk_tns_txq_eq_aqmq_wsarb_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t mode                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_aqmq_wsarb_mode_s cn; */
};
typedef union bdk_tns_txq_eq_aqmq_wsarb_mode bdk_tns_txq_eq_aqmq_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848f8ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_AQMQ_WSARB_MODE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE bdk_tns_txq_eq_aqmq_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE "TNS_TXQ_EQ_AQMQ_WSARB_MODE"
#define device_bar_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_aqmq_wsarb_wgt
 *
 * TNS TxQ Enque AQM Query WRR/SP Arbiter Weight Register
 * AQM_query arbiter weights for egress mirror (defeatured) and Multi-cast packets
 */
union bdk_tns_txq_eq_aqmq_wsarb_wgt
{
    uint32_t u;
    struct bdk_tns_txq_eq_aqmq_wsarb_wgt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t em_weight             : 8;  /**< [ 15:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t mc_weight             : 8;  /**< [  7:  0](R/W) MC weight. */
#else /* Word 0 - Little Endian */
        uint32_t mc_weight             : 8;  /**< [  7:  0](R/W) MC weight. */
        uint32_t em_weight             : 8;  /**< [ 15:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_aqmq_wsarb_wgt_s cn; */
};
typedef union bdk_tns_txq_eq_aqmq_wsarb_wgt bdk_tns_txq_eq_aqmq_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848fcll;
    __bdk_csr_fatal("TNS_TXQ_EQ_AQMQ_WSARB_WGT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT bdk_tns_txq_eq_aqmq_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT "TNS_TXQ_EQ_AQMQ_WSARB_WGT"
#define device_bar_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_bist_stdn
 *
 * TNS TxQ Enque Bist Status Done Register
 * TxQ EQ bist status and bist_done
 */
union bdk_tns_txq_eq_bist_stdn
{
    uint32_t u;
    struct bdk_tns_txq_eq_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t pfc_map_mem_status    : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t pfc_map_mem_done      : 1;  /**< [  0:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t pfc_map_mem_done      : 1;  /**< [  0:  0](RO/H) -- */
        uint32_t pfc_map_mem_status    : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_bist_stdn_s cn; */
};
typedef union bdk_tns_txq_eq_bist_stdn bdk_tns_txq_eq_bist_stdn_t;

#define BDK_TNS_TXQ_EQ_BIST_STDN BDK_TNS_TXQ_EQ_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_BIST_STDN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684890ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_BIST_STDN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_BIST_STDN bdk_tns_txq_eq_bist_stdn_t
#define bustype_BDK_TNS_TXQ_EQ_BIST_STDN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_BIST_STDN "TNS_TXQ_EQ_BIST_STDN"
#define device_bar_BDK_TNS_TXQ_EQ_BIST_STDN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_EQ_BIST_STDN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_clr_pt_wait_eop
 *
 * TNS TxQ Enque CLear PORT Wait EOP Register
 * Debug/initialization to clear out waiting for EOP status on port in case of
 * errors, or unclean port disabling
 */
union bdk_tns_txq_eq_clr_pt_wait_eop
{
    uint32_t u;
    struct bdk_tns_txq_eq_clr_pt_wait_eop_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t port15                : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t port14                : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t port13                : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t port12                : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t port11                : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t port10                : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t port9                 : 1;  /**< [  9:  9](R/W) -- */
        uint32_t port8                 : 1;  /**< [  8:  8](R/W) -- */
        uint32_t port7                 : 1;  /**< [  7:  7](R/W) -- */
        uint32_t port6                 : 1;  /**< [  6:  6](R/W) -- */
        uint32_t port5                 : 1;  /**< [  5:  5](R/W) -- */
        uint32_t port4                 : 1;  /**< [  4:  4](R/W) -- */
        uint32_t port3                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t port2                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t port1                 : 1;  /**< [  1:  1](R/W) -- */
        uint32_t port0                 : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t port0                 : 1;  /**< [  0:  0](R/W) -- */
        uint32_t port1                 : 1;  /**< [  1:  1](R/W) -- */
        uint32_t port2                 : 1;  /**< [  2:  2](R/W) -- */
        uint32_t port3                 : 1;  /**< [  3:  3](R/W) -- */
        uint32_t port4                 : 1;  /**< [  4:  4](R/W) -- */
        uint32_t port5                 : 1;  /**< [  5:  5](R/W) -- */
        uint32_t port6                 : 1;  /**< [  6:  6](R/W) -- */
        uint32_t port7                 : 1;  /**< [  7:  7](R/W) -- */
        uint32_t port8                 : 1;  /**< [  8:  8](R/W) -- */
        uint32_t port9                 : 1;  /**< [  9:  9](R/W) -- */
        uint32_t port10                : 1;  /**< [ 10: 10](R/W) -- */
        uint32_t port11                : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t port12                : 1;  /**< [ 12: 12](R/W) -- */
        uint32_t port13                : 1;  /**< [ 13: 13](R/W) -- */
        uint32_t port14                : 1;  /**< [ 14: 14](R/W) -- */
        uint32_t port15                : 1;  /**< [ 15: 15](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_clr_pt_wait_eop_s cn; */
};
typedef union bdk_tns_txq_eq_clr_pt_wait_eop bdk_tns_txq_eq_clr_pt_wait_eop_t;

#define BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848acll;
    __bdk_csr_fatal("TNS_TXQ_EQ_CLR_PT_WAIT_EOP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP bdk_tns_txq_eq_clr_pt_wait_eop_t
#define bustype_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP "TNS_TXQ_EQ_CLR_PT_WAIT_EOP"
#define device_bar_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP 0
#define arguments_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_cut_thru_bcnt_cfg
 *
 * TNS TxQ Enque Cut Through Byte Count Configuration Register
 * Byte count in case of cut thru mode for statistics, AQM, etc
 */
union bdk_tns_txq_eq_cut_thru_bcnt_cfg
{
    uint32_t u;
    struct bdk_tns_txq_eq_cut_thru_bcnt_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t data                  : 14; /**< [ 13:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 14; /**< [ 13:  0](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_cut_thru_bcnt_cfg_s cn; */
};
typedef union bdk_tns_txq_eq_cut_thru_bcnt_cfg bdk_tns_txq_eq_cut_thru_bcnt_cfg_t;

#define BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207068489cll;
    __bdk_csr_fatal("TNS_TXQ_EQ_CUT_THRU_BCNT_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG bdk_tns_txq_eq_cut_thru_bcnt_cfg_t
#define bustype_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG "TNS_TXQ_EQ_CUT_THRU_BCNT_CFG"
#define device_bar_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG 0
#define arguments_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_cut_thru_npgs_cfg
 *
 * TNS TxQ Enque Cut Through Number of Pages Used Configuration Register
 * Pages used in case of cut thru mode for statistics, AQM, etc.
 */
union bdk_tns_txq_eq_cut_thru_npgs_cfg
{
    uint32_t u;
    struct bdk_tns_txq_eq_cut_thru_npgs_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t data                  : 7;  /**< [  6:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 7;  /**< [  6:  0](R/W) -- */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_cut_thru_npgs_cfg_s cn; */
};
typedef union bdk_tns_txq_eq_cut_thru_npgs_cfg bdk_tns_txq_eq_cut_thru_npgs_cfg_t;

#define BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848a0ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_CUT_THRU_NPGS_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG bdk_tns_txq_eq_cut_thru_npgs_cfg_t
#define bustype_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG "TNS_TXQ_EQ_CUT_THRU_NPGS_CFG"
#define device_bar_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG 0
#define arguments_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_eq_dist_fif_usage
 *
 * TNS TxQ Enque Distributor FIFO Usage Register
 * All distributor FIFO usage
 */
union bdk_tns_txq_eq_dist_fif_usage
{
    uint64_t u;
    struct bdk_tns_txq_eq_dist_fif_usage_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_46_63        : 18;
        uint64_t source_em_fifo        : 5;  /**< [ 45: 41](RO/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. Distributor source egress mirror FIFO usage */
        uint64_t mc_fifo               : 5;  /**< [ 40: 36](RO/H) Distributor source multi-cast FIFO usage */
        uint64_t uc_drop_fifo          : 5;  /**< [ 35: 31](RO/H) Distributor source unicast and drop FIFO usage */
        uint64_t mc_40g_fifo           : 5;  /**< [ 30: 26](RO/H) Distributor 40G speed multi-cast FIFO usage */
        uint64_t mc_10g_fifo           : 5;  /**< [ 25: 21](RO/H) Distributor 10G speed multi-cast FIFO usage */
        uint64_t mc_misc_fifo          : 5;  /**< [ 20: 16](RO/H) Distributor misc speed multi-cast FIFO usage */
        uint64_t mc2drop_fifo          : 5;  /**< [ 15: 11](RO/H) Distributor Multi-cast drop FIFO usage */
        uint64_t aqm_lat_fifo          : 5;  /**< [ 10:  6](RO/H) Distributor AQM query latency FIFO usage */
        uint64_t query_out_fifo        : 6;  /**< [  5:  0](RO/H) Distributor post-AQM query FIFO usage */
#else /* Word 0 - Little Endian */
        uint64_t query_out_fifo        : 6;  /**< [  5:  0](RO/H) Distributor post-AQM query FIFO usage */
        uint64_t aqm_lat_fifo          : 5;  /**< [ 10:  6](RO/H) Distributor AQM query latency FIFO usage */
        uint64_t mc2drop_fifo          : 5;  /**< [ 15: 11](RO/H) Distributor Multi-cast drop FIFO usage */
        uint64_t mc_misc_fifo          : 5;  /**< [ 20: 16](RO/H) Distributor misc speed multi-cast FIFO usage */
        uint64_t mc_10g_fifo           : 5;  /**< [ 25: 21](RO/H) Distributor 10G speed multi-cast FIFO usage */
        uint64_t mc_40g_fifo           : 5;  /**< [ 30: 26](RO/H) Distributor 40G speed multi-cast FIFO usage */
        uint64_t uc_drop_fifo          : 5;  /**< [ 35: 31](RO/H) Distributor source unicast and drop FIFO usage */
        uint64_t mc_fifo               : 5;  /**< [ 40: 36](RO/H) Distributor source multi-cast FIFO usage */
        uint64_t source_em_fifo        : 5;  /**< [ 45: 41](RO/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. Distributor source egress mirror FIFO usage */
        uint64_t reserved_46_63        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_dist_fif_usage_s cn; */
};
typedef union bdk_tns_txq_eq_dist_fif_usage bdk_tns_txq_eq_dist_fif_usage_t;

#define BDK_TNS_TXQ_EQ_DIST_FIF_USAGE BDK_TNS_TXQ_EQ_DIST_FIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DIST_FIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DIST_FIF_USAGE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848b0ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_DIST_FIF_USAGE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE bdk_tns_txq_eq_dist_fif_usage_t
#define bustype_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE "TNS_TXQ_EQ_DIST_FIF_USAGE"
#define device_bar_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE 0
#define arguments_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_disto_wsarb_mode
 *
 * TNS TxQ Enque Distributor Output WRR/SP Arbiter Mode Register
 * Distributer Output aribter '0' - WRR, '1' - SP for Unicast
 */
union bdk_tns_txq_eq_disto_wsarb_mode
{
    uint32_t u;
    struct bdk_tns_txq_eq_disto_wsarb_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t mode                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t mode                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_disto_wsarb_mode_s cn; */
};
typedef union bdk_tns_txq_eq_disto_wsarb_mode bdk_tns_txq_eq_disto_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684900ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_DISTO_WSARB_MODE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE bdk_tns_txq_eq_disto_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE "TNS_TXQ_EQ_DISTO_WSARB_MODE"
#define device_bar_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_disto_wsarb_wgt
 *
 * INTERNAL: TNS TxQ Enque Distributor Output WRR/SP Arbiter Weight Register
 *
 * Distributer Output ariber weights for Unicast, MC drop, and MC/EM packets. EM
 * is defeatured.
 */
union bdk_tns_txq_eq_disto_wsarb_wgt
{
    uint32_t u;
    struct bdk_tns_txq_eq_disto_wsarb_wgt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t mc_em_weight          : 8;  /**< [ 23: 16](R/W) MC weight.
                                                                 Internal:
                                                                 EM is defeatured. */
        uint32_t mc_drop_weight        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t uc_weight             : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t uc_weight             : 8;  /**< [  7:  0](R/W) -- */
        uint32_t mc_drop_weight        : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t mc_em_weight          : 8;  /**< [ 23: 16](R/W) MC weight.
                                                                 Internal:
                                                                 EM is defeatured. */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_disto_wsarb_wgt_s cn; */
};
typedef union bdk_tns_txq_eq_disto_wsarb_wgt bdk_tns_txq_eq_disto_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684904ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_DISTO_WSARB_WGT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT bdk_tns_txq_eq_disto_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT "TNS_TXQ_EQ_DISTO_WSARB_WGT"
#define device_bar_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_dists_em_drp_ct
 *
 * INTERNAL: TNS TxQ Enque Distributor (source) Egress Mirror Drop Count Register
 *
 * Counter of Egress Mirror (defeatured) packet drops made by distributor (source)
 * due to EM copy FIFO being full.  Saturates at 32'hffffffff.  Read only, clear
 * on read.
 */
union bdk_tns_txq_eq_dists_em_drp_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_dists_em_drp_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_dists_em_drp_ct_s cn; */
};
typedef union bdk_tns_txq_eq_dists_em_drp_ct bdk_tns_txq_eq_dists_em_drp_ct_t;

#define BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848c0ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_DISTS_EM_DRP_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT bdk_tns_txq_eq_dists_em_drp_ct_t
#define bustype_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT "TNS_TXQ_EQ_DISTS_EM_DRP_CT"
#define device_bar_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_dists_mc_drp_ct
 *
 * TNS TxQ Enque Distributor (source) Multip-cast Drop Count Register
 * Counter of TXQ multi-cast packet drops made by distributor (source) due to MC
 * FIFO being full.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
union bdk_tns_txq_eq_dists_mc_drp_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_dists_mc_drp_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_dists_mc_drp_ct_s cn; */
};
typedef union bdk_tns_txq_eq_dists_mc_drp_ct bdk_tns_txq_eq_dists_mc_drp_ct_t;

#define BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848c4ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_DISTS_MC_DRP_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT bdk_tns_txq_eq_dists_mc_drp_ct_t
#define bustype_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT "TNS_TXQ_EQ_DISTS_MC_DRP_CT"
#define device_bar_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_ecc_ctl
 *
 * TNS TxQ Enque ECC Control Register
 * ECC configuration of Token Buffer memories
 */
union bdk_tns_txq_eq_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_eq_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t pfc_map_db_ecc        : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in PFC mapping memory */
        uint32_t pfc_map_sb_ecc        : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in PFC mapping  memory */
        uint32_t pfc_map_ecc_dis       : 1;  /**< [  0:  0](R/W) Disable ECC for PFC mapping memory */
#else /* Word 0 - Little Endian */
        uint32_t pfc_map_ecc_dis       : 1;  /**< [  0:  0](R/W) Disable ECC for PFC mapping memory */
        uint32_t pfc_map_sb_ecc        : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in PFC mapping  memory */
        uint32_t pfc_map_db_ecc        : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in PFC mapping memory */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_eq_ecc_ctl bdk_tns_txq_eq_ecc_ctl_t;

#define BDK_TNS_TXQ_EQ_ECC_CTL BDK_TNS_TXQ_EQ_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684894ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_ECC_CTL bdk_tns_txq_eq_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_EQ_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_ECC_CTL "TNS_TXQ_EQ_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_EQ_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_EQ_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_em_copy_cfg
 *
 * INTERNAL: TNS TxQ Enque Egress Mirror Copy Configuration Register
 *
 * Egress mirror configuration
 */
union bdk_tns_txq_eq_em_copy_cfg
{
    uint32_t u;
    struct bdk_tns_txq_eq_em_copy_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_28_31        : 4;
        uint32_t tc                    : 4;  /**< [ 27: 24](R/W) -- */
        uint32_t dst_port              : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t txq_sel_vect          : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t txq_sel_vect          : 16; /**< [ 15:  0](R/W) -- */
        uint32_t dst_port              : 8;  /**< [ 23: 16](R/W) -- */
        uint32_t tc                    : 4;  /**< [ 27: 24](R/W) -- */
        uint32_t reserved_28_31        : 4;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_em_copy_cfg_s cn; */
};
typedef union bdk_tns_txq_eq_em_copy_cfg bdk_tns_txq_eq_em_copy_cfg_t;

#define BDK_TNS_TXQ_EQ_EM_COPY_CFG BDK_TNS_TXQ_EQ_EM_COPY_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EM_COPY_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_COPY_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684908ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_EM_COPY_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EM_COPY_CFG bdk_tns_txq_eq_em_copy_cfg_t
#define bustype_BDK_TNS_TXQ_EQ_EM_COPY_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EM_COPY_CFG "TNS_TXQ_EQ_EM_COPY_CFG"
#define device_bar_BDK_TNS_TXQ_EQ_EM_COPY_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EM_COPY_CFG 0
#define arguments_BDK_TNS_TXQ_EQ_EM_COPY_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_em_fif#_w#
 *
 * INTERNAL: TNS TxQ Enque Egress Mirror FIFO Registers
 *
 * EM_token input FIFO to Cut-thru check. EM is defeatued.
 * Bits[31:26] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_em_fifx_wx
{
    uint32_t u;
    struct bdk_tns_txq_eq_em_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t em_token              : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t em_token              : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_em_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_em_fifx_wx bdk_tns_txq_eq_em_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=4)))
        return 0x842070683800ll + 0x20ll * ((a) & 0xf) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_EM_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EM_FIFX_WX(a,b) bdk_tns_txq_eq_em_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_EM_FIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EM_FIFX_WX(a,b) "TNS_TXQ_EQ_EM_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_EM_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EM_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_EM_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_em_fif_fc_thr
 *
 * INTERNAL: TNS TxQ Enque Egress Mirror FIFO Flow Control Threshold Register
 *
 * Distributor egress (defeatured) mirror input FIFO flow control threshold
 */
union bdk_tns_txq_eq_em_fif_fc_thr
{
    uint32_t u;
    struct bdk_tns_txq_eq_em_fif_fc_thr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t theshold              : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t theshold              : 5;  /**< [  4:  0](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_em_fif_fc_thr_s cn; */
};
typedef union bdk_tns_txq_eq_em_fif_fc_thr bdk_tns_txq_eq_em_fif_fc_thr_t;

#define BDK_TNS_TXQ_EQ_EM_FIF_FC_THR BDK_TNS_TXQ_EQ_EM_FIF_FC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIF_FC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIF_FC_THR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848d8ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_EM_FIF_FC_THR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR bdk_tns_txq_eq_em_fif_fc_thr_t
#define bustype_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR "TNS_TXQ_EQ_EM_FIF_FC_THR"
#define device_bar_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR 0
#define arguments_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_em_pkt_drp_ct
 *
 * INTERNAL: TNS TxQ Enque Egress Mirror Packet Drop Count Register
 *
 * Egress Mirror (defeatured) drop count due to FIFO full in Egress mirror
 * generation.  Saturates at 32'hffffffff.  Read-only, clear on read.
 */
union bdk_tns_txq_eq_em_pkt_drp_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_em_pkt_drp_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_em_pkt_drp_ct_s cn; */
};
typedef union bdk_tns_txq_eq_em_pkt_drp_ct bdk_tns_txq_eq_em_pkt_drp_ct_t;

#define BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848bcll;
    __bdk_csr_fatal("TNS_TXQ_EQ_EM_PKT_DRP_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT bdk_tns_txq_eq_em_pkt_drp_ct_t
#define bustype_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT "TNS_TXQ_EQ_EM_PKT_DRP_CT"
#define device_bar_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_emsd_wsarb_mode
 *
 * TNS TxQ Enque Cut-thru Egress Mirror and SDMA WRR/SP Arbiter Mode Register
 * Cut-thru Egress Mirror (defeatured) and SDMA token WRR/SP arbiter mode; '0' -
 * WRR, '1' - SP for SDMA
 */
union bdk_tns_txq_eq_emsd_wsarb_mode
{
    uint32_t u;
    struct bdk_tns_txq_eq_emsd_wsarb_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_emsd_wsarb_mode_s cn; */
};
typedef union bdk_tns_txq_eq_emsd_wsarb_mode bdk_tns_txq_eq_emsd_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848a4ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_EMSD_WSARB_MODE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE bdk_tns_txq_eq_emsd_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE "TNS_TXQ_EQ_EMSD_WSARB_MODE"
#define device_bar_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_emsd_wsarb_wgt
 *
 * TNS TxQ Enque Cut-thru Egress Mirror and SDMA WRR/SP Arbiter Weight Register
 * Cut-Thru Egress Mirror (defeatured) and SDMA WRR/SP arbiter weights
 */
union bdk_tns_txq_eq_emsd_wsarb_wgt
{
    uint32_t u;
    struct bdk_tns_txq_eq_emsd_wsarb_wgt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t em_weight             : 8;  /**< [ 15:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t sdma_weight           : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sdma_weight           : 8;  /**< [  7:  0](R/W) -- */
        uint32_t em_weight             : 8;  /**< [ 15:  8](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_emsd_wsarb_wgt_s cn; */
};
typedef union bdk_tns_txq_eq_emsd_wsarb_wgt bdk_tns_txq_eq_emsd_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848a8ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_EMSD_WSARB_WGT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT bdk_tns_txq_eq_emsd_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT "TNS_TXQ_EQ_EMSD_WSARB_WGT"
#define device_bar_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_eop_mem#
 *
 * TNS TxQ Enque EOP Memory Registers
 * Packet ID memory for storing packet ID of last EOP on port
 */
union bdk_tns_txq_eq_eop_memx
{
    uint32_t u;
    struct bdk_tns_txq_eq_eop_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t packet_id             : 10; /**< [  9:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t packet_id             : 10; /**< [  9:  0](R/W) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_eop_memx_s cn; */
};
typedef union bdk_tns_txq_eq_eop_memx bdk_tns_txq_eq_eop_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_EOP_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EOP_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070684800ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_EQ_EOP_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EOP_MEMX(a) bdk_tns_txq_eq_eop_memx_t
#define bustype_BDK_TNS_TXQ_EQ_EOP_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EOP_MEMX(a) "TNS_TXQ_EQ_EOP_MEMX"
#define device_bar_BDK_TNS_TXQ_EQ_EOP_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EOP_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_EQ_EOP_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_eqem_fif#_w#
 *
 * INTERNAL: TNS TxQ Enque Source Pipe Based Egress Mirroring FIFO Registers
 *
 * Source pipe based FIFOs used in emcopy path. EM is defeatured.
 * Bits[31:26] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_eqem_fifx_wx
{
    uint32_t u;
    struct bdk_tns_txq_eq_eqem_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_eqem_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_eqem_fifx_wx bdk_tns_txq_eq_eqem_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=4)))
        return 0x842070683a00ll + 0x20ll * ((a) & 0xf) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_EQEM_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(a,b) bdk_tns_txq_eq_eqem_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(a,b) "TNS_TXQ_EQ_EQEM_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_fif_usage
 *
 * TNS TxQ Enque FIFO Usage Register
 * EQ cut thru and write token FIFO usage
 */
union bdk_tns_txq_eq_fif_usage
{
    uint32_t u;
    struct bdk_tns_txq_eq_fif_usage_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_20_31        : 12;
        uint32_t em_fifo               : 5;  /**< [ 19: 15](RO/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. Cut-thru EM FIFO usage */
        uint32_t lat_fifo              : 5;  /**< [ 14: 10](RO/H) Write token latency FIFO usage */
        uint32_t pool_fifo             : 5;  /**< [  9:  5](RO/H) Write token pool FIFO usage */
        uint32_t tail_fifo             : 5;  /**< [  4:  0](RO/H) Write token tail FIFO usage */
#else /* Word 0 - Little Endian */
        uint32_t tail_fifo             : 5;  /**< [  4:  0](RO/H) Write token tail FIFO usage */
        uint32_t pool_fifo             : 5;  /**< [  9:  5](RO/H) Write token pool FIFO usage */
        uint32_t lat_fifo              : 5;  /**< [ 14: 10](RO/H) Write token latency FIFO usage */
        uint32_t em_fifo               : 5;  /**< [ 19: 15](RO/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. Cut-thru EM FIFO usage */
        uint32_t reserved_20_31        : 12;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_fif_usage_s cn; */
};
typedef union bdk_tns_txq_eq_fif_usage bdk_tns_txq_eq_fif_usage_t;

#define BDK_TNS_TXQ_EQ_FIF_USAGE BDK_TNS_TXQ_EQ_FIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_FIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_FIF_USAGE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848b8ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_FIF_USAGE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_FIF_USAGE bdk_tns_txq_eq_fif_usage_t
#define bustype_BDK_TNS_TXQ_EQ_FIF_USAGE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_FIF_USAGE "TNS_TXQ_EQ_FIF_USAGE"
#define device_bar_BDK_TNS_TXQ_EQ_FIF_USAGE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_FIF_USAGE 0
#define arguments_BDK_TNS_TXQ_EQ_FIF_USAGE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_int_en_hi
 *
 * TNS TxQ Enque Interrrupt Enable High Register
 * EQ Interrupt register
 */
union bdk_tns_txq_eq_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_eq_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](R/W) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](R/W) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](R/W) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](R/W) -- */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](R/W) -- */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) EQ configuration input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](R/W) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](R/W) SDMA to EQ token input DFC Rx overflow */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](R/W) PFC mapping memory double bit ECC interrupt */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](R/W) PFC mapping memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](R/W) PFC mapping memory single bit ECC interrupt */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](R/W) PFC mapping memory double bit ECC interrupt */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](R/W) SDMA to EQ token input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](R/W) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) EQ configuration input DFC Rx overflow */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](R/W) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](R/W) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](R/W) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](R/W) -- */
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](R/W) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_eq_int_en_hi bdk_tns_txq_eq_int_en_hi_t;

#define BDK_TNS_TXQ_EQ_INT_EN_HI BDK_TNS_TXQ_EQ_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684884ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_INT_EN_HI bdk_tns_txq_eq_int_en_hi_t
#define bustype_BDK_TNS_TXQ_EQ_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_INT_EN_HI "TNS_TXQ_EQ_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_EQ_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_EQ_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_int_en_lo
 *
 * TNS TxQ Enque Interrrupt Enable Low Register
 * EQ Interrupt register
 */
union bdk_tns_txq_eq_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_eq_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](R/W) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](R/W) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](R/W) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](R/W) -- */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](R/W) -- */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) EQ configuration input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](R/W) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](R/W) SDMA to EQ token input DFC Rx overflow */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](R/W) PFC mapping memory double bit ECC interrupt */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](R/W) PFC mapping memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](R/W) PFC mapping memory single bit ECC interrupt */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](R/W) PFC mapping memory double bit ECC interrupt */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](R/W) SDMA to EQ token input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](R/W) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) EQ configuration input DFC Rx overflow */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](R/W) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](R/W) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](R/W) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](R/W) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](R/W) -- */
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](R/W) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_eq_int_en_lo bdk_tns_txq_eq_int_en_lo_t;

#define BDK_TNS_TXQ_EQ_INT_EN_LO BDK_TNS_TXQ_EQ_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684888ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_INT_EN_LO bdk_tns_txq_eq_int_en_lo_t
#define bustype_BDK_TNS_TXQ_EQ_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_INT_EN_LO "TNS_TXQ_EQ_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_EQ_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_EQ_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_int_frc
 *
 * TNS TxQ Enque Interrrupt Force Register
 * EQ Interrupt register
 */
union bdk_tns_txq_eq_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_eq_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](WO) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](WO) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](WO) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](WO) -- */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](WO) -- */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](WO) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](WO) EQ configuration input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](WO) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](WO) SDMA to EQ token input DFC Rx overflow */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](WO) PFC mapping memory double bit ECC interrupt */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](WO) PFC mapping memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](WO) PFC mapping memory single bit ECC interrupt */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](WO) PFC mapping memory double bit ECC interrupt */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](WO) SDMA to EQ token input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](WO) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](WO) EQ configuration input DFC Rx overflow */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](WO) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](WO) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](WO) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](WO) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](WO) -- */
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](WO) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_int_frc_s cn; */
};
typedef union bdk_tns_txq_eq_int_frc bdk_tns_txq_eq_int_frc_t;

#define BDK_TNS_TXQ_EQ_INT_FRC BDK_TNS_TXQ_EQ_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207068488cll;
    __bdk_csr_fatal("TNS_TXQ_EQ_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_INT_FRC bdk_tns_txq_eq_int_frc_t
#define bustype_BDK_TNS_TXQ_EQ_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_INT_FRC "TNS_TXQ_EQ_INT_FRC"
#define device_bar_BDK_TNS_TXQ_EQ_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_INT_FRC 0
#define arguments_BDK_TNS_TXQ_EQ_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_int_w1c
 *
 * TNS TxQ Enque Interrrupt W1C Register
 * EQ Interrupt register
 */
union bdk_tns_txq_eq_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_eq_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](R/W1C/H) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](R/W1C/H) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](R/W1C/H) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](R/W1C/H) -- */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](R/W1C/H) -- */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W1C/H) EQ configuration input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](R/W1C/H) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](R/W1C/H) SDMA to EQ token input DFC Rx overflow */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](R/W1C/H) PFC mapping memory double bit ECC interrupt */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](R/W1C/H) PFC mapping memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t pfc_map_mem_sb_err    : 1;  /**< [  0:  0](R/W1C/H) PFC mapping memory single bit ECC interrupt */
        uint32_t pfc_map_mem_db_err    : 1;  /**< [  1:  1](R/W1C/H) PFC mapping memory double bit ECC interrupt */
        uint32_t sdma_eq_dfc_ovfl_err  : 1;  /**< [  2:  2](R/W1C/H) SDMA to EQ token input DFC Rx overflow */
        uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;/**< [  3:  3](R/W1C/H) TBM to EQ tail pointer input DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W1C/H) EQ configuration input DFC Rx overflow */
        uint32_t em_pkt_drop           : 1;  /**< [  5:  5](R/W1C/H) Reserved.
                                                                 Internal:
                                                                 Defeatured. */
        uint32_t tail_fifo_ovfl        : 1;  /**< [  6:  6](R/W1C/H) -- */
        uint32_t pool_fifo_ovfl        : 1;  /**< [  7:  7](R/W1C/H) -- */
        uint32_t lat_fifo_ovfl         : 1;  /**< [  8:  8](R/W1C/H) -- */
        uint32_t post_query_fifo_ovfl  : 1;  /**< [  9:  9](R/W1C/H) -- */
        uint32_t cut_thru_2_tkns_bef_eop_err : 1;/**< [ 10: 10](R/W1C/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_int_w1c_s cn; */
};
typedef union bdk_tns_txq_eq_int_w1c bdk_tns_txq_eq_int_w1c_t;

#define BDK_TNS_TXQ_EQ_INT_W1C BDK_TNS_TXQ_EQ_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684880ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_INT_W1C bdk_tns_txq_eq_int_w1c_t
#define bustype_BDK_TNS_TXQ_EQ_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_INT_W1C "TNS_TXQ_EQ_INT_W1C"
#define device_bar_BDK_TNS_TXQ_EQ_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_INT_W1C 0
#define arguments_BDK_TNS_TXQ_EQ_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_lock
 *
 * TNS TxQ Enque Lock Register
 * Lock Register
 */
union bdk_tns_txq_eq_lock
{
    uint32_t u;
    struct bdk_tns_txq_eq_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_lock_s cn; */
};
typedef union bdk_tns_txq_eq_lock bdk_tns_txq_eq_lock_t;

#define BDK_TNS_TXQ_EQ_LOCK BDK_TNS_TXQ_EQ_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684918ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_LOCK bdk_tns_txq_eq_lock_t
#define bustype_BDK_TNS_TXQ_EQ_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_LOCK "TNS_TXQ_EQ_LOCK"
#define device_bar_BDK_TNS_TXQ_EQ_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_LOCK 0
#define arguments_BDK_TNS_TXQ_EQ_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_lp2pp_mem#
 *
 * TNS TxQ Enque Logic Port To Physical Port Mapping Memory Registers
 * Logical Source Port to Physical Source Port Mapping.
 */
union bdk_tns_txq_eq_lp2pp_memx
{
    uint32_t u;
    struct bdk_tns_txq_eq_lp2pp_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_4_31         : 28;
        uint32_t physical_port         : 4;  /**< [  3:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t physical_port         : 4;  /**< [  3:  0](R/W) -- */
        uint32_t reserved_4_31         : 28;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_lp2pp_memx_s cn; */
};
typedef union bdk_tns_txq_eq_lp2pp_memx bdk_tns_txq_eq_lp2pp_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_LP2PP_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_LP2PP_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x842070684400ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_EQ_LP2PP_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_LP2PP_MEMX(a) bdk_tns_txq_eq_lp2pp_memx_t
#define bustype_BDK_TNS_TXQ_EQ_LP2PP_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_LP2PP_MEMX(a) "TNS_TXQ_EQ_LP2PP_MEMX"
#define device_bar_BDK_TNS_TXQ_EQ_LP2PP_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_LP2PP_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_EQ_LP2PP_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_mc2drop_ct
 *
 * TNS TxQ Enque Target Pipe Based MC Drop Count Register
 * Counter of TXQ multi-cast packet drops made by distributor due to per-speed MC
 * FIFO being full.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
union bdk_tns_txq_eq_mc2drop_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_mc2drop_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc2drop_ct_s cn; */
};
typedef union bdk_tns_txq_eq_mc2drop_ct bdk_tns_txq_eq_mc2drop_ct_t;

#define BDK_TNS_TXQ_EQ_MC2DROP_CT BDK_TNS_TXQ_EQ_MC2DROP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848c8ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_MC2DROP_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC2DROP_CT bdk_tns_txq_eq_mc2drop_ct_t
#define bustype_BDK_TNS_TXQ_EQ_MC2DROP_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_MC2DROP_CT "TNS_TXQ_EQ_MC2DROP_CT"
#define device_bar_BDK_TNS_TXQ_EQ_MC2DROP_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC2DROP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_MC2DROP_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_mc2drop_fif#_w#
 *
 * TNS TxQ Enque Target Pipe Based MC Drop FIFO Registers
 * Target pipe based FIFOs used for MC drop tokens
 * Bits[31:27] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_mc2drop_fifx_wx
{
    uint32_t u;
    struct bdk_tns_txq_eq_mc2drop_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc2drop_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_mc2drop_fifx_wx bdk_tns_txq_eq_mc2drop_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=4)))
        return 0x842070683e00ll + 0x20ll * ((a) & 0xf) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_MC2DROP_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(a,b) bdk_tns_txq_eq_mc2drop_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(a,b) "TNS_TXQ_EQ_MC2DROP_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_txq_eq_mc_10g_rep_fif#_w#
 *
 * TNS TxQ Enque Multip-cast 10G Replication FIFO Registers
 * Target pipe based FIFOs used for 10G replication copies
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_mc_10g_rep_fifx_wx
{
    uint64_t u;
    struct bdk_tns_txq_eq_mc_10g_rep_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_10g_rep_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_mc_10g_rep_fifx_wx bdk_tns_txq_eq_mc_10g_rep_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=6)))
        return 0x842070682c00ll + 0x40ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_10G_REP_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(a,b) bdk_tns_txq_eq_mc_10g_rep_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(a,b) "TNS_TXQ_EQ_MC_10G_REP_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_mc_10g_spd_map
 *
 * TNS TxQ Enque Multip-cast 10G Speed Map Register
 * Ports that are 10G mode.  Bit 0 = port 0, bit 1 = port 1, etc.
 */
union bdk_tns_txq_eq_mc_10g_spd_map
{
    uint32_t u;
    struct bdk_tns_txq_eq_mc_10g_spd_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t pt_bitmap             : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_bitmap             : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_10g_spd_map_s cn; */
};
typedef union bdk_tns_txq_eq_mc_10g_spd_map bdk_tns_txq_eq_mc_10g_spd_map_t;

#define BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848e8ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_10G_SPD_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP bdk_tns_txq_eq_mc_10g_spd_map_t
#define bustype_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP "TNS_TXQ_EQ_MC_10G_SPD_MAP"
#define device_bar_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP 0
#define arguments_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_eq_mc_40g_rep_fif#_w#
 *
 * TNS TxQ Enque Multip-cast 40G Replication FIFO Registers
 * Target pipe based FIFOs used for 40G replication copies
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_mc_40g_rep_fifx_wx
{
    uint64_t u;
    struct bdk_tns_txq_eq_mc_40g_rep_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_40g_rep_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_mc_40g_rep_fifx_wx bdk_tns_txq_eq_mc_40g_rep_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=6)))
        return 0x842070682800ll + 0x40ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_40G_REP_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(a,b) bdk_tns_txq_eq_mc_40g_rep_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(a,b) "TNS_TXQ_EQ_MC_40G_REP_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_mc_40g_spd_map
 *
 * TNS TxQ Enque Multip-cast 40G Speed Map Register
 * Ports that are in 40G mode.  Bit 0 = port 0, bit 1 = port 1, etc.
 */
union bdk_tns_txq_eq_mc_40g_spd_map
{
    uint32_t u;
    struct bdk_tns_txq_eq_mc_40g_spd_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t pt_bitmap             : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_bitmap             : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_40g_spd_map_s cn; */
};
typedef union bdk_tns_txq_eq_mc_40g_spd_map bdk_tns_txq_eq_mc_40g_spd_map_t;

#define BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848e4ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_40G_SPD_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP bdk_tns_txq_eq_mc_40g_spd_map_t
#define bustype_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP "TNS_TXQ_EQ_MC_40G_SPD_MAP"
#define device_bar_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP 0
#define arguments_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_eq_mc_fif#_w#
 *
 * TNS TxQ Enque Multip-cast FIFO Registers
 * Source pipe based FIFOs used in multi-cast path
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_mc_fifx_wx
{
    uint64_t u;
    struct bdk_tns_txq_eq_mc_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_mc_fifx_wx bdk_tns_txq_eq_mc_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=6)))
        return 0x842070682400ll + 0x40ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_FIFX_WX(a,b) bdk_tns_txq_eq_mc_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_FIFX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_MC_FIFX_WX(a,b) "TNS_TXQ_EQ_MC_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_MC_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_MC_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB) tns_txq_eq_mc_misc_rep_fif#_w#
 *
 * TNS TxQ Enque Multip-cast MISC Replication FIFO Registers
 * Target pipe based FIFOs used for less than 10G replication copies
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_mc_misc_rep_fifx_wx
{
    uint64_t u;
    struct bdk_tns_txq_eq_mc_misc_rep_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_misc_rep_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_mc_misc_rep_fifx_wx bdk_tns_txq_eq_mc_misc_rep_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=6)))
        return 0x842070683000ll + 0x40ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(a,b) bdk_tns_txq_eq_mc_misc_rep_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(a,b) "TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_mc_misc_spd_map
 *
 * TNS TxQ Enque Multip-cast MISC Speed Map Register
 * Ports that are 1G or less mode.  Bit 0 = port 0, bit 1 = port 1, etc.
 */
union bdk_tns_txq_eq_mc_misc_spd_map
{
    uint32_t u;
    struct bdk_tns_txq_eq_mc_misc_spd_map_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t pt_bitmap             : 16; /**< [ 15:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t pt_bitmap             : 16; /**< [ 15:  0](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_misc_spd_map_s cn; */
};
typedef union bdk_tns_txq_eq_mc_misc_spd_map bdk_tns_txq_eq_mc_misc_spd_map_t;

#define BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848ecll;
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_MISC_SPD_MAP", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP bdk_tns_txq_eq_mc_misc_spd_map_t
#define bustype_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP "TNS_TXQ_EQ_MC_MISC_SPD_MAP"
#define device_bar_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP 0
#define arguments_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_mc_src_fif_fc_thr
 *
 * TNS TxQ Enque Multip-cast Source FIFO Flow Control Threshold Register
 * Distributor source multi-cast FIFO flow control threshold.  Lower this to 0 to
 * turn off TxQ multi-cast replication.
 */
union bdk_tns_txq_eq_mc_src_fif_fc_thr
{
    uint32_t u;
    struct bdk_tns_txq_eq_mc_src_fif_fc_thr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t theshold              : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t theshold              : 5;  /**< [  4:  0](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_mc_src_fif_fc_thr_s cn; */
};
typedef union bdk_tns_txq_eq_mc_src_fif_fc_thr bdk_tns_txq_eq_mc_src_fif_fc_thr_t;

#define BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848dcll;
    __bdk_csr_fatal("TNS_TXQ_EQ_MC_SRC_FIF_FC_THR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR bdk_tns_txq_eq_mc_src_fif_fc_thr_t
#define bustype_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR "TNS_TXQ_EQ_MC_SRC_FIF_FC_THR"
#define device_bar_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR 0
#define arguments_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_pfc_map_ecc_log
 *
 * TNS TxQ Enque PFC Map ECC Log Register
 * PFC mapping memory ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_eq_pfc_map_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_eq_pfc_map_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_10_31        : 22;
        uint32_t ecc_err_addr          : 10; /**< [  9:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 10; /**< [  9:  0](R/W/H) -- */
        uint32_t reserved_10_31        : 22;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_pfc_map_ecc_log_s cn; */
};
typedef union bdk_tns_txq_eq_pfc_map_ecc_log bdk_tns_txq_eq_pfc_map_ecc_log_t;

#define BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070684898ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_PFC_MAP_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG bdk_tns_txq_eq_pfc_map_ecc_log_t
#define bustype_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG "TNS_TXQ_EQ_PFC_MAP_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_eq_pfc_map_mem#
 *
 * TNS TxQ Enque PFC Map Memory Registers
 * Virtual port/TC to physical port/TC/channel mapping.  There are 4 entries
 * stored per line.  Logically, this is a 4k x 11 memory.
 * The index is {virtual_port[7:0], tc[3:0]}.  The result is
 * {physical_port[3:0], tc_channel[6:0]}.  The tc_channel is overloaded
 * to mean both TC and channel.  On ports 8 and 9, it is a full 7 bit
 * channel.   On other ports, it is a 4 bit TC.
 */
union bdk_tns_txq_eq_pfc_map_memx
{
    uint64_t u;
    struct bdk_tns_txq_eq_pfc_map_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t data                  : 44; /**< [ 43:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 44; /**< [ 43:  0](R/W) -- */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_pfc_map_memx_s cn; */
};
typedef union bdk_tns_txq_eq_pfc_map_memx bdk_tns_txq_eq_pfc_map_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1023))
        return 0x842070680000ll + 8ll * ((a) & 0x3ff);
    __bdk_csr_fatal("TNS_TXQ_EQ_PFC_MAP_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(a) bdk_tns_txq_eq_pfc_map_memx_t
#define bustype_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(a) "TNS_TXQ_EQ_PFC_MAP_MEMX"
#define device_bar_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_pg_clr_ct
 *
 * TNS TxQ Enque Page CLear Count Register
 * Counter of TXQ page clear requests to BM.  Saturates at 32'hffffffff.  Read
 * only, clear on read.
 */
union bdk_tns_txq_eq_pg_clr_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_pg_clr_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_pg_clr_ct_s cn; */
};
typedef union bdk_tns_txq_eq_pg_clr_ct bdk_tns_txq_eq_pg_clr_ct_t;

#define BDK_TNS_TXQ_EQ_PG_CLR_CT BDK_TNS_TXQ_EQ_PG_CLR_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_PG_CLR_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PG_CLR_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848ccll;
    __bdk_csr_fatal("TNS_TXQ_EQ_PG_CLR_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_PG_CLR_CT bdk_tns_txq_eq_pg_clr_ct_t
#define bustype_BDK_TNS_TXQ_EQ_PG_CLR_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_PG_CLR_CT "TNS_TXQ_EQ_PG_CLR_CT"
#define device_bar_BDK_TNS_TXQ_EQ_PG_CLR_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_PG_CLR_CT 0
#define arguments_BDK_TNS_TXQ_EQ_PG_CLR_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_pt_spd_mem#
 *
 * TNS TxQ Enque PORT Speed Memory Registers
 * Unicast_Port_Speed_Map.  0=10M, 1=100M, 2=1G, 3=10G, 4=40G, 5=100G
 */
union bdk_tns_txq_eq_pt_spd_memx
{
    uint32_t u;
    struct bdk_tns_txq_eq_pt_spd_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t data                  : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 3;  /**< [  2:  0](R/W) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_pt_spd_memx_s cn; */
};
typedef union bdk_tns_txq_eq_pt_spd_memx bdk_tns_txq_eq_pt_spd_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_PT_SPD_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PT_SPD_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x842070684840ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_EQ_PT_SPD_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(a) bdk_tns_txq_eq_pt_spd_memx_t
#define bustype_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(a) "TNS_TXQ_EQ_PT_SPD_MEMX"
#define device_bar_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_query_ofif#_w#
 *
 * TNS TxQ Enque Query Out FIFO Registers
 * Target pipe based FIFOs used for absorbing pending replies when lower module is
 * flow controlling
 * Bits[31:27] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_query_ofifx_wx
{
    uint32_t u;
    struct bdk_tns_txq_eq_query_ofifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_query_ofifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_query_ofifx_wx bdk_tns_txq_eq_query_ofifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=31) && (b<=4)))
        return 0x842070683400ll + 0x20ll * ((a) & 0x1f) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_QUERY_OFIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(a,b) bdk_tns_txq_eq_query_ofifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(a,b) "TNS_TXQ_EQ_QUERY_OFIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_query_ofif_maxcrd
 *
 * TNS TxQ Enque Query Out FIFO Max Credit Configure Register
 * Post-query FIFO maxium credit.  The total number of entries of the FIFO is 32.
 * This can be set to lower number to limit the outstanding EQ QMAP/AQM requests.
 * Once all the crdits are used, EQ should stop issuing queries to QMAP/AQM. This
 * is for debug use only.
 */
union bdk_tns_txq_eq_query_ofif_maxcrd
{
    uint32_t u;
    struct bdk_tns_txq_eq_query_ofif_maxcrd_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t theshold              : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t theshold              : 6;  /**< [  5:  0](R/W) -- */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_query_ofif_maxcrd_s cn; */
};
typedef union bdk_tns_txq_eq_query_ofif_maxcrd bdk_tns_txq_eq_query_ofif_maxcrd_t;

#define BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848e0ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_QUERY_OFIF_MAXCRD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD bdk_tns_txq_eq_query_ofif_maxcrd_t
#define bustype_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD "TNS_TXQ_EQ_QUERY_OFIF_MAXCRD"
#define device_bar_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD 0
#define arguments_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_spad
 *
 * TNS TxQ Enque ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_eq_spad
{
    uint32_t u;
    struct bdk_tns_txq_eq_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_spad_s cn; */
};
typedef union bdk_tns_txq_eq_spad bdk_tns_txq_eq_spad_t;

#define BDK_TNS_TXQ_EQ_SPAD BDK_TNS_TXQ_EQ_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207068491cll;
    __bdk_csr_fatal("TNS_TXQ_EQ_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_SPAD bdk_tns_txq_eq_spad_t
#define bustype_BDK_TNS_TXQ_EQ_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_SPAD "TNS_TXQ_EQ_SPAD"
#define device_bar_BDK_TNS_TXQ_EQ_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_SPAD 0
#define arguments_BDK_TNS_TXQ_EQ_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_tail_req_ct
 *
 * TNS TxQ Enque Tail Request Count Register
 * Counter of TXQ tail pointer requests to TBM.  Saturates at 32'hffffffff.  Read
 * only, clear on read.
 */
union bdk_tns_txq_eq_tail_req_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_tail_req_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_tail_req_ct_s cn; */
};
typedef union bdk_tns_txq_eq_tail_req_ct bdk_tns_txq_eq_tail_req_ct_t;

#define BDK_TNS_TXQ_EQ_TAIL_REQ_CT BDK_TNS_TXQ_EQ_TAIL_REQ_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_TAIL_REQ_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_TAIL_REQ_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848d0ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_TAIL_REQ_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_TAIL_REQ_CT bdk_tns_txq_eq_tail_req_ct_t
#define bustype_BDK_TNS_TXQ_EQ_TAIL_REQ_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_TAIL_REQ_CT "TNS_TXQ_EQ_TAIL_REQ_CT"
#define device_bar_BDK_TNS_TXQ_EQ_TAIL_REQ_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_TAIL_REQ_CT 0
#define arguments_BDK_TNS_TXQ_EQ_TAIL_REQ_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_eq_tb_wr_ct
 *
 * TNS TxQ Enque Token Buffer Write Count Register
 * Counter of TXQ writes to token buffer.  Saturates at 32'hffffffff.  Read only,
 * clear on read.
 */
union bdk_tns_txq_eq_tb_wr_ct
{
    uint32_t u;
    struct bdk_tns_txq_eq_tb_wr_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_tb_wr_ct_s cn; */
};
typedef union bdk_tns_txq_eq_tb_wr_ct bdk_tns_txq_eq_tb_wr_ct_t;

#define BDK_TNS_TXQ_EQ_TB_WR_CT BDK_TNS_TXQ_EQ_TB_WR_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_TB_WR_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_TB_WR_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x8420706848d4ll;
    __bdk_csr_fatal("TNS_TXQ_EQ_TB_WR_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_TB_WR_CT bdk_tns_txq_eq_tb_wr_ct_t
#define bustype_BDK_TNS_TXQ_EQ_TB_WR_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_TB_WR_CT "TNS_TXQ_EQ_TB_WR_CT"
#define device_bar_BDK_TNS_TXQ_EQ_TB_WR_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_TB_WR_CT 0
#define arguments_BDK_TNS_TXQ_EQ_TB_WR_CT -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_eq_token_mem#_w#
 *
 * TNS TxQ Enque Token Memory Registers
 * Token memory for Cut-thru waiting
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_token_memx_wx
{
    uint64_t u;
    struct bdk_tns_txq_eq_token_memx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t token                 : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t token                 : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_token_memx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_token_memx_wx bdk_tns_txq_eq_token_memx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=6)))
        return 0x842070682000ll + 0x40ll * ((a) & 0xf) + 8ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_TOKEN_MEMX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(a,b) bdk_tns_txq_eq_token_memx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(a,b) "TNS_TXQ_EQ_TOKEN_MEMX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_uc_fif#_w#
 *
 * TNS TxQ Enque Sourced Based Uni-cast FIFO Registers
 * Source pipe based FIFOs used in UC and drop path
 * Bits[31:27] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_eq_uc_fifx_wx
{
    uint32_t u;
    struct bdk_tns_txq_eq_uc_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_uc_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_eq_uc_fifx_wx bdk_tns_txq_eq_uc_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_UC_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_UC_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=15) && (b<=4)))
        return 0x842070683c00ll + 0x20ll * ((a) & 0xf) + 4ll * ((b) & 0x7);
    __bdk_csr_fatal("TNS_TXQ_EQ_UC_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_UC_FIFX_WX(a,b) bdk_tns_txq_eq_uc_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_UC_FIFX_WX(a,b) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_UC_FIFX_WX(a,b) "TNS_TXQ_EQ_UC_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_EQ_UC_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_UC_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_EQ_UC_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_eq_wr_token_lfif_thr
 *
 * TNS TxQ Enque Write Token Latency FIFO Threshold Register
 * Write token latency fifo flow control threshold configuration
 */
union bdk_tns_txq_eq_wr_token_lfif_thr
{
    uint32_t u;
    struct bdk_tns_txq_eq_wr_token_lfif_thr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t theshold              : 5;  /**< [  4:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t theshold              : 5;  /**< [  4:  0](R/W) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_eq_wr_token_lfif_thr_s cn; */
};
typedef union bdk_tns_txq_eq_wr_token_lfif_thr bdk_tns_txq_eq_wr_token_lfif_thr_t;

#define BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207068490cll;
    __bdk_csr_fatal("TNS_TXQ_EQ_WR_TOKEN_LFIF_THR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR bdk_tns_txq_eq_wr_token_lfif_thr_t
#define bustype_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR "TNS_TXQ_EQ_WR_TOKEN_LFIF_THR"
#define device_bar_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR 0
#define arguments_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w0
 *
 * TNS TxQ QMAP AQM Profile Memory Word 0 Registers
 * AQM Profile Table
 * Bits[31:19] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w0
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t qcn_prob_shift0       : 7;  /**< [ 31: 25](R/W) -- */
        uint32_t qcn_prob_shift1       : 8;  /**< [ 24: 17](R/W) -- */
        uint32_t qcn_prob_shift2       : 8;  /**< [ 16:  9](R/W) -- */
        uint32_t qcn_fb_shift_val      : 5;  /**< [  8:  4](R/W) -- */
        uint32_t q_share_en            : 1;  /**< [  3:  3](R/W) -- */
        uint32_t q_share_pool          : 3;  /**< [  2:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t q_share_pool          : 3;  /**< [  2:  0](R/W) -- */
        uint32_t q_share_en            : 1;  /**< [  3:  3](R/W) -- */
        uint32_t qcn_fb_shift_val      : 5;  /**< [  8:  4](R/W) -- */
        uint32_t qcn_prob_shift2       : 8;  /**< [ 16:  9](R/W) -- */
        uint32_t qcn_prob_shift1       : 8;  /**< [ 24: 17](R/W) -- */
        uint32_t qcn_prob_shift0       : 7;  /**< [ 31: 25](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w0_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w0 bdk_tns_txq_qmap_aqm_pfl_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070608000ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(a) bdk_tns_txq_qmap_aqm_pfl_memx_w0_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W0"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w1
 *
 * TNS TxQ QMAP AQM Profile Memory Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w1
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t qcn_fb_max            : 15; /**< [ 31: 17](R/W) -- */
        uint32_t qcn_fb_min_samp_prob  : 8;  /**< [ 16:  9](R/W) -- */
        uint32_t qcn_fb_max_samp_prob  : 8;  /**< [  8:  1](R/W) -- */
        uint32_t qcn_prob_shift0       : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field QCN_PROB_SHIFT0 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t qcn_prob_shift0       : 1;  /**< [  0:  0](R/W) Continuation of MSBs of field QCN_PROB_SHIFT0 from previous word. */
        uint32_t qcn_fb_max_samp_prob  : 8;  /**< [  8:  1](R/W) -- */
        uint32_t qcn_fb_min_samp_prob  : 8;  /**< [ 16:  9](R/W) -- */
        uint32_t qcn_fb_max            : 15; /**< [ 31: 17](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w1_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w1 bdk_tns_txq_qmap_aqm_pfl_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070608004ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(a) bdk_tns_txq_qmap_aqm_pfl_memx_w1_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W1"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w2
 *
 * TNS TxQ QMAP AQM Profile Memory Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w2
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t qcn_eq_param          : 6;  /**< [ 31: 26](R/W) -- */
        uint32_t qcn_weight_shift0     : 3;  /**< [ 25: 23](R/W) -- */
        uint32_t qcn_weight_shift1     : 3;  /**< [ 22: 20](R/W) -- */
        uint32_t qcn_weight_shift2     : 3;  /**< [ 19: 17](R/W) -- */
        uint32_t qcn_fb_max            : 17; /**< [ 16:  0](R/W) Continuation of MSBs of field QCN_FB_MAX from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t qcn_fb_max            : 17; /**< [ 16:  0](R/W) Continuation of MSBs of field QCN_FB_MAX from previous word. */
        uint32_t qcn_weight_shift2     : 3;  /**< [ 19: 17](R/W) -- */
        uint32_t qcn_weight_shift1     : 3;  /**< [ 22: 20](R/W) -- */
        uint32_t qcn_weight_shift0     : 3;  /**< [ 25: 23](R/W) -- */
        uint32_t qcn_eq_param          : 6;  /**< [ 31: 26](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w2_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w2 bdk_tns_txq_qmap_aqm_pfl_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070608008ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(a) bdk_tns_txq_qmap_aqm_pfl_memx_w2_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W2"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w3
 *
 * TNS TxQ QMAP AQM Profile Memory Word 3 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w3
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wred_mark_drop_prob   : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t dctcp_mark_en         : 1;  /**< [ 27: 27](R/W) -- */
        uint32_t dctcp_mark_th         : 15; /**< [ 26: 12](R/W) -- */
        uint32_t phantom_q_en          : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t qcn_mode              : 2;  /**< [ 10:  9](R/W) -- */
        uint32_t qcn_eq_param          : 9;  /**< [  8:  0](R/W) Continuation of MSBs of field QCN_EQ_PARAM from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t qcn_eq_param          : 9;  /**< [  8:  0](R/W) Continuation of MSBs of field QCN_EQ_PARAM from previous word. */
        uint32_t qcn_mode              : 2;  /**< [ 10:  9](R/W) -- */
        uint32_t phantom_q_en          : 1;  /**< [ 11: 11](R/W) -- */
        uint32_t dctcp_mark_th         : 15; /**< [ 26: 12](R/W) -- */
        uint32_t dctcp_mark_en         : 1;  /**< [ 27: 27](R/W) -- */
        uint32_t wred_mark_drop_prob   : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w3_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w3 bdk_tns_txq_qmap_aqm_pfl_memx_w3_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x84207060800cll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W3", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(a) bdk_tns_txq_qmap_aqm_pfl_memx_w3_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W3"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w4
 *
 * TNS TxQ QMAP AQM Profile Memory Word 4 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w4
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wred_avg_length_weight : 4; /**< [ 31: 28](R/W) -- */
        uint32_t wred_shift0           : 8;  /**< [ 27: 20](R/W) -- */
        uint32_t wred_shift1           : 8;  /**< [ 19: 12](R/W) -- */
        uint32_t wred_shift2           : 8;  /**< [ 11:  4](R/W) -- */
        uint32_t wred_mark_drop_prob   : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field WRED_MARK_DROP_PROB from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t wred_mark_drop_prob   : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field WRED_MARK_DROP_PROB from previous word. */
        uint32_t wred_shift2           : 8;  /**< [ 11:  4](R/W) -- */
        uint32_t wred_shift1           : 8;  /**< [ 19: 12](R/W) -- */
        uint32_t wred_shift0           : 8;  /**< [ 27: 20](R/W) -- */
        uint32_t wred_avg_length_weight : 4; /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w4_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w4 bdk_tns_txq_qmap_aqm_pfl_memx_w4_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070608010ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W4", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(a) bdk_tns_txq_qmap_aqm_pfl_memx_w4_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W4"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w5
 *
 * TNS TxQ QMAP AQM Profile Memory Word 5 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w5
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t wred_avg_length_min_th : 13;/**< [ 31: 19](R/W) -- */
        uint32_t wred_avg_length_max_th : 15;/**< [ 18:  4](R/W) -- */
        uint32_t wred_avg_length_weight : 4; /**< [  3:  0](R/W) Continuation of MSBs of field WRED_AVG_LENGTH_WEIGHT from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t wred_avg_length_weight : 4; /**< [  3:  0](R/W) Continuation of MSBs of field WRED_AVG_LENGTH_WEIGHT from previous word. */
        uint32_t wred_avg_length_max_th : 15;/**< [ 18:  4](R/W) -- */
        uint32_t wred_avg_length_min_th : 13;/**< [ 31: 19](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w5_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w5 bdk_tns_txq_qmap_aqm_pfl_memx_w5_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070608014ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W5", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(a) bdk_tns_txq_qmap_aqm_pfl_memx_w5_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W5"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_aqm_pfl_mem#_w6
 *
 * TNS TxQ QMAP AQM Profile Memory Word 6 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 */
union bdk_tns_txq_qmap_aqm_pfl_memx_w6
{
    uint32_t u;
    struct bdk_tns_txq_qmap_aqm_pfl_memx_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_19_31        : 13;
        uint32_t length_max_th         : 15; /**< [ 18:  4](R/W) -- */
        uint32_t wred_mode             : 2;  /**< [  3:  2](R/W) -- */
        uint32_t wred_avg_length_min_th : 2; /**< [  1:  0](R/W) Continuation of MSBs of field WRED_AVG_LENGTH_MIN_TH from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t wred_avg_length_min_th : 2; /**< [  1:  0](R/W) Continuation of MSBs of field WRED_AVG_LENGTH_MIN_TH from previous word. */
        uint32_t wred_mode             : 2;  /**< [  3:  2](R/W) -- */
        uint32_t length_max_th         : 15; /**< [ 18:  4](R/W) -- */
        uint32_t reserved_19_31        : 13;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_aqm_pfl_memx_w6_s cn; */
};
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w6 bdk_tns_txq_qmap_aqm_pfl_memx_w6_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=127))
        return 0x842070608018ll + 0x20ll * ((a) & 0x7f);
    __bdk_csr_fatal("TNS_TXQ_QMAP_AQM_PFL_MEMX_W6", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(a) bdk_tns_txq_qmap_aqm_pfl_memx_w6_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(a) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W6"
#define device_bar_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_ecc_ctl
 *
 * TNS TxQ QMAP ECC Control Register
 * ECC configuration of Token Buffer memories
 */
union bdk_tns_txq_qmap_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_qmap_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_6_31         : 26;
        uint32_t qmap_table_db_ecc     : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in QMAP memory */
        uint32_t qmap_table_sb_ecc     : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in QMAP memory */
        uint32_t qmap_table_ecc_dis    : 1;  /**< [  3:  3](R/W) Disable ECC for QMAP memory */
        uint32_t eq_cfg_db_ecc         : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in EQ Configuration memory */
        uint32_t eq_cfg_sb_ecc         : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in EQ Configuration memory */
        uint32_t eq_cfg_ecc_dis        : 1;  /**< [  0:  0](R/W) Disable ECC for EQ Configuration memory */
#else /* Word 0 - Little Endian */
        uint32_t eq_cfg_ecc_dis        : 1;  /**< [  0:  0](R/W) Disable ECC for EQ Configuration memory */
        uint32_t eq_cfg_sb_ecc         : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in EQ Configuration memory */
        uint32_t eq_cfg_db_ecc         : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in EQ Configuration memory */
        uint32_t qmap_table_ecc_dis    : 1;  /**< [  3:  3](R/W) Disable ECC for QMAP memory */
        uint32_t qmap_table_sb_ecc     : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in QMAP memory */
        uint32_t qmap_table_db_ecc     : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in QMAP memory */
        uint32_t reserved_6_31         : 26;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_qmap_ecc_ctl bdk_tns_txq_qmap_ecc_ctl_t;

#define BDK_TNS_TXQ_QMAP_ECC_CTL BDK_TNS_TXQ_QMAP_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c470ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_ECC_CTL bdk_tns_txq_qmap_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_QMAP_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_ECC_CTL "TNS_TXQ_QMAP_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_QMAP_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_QMAP_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_en_cfg
 *
 * TNS TxQ QMAP Enable Configuration Register
 * QMap enabled to accept requests into its pipeline.
 */
union bdk_tns_txq_qmap_en_cfg
{
    uint32_t u;
    struct bdk_tns_txq_qmap_en_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_en_cfg_s cn; */
};
typedef union bdk_tns_txq_qmap_en_cfg bdk_tns_txq_qmap_en_cfg_t;

#define BDK_TNS_TXQ_QMAP_EN_CFG BDK_TNS_TXQ_QMAP_EN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EN_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c48cll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_EN_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_EN_CFG bdk_tns_txq_qmap_en_cfg_t
#define bustype_BDK_TNS_TXQ_QMAP_EN_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_EN_CFG "TNS_TXQ_QMAP_EN_CFG"
#define device_bar_BDK_TNS_TXQ_QMAP_EN_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_EN_CFG 0
#define arguments_BDK_TNS_TXQ_QMAP_EN_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_eq_cfg_ecc_log
 *
 * TNS TxQ QMAP Enque Configuration ECC Log Register
 * QMAP EQ configuration memory ECC error log.  Address is sticky on first error.
 * Re-armed after reading
 */
union bdk_tns_txq_qmap_eq_cfg_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_qmap_eq_cfg_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_eq_cfg_ecc_log_s cn; */
};
typedef union bdk_tns_txq_qmap_eq_cfg_ecc_log bdk_tns_txq_qmap_eq_cfg_ecc_log_t;

#define BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c478ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_EQ_CFG_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG bdk_tns_txq_qmap_eq_cfg_ecc_log_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG "TNS_TXQ_QMAP_EQ_CFG_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_qmap_eq_cfg_mem#
 *
 * TNS TxQ QMAP Enque Configuration Memory Registers
 * Eq Configuration Table
 */
union bdk_tns_txq_qmap_eq_cfg_memx
{
    uint64_t u;
    struct bdk_tns_txq_qmap_eq_cfg_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_39_63        : 25;
        uint64_t h1                    : 8;  /**< [ 38: 31](R/W) -- */
        uint64_t p                     : 4;  /**< [ 30: 27](R/W) -- */
        uint64_t q_pfl                 : 7;  /**< [ 26: 20](R/W) -- */
        uint64_t h1_pfl                : 7;  /**< [ 19: 13](R/W) -- */
        uint64_t p_pfl                 : 7;  /**< [ 12:  6](R/W) -- */
        uint64_t q_eq_en               : 1;  /**< [  5:  5](R/W) -- */
        uint64_t h1_eq_en              : 1;  /**< [  4:  4](R/W) -- */
        uint64_t p_eq_en               : 1;  /**< [  3:  3](R/W) -- */
        uint64_t q_em_en               : 1;  /**< [  2:  2](R/W) Reserved and must be set to 0.
                                                                 Internal:
                                                                 Defeatured. */
        uint64_t h1_em_en              : 1;  /**< [  1:  1](R/W) Reserved and must be set to 0.
                                                                 Internal:
                                                                 Defeatured. */
        uint64_t p_em_en               : 1;  /**< [  0:  0](R/W) Reserved and must be set to 0.
                                                                 Internal:
                                                                 Defeatured. */
#else /* Word 0 - Little Endian */
        uint64_t p_em_en               : 1;  /**< [  0:  0](R/W) Reserved and must be set to 0.
                                                                 Internal:
                                                                 Defeatured. */
        uint64_t h1_em_en              : 1;  /**< [  1:  1](R/W) Reserved and must be set to 0.
                                                                 Internal:
                                                                 Defeatured. */
        uint64_t q_em_en               : 1;  /**< [  2:  2](R/W) Reserved and must be set to 0.
                                                                 Internal:
                                                                 Defeatured. */
        uint64_t p_eq_en               : 1;  /**< [  3:  3](R/W) -- */
        uint64_t h1_eq_en              : 1;  /**< [  4:  4](R/W) -- */
        uint64_t q_eq_en               : 1;  /**< [  5:  5](R/W) -- */
        uint64_t p_pfl                 : 7;  /**< [ 12:  6](R/W) -- */
        uint64_t h1_pfl                : 7;  /**< [ 19: 13](R/W) -- */
        uint64_t q_pfl                 : 7;  /**< [ 26: 20](R/W) -- */
        uint64_t p                     : 4;  /**< [ 30: 27](R/W) -- */
        uint64_t h1                    : 8;  /**< [ 38: 31](R/W) -- */
        uint64_t reserved_39_63        : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_eq_cfg_memx_s cn; */
};
typedef union bdk_tns_txq_qmap_eq_cfg_memx bdk_tns_txq_qmap_eq_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070604000ll + 8ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_QMAP_EQ_CFG_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(a) bdk_tns_txq_qmap_eq_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(a) "TNS_TXQ_QMAP_EQ_CFG_MEMX"
#define device_bar_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_eq_query_ct
 *
 * TNS TxQ QMAP Enque Query Count Register
 * Counter of EQ queries.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
union bdk_tns_txq_qmap_eq_query_ct
{
    uint32_t u;
    struct bdk_tns_txq_qmap_eq_query_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_eq_query_ct_s cn; */
};
typedef union bdk_tns_txq_qmap_eq_query_ct bdk_tns_txq_qmap_eq_query_ct_t;

#define BDK_TNS_TXQ_QMAP_EQ_QUERY_CT BDK_TNS_TXQ_QMAP_EQ_QUERY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_QUERY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_QUERY_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c480ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_EQ_QUERY_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT bdk_tns_txq_qmap_eq_query_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT "TNS_TXQ_QMAP_EQ_QUERY_CT"
#define device_bar_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_eq_reply_ct
 *
 * TNS TxQ QMAP Enque Reply Count Register
 * Counter of EQ replies.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
union bdk_tns_txq_qmap_eq_reply_ct
{
    uint32_t u;
    struct bdk_tns_txq_qmap_eq_reply_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_eq_reply_ct_s cn; */
};
typedef union bdk_tns_txq_qmap_eq_reply_ct bdk_tns_txq_qmap_eq_reply_ct_t;

#define BDK_TNS_TXQ_QMAP_EQ_REPLY_CT BDK_TNS_TXQ_QMAP_EQ_REPLY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_REPLY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_REPLY_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c488ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_EQ_REPLY_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT bdk_tns_txq_qmap_eq_reply_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT "TNS_TXQ_QMAP_EQ_REPLY_CT"
#define device_bar_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_h1_full_cfg_mem#
 *
 * TNS TxQ QMAP H1 Full Configuration Memory Registers
 * H1 full vector
 */
union bdk_tns_txq_qmap_h1_full_cfg_memx
{
    uint32_t u;
    struct bdk_tns_txq_qmap_h1_full_cfg_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t full                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t full                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_h1_full_cfg_memx_s cn; */
};
typedef union bdk_tns_txq_qmap_h1_full_cfg_memx bdk_tns_txq_qmap_h1_full_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=255))
        return 0x84207060c000ll + 4ll * ((a) & 0xff);
    __bdk_csr_fatal("TNS_TXQ_QMAP_H1_FULL_CFG_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(a) bdk_tns_txq_qmap_h1_full_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(a) "TNS_TXQ_QMAP_H1_FULL_CFG_MEMX"
#define device_bar_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_int_en_hi
 *
 * TNS TxQ QMAP Interrrupt Enable High Register
 * QMAP interrupt register
 */
union bdk_tns_txq_qmap_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_qmap_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](R/W) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](R/W) QMAP EQ query DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](R/W) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) QMAP configuration input DFC Rx overflow */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](R/W) QMAP memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](R/W) QMAP Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](R/W) EQ configuration memory double bit ECC interrupt */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](R/W) EQ configuration Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](R/W) EQ configuration Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](R/W) EQ configuration memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](R/W) QMAP Buffer memory single bit ECC interrupt */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](R/W) QMAP memory double bit ECC interrupt */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) QMAP configuration input DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](R/W) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](R/W) QMAP EQ query DFC Rx overflow */
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](R/W) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_qmap_int_en_hi bdk_tns_txq_qmap_int_en_hi_t;

#define BDK_TNS_TXQ_QMAP_INT_EN_HI BDK_TNS_TXQ_QMAP_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c464ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_INT_EN_HI bdk_tns_txq_qmap_int_en_hi_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_INT_EN_HI "TNS_TXQ_QMAP_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_QMAP_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_int_en_lo
 *
 * TNS TxQ QMAP Interrrupt Enable Low Register
 * QMAP interrupt register
 */
union bdk_tns_txq_qmap_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_qmap_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](R/W) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](R/W) QMAP EQ query DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](R/W) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) QMAP configuration input DFC Rx overflow */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](R/W) QMAP memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](R/W) QMAP Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](R/W) EQ configuration memory double bit ECC interrupt */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](R/W) EQ configuration Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](R/W) EQ configuration Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](R/W) EQ configuration memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](R/W) QMAP Buffer memory single bit ECC interrupt */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](R/W) QMAP memory double bit ECC interrupt */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W) QMAP configuration input DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](R/W) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](R/W) QMAP EQ query DFC Rx overflow */
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](R/W) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_qmap_int_en_lo bdk_tns_txq_qmap_int_en_lo_t;

#define BDK_TNS_TXQ_QMAP_INT_EN_LO BDK_TNS_TXQ_QMAP_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c468ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_INT_EN_LO bdk_tns_txq_qmap_int_en_lo_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_INT_EN_LO "TNS_TXQ_QMAP_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_QMAP_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_int_frc
 *
 * TNS TxQ QMAP Interrrupt Force Register
 * QMAP interrupt register
 */
union bdk_tns_txq_qmap_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_qmap_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](WO) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](WO) QMAP EQ query DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](WO) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](WO) QMAP configuration input DFC Rx overflow */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](WO) QMAP memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](WO) QMAP Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](WO) EQ configuration memory double bit ECC interrupt */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](WO) EQ configuration Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](WO) EQ configuration Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](WO) EQ configuration memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](WO) QMAP Buffer memory single bit ECC interrupt */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](WO) QMAP memory double bit ECC interrupt */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](WO) QMAP configuration input DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](WO) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](WO) QMAP EQ query DFC Rx overflow */
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](WO) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_int_frc_s cn; */
};
typedef union bdk_tns_txq_qmap_int_frc bdk_tns_txq_qmap_int_frc_t;

#define BDK_TNS_TXQ_QMAP_INT_FRC BDK_TNS_TXQ_QMAP_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c46cll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_INT_FRC bdk_tns_txq_qmap_int_frc_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_INT_FRC "TNS_TXQ_QMAP_INT_FRC"
#define device_bar_BDK_TNS_TXQ_QMAP_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_INT_FRC 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_int_w1c
 *
 * TNS TxQ QMAP Interrrupt W1C Register
 * QMAP interrupt register
 */
union bdk_tns_txq_qmap_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_qmap_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](R/W1C/H) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](R/W1C/H) QMAP EQ query DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](R/W1C/H) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W1C/H) QMAP configuration input DFC Rx overflow */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](R/W1C/H) QMAP memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](R/W1C/H) QMAP Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](R/W1C/H) EQ configuration memory double bit ECC interrupt */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](R/W1C/H) EQ configuration Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t eq_cfg_sb_err         : 1;  /**< [  0:  0](R/W1C/H) EQ configuration Buffer memory single bit ECC interrupt */
        uint32_t eq_cfg_db_err         : 1;  /**< [  1:  1](R/W1C/H) EQ configuration memory double bit ECC interrupt */
        uint32_t qmap_table_sb_err     : 1;  /**< [  2:  2](R/W1C/H) QMAP Buffer memory single bit ECC interrupt */
        uint32_t qmap_table_db_err     : 1;  /**< [  3:  3](R/W1C/H) QMAP memory double bit ECC interrupt */
        uint32_t dfc_rx_cfg_i_ovfl_err : 1;  /**< [  4:  4](R/W1C/H) QMAP configuration input DFC Rx overflow */
        uint32_t dfc_rx_urw_query_ovfl_err : 1;/**< [  5:  5](R/W1C/H) QMAP URW query DFC Rx overflow */
        uint32_t dfc_rx_eq_query_ovfl_err : 1;/**< [  6:  6](R/W1C/H) QMAP EQ query DFC Rx overflow */
        uint32_t cnt_return_data_err   : 1;  /**< [  7:  7](R/W1C/H) Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_int_w1c_s cn; */
};
typedef union bdk_tns_txq_qmap_int_w1c bdk_tns_txq_qmap_int_w1c_t;

#define BDK_TNS_TXQ_QMAP_INT_W1C BDK_TNS_TXQ_QMAP_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c460ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_INT_W1C bdk_tns_txq_qmap_int_w1c_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_INT_W1C "TNS_TXQ_QMAP_INT_W1C"
#define device_bar_BDK_TNS_TXQ_QMAP_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_INT_W1C 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_lock
 *
 * TNS TxQ QMAP Lock Register
 * Lock Register
 */
union bdk_tns_txq_qmap_lock
{
    uint32_t u;
    struct bdk_tns_txq_qmap_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_lock_s cn; */
};
typedef union bdk_tns_txq_qmap_lock bdk_tns_txq_qmap_lock_t;

#define BDK_TNS_TXQ_QMAP_LOCK BDK_TNS_TXQ_QMAP_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c4c0ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_LOCK bdk_tns_txq_qmap_lock_t
#define bustype_BDK_TNS_TXQ_QMAP_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_LOCK "TNS_TXQ_QMAP_LOCK"
#define device_bar_BDK_TNS_TXQ_QMAP_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_LOCK 0
#define arguments_BDK_TNS_TXQ_QMAP_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_ptf_cfg_mem#
 *
 * TNS TxQ QMAP Port Full Configuration Memory Registers
 * Port full vector
 */
union bdk_tns_txq_qmap_ptf_cfg_memx
{
    uint32_t u;
    struct bdk_tns_txq_qmap_ptf_cfg_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t full                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t full                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_ptf_cfg_memx_s cn; */
};
typedef union bdk_tns_txq_qmap_ptf_cfg_memx bdk_tns_txq_qmap_ptf_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=15))
        return 0x84207060c400ll + 4ll * ((a) & 0xf);
    __bdk_csr_fatal("TNS_TXQ_QMAP_PTF_CFG_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(a) bdk_tns_txq_qmap_ptf_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(a) "TNS_TXQ_QMAP_PTF_CFG_MEMX"
#define device_bar_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_q_full_cfg_mem#
 *
 * TNS TxQ QMAP Queue Full Configuration Memory Registers
 * Queue full vector
 */
union bdk_tns_txq_qmap_q_full_cfg_memx
{
    uint32_t u;
    struct bdk_tns_txq_qmap_q_full_cfg_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t full                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t full                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_q_full_cfg_memx_s cn; */
};
typedef union bdk_tns_txq_qmap_q_full_cfg_memx bdk_tns_txq_qmap_q_full_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x84207060a000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_QMAP_Q_FULL_CFG_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(a) bdk_tns_txq_qmap_q_full_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(a) "TNS_TXQ_QMAP_Q_FULL_CFG_MEMX"
#define device_bar_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_qmap_qcn_cp_rng
 *
 * INTERNAL: TNS TxQ QMAP QCN Is COPY2CPU Random Number Generator Register
 *
 * QCN (defeatured) congestion point RNG configuration.
 */
union bdk_tns_txq_qmap_qcn_cp_rng
{
    uint64_t u;
    struct bdk_tns_txq_qmap_qcn_cp_rng_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t enable                : 1;  /**< [ 32: 32](R/W) -- */
        uint64_t seed                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 32; /**< [ 31:  0](R/W) -- */
        uint64_t enable                : 1;  /**< [ 32: 32](R/W) -- */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_qcn_cp_rng_s cn; */
};
typedef union bdk_tns_txq_qmap_qcn_cp_rng bdk_tns_txq_qmap_qcn_cp_rng_t;

#define BDK_TNS_TXQ_QMAP_QCN_CP_RNG BDK_TNS_TXQ_QMAP_QCN_CP_RNG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_QCN_CP_RNG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_QCN_CP_RNG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c498ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_QCN_CP_RNG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_QCN_CP_RNG bdk_tns_txq_qmap_qcn_cp_rng_t
#define bustype_BDK_TNS_TXQ_QMAP_QCN_CP_RNG BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_QMAP_QCN_CP_RNG "TNS_TXQ_QMAP_QCN_CP_RNG"
#define device_bar_BDK_TNS_TXQ_QMAP_QCN_CP_RNG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_QCN_CP_RNG 0
#define arguments_BDK_TNS_TXQ_QMAP_QCN_CP_RNG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_sde_query_ct
 *
 * TNS TxQ QMAP SDE Query Count Register
 * Counter of SDE queries.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
union bdk_tns_txq_qmap_sde_query_ct
{
    uint32_t u;
    struct bdk_tns_txq_qmap_sde_query_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_sde_query_ct_s cn; */
};
typedef union bdk_tns_txq_qmap_sde_query_ct bdk_tns_txq_qmap_sde_query_ct_t;

#define BDK_TNS_TXQ_QMAP_SDE_QUERY_CT BDK_TNS_TXQ_QMAP_SDE_QUERY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_QUERY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_QUERY_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c47cll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_SDE_QUERY_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT bdk_tns_txq_qmap_sde_query_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT "TNS_TXQ_QMAP_SDE_QUERY_CT"
#define device_bar_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_sde_reply_ct
 *
 * TNS TxQ QMAP SDE Reply Count Register
 * Counter of SDE replies.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
union bdk_tns_txq_qmap_sde_reply_ct
{
    uint32_t u;
    struct bdk_tns_txq_qmap_sde_reply_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_sde_reply_ct_s cn; */
};
typedef union bdk_tns_txq_qmap_sde_reply_ct bdk_tns_txq_qmap_sde_reply_ct_t;

#define BDK_TNS_TXQ_QMAP_SDE_REPLY_CT BDK_TNS_TXQ_QMAP_SDE_REPLY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_REPLY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_REPLY_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c484ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_SDE_REPLY_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT bdk_tns_txq_qmap_sde_reply_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT "TNS_TXQ_QMAP_SDE_REPLY_CT"
#define device_bar_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_spad
 *
 * TNS TxQ QMAP ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_qmap_spad
{
    uint32_t u;
    struct bdk_tns_txq_qmap_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_spad_s cn; */
};
typedef union bdk_tns_txq_qmap_spad bdk_tns_txq_qmap_spad_t;

#define BDK_TNS_TXQ_QMAP_SPAD BDK_TNS_TXQ_QMAP_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c4c4ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_SPAD bdk_tns_txq_qmap_spad_t
#define bustype_BDK_TNS_TXQ_QMAP_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_SPAD "TNS_TXQ_QMAP_SPAD"
#define device_bar_BDK_TNS_TXQ_QMAP_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_SPAD 0
#define arguments_BDK_TNS_TXQ_QMAP_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_tbl_ecc_log
 *
 * TNS TxQ QMAP Table ECC Log Register
 * QMAP table memory ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_qmap_tbl_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_qmap_tbl_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_tbl_ecc_log_s cn; */
};
typedef union bdk_tns_txq_qmap_tbl_ecc_log bdk_tns_txq_qmap_tbl_ecc_log_t;

#define BDK_TNS_TXQ_QMAP_TBL_ECC_LOG BDK_TNS_TXQ_QMAP_TBL_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c474ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_TBL_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG bdk_tns_txq_qmap_tbl_ecc_log_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG "TNS_TXQ_QMAP_TBL_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_tbl_idx_cfg#_w0
 *
 * TNS TxQ QMAP Table Index Configuration Word 0 Registers
 * QMap Table index selection
 */
union bdk_tns_txq_qmap_tbl_idx_cfgx_w0
{
    uint32_t u;
    struct bdk_tns_txq_qmap_tbl_idx_cfgx_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit5_array_index      : 2;  /**< [ 31: 30](R/W) -- */
        uint32_t bit4_array_index      : 6;  /**< [ 29: 24](R/W) -- */
        uint32_t bit3_array_index      : 6;  /**< [ 23: 18](R/W) -- */
        uint32_t bit2_array_index      : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t bit1_array_index      : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t bit0_array_index      : 6;  /**< [  5:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t bit0_array_index      : 6;  /**< [  5:  0](R/W) -- */
        uint32_t bit1_array_index      : 6;  /**< [ 11:  6](R/W) -- */
        uint32_t bit2_array_index      : 6;  /**< [ 17: 12](R/W) -- */
        uint32_t bit3_array_index      : 6;  /**< [ 23: 18](R/W) -- */
        uint32_t bit4_array_index      : 6;  /**< [ 29: 24](R/W) -- */
        uint32_t bit5_array_index      : 2;  /**< [ 31: 30](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w0_s cn; */
};
typedef union bdk_tns_txq_qmap_tbl_idx_cfgx_w0 bdk_tns_txq_qmap_tbl_idx_cfgx_w0_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84207060c4a8ll + 0xcll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_TXQ_QMAP_TBL_IDX_CFGX_W0", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(a) bdk_tns_txq_qmap_tbl_idx_cfgx_w0_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(a) "TNS_TXQ_QMAP_TBL_IDX_CFGX_W0"
#define device_bar_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_tbl_idx_cfg#_w1
 *
 * TNS TxQ QMAP Table Index Configuration Word 1 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_TBL_IDX_CFG(0..1)_W0
 */
union bdk_tns_txq_qmap_tbl_idx_cfgx_w1
{
    uint32_t u;
    struct bdk_tns_txq_qmap_tbl_idx_cfgx_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t bit10_array_index     : 4;  /**< [ 31: 28](R/W) -- */
        uint32_t bit9_array_index      : 6;  /**< [ 27: 22](R/W) -- */
        uint32_t bit8_array_index      : 6;  /**< [ 21: 16](R/W) -- */
        uint32_t bit7_array_index      : 6;  /**< [ 15: 10](R/W) -- */
        uint32_t bit6_array_index      : 6;  /**< [  9:  4](R/W) -- */
        uint32_t bit5_array_index      : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field BIT5_ARRAY_INDEX from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t bit5_array_index      : 4;  /**< [  3:  0](R/W) Continuation of MSBs of field BIT5_ARRAY_INDEX from previous word. */
        uint32_t bit6_array_index      : 6;  /**< [  9:  4](R/W) -- */
        uint32_t bit7_array_index      : 6;  /**< [ 15: 10](R/W) -- */
        uint32_t bit8_array_index      : 6;  /**< [ 21: 16](R/W) -- */
        uint32_t bit9_array_index      : 6;  /**< [ 27: 22](R/W) -- */
        uint32_t bit10_array_index     : 4;  /**< [ 31: 28](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w1_s cn; */
};
typedef union bdk_tns_txq_qmap_tbl_idx_cfgx_w1 bdk_tns_txq_qmap_tbl_idx_cfgx_w1_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84207060c4acll + 0xcll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_TXQ_QMAP_TBL_IDX_CFGX_W1", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(a) bdk_tns_txq_qmap_tbl_idx_cfgx_w1_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(a) "TNS_TXQ_QMAP_TBL_IDX_CFGX_W1"
#define device_bar_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_tbl_idx_cfg#_w2
 *
 * TNS TxQ QMAP Table Index Configuration Word 2 Registers
 * Continuation of structure defined in TNS_TXQ_QMAP_TBL_IDX_CFG(0..1)_W0
 */
union bdk_tns_txq_qmap_tbl_idx_cfgx_w2
{
    uint32_t u;
    struct bdk_tns_txq_qmap_tbl_idx_cfgx_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_8_31         : 24;
        uint32_t bit11_array_index     : 6;  /**< [  7:  2](R/W) -- */
        uint32_t bit10_array_index     : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field BIT10_ARRAY_INDEX from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t bit10_array_index     : 2;  /**< [  1:  0](R/W) Continuation of MSBs of field BIT10_ARRAY_INDEX from previous word. */
        uint32_t bit11_array_index     : 6;  /**< [  7:  2](R/W) -- */
        uint32_t reserved_8_31         : 24;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w2_s cn; */
};
typedef union bdk_tns_txq_qmap_tbl_idx_cfgx_w2 bdk_tns_txq_qmap_tbl_idx_cfgx_w2_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=1))
        return 0x84207060c4b0ll + 0xcll * ((a) & 0x1);
    __bdk_csr_fatal("TNS_TXQ_QMAP_TBL_IDX_CFGX_W2", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(a) bdk_tns_txq_qmap_tbl_idx_cfgx_w2_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(a) "TNS_TXQ_QMAP_TBL_IDX_CFGX_W2"
#define device_bar_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_qmap_tbl_mem#
 *
 * TNS TxQ QMAP Table Memory Registers
 * QMap Tbl (Each line contains four Q#s - Q3,Q2,Q1,Q0)
 */
union bdk_tns_txq_qmap_tbl_memx
{
    uint64_t u;
    struct bdk_tns_txq_qmap_tbl_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_44_63        : 20;
        uint64_t q3                    : 11; /**< [ 43: 33](R/W) -- */
        uint64_t q2                    : 11; /**< [ 32: 22](R/W) -- */
        uint64_t q1                    : 11; /**< [ 21: 11](R/W) -- */
        uint64_t q0                    : 11; /**< [ 10:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t q0                    : 11; /**< [ 10:  0](R/W) -- */
        uint64_t q1                    : 11; /**< [ 21: 11](R/W) -- */
        uint64_t q2                    : 11; /**< [ 32: 22](R/W) -- */
        uint64_t q3                    : 11; /**< [ 43: 33](R/W) -- */
        uint64_t reserved_44_63        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_tbl_memx_s cn; */
};
typedef union bdk_tns_txq_qmap_tbl_memx bdk_tns_txq_qmap_tbl_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070600000ll + 8ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_QMAP_TBL_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_TBL_MEMX(a) bdk_tns_txq_qmap_tbl_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_MEMX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_QMAP_TBL_MEMX(a) "TNS_TXQ_QMAP_TBL_MEMX"
#define device_bar_BDK_TNS_TXQ_QMAP_TBL_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_TBL_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB) tns_txq_qmap_wred_rng_cfg
 *
 * TNS TxQ QMAP WRED Random Number Generator Configuration Register
 * WRED Queue RNG configuration
 */
union bdk_tns_txq_qmap_wred_rng_cfg
{
    uint64_t u;
    struct bdk_tns_txq_qmap_wred_rng_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t reserved_33_63        : 31;
        uint64_t enable                : 1;  /**< [ 32: 32](R/W) -- */
        uint64_t seed                  : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t seed                  : 32; /**< [ 31:  0](R/W) -- */
        uint64_t enable                : 1;  /**< [ 32: 32](R/W) -- */
        uint64_t reserved_33_63        : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_wred_rng_cfg_s cn; */
};
typedef union bdk_tns_txq_qmap_wred_rng_cfg bdk_tns_txq_qmap_wred_rng_cfg_t;

#define BDK_TNS_TXQ_QMAP_WRED_RNG_CFG BDK_TNS_TXQ_QMAP_WRED_RNG_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_WRED_RNG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_WRED_RNG_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c4a0ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_WRED_RNG_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG bdk_tns_txq_qmap_wred_rng_cfg_t
#define bustype_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG "TNS_TXQ_QMAP_WRED_RNG_CFG"
#define device_bar_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG 0
#define arguments_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_wsarb_mode
 *
 * TNS TxQ QMAP WRR/SP Arbiter Mode Register
 * QMap WRR/SP arbiter mode; '0' - WRR, '1' - SP
 */
union bdk_tns_txq_qmap_wsarb_mode
{
    uint32_t u;
    struct bdk_tns_txq_qmap_wsarb_mode_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_1_31         : 31;
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 1;  /**< [  0:  0](R/W) -- */
        uint32_t reserved_1_31         : 31;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_wsarb_mode_s cn; */
};
typedef union bdk_tns_txq_qmap_wsarb_mode bdk_tns_txq_qmap_wsarb_mode_t;

#define BDK_TNS_TXQ_QMAP_WSARB_MODE BDK_TNS_TXQ_QMAP_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_MODE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c490ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_WSARB_MODE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_WSARB_MODE bdk_tns_txq_qmap_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_QMAP_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_WSARB_MODE "TNS_TXQ_QMAP_WSARB_MODE"
#define device_bar_BDK_TNS_TXQ_QMAP_WSARB_MODE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_QMAP_WSARB_MODE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_qmap_wsarb_wgt
 *
 * TNS TxQ QMAP WRR/SP Arbiter Weight Register
 * QMap WRR/SP arbiter weights
 */
union bdk_tns_txq_qmap_wsarb_wgt
{
    uint32_t u;
    struct bdk_tns_txq_qmap_wsarb_wgt_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_16_31        : 16;
        uint32_t eq_weight             : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t sde_weight            : 8;  /**< [  7:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t sde_weight            : 8;  /**< [  7:  0](R/W) -- */
        uint32_t eq_weight             : 8;  /**< [ 15:  8](R/W) -- */
        uint32_t reserved_16_31        : 16;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_qmap_wsarb_wgt_s cn; */
};
typedef union bdk_tns_txq_qmap_wsarb_wgt bdk_tns_txq_qmap_wsarb_wgt_t;

#define BDK_TNS_TXQ_QMAP_WSARB_WGT BDK_TNS_TXQ_QMAP_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_WGT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207060c494ll;
    __bdk_csr_fatal("TNS_TXQ_QMAP_WSARB_WGT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_QMAP_WSARB_WGT bdk_tns_txq_qmap_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_QMAP_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_QMAP_WSARB_WGT "TNS_TXQ_QMAP_WSARB_WGT"
#define device_bar_BDK_TNS_TXQ_QMAP_WSARB_WGT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_QMAP_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_QMAP_WSARB_WGT -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_spt_qmap_tbl_cfg_w#
 *
 * TNS TxQ Source Port QMAP Table Configuration Registers
 * QMap Tbl 0/1 selection based on source port
 */
union bdk_tns_txq_spt_qmap_tbl_cfg_wx
{
    uint64_t u;
    struct bdk_tns_txq_spt_qmap_tbl_cfg_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t qmap_tbl_sel          : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t qmap_tbl_sel          : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_spt_qmap_tbl_cfg_wx_s cn; */
};
typedef union bdk_tns_txq_spt_qmap_tbl_cfg_wx bdk_tns_txq_spt_qmap_tbl_cfg_wx_t;

static inline uint64_t BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=3))
        return 0x84207060c440ll + 8ll * ((a) & 0x3);
    __bdk_csr_fatal("TNS_TXQ_SPT_QMAP_TBL_CFG_WX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(a) bdk_tns_txq_spt_qmap_tbl_cfg_wx_t
#define bustype_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(a) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(a) "TNS_TXQ_SPT_QMAP_TBL_CFG_WX"
#define device_bar_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(a) (a)
#define arguments_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb0_ecc_log
 *
 * TNS TxQ Toke Buffer Memory 0 ECC Log Register
 * Token Buffer memory 0 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_tb0_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tb0_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb0_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tb0_ecc_log bdk_tns_txq_tb0_ecc_log_t;

#define BDK_TNS_TXQ_TB0_ECC_LOG BDK_TNS_TXQ_TB0_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB0_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB0_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040014ll;
    __bdk_csr_fatal("TNS_TXQ_TB0_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB0_ECC_LOG bdk_tns_txq_tb0_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB0_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB0_ECC_LOG "TNS_TXQ_TB0_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TB0_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB0_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB0_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb1_ecc_log
 *
 * TNS TxQ Toke Buffer Memory 1 ECC Log Register
 * Token Buffer memory 1 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_tb1_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tb1_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb1_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tb1_ecc_log bdk_tns_txq_tb1_ecc_log_t;

#define BDK_TNS_TXQ_TB1_ECC_LOG BDK_TNS_TXQ_TB1_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB1_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB1_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040018ll;
    __bdk_csr_fatal("TNS_TXQ_TB1_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB1_ECC_LOG bdk_tns_txq_tb1_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB1_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB1_ECC_LOG "TNS_TXQ_TB1_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TB1_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB1_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB1_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb2_ecc_log
 *
 * TNS TxQ Toke Buffer Memory 2 ECC Log Register
 * Token Buffer memory 2 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_tb2_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tb2_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb2_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tb2_ecc_log bdk_tns_txq_tb2_ecc_log_t;

#define BDK_TNS_TXQ_TB2_ECC_LOG BDK_TNS_TXQ_TB2_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB2_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB2_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207004001cll;
    __bdk_csr_fatal("TNS_TXQ_TB2_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB2_ECC_LOG bdk_tns_txq_tb2_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB2_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB2_ECC_LOG "TNS_TXQ_TB2_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TB2_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB2_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB2_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb3_ecc_log
 *
 * TNS TxQ Toke Buffer Memory 3 ECC Log Register
 * Token Buffer memory 3 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_tb3_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tb3_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_12_31        : 20;
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 12; /**< [ 11:  0](R/W/H) -- */
        uint32_t reserved_12_31        : 20;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb3_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tb3_ecc_log bdk_tns_txq_tb3_ecc_log_t;

#define BDK_TNS_TXQ_TB3_ECC_LOG BDK_TNS_TXQ_TB3_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB3_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB3_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040020ll;
    __bdk_csr_fatal("TNS_TXQ_TB3_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB3_ECC_LOG bdk_tns_txq_tb3_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB3_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB3_ECC_LOG "TNS_TXQ_TB3_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TB3_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB3_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB3_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb_ecc_ctl
 *
 * TNS TxQ Token Buffer ECC Control Register
 * ECC configuration of Token Buffer memories
 */
union bdk_tns_txq_tb_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_tb_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t tb3_db_ecc            : 1;  /**< [  8:  8](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb3_sb_ecc            : 1;  /**< [  7:  7](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb2_db_ecc            : 1;  /**< [  6:  6](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb2_sb_ecc            : 1;  /**< [  5:  5](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb1_db_ecc            : 1;  /**< [  4:  4](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb1_sb_ecc            : 1;  /**< [  3:  3](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb0_db_ecc            : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb0_sb_ecc            : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb_ecc_dis            : 1;  /**< [  0:  0](R/W) Disable ECC for Token Buffer memory */
#else /* Word 0 - Little Endian */
        uint32_t tb_ecc_dis            : 1;  /**< [  0:  0](R/W) Disable ECC for Token Buffer memory */
        uint32_t tb0_sb_ecc            : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb0_db_ecc            : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb1_sb_ecc            : 1;  /**< [  3:  3](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb1_db_ecc            : 1;  /**< [  4:  4](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb2_sb_ecc            : 1;  /**< [  5:  5](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb2_db_ecc            : 1;  /**< [  6:  6](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t tb3_sb_ecc            : 1;  /**< [  7:  7](R/W) Flip 1 bit of ECC syndrome in Token Buffer memory */
        uint32_t tb3_db_ecc            : 1;  /**< [  8:  8](R/W) Flip 2 bits of ECC syndrome in Token Buffer memory */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_tb_ecc_ctl bdk_tns_txq_tb_ecc_ctl_t;

#define BDK_TNS_TXQ_TB_ECC_CTL BDK_TNS_TXQ_TB_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040010ll;
    __bdk_csr_fatal("TNS_TXQ_TB_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_ECC_CTL bdk_tns_txq_tb_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_TB_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_ECC_CTL "TNS_TXQ_TB_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_TB_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_TB_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb_int_en_hi
 *
 * TNS TxQ Token Buffer Interrrupt Enable High Register
 * TxQ Token Buffer interrupts
 */
union bdk_tns_txq_tb_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_tb_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](R/W) DFC Rx overflow on input from CNT config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](R/W) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](R/W) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](R/W) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](R/W) DFC Rx overflow on input from top level config chain interface */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](R/W) Token Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](R/W) DFC Rx overflow on input from top level config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](R/W) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](R/W) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](R/W) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](R/W) DFC Rx overflow on input from CNT config chain interface */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_tb_int_en_hi bdk_tns_txq_tb_int_en_hi_t;

#define BDK_TNS_TXQ_TB_INT_EN_HI BDK_TNS_TXQ_TB_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040004ll;
    __bdk_csr_fatal("TNS_TXQ_TB_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_INT_EN_HI bdk_tns_txq_tb_int_en_hi_t
#define bustype_BDK_TNS_TXQ_TB_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_INT_EN_HI "TNS_TXQ_TB_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_TB_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_TB_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb_int_en_lo
 *
 * TNS TxQ Token Buffer Interrrupt Enable Low Register
 * TxQ Token Buffer interrupts
 */
union bdk_tns_txq_tb_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_tb_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](R/W) DFC Rx overflow on input from CNT config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](R/W) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](R/W) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](R/W) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](R/W) DFC Rx overflow on input from top level config chain interface */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](R/W) Token Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](R/W) Token Buffer memory single bit ECC interrupt */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](R/W) Token Buffer memory double bit ECC interrupt */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](R/W) DFC Rx overflow on input from top level config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](R/W) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](R/W) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](R/W) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](R/W) DFC Rx overflow on input from CNT config chain interface */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_tb_int_en_lo bdk_tns_txq_tb_int_en_lo_t;

#define BDK_TNS_TXQ_TB_INT_EN_LO BDK_TNS_TXQ_TB_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040008ll;
    __bdk_csr_fatal("TNS_TXQ_TB_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_INT_EN_LO bdk_tns_txq_tb_int_en_lo_t
#define bustype_BDK_TNS_TXQ_TB_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_INT_EN_LO "TNS_TXQ_TB_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_TB_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_TB_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb_int_frc
 *
 * TNS TxQ Token Buffer Interrrupt Force Register
 * TxQ Token Buffer interrupts
 */
union bdk_tns_txq_tb_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_tb_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](WO) DFC Rx overflow on input from CNT config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](WO) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](WO) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](WO) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](WO) DFC Rx overflow on input from top level config chain interface */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](WO) Token Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](WO) Token Buffer memory single bit ECC interrupt */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](WO) Token Buffer memory double bit ECC interrupt */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](WO) DFC Rx overflow on input from top level config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](WO) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](WO) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](WO) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](WO) DFC Rx overflow on input from CNT config chain interface */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_int_frc_s cn; */
};
typedef union bdk_tns_txq_tb_int_frc bdk_tns_txq_tb_int_frc_t;

#define BDK_TNS_TXQ_TB_INT_FRC BDK_TNS_TXQ_TB_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207004000cll;
    __bdk_csr_fatal("TNS_TXQ_TB_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_INT_FRC bdk_tns_txq_tb_int_frc_t
#define bustype_BDK_TNS_TXQ_TB_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_INT_FRC "TNS_TXQ_TB_INT_FRC"
#define device_bar_BDK_TNS_TXQ_TB_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_INT_FRC 0
#define arguments_BDK_TNS_TXQ_TB_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb_int_w1c
 *
 * TNS TxQ Token Buffer Interrrupt W1C Register
 * TxQ Token Buffer interrupts
 */
union bdk_tns_txq_tb_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_tb_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_13_31        : 19;
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](R/W1C/H) DFC Rx overflow on input from CNT config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](R/W1C/H) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](R/W1C/H) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](R/W1C/H) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](R/W1C/H) DFC Rx overflow on input from top level config chain interface */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](R/W1C/H) Token Buffer memory single bit ECC interrupt */
#else /* Word 0 - Little Endian */
        uint32_t tb0_mem_sb_err        : 1;  /**< [  0:  0](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb0_mem_db_err        : 1;  /**< [  1:  1](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb1_mem_sb_err        : 1;  /**< [  2:  2](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb1_mem_db_err        : 1;  /**< [  3:  3](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb2_mem_sb_err        : 1;  /**< [  4:  4](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb2_mem_db_err        : 1;  /**< [  5:  5](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t tb3_mem_sb_err        : 1;  /**< [  6:  6](R/W1C/H) Token Buffer memory single bit ECC interrupt */
        uint32_t tb3_mem_db_err        : 1;  /**< [  7:  7](R/W1C/H) Token Buffer memory double bit ECC interrupt */
        uint32_t dfc_rx_txq_i_cfg_ovfl_err : 1;/**< [  8:  8](R/W1C/H) DFC Rx overflow on input from top level config chain interface */
        uint32_t dfc_rx_qmap_o_cfg_ovfl_err : 1;/**< [  9:  9](R/W1C/H) DFC Rx overflow on input from QMAP config chain interface */
        uint32_t dfc_rx_eq_o_cfg_ovfl_err : 1;/**< [ 10: 10](R/W1C/H) DFC Rx overflow on input from EQ config chain interface */
        uint32_t dfc_rx_dq_o_cfg_ovfl_err : 1;/**< [ 11: 11](R/W1C/H) DFC Rx overflow on input from DQ config chain interface */
        uint32_t dfc_rx_cnt_o_cfg_ovfl_err : 1;/**< [ 12: 12](R/W1C/H) DFC Rx overflow on input from CNT config chain interface */
        uint32_t reserved_13_31        : 19;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_int_w1c_s cn; */
};
typedef union bdk_tns_txq_tb_int_w1c bdk_tns_txq_tb_int_w1c_t;

#define BDK_TNS_TXQ_TB_INT_W1C BDK_TNS_TXQ_TB_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040000ll;
    __bdk_csr_fatal("TNS_TXQ_TB_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_INT_W1C bdk_tns_txq_tb_int_w1c_t
#define bustype_BDK_TNS_TXQ_TB_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_INT_W1C "TNS_TXQ_TB_INT_W1C"
#define device_bar_BDK_TNS_TXQ_TB_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_INT_W1C 0
#define arguments_BDK_TNS_TXQ_TB_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tb_lock
 *
 * TNS TxQ Token Buffer Lock Register
 * Lock Register
 */
union bdk_tns_txq_tb_lock
{
    uint32_t u;
    struct bdk_tns_txq_tb_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_lock_s cn; */
};
typedef union bdk_tns_txq_tb_lock bdk_tns_txq_tb_lock_t;

#define BDK_TNS_TXQ_TB_LOCK BDK_TNS_TXQ_TB_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040028ll;
    __bdk_csr_fatal("TNS_TXQ_TB_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_LOCK bdk_tns_txq_tb_lock_t
#define bustype_BDK_TNS_TXQ_TB_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_LOCK "TNS_TXQ_TB_LOCK"
#define device_bar_BDK_TNS_TXQ_TB_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_LOCK 0
#define arguments_BDK_TNS_TXQ_TB_LOCK -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_tb_mem#_w#
 *
 * TNS TxQ Token Buffer Memory Registers
 * TxQ Token Buffer SRAM debug access
 * Bits[63:51] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_tb_memx_wx
{
    uint64_t u;
    struct bdk_tns_txq_tb_memx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_memx_wx_s cn; */
};
typedef union bdk_tns_txq_tb_memx_wx bdk_tns_txq_tb_memx_wx_t;

static inline uint64_t BDK_TNS_TXQ_TB_MEMX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_MEMX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=14335) && (b<=1)))
        return 0x842070000000ll + 0x10ll * ((a) & 0x3fff) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_TXQ_TB_MEMX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_MEMX_WX(a,b) bdk_tns_txq_tb_memx_wx_t
#define bustype_BDK_TNS_TXQ_TB_MEMX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_TB_MEMX_WX(a,b) "TNS_TXQ_TB_MEMX_WX"
#define device_bar_BDK_TNS_TXQ_TB_MEMX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_MEMX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_TB_MEMX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_tb_spad
 *
 * TNS TxQ Token Buffer ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_tb_spad
{
    uint32_t u;
    struct bdk_tns_txq_tb_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tb_spad_s cn; */
};
typedef union bdk_tns_txq_tb_spad bdk_tns_txq_tb_spad_t;

#define BDK_TNS_TXQ_TB_SPAD BDK_TNS_TXQ_TB_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207004002cll;
    __bdk_csr_fatal("TNS_TXQ_TB_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TB_SPAD bdk_tns_txq_tb_spad_t
#define bustype_BDK_TNS_TXQ_TB_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TB_SPAD "TNS_TXQ_TB_SPAD"
#define device_bar_BDK_TNS_TXQ_TB_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TB_SPAD 0
#define arguments_BDK_TNS_TXQ_TB_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbc_bist_stdn
 *
 * TNS TxQ TBC Bist Status Done Register
 * TxQ TBC bist status and bist_done
 */
union bdk_tns_txq_tbc_bist_stdn
{
    uint32_t u;
    struct bdk_tns_txq_tbc_bist_stdn_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t ft_fifo_mem_status    : 1;  /**< [ 13: 13](RO/H) -- */
        uint32_t tail_ptr_mem_status   : 1;  /**< [ 12: 12](RO/H) -- */
        uint32_t head_ptr_mem_status   : 1;  /**< [ 11: 11](RO/H) -- */
        uint32_t tb_mem_status         : 4;  /**< [ 10:  7](RO/H) -- */
        uint32_t ft_fifo_mem_done      : 1;  /**< [  6:  6](RO/H) -- */
        uint32_t tail_ptr_mem_done     : 1;  /**< [  5:  5](RO/H) -- */
        uint32_t head_ptr_mem_done     : 1;  /**< [  4:  4](RO/H) -- */
        uint32_t tb_mem_done           : 4;  /**< [  3:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t tb_mem_done           : 4;  /**< [  3:  0](RO/H) -- */
        uint32_t head_ptr_mem_done     : 1;  /**< [  4:  4](RO/H) -- */
        uint32_t tail_ptr_mem_done     : 1;  /**< [  5:  5](RO/H) -- */
        uint32_t ft_fifo_mem_done      : 1;  /**< [  6:  6](RO/H) -- */
        uint32_t tb_mem_status         : 4;  /**< [ 10:  7](RO/H) -- */
        uint32_t head_ptr_mem_status   : 1;  /**< [ 11: 11](RO/H) -- */
        uint32_t tail_ptr_mem_status   : 1;  /**< [ 12: 12](RO/H) -- */
        uint32_t ft_fifo_mem_status    : 1;  /**< [ 13: 13](RO/H) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbc_bist_stdn_s cn; */
};
typedef union bdk_tns_txq_tbc_bist_stdn bdk_tns_txq_tbc_bist_stdn_t;

#define BDK_TNS_TXQ_TBC_BIST_STDN BDK_TNS_TXQ_TBC_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBC_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBC_BIST_STDN_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x842070040024ll;
    __bdk_csr_fatal("TNS_TXQ_TBC_BIST_STDN", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBC_BIST_STDN bdk_tns_txq_tbc_bist_stdn_t
#define bustype_BDK_TNS_TXQ_TBC_BIST_STDN BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBC_BIST_STDN "TNS_TXQ_TBC_BIST_STDN"
#define device_bar_BDK_TNS_TXQ_TBC_BIST_STDN 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBC_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_TBC_BIST_STDN -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ecc_ctl
 *
 * TNS TxQ Token Buffer Manager ECC Control Register
 * ECC configuration of all TBM memories
 */
union bdk_tns_txq_tbm_ecc_ctl
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ecc_ctl_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_9_31         : 23;
        uint32_t head_ptr_flip_db_ecc  : 1;  /**< [  8:  8](R/W) Flip 2 bits of ECC syndrome in head pointer memory */
        uint32_t head_ptr_flip_sb_ecc  : 1;  /**< [  7:  7](R/W) Flip 1 bit of ECC syndrome in head pointer memory */
        uint32_t head_ptr_ecc_dis      : 1;  /**< [  6:  6](R/W) Disable ECC for head pointer memory */
        uint32_t tail_ptr_flip_db_ecc  : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in tail pointer memory */
        uint32_t tail_ptr_flip_sb_ecc  : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in tail pointer memory */
        uint32_t tail_ptr_ecc_dis      : 1;  /**< [  3:  3](R/W) Disable ECC for tail pointer memory */
        uint32_t ft_fifo_flip_db_ecc   : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in FT memory */
        uint32_t ft_fifo_flip_sb_ecc   : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in FT memory */
        uint32_t ft_fifo_ecc_dis       : 1;  /**< [  0:  0](R/W) Disable ECC for Free token FIFO memory */
#else /* Word 0 - Little Endian */
        uint32_t ft_fifo_ecc_dis       : 1;  /**< [  0:  0](R/W) Disable ECC for Free token FIFO memory */
        uint32_t ft_fifo_flip_sb_ecc   : 1;  /**< [  1:  1](R/W) Flip 1 bit of ECC syndrome in FT memory */
        uint32_t ft_fifo_flip_db_ecc   : 1;  /**< [  2:  2](R/W) Flip 2 bits of ECC syndrome in FT memory */
        uint32_t tail_ptr_ecc_dis      : 1;  /**< [  3:  3](R/W) Disable ECC for tail pointer memory */
        uint32_t tail_ptr_flip_sb_ecc  : 1;  /**< [  4:  4](R/W) Flip 1 bit of ECC syndrome in tail pointer memory */
        uint32_t tail_ptr_flip_db_ecc  : 1;  /**< [  5:  5](R/W) Flip 2 bits of ECC syndrome in tail pointer memory */
        uint32_t head_ptr_ecc_dis      : 1;  /**< [  6:  6](R/W) Disable ECC for head pointer memory */
        uint32_t head_ptr_flip_sb_ecc  : 1;  /**< [  7:  7](R/W) Flip 1 bit of ECC syndrome in head pointer memory */
        uint32_t head_ptr_flip_db_ecc  : 1;  /**< [  8:  8](R/W) Flip 2 bits of ECC syndrome in head pointer memory */
        uint32_t reserved_9_31         : 23;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ecc_ctl_s cn; */
};
typedef union bdk_tns_txq_tbm_ecc_ctl bdk_tns_txq_tbm_ecc_ctl_t;

#define BDK_TNS_TXQ_TBM_ECC_CTL BDK_TNS_TXQ_TBM_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_ECC_CTL_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c010ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_ECC_CTL", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_ECC_CTL bdk_tns_txq_tbm_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_TBM_ECC_CTL BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_ECC_CTL "TNS_TXQ_TBM_ECC_CTL"
#define device_bar_BDK_TNS_TXQ_TBM_ECC_CTL 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_TBM_ECC_CTL -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_cnt_dat_cfg
 *
 * TNS TxQ Token Buffer Manager Free Token CNT Data Configuration Register
 * Indicates free token fifo counter data per bank
 */
union bdk_tns_txq_tbm_ft_cnt_dat_cfg
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_cnt_dat_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t cnt                   : 14; /**< [ 13:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t cnt                   : 14; /**< [ 13:  0](RO/H) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_cnt_dat_cfg_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_cnt_dat_cfg bdk_tns_txq_tbm_ft_cnt_dat_cfg_t;

#define BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c030ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_CNT_DAT_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG bdk_tns_txq_tbm_ft_cnt_dat_cfg_t
#define bustype_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG "TNS_TXQ_TBM_FT_CNT_DAT_CFG"
#define device_bar_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_cnt_init_cfg
 *
 * TNS TxQ Token Buffer Manager Free Token CNT Init Configuration Register
 * Configuration to initialize free token count.  Note that 2k tokens are pre-
 * allocated to the queues with HW init.  This number should be adjusted
 * accordingly
 */
union bdk_tns_txq_tbm_ft_cnt_init_cfg
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_cnt_init_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t cnt                   : 14; /**< [ 13:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t cnt                   : 14; /**< [ 13:  0](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_cnt_init_cfg_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_cnt_init_cfg bdk_tns_txq_tbm_ft_cnt_init_cfg_t;

#define BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c028ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_CNT_INIT_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG bdk_tns_txq_tbm_ft_cnt_init_cfg_t
#define bustype_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG "TNS_TXQ_TBM_FT_CNT_INIT_CFG"
#define device_bar_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_cnt_thr
 *
 * TNS TxQ Token Buffer Manager Free Token CNT Threshold Register
 * Configuration to indicate threshold below which no free tokens are issued
 */
union bdk_tns_txq_tbm_ft_cnt_thr
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_cnt_thr_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t cnt                   : 14; /**< [ 13:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t cnt                   : 14; /**< [ 13:  0](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_cnt_thr_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_cnt_thr bdk_tns_txq_tbm_ft_cnt_thr_t;

#define BDK_TNS_TXQ_TBM_FT_CNT_THR BDK_TNS_TXQ_TBM_FT_CNT_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_THR_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c02cll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_CNT_THR", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_CNT_THR bdk_tns_txq_tbm_ft_cnt_thr_t
#define bustype_BDK_TNS_TXQ_TBM_FT_CNT_THR BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_CNT_THR "TNS_TXQ_TBM_FT_CNT_THR"
#define device_bar_BDK_TNS_TXQ_TBM_FT_CNT_THR 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_CNT_THR 0
#define arguments_BDK_TNS_TXQ_TBM_FT_CNT_THR -1,-1,-1,-1

/**
 * Register (NCB) tns_txq_tbm_ft_fif#_w#
 *
 * TNS TxQ Token Buffer Manager Free Token FIFO Registers
 * TBM free token fifo CPU access
 * Bits[63:48] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
union bdk_tns_txq_tbm_ft_fifx_wx
{
    uint64_t u;
    struct bdk_tns_txq_tbm_ft_fifx_wx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint64_t data                  : 64; /**< [ 63:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_fifx_wx_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_fifx_wx bdk_tns_txq_tbm_ft_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIFX_WX(unsigned long a, unsigned long b) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIFX_WX(unsigned long a, unsigned long b)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && ((a<=1791) && (b<=1)))
        return 0x842070500000ll + 0x10ll * ((a) & 0x7ff) + 8ll * ((b) & 0x1);
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_FIFX_WX", 2, a, b, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_FIFX_WX(a,b) bdk_tns_txq_tbm_ft_fifx_wx_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIFX_WX(a,b) BDK_CSR_TYPE_NCB
#define basename_BDK_TNS_TXQ_TBM_FT_FIFX_WX(a,b) "TNS_TXQ_TBM_FT_FIFX_WX"
#define device_bar_BDK_TNS_TXQ_TBM_FT_FIFX_WX(a,b) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_FIFX_WX(a,b) (a)
#define arguments_BDK_TNS_TXQ_TBM_FT_FIFX_WX(a,b) (a),(b),-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_fif_dbg
 *
 * TNS TxQ Token Buffer Manager Free Token FIFO Debug Register
 * Free token fifo debug register
 */
union bdk_tns_txq_tbm_ft_fif_dbg
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_fif_dbg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_24_31        : 8;
        uint32_t debug                 : 24; /**< [ 23:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t debug                 : 24; /**< [ 23:  0](R/W/H) -- */
        uint32_t reserved_24_31        : 8;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_fif_dbg_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_fif_dbg bdk_tns_txq_tbm_ft_fif_dbg_t;

#define BDK_TNS_TXQ_TBM_FT_FIF_DBG BDK_TNS_TXQ_TBM_FT_FIF_DBG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_DBG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c060ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_FIF_DBG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_FIF_DBG bdk_tns_txq_tbm_ft_fif_dbg_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIF_DBG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_FIF_DBG "TNS_TXQ_TBM_FT_FIF_DBG"
#define device_bar_BDK_TNS_TXQ_TBM_FT_FIF_DBG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_FIF_DBG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_FIF_DBG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_fif_ecc_log
 *
 * TNS TxQ Token Buffer Manager Free Token FIFO ECC Log Register
 * Free token fifo pointer ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
union bdk_tns_txq_tbm_ft_fif_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_fif_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_fif_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_fif_ecc_log bdk_tns_txq_tbm_ft_fif_ecc_log_t;

#define BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c01cll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_FIF_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG bdk_tns_txq_tbm_ft_fif_ecc_log_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG "TNS_TXQ_TBM_FT_FIF_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_fif_usage
 *
 * TNS TxQ Token Buffer Manager Free Token FIFO Usage Register
 * Token buffer Free Token FIFO usage level
 */
union bdk_tns_txq_tbm_ft_fif_usage
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_fif_usage_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t fifo_usage            : 11; /**< [ 10:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t fifo_usage            : 11; /**< [ 10:  0](RO/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_fif_usage_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_fif_usage bdk_tns_txq_tbm_ft_fif_usage_t;

#define BDK_TNS_TXQ_TBM_FT_FIF_USAGE BDK_TNS_TXQ_TBM_FT_FIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_USAGE_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c040ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_FIF_USAGE", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_FIF_USAGE bdk_tns_txq_tbm_ft_fif_usage_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIF_USAGE BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_FIF_USAGE "TNS_TXQ_TBM_FT_FIF_USAGE"
#define device_bar_BDK_TNS_TXQ_TBM_FT_FIF_USAGE 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_FIF_USAGE 0
#define arguments_BDK_TNS_TXQ_TBM_FT_FIF_USAGE -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_ct
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Count Register
 * Count of the number of valid pre-fetched free-tokens in the ft_prefetch
 */
union bdk_tns_txq_tbm_ft_prefetch_ct
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_5_31         : 27;
        uint32_t count                 : 5;  /**< [  4:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 5;  /**< [  4:  0](RO/H) -- */
        uint32_t reserved_5_31         : 27;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_ct_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_ct bdk_tns_txq_tbm_ft_prefetch_ct_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_CT BDK_TNS_TXQ_TBM_FT_PREFETCH_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c034ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT bdk_tns_txq_tbm_ft_prefetch_ct_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT "TNS_TXQ_TBM_FT_PREFETCH_CT"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w0
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 0 Register
 * Read-out of pre-fetched free tokens in the tail pointer block.
 */
union bdk_tns_txq_tbm_ft_prefetch_w0
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w0_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr13              : 4;  /**< [ 31: 28](RO/H) -- */
        uint32_t tb_ptr14              : 14; /**< [ 27: 14](RO/H) -- */
        uint32_t tb_ptr15              : 14; /**< [ 13:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr15              : 14; /**< [ 13:  0](RO/H) -- */
        uint32_t tb_ptr14              : 14; /**< [ 27: 14](RO/H) -- */
        uint32_t tb_ptr13              : 4;  /**< [ 31: 28](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w0_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w0 bdk_tns_txq_tbm_ft_prefetch_w0_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 BDK_TNS_TXQ_TBM_FT_PREFETCH_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W0_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c044ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W0", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 bdk_tns_txq_tbm_ft_prefetch_w0_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 "TNS_TXQ_TBM_FT_PREFETCH_W0"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w1
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 1 Register
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 */
union bdk_tns_txq_tbm_ft_prefetch_w1
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w1_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr11              : 8;  /**< [ 31: 24](RO/H) -- */
        uint32_t tb_ptr12              : 14; /**< [ 23: 10](RO/H) -- */
        uint32_t tb_ptr13              : 10; /**< [  9:  0](RO/H) Continuation of MSBs of field TB_PTR13 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr13              : 10; /**< [  9:  0](RO/H) Continuation of MSBs of field TB_PTR13 from previous word. */
        uint32_t tb_ptr12              : 14; /**< [ 23: 10](RO/H) -- */
        uint32_t tb_ptr11              : 8;  /**< [ 31: 24](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w1_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w1 bdk_tns_txq_tbm_ft_prefetch_w1_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 BDK_TNS_TXQ_TBM_FT_PREFETCH_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W1_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c048ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W1", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 bdk_tns_txq_tbm_ft_prefetch_w1_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 "TNS_TXQ_TBM_FT_PREFETCH_W1"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w2
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 2 Register
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 */
union bdk_tns_txq_tbm_ft_prefetch_w2
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w2_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr9               : 12; /**< [ 31: 20](RO/H) -- */
        uint32_t tb_ptr10              : 14; /**< [ 19:  6](RO/H) -- */
        uint32_t tb_ptr11              : 6;  /**< [  5:  0](RO/H) Continuation of MSBs of field TB_PTR11 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr11              : 6;  /**< [  5:  0](RO/H) Continuation of MSBs of field TB_PTR11 from previous word. */
        uint32_t tb_ptr10              : 14; /**< [ 19:  6](RO/H) -- */
        uint32_t tb_ptr9               : 12; /**< [ 31: 20](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w2_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w2 bdk_tns_txq_tbm_ft_prefetch_w2_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 BDK_TNS_TXQ_TBM_FT_PREFETCH_W2_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W2_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c04cll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W2", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 bdk_tns_txq_tbm_ft_prefetch_w2_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 "TNS_TXQ_TBM_FT_PREFETCH_W2"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w3
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 3 Register
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 */
union bdk_tns_txq_tbm_ft_prefetch_w3
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w3_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr6               : 2;  /**< [ 31: 30](RO/H) -- */
        uint32_t tb_ptr7               : 14; /**< [ 29: 16](RO/H) -- */
        uint32_t tb_ptr8               : 14; /**< [ 15:  2](RO/H) -- */
        uint32_t tb_ptr9               : 2;  /**< [  1:  0](RO/H) Continuation of MSBs of field TB_PTR9 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr9               : 2;  /**< [  1:  0](RO/H) Continuation of MSBs of field TB_PTR9 from previous word. */
        uint32_t tb_ptr8               : 14; /**< [ 15:  2](RO/H) -- */
        uint32_t tb_ptr7               : 14; /**< [ 29: 16](RO/H) -- */
        uint32_t tb_ptr6               : 2;  /**< [ 31: 30](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w3_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w3 bdk_tns_txq_tbm_ft_prefetch_w3_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 BDK_TNS_TXQ_TBM_FT_PREFETCH_W3_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W3_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c050ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W3", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 bdk_tns_txq_tbm_ft_prefetch_w3_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 "TNS_TXQ_TBM_FT_PREFETCH_W3"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w4
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 4 Register
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 */
union bdk_tns_txq_tbm_ft_prefetch_w4
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w4_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr4               : 6;  /**< [ 31: 26](RO/H) -- */
        uint32_t tb_ptr5               : 14; /**< [ 25: 12](RO/H) -- */
        uint32_t tb_ptr6               : 12; /**< [ 11:  0](RO/H) Continuation of MSBs of field TB_PTR6 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr6               : 12; /**< [ 11:  0](RO/H) Continuation of MSBs of field TB_PTR6 from previous word. */
        uint32_t tb_ptr5               : 14; /**< [ 25: 12](RO/H) -- */
        uint32_t tb_ptr4               : 6;  /**< [ 31: 26](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w4_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w4 bdk_tns_txq_tbm_ft_prefetch_w4_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 BDK_TNS_TXQ_TBM_FT_PREFETCH_W4_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W4_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c054ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W4", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 bdk_tns_txq_tbm_ft_prefetch_w4_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 "TNS_TXQ_TBM_FT_PREFETCH_W4"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w5
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 5 Register
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 */
union bdk_tns_txq_tbm_ft_prefetch_w5
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w5_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr2               : 10; /**< [ 31: 22](RO/H) -- */
        uint32_t tb_ptr3               : 14; /**< [ 21:  8](RO/H) -- */
        uint32_t tb_ptr4               : 8;  /**< [  7:  0](RO/H) Continuation of MSBs of field TB_PTR4 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr4               : 8;  /**< [  7:  0](RO/H) Continuation of MSBs of field TB_PTR4 from previous word. */
        uint32_t tb_ptr3               : 14; /**< [ 21:  8](RO/H) -- */
        uint32_t tb_ptr2               : 10; /**< [ 31: 22](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w5_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w5 bdk_tns_txq_tbm_ft_prefetch_w5_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 BDK_TNS_TXQ_TBM_FT_PREFETCH_W5_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W5_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c058ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W5", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 bdk_tns_txq_tbm_ft_prefetch_w5_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 "TNS_TXQ_TBM_FT_PREFETCH_W5"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_ft_prefetch_w6
 *
 * TNS TxQ Token Buffer Manager Free Token Prefecth Word 6 Register
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 */
union bdk_tns_txq_tbm_ft_prefetch_w6
{
    uint32_t u;
    struct bdk_tns_txq_tbm_ft_prefetch_w6_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t tb_ptr0               : 14; /**< [ 31: 18](RO/H) -- */
        uint32_t tb_ptr1               : 14; /**< [ 17:  4](RO/H) -- */
        uint32_t tb_ptr2               : 4;  /**< [  3:  0](RO/H) Continuation of MSBs of field TB_PTR2 from previous word. */
#else /* Word 0 - Little Endian */
        uint32_t tb_ptr2               : 4;  /**< [  3:  0](RO/H) Continuation of MSBs of field TB_PTR2 from previous word. */
        uint32_t tb_ptr1               : 14; /**< [ 17:  4](RO/H) -- */
        uint32_t tb_ptr0               : 14; /**< [ 31: 18](RO/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_ft_prefetch_w6_s cn; */
};
typedef union bdk_tns_txq_tbm_ft_prefetch_w6 bdk_tns_txq_tbm_ft_prefetch_w6_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 BDK_TNS_TXQ_TBM_FT_PREFETCH_W6_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W6_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c05cll;
    __bdk_csr_fatal("TNS_TXQ_TBM_FT_PREFETCH_W6", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 bdk_tns_txq_tbm_ft_prefetch_w6_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 "TNS_TXQ_TBM_FT_PREFETCH_W6"
#define device_bar_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_head_ptr_ecc_log
 *
 * TNS TxQ Token Buffer Manager Head Pointer ECC Log Register
 * TBM head pointer ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_tbm_head_ptr_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tbm_head_ptr_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_head_ptr_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tbm_head_ptr_ecc_log bdk_tns_txq_tbm_head_ptr_ecc_log_t;

#define BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c014ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_HEAD_PTR_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG bdk_tns_txq_tbm_head_ptr_ecc_log_t
#define bustype_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG "TNS_TXQ_TBM_HEAD_PTR_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_head_ptr_mem#
 *
 * TNS TxQ Token Buffer Manager Head Pointer Memory Registers
 * Queue Head pointer memory CPU access
 */
union bdk_tns_txq_tbm_head_ptr_memx
{
    uint32_t u;
    struct bdk_tns_txq_tbm_head_ptr_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t data                  : 14; /**< [ 13:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 14; /**< [ 13:  0](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_head_ptr_memx_s cn; */
};
typedef union bdk_tns_txq_tbm_head_ptr_memx bdk_tns_txq_tbm_head_ptr_memx_t;

static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x84207050a000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_TBM_HEAD_PTR_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(a) bdk_tns_txq_tbm_head_ptr_memx_t
#define bustype_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(a) "TNS_TXQ_TBM_HEAD_PTR_MEMX"
#define device_bar_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_hw_init_sta
 *
 * TNS TxQ Token Buffer Manager Hardware Init Status Register
 * Per memory HW init.  Write '1' to force HW init.  Read for status.  '1'
 * indicates that HW init is completed
 */
union bdk_tns_txq_tbm_hw_init_sta
{
    uint32_t u;
    struct bdk_tns_txq_tbm_hw_init_sta_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_3_31         : 29;
        uint32_t tail_ptr_mem          : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t head_ptr_mem          : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t ft_fifo               : 1;  /**< [  0:  0](RO/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ft_fifo               : 1;  /**< [  0:  0](RO/H) -- */
        uint32_t head_ptr_mem          : 1;  /**< [  1:  1](RO/H) -- */
        uint32_t tail_ptr_mem          : 1;  /**< [  2:  2](RO/H) -- */
        uint32_t reserved_3_31         : 29;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_hw_init_sta_s cn; */
};
typedef union bdk_tns_txq_tbm_hw_init_sta bdk_tns_txq_tbm_hw_init_sta_t;

#define BDK_TNS_TXQ_TBM_HW_INIT_STA BDK_TNS_TXQ_TBM_HW_INIT_STA_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_HW_INIT_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_HW_INIT_STA_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c024ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_HW_INIT_STA", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_HW_INIT_STA bdk_tns_txq_tbm_hw_init_sta_t
#define bustype_BDK_TNS_TXQ_TBM_HW_INIT_STA BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_HW_INIT_STA "TNS_TXQ_TBM_HW_INIT_STA"
#define device_bar_BDK_TNS_TXQ_TBM_HW_INIT_STA 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_HW_INIT_STA 0
#define arguments_BDK_TNS_TXQ_TBM_HW_INIT_STA -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_int_en_hi
 *
 * TNS TxQ Token Buffer Manager Interrrupt Enable High Register
 * Token Buffer Manager Interrupt register
 */
union bdk_tns_txq_tbm_int_en_hi
{
    uint32_t u;
    struct bdk_tns_txq_tbm_int_en_hi_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](R/W) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](R/W) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](R/W) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](R/W) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](R/W) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](R/W) -- */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](R/W) -- */
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](R/W) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_int_en_hi_s cn; */
};
typedef union bdk_tns_txq_tbm_int_en_hi bdk_tns_txq_tbm_int_en_hi_t;

#define BDK_TNS_TXQ_TBM_INT_EN_HI BDK_TNS_TXQ_TBM_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_HI_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c004ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_INT_EN_HI", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_INT_EN_HI bdk_tns_txq_tbm_int_en_hi_t
#define bustype_BDK_TNS_TXQ_TBM_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_INT_EN_HI "TNS_TXQ_TBM_INT_EN_HI"
#define device_bar_BDK_TNS_TXQ_TBM_INT_EN_HI 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_TBM_INT_EN_HI -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_int_en_lo
 *
 * TNS TxQ Token Buffer Manager Interrrupt Enable Low Register
 * Token Buffer Manager Interrupt register
 */
union bdk_tns_txq_tbm_int_en_lo
{
    uint32_t u;
    struct bdk_tns_txq_tbm_int_en_lo_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](R/W) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](R/W) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](R/W) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](R/W) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](R/W) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](R/W) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](R/W) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](R/W) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](R/W) -- */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](R/W) -- */
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](R/W) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_int_en_lo_s cn; */
};
typedef union bdk_tns_txq_tbm_int_en_lo bdk_tns_txq_tbm_int_en_lo_t;

#define BDK_TNS_TXQ_TBM_INT_EN_LO BDK_TNS_TXQ_TBM_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_LO_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c008ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_INT_EN_LO", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_INT_EN_LO bdk_tns_txq_tbm_int_en_lo_t
#define bustype_BDK_TNS_TXQ_TBM_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_INT_EN_LO "TNS_TXQ_TBM_INT_EN_LO"
#define device_bar_BDK_TNS_TXQ_TBM_INT_EN_LO 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_TBM_INT_EN_LO -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_int_frc
 *
 * TNS TxQ Token Buffer Manager Interrrupt Force Register
 * Token Buffer Manager Interrupt register
 */
union bdk_tns_txq_tbm_int_frc
{
    uint32_t u;
    struct bdk_tns_txq_tbm_int_frc_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](WO) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](WO) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](WO) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](WO) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](WO) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](WO) -- */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](WO) -- */
#else /* Word 0 - Little Endian */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](WO) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](WO) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](WO) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](WO) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](WO) -- */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](WO) -- */
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](WO) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_int_frc_s cn; */
};
typedef union bdk_tns_txq_tbm_int_frc bdk_tns_txq_tbm_int_frc_t;

#define BDK_TNS_TXQ_TBM_INT_FRC BDK_TNS_TXQ_TBM_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_FRC_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c00cll;
    __bdk_csr_fatal("TNS_TXQ_TBM_INT_FRC", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_INT_FRC bdk_tns_txq_tbm_int_frc_t
#define bustype_BDK_TNS_TXQ_TBM_INT_FRC BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_INT_FRC "TNS_TXQ_TBM_INT_FRC"
#define device_bar_BDK_TNS_TXQ_TBM_INT_FRC 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_INT_FRC 0
#define arguments_BDK_TNS_TXQ_TBM_INT_FRC -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_int_w1c
 *
 * TNS TxQ Token Buffer Manager Interrrupt W1C Register
 * Token Buffer Manager Interrupt register
 */
union bdk_tns_txq_tbm_int_w1c
{
    uint32_t u;
    struct bdk_tns_txq_tbm_int_w1c_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_7_31         : 25;
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](R/W1C/H) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](R/W1C/H) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](R/W1C/H) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](R/W1C/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t head_ptr_mem_sb_err   : 1;  /**< [  0:  0](R/W1C/H) -- */
        uint32_t head_ptr_mem_db_err   : 1;  /**< [  1:  1](R/W1C/H) -- */
        uint32_t tail_ptr_mem_sb_err   : 1;  /**< [  2:  2](R/W1C/H) -- */
        uint32_t tail_ptr_mem_db_err   : 1;  /**< [  3:  3](R/W1C/H) -- */
        uint32_t ft_fifo_sb_err        : 1;  /**< [  4:  4](R/W1C/H) -- */
        uint32_t ft_fifo_db_err        : 1;  /**< [  5:  5](R/W1C/H) -- */
        uint32_t dfc_rx_eq_tbm_ovfl_err : 1; /**< [  6:  6](R/W1C/H) DFC Rx overflow on EQ to TBM tail pointer interface */
        uint32_t reserved_7_31         : 25;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_int_w1c_s cn; */
};
typedef union bdk_tns_txq_tbm_int_w1c bdk_tns_txq_tbm_int_w1c_t;

#define BDK_TNS_TXQ_TBM_INT_W1C BDK_TNS_TXQ_TBM_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_W1C_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c000ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_INT_W1C", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_INT_W1C bdk_tns_txq_tbm_int_w1c_t
#define bustype_BDK_TNS_TXQ_TBM_INT_W1C BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_INT_W1C "TNS_TXQ_TBM_INT_W1C"
#define device_bar_BDK_TNS_TXQ_TBM_INT_W1C 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_INT_W1C 0
#define arguments_BDK_TNS_TXQ_TBM_INT_W1C -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_lock
 *
 * TNS TxQ Token Buffer Manager Lock Register
 * Lock Register
 */
union bdk_tns_txq_tbm_lock
{
    uint32_t u;
    struct bdk_tns_txq_tbm_lock_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t lock                  : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_lock_s cn; */
};
typedef union bdk_tns_txq_tbm_lock bdk_tns_txq_tbm_lock_t;

#define BDK_TNS_TXQ_TBM_LOCK BDK_TNS_TXQ_TBM_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_LOCK_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c064ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_LOCK", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_LOCK bdk_tns_txq_tbm_lock_t
#define bustype_BDK_TNS_TXQ_TBM_LOCK BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_LOCK "TNS_TXQ_TBM_LOCK"
#define device_bar_BDK_TNS_TXQ_TBM_LOCK 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_LOCK 0
#define arguments_BDK_TNS_TXQ_TBM_LOCK -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_rst_cfg
 *
 * TNS TxQ Token Buffer Manager Reset Configuration Register
 * Reset configuration to initialize and start various modules within TBM
 */
union bdk_tns_txq_tbm_rst_cfg
{
    uint32_t u;
    struct bdk_tns_txq_tbm_rst_cfg_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_2_31         : 30;
        uint32_t tbm_module_en         : 1;  /**< [  1:  1](R/W) -- */
        uint32_t tbm_hw_init           : 1;  /**< [  0:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t tbm_hw_init           : 1;  /**< [  0:  0](R/W) -- */
        uint32_t tbm_module_en         : 1;  /**< [  1:  1](R/W) -- */
        uint32_t reserved_2_31         : 30;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_rst_cfg_s cn; */
};
typedef union bdk_tns_txq_tbm_rst_cfg bdk_tns_txq_tbm_rst_cfg_t;

#define BDK_TNS_TXQ_TBM_RST_CFG BDK_TNS_TXQ_TBM_RST_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_RST_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_RST_CFG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c020ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_RST_CFG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_RST_CFG bdk_tns_txq_tbm_rst_cfg_t
#define bustype_BDK_TNS_TXQ_TBM_RST_CFG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_RST_CFG "TNS_TXQ_TBM_RST_CFG"
#define device_bar_BDK_TNS_TXQ_TBM_RST_CFG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_RST_CFG 0
#define arguments_BDK_TNS_TXQ_TBM_RST_CFG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_spad
 *
 * TNS TxQ Token Buffer Manager ScratchPad Register
 * Scratch Pad Register for XCAT
 */
union bdk_tns_txq_tbm_spad
{
    uint32_t u;
    struct bdk_tns_txq_tbm_spad_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t scratchpad            : 32; /**< [ 31:  0](R/W) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_spad_s cn; */
};
typedef union bdk_tns_txq_tbm_spad bdk_tns_txq_tbm_spad_t;

#define BDK_TNS_TXQ_TBM_SPAD BDK_TNS_TXQ_TBM_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_SPAD_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c068ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_SPAD", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_SPAD bdk_tns_txq_tbm_spad_t
#define bustype_BDK_TNS_TXQ_TBM_SPAD BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_SPAD "TNS_TXQ_TBM_SPAD"
#define device_bar_BDK_TNS_TXQ_TBM_SPAD 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_SPAD 0
#define arguments_BDK_TNS_TXQ_TBM_SPAD -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_tail_ptr_ecc_log
 *
 * TNS TxQ Token Buffer Manager Tail Pointer ECC Log Register
 * TBM tail pointer ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
union bdk_tns_txq_tbm_tail_ptr_ecc_log
{
    uint32_t u;
    struct bdk_tns_txq_tbm_tail_ptr_ecc_log_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_11_31        : 21;
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t ecc_err_addr          : 11; /**< [ 10:  0](R/W/H) -- */
        uint32_t reserved_11_31        : 21;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_tail_ptr_ecc_log_s cn; */
};
typedef union bdk_tns_txq_tbm_tail_ptr_ecc_log bdk_tns_txq_tbm_tail_ptr_ecc_log_t;

#define BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c018ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_TAIL_PTR_ECC_LOG", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG bdk_tns_txq_tbm_tail_ptr_ecc_log_t
#define bustype_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG "TNS_TXQ_TBM_TAIL_PTR_ECC_LOG"
#define device_bar_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_tail_ptr_mem#
 *
 * TNS TxQ Token Buffer Manager Tail Pointer Memory Registers
 * Queue Head pointer memory CPU access
 */
union bdk_tns_txq_tbm_tail_ptr_memx
{
    uint32_t u;
    struct bdk_tns_txq_tbm_tail_ptr_memx_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t reserved_14_31        : 18;
        uint32_t data                  : 14; /**< [ 13:  0](R/W) -- */
#else /* Word 0 - Little Endian */
        uint32_t data                  : 14; /**< [ 13:  0](R/W) -- */
        uint32_t reserved_14_31        : 18;
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_tail_ptr_memx_s cn; */
};
typedef union bdk_tns_txq_tbm_tail_ptr_memx bdk_tns_txq_tbm_tail_ptr_memx_t;

static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(unsigned long a) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(unsigned long a)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX) && (a<=2047))
        return 0x842070508000ll + 4ll * ((a) & 0x7ff);
    __bdk_csr_fatal("TNS_TXQ_TBM_TAIL_PTR_MEMX", 1, a, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(a) bdk_tns_txq_tbm_tail_ptr_memx_t
#define bustype_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(a) BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(a) "TNS_TXQ_TBM_TAIL_PTR_MEMX"
#define device_bar_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(a) 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(a) (a)
#define arguments_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(a) (a),-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_token_alloc_ct
 *
 * TNS TxQ Token Buffer Manager Token Allocation Count Register
 * Counter of the number of tokens allocated by TBM.  Saturates at 32'hffffffff.
 * Read only, clear on read.
 */
union bdk_tns_txq_tbm_token_alloc_ct
{
    uint32_t u;
    struct bdk_tns_txq_tbm_token_alloc_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_token_alloc_ct_s cn; */
};
typedef union bdk_tns_txq_tbm_token_alloc_ct bdk_tns_txq_tbm_token_alloc_ct_t;

#define BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c038ll;
    __bdk_csr_fatal("TNS_TXQ_TBM_TOKEN_ALLOC_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT bdk_tns_txq_tbm_token_alloc_ct_t
#define bustype_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT "TNS_TXQ_TBM_TOKEN_ALLOC_CT"
#define device_bar_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT 0
#define arguments_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT -1,-1,-1,-1

/**
 * Register (NCB32b) tns_txq_tbm_token_free_ct
 *
 * TNS TxQ Token Buffer Manager Token Free Count Register
 * Counter of the number of tokens freed back to TBM.  Saturates at 32'hffffffff.
 * Read only, clear on read.
 */
union bdk_tns_txq_tbm_token_free_ct
{
    uint32_t u;
    struct bdk_tns_txq_tbm_token_free_ct_s
    {
#if __BYTE_ORDER == __BIG_ENDIAN /* Word 0 - Big Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#else /* Word 0 - Little Endian */
        uint32_t count                 : 32; /**< [ 31:  0](R/W/H) -- */
#endif /* Word 0 - End */
    } s;
    /* struct bdk_tns_txq_tbm_token_free_ct_s cn; */
};
typedef union bdk_tns_txq_tbm_token_free_ct bdk_tns_txq_tbm_token_free_ct_t;

#define BDK_TNS_TXQ_TBM_TOKEN_FREE_CT BDK_TNS_TXQ_TBM_TOKEN_FREE_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_FREE_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_FREE_CT_FUNC(void)
{
    if (CAVIUM_IS_MODEL(CAVIUM_CN88XX))
        return 0x84207050c03cll;
    __bdk_csr_fatal("TNS_TXQ_TBM_TOKEN_FREE_CT", 0, 0, 0, 0, 0);
}

#define typedef_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT bdk_tns_txq_tbm_token_free_ct_t
#define bustype_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT BDK_CSR_TYPE_NCB32b
#define basename_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT "TNS_TXQ_TBM_TOKEN_FREE_CT"
#define device_bar_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT 0x2 /* PF_BAR2 */
#define busnum_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT 0
#define arguments_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT -1,-1,-1,-1

#endif /* __BDK_CSRS_TNS_SST_H__ */
